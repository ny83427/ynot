<?xml version="1.0" encoding="utf-8"?>
<nugget name="YNOT">
 <DTEL ROLLNAME="ZSTRING" DDLANGUAGE="E" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DDTEXT="JSON Key/Value" AUTHCLASS="00" DTELMASTER="E" DATATYPE="STRG" LENG="000000" DECIMALS="000000" OUTPUTLEN="000000">
  <tpara/>
 </DTEL>
 <FUGR AREA="ZJSON" SPRAS="E" AREAT="groupe de fonction JSON">
  <functionGroupDocumentation/>
  <mainprogram NAME="SAPLZJSON" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="100" RLOAD="F" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZJSONTOP.                         &quot; Global Data
  INCLUDE LZJSONUXX.                         &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZJSONF...                         &quot; Subprograms
* INCLUDE LZJSONO...                         &quot; PBO-Modules
* INCLUDE LZJSONI...                         &quot; PAI-Modules</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZJSONTOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="100" RLOAD="F" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ZJSON.                        &quot;MESSAGE-ID ..

TYPES:BEGIN OF tab_struct,
        fieldname TYPE fieldname,
        type      TYPE c,
      END OF tab_struct.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_JSON_OUT" STEXT="ABAP to JSON">
    <importing PARAMETER="TREE" OPTIONAL="X" REFERENCE="X" TYP="C"/>
    <importing PARAMETER="STRUC" OPTIONAL="X" REFERENCE="X"/>
    <exporting PARAMETER="JSON" TYP="STRING"/>
    <tables PARAMETER="ITAB" OPTIONAL="X" TYP="STANDARD TABLE"/>
    <tables PARAMETER="ISTRUC" OPTIONAL="X" TYP="ZGY_0004"/>
    <documentation PARAMETER="TREE" KIND="P" INDEX=" 001"/>
    <documentation PARAMETER="STRUC" KIND="P" INDEX=" 002"/>
    <documentation PARAMETER="JSON" KIND="P" STEXT="JSON String" INDEX=" 003"/>
    <documentation PARAMETER="ITAB" KIND="P" INDEX=" 004"/>
    <documentation PARAMETER="ISTRUC" KIND="P" STEXT="Table JSON OBJET" INDEX=" 005"/>
    <fm_source_new>TYPE-POOLS: sydes.

  DATA : i_structfield TYPE tab_struct OCCURS 0.
  DATA : w_lines TYPE i.

  IF itab IS SUPPLIED.
    PERFORM get_fieldname_table TABLES itab i_structfield.
    DESCRIBE TABLE i_structfield LINES w_lines.
    IF w_lines EQ 0.
      PERFORM write_array_to_json TABLES itab USING tree CHANGING json.
    ELSE.
      PERFORM write_itab_to_json TABLES itab i_structfield USING tree CHANGING json.
    ENDIF.
  ELSEIF struc IS SUPPLIED.
    PERFORM get_fieldname_struc TABLES i_structfield USING struc.
    IF i_structfield[] IS INITIAL.
      PERFORM write_field_to_json USING struc CHANGING json.
    ELSE.
      PERFORM write_struc_to_json TABLES i_structfield USING struc CHANGING json.
    ENDIF.
  ELSEIF istruc IS SUPPLIED.
    PERFORM write_istruc_to_json TABLES istruc CHANGING json.
  ENDIF.

*&amp;---------------------------------------------------------------------*
FORM write_array_to_json TABLES p_itab USING p_tree CHANGING p_json.

  DATA w_dref_str TYPE REF TO data.
  DATA w_data TYPE string.
  DATA w_json_elem TYPE string.
  DATA w_json_lines TYPE string.
  DATA w_field TYPE string.
  DATA w_tab_struct TYPE  tab_struct.
  DATA w_field_table TYPE string.

  FIELD-SYMBOLS &lt;wa&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.

  CLEAR p_json.
  CONCATENATE p_json &apos;[&apos; INTO p_json.
  CREATE DATA w_dref_str LIKE p_itab.
  ASSIGN w_dref_str-&gt;* TO &lt;wa&gt;.
  LOOP AT p_itab INTO &lt;wa&gt;.
    CLEAR w_json_elem.
    CONCATENATE w_json_lines &apos;,&apos; INTO w_json_lines.
    CLEAR w_data.
    w_field = &apos;&lt;wa&gt;&apos;.
    ASSIGN (w_field) TO &lt;field&gt;.
    CALL FUNCTION &apos;Z_JSON_OUT&apos;
      EXPORTING
        struc = &lt;field&gt;
      IMPORTING
        json  = w_data.
    CONCATENATE w_json_elem &apos;,&apos; w_data INTO w_json_elem.
    SHIFT w_json_elem.
    CONCATENATE w_json_lines w_json_elem INTO w_json_lines.
  ENDLOOP.
  SHIFT w_json_lines.
  CONCATENATE p_json w_json_lines &apos;]&apos; INTO p_json.

ENDFORM.                    &quot;write_array_to_json

*&amp;---------------------------------------------------------------------*
FORM write_itab_to_json TABLES p_itab p_istruct USING p_tree CHANGING p_json.

  DATA w_dref_str TYPE REF TO data.
  DATA w_data TYPE string.
  DATA w_json_elem TYPE string.
  DATA w_json_lines TYPE string.
  DATA w_field TYPE string.
  DATA w_struct TYPE tab_struct.
  DATA w_field_table TYPE string.

  FIELD-SYMBOLS &lt;wa&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;table&gt; TYPE STANDARD TABLE.

  CLEAR p_json.
  CONCATENATE p_json &apos;[&apos; INTO p_json.
  CREATE DATA w_dref_str LIKE p_itab.
  ASSIGN w_dref_str-&gt;* TO &lt;wa&gt;.
  LOOP AT p_itab INTO &lt;wa&gt;.
    CLEAR w_json_elem.
    CONCATENATE w_json_lines &apos;,{&apos; INTO w_json_lines.
    LOOP AT p_istruct INTO w_struct.
      CASE w_struct-type.
        WHEN &apos;T&apos;.
          CLEAR w_data.
          CONCATENATE &apos;&lt;wa&gt;-&apos; w_struct-fieldname INTO w_field.
          ASSIGN (w_field) TO &lt;table&gt;.
          w_field_table =  w_struct-fieldname.
          IF p_tree IS NOT INITIAL AND &lt;table&gt;[] IS NOT INITIAL.
            w_field_table = &apos;children&apos;.
          ENDIF.
          CALL FUNCTION &apos;Z_JSON_OUT&apos;
            EXPORTING
              tree = p_tree
            IMPORTING
              json = w_data
            TABLES
              itab = &lt;table&gt;.
          CONCATENATE w_json_elem &apos;,&apos; &apos;&quot;&apos;  w_field_table  &apos;&quot;&apos; &apos;:&apos;  w_data  INTO w_json_elem.
        WHEN OTHERS.
          CLEAR w_data.
          CONCATENATE &apos;&lt;wa&gt;-&apos; w_struct-fieldname INTO w_field.
          ASSIGN (w_field) TO &lt;field&gt;.
          CALL FUNCTION &apos;Z_JSON_OUT&apos;
            EXPORTING
              struc = &lt;field&gt;
            IMPORTING
              json  = w_data.
          CONCATENATE w_json_elem &apos;,&apos; &apos;&quot;&apos; w_struct-fieldname &apos;&quot;&apos; &apos;:&apos; w_data INTO w_json_elem.
      ENDCASE.
    ENDLOOP.
    SHIFT w_json_elem.
    CONCATENATE w_json_lines w_json_elem &apos;}&apos; INTO w_json_lines.
  ENDLOOP.
  SHIFT w_json_lines.
  CONCATENATE p_json w_json_lines &apos;]&apos; INTO p_json.

ENDFORM.                    &quot;write_itab_to_json

*&amp;---------------------------------------------------------------------*
FORM write_field_to_json USING p_field CHANGING p_json.

  DATA w_field TYPE string.

  w_field  = p_field.

  CALL FUNCTION &apos;Z_JSON_FORMATER_VALUE&apos;
    CHANGING
      str = w_field.

  CONCATENATE &apos;&quot;&apos; w_field &apos;&quot;&apos; INTO p_json.

ENDFORM.                    &quot;write_struc_to_json

*&amp;---------------------------------------------------------------------*
FORM write_struc_to_json TABLES p_istruct USING p_struc CHANGING p_json.

  DATA w_data TYPE string.
  DATA w_json_elem TYPE string.
  DATA w_field TYPE string.
  DATA w_struct TYPE tab_struct.
  DATA w_field_table TYPE string.

  FIELD-SYMBOLS &lt;field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;table&gt; TYPE STANDARD TABLE.

  LOOP AT p_istruct INTO w_struct.
    CASE w_struct-type.
      WHEN &apos;T&apos;.
        CLEAR w_data.
        CONCATENATE &apos;p_struc-&apos; w_struct-fieldname INTO w_field.
        ASSIGN (w_field) TO &lt;table&gt;.
        w_field_table = w_struct-fieldname.
        CALL FUNCTION &apos;Z_JSON_OUT&apos;
          IMPORTING
            json = w_data
          TABLES
            itab = &lt;table&gt;.
        CONCATENATE w_json_elem &apos;,&apos; &apos;&quot;&apos;  w_field_table  &apos;&quot;&apos; &apos;:&apos;  w_data  INTO w_json_elem.
      WHEN OTHERS.
        CLEAR w_data.
        CONCATENATE &apos;p_struc-&apos; w_struct-fieldname INTO w_field.
        ASSIGN (w_field) TO &lt;field&gt;.
        CALL FUNCTION &apos;Z_JSON_OUT&apos;
          EXPORTING
            struc = &lt;field&gt;
          IMPORTING
            json  = w_data.
        CONCATENATE w_json_elem &apos;,&apos; &apos;&quot;&apos; w_struct-fieldname &apos;&quot;&apos; &apos;:&apos; w_data INTO w_json_elem.
    ENDCASE.
  ENDLOOP.
  SHIFT w_json_elem.
  CONCATENATE &apos;{&apos; w_json_elem &apos;}&apos; INTO p_json.

ENDFORM.                    &quot;write_struc_to_json


*----------------------------------------------------------------------*
FORM get_fieldname_struc TABLES p_istructfield USING p_struc.

  DATA w_dref_str TYPE REF TO data.
  DATA i_table_desc TYPE sydes_desc.
  DATA wa_names TYPE sydes_nameinfo.
  DATA wa_types TYPE sydes_typeinfo.
  DATA w_tab_struct TYPE tab_struct.
  DATA wa_names_continue TYPE sydes_nameinfo.
  DATA w_from TYPE i.
  DATA w_to TYPE i.

  FIELD-SYMBOLS &lt;struc&gt; TYPE ANY.

  CREATE DATA w_dref_str LIKE p_struc.
  ASSIGN w_dref_str-&gt;* TO &lt;struc&gt;.
  DESCRIBE FIELD &lt;struc&gt; INTO i_table_desc.
  READ TABLE i_table_desc-types INTO wa_types INDEX 1.
  IF wa_types-table_kind EQ &apos;T&apos;.
    READ TABLE i_table_desc-types INTO wa_types INDEX wa_types-from.
  ENDIF.
  w_from = wa_types-from.
  w_to = wa_types-to.
  LOOP AT i_table_desc-types INTO wa_types FROM w_from TO w_to.
    CLEAR p_istructfield.
    CHECK wa_types-idx_name GT 0.
    READ TABLE i_table_desc-names INTO wa_names INDEX wa_types-idx_name.
    MOVE wa_names-name TO w_tab_struct-fieldname.
*   ADE - Le nom du champ peut Ãªtre sur 2 lignes
    IF wa_names-continue EQ &apos;*&apos;.
      CLEAR wa_names_continue.
      wa_types-idx_name = wa_types-idx_name + 1.
      READ TABLE i_table_desc-names INTO wa_names_continue INDEX wa_types-idx_name.
      CONCATENATE w_tab_struct-fieldname wa_names_continue-name INTO w_tab_struct-fieldname.
    ENDIF.

    MOVE wa_types-table_kind TO w_tab_struct-type.
    APPEND w_tab_struct TO p_istructfield.
  ENDLOOP.

ENDFORM.                    &quot;get_fieldname_struc


*&amp;---------------------------------------------------------------------*
FORM get_fieldname_table TABLES p_itab p_istructfield.

  DATA w_dref_str TYPE REF TO data.
  DATA i_table_desc TYPE sydes_desc.
  DATA wa_names TYPE sydes_nameinfo.
  DATA wa_types TYPE sydes_typeinfo.
  DATA w_tab_struct TYPE tab_struct.
  DATA w_fieldname TYPE fieldname.
  DATA w_index TYPE i.


  FIELD-SYMBOLS &lt;table&gt; TYPE ANY.

  CREATE DATA w_dref_str LIKE p_itab.
  ASSIGN w_dref_str-&gt;* TO &lt;table&gt;.
  DESCRIBE FIELD &lt;table&gt; INTO i_table_desc.
  LOOP AT i_table_desc-types INTO wa_types.
    CLEAR p_istructfield.
    CHECK wa_types-idx_name GT 0 AND wa_types-back EQ 1.
    READ TABLE i_table_desc-names INTO wa_names INDEX wa_types-idx_name.

    MOVE wa_names-name TO w_tab_struct-fieldname.
* si le champs fait plus de 30 caracteres
    IF wa_names-continue EQ &apos;*&apos;.
      w_fieldname = wa_names-name.
      w_index = wa_types-idx_name + 1.
      READ TABLE i_table_desc-names INTO wa_names INDEX w_index.
      CONCATENATE w_fieldname wa_names-name INTO w_tab_struct-fieldname.
    ENDIF.
*
    MOVE wa_types-table_kind TO w_tab_struct-type.
    APPEND w_tab_struct TO p_istructfield.
    CLEAR w_fieldname.
  ENDLOOP.

ENDFORM.                    &quot;get_fieldname_table


*&amp;---------------------------------------------------------------------*
FORM write_istruc_to_json TABLES p_istruc CHANGING p_json.

  DATA w_data TYPE string.
  DATA w_json_elem TYPE string.
  DATA w_istruc TYPE zgs_0004.

  LOOP AT p_istruc INTO w_istruc.
    CLEAR w_data.
    CALL FUNCTION &apos;Z_JSON_OUT&apos;
      EXPORTING
        struc = w_istruc-tx
      IMPORTING
        json  = w_data.
    CONCATENATE w_json_elem &apos;,&apos; &apos;&quot;&apos; w_istruc-id &apos;&quot;&apos; &apos;:&apos; w_data INTO w_json_elem.
  ENDLOOP.
  SHIFT w_json_elem.
  CONCATENATE &apos;{&apos; w_json_elem &apos;}&apos; INTO p_json.

ENDFORM.                    &quot;write_struc_to_json</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_JSON_IN" STEXT="JSON to ABAP iTab">
    <importing PARAMETER="JSON" REFERENCE="X" TYP="STRING"/>
    <exporting PARAMETER="STRUC" REFERENCE="X"/>
    <tables PARAMETER="ITAB" OPTIONAL="X" TYP="STANDARD TABLE"/>
    <documentation PARAMETER="JSON" KIND="P" INDEX=" 001"/>
    <documentation PARAMETER="STRUC" KIND="P" INDEX=" 002"/>
    <documentation PARAMETER="ITAB" KIND="P" INDEX=" 003"/>
    <fm_source_new>TYPE-POOLS: sydes.

  DATA w_len TYPE i.
  w_len = STRLEN( json ).
  CHECK w_len GT 1.
  w_len = w_len - 1.
  IF json(1) EQ &apos;{&apos; AND json+w_len(1) EQ &apos;}&apos;.
    PERFORM json_to_struc USING json CHANGING struc.
  ELSEIF json(1) EQ &apos;[&apos; AND json+w_len(1) EQ &apos;]&apos;.
    IF json+1(1) EQ &apos;{&apos;.
      PERFORM json_to_itab TABLES itab USING json.
    ELSE.
      PERFORM json_to_array TABLES itab USING json.
    ENDIF.
  ELSEIF json(1) EQ &apos;&quot;&apos; AND json+w_len(1) EQ &apos;&quot;&apos;.
    w_len = w_len - 1.
    struc = json+1(w_len).
    CALL FUNCTION &apos;Z_JSON_DEFORMATER_VALUE&apos;
      CHANGING
        str = struc.
  ENDIF.
*&amp;---------------------------------------------------------------------*
*&amp;      Form  json_to_struc
*&amp;---------------------------------------------------------------------*
FORM json_to_struc USING p_json CHANGING p_struc.

  DATA w_pos_deb_nom TYPE i.
  DATA w_pos_fin_nom TYPE i.
  DATA w_pos_deb_val TYPE i.
  DATA w_pos_fin_val TYPE i.
  DATA w_lenfield TYPE i.
  DATA w_lenvalue TYPE i.
  DATA w_field TYPE string.
  DATA w_value TYPE string.
  DATA i_table_desc TYPE sydes_desc.
  DATA w_type TYPE sydes_typeinfo.

  FIELD-SYMBOLS &lt;champ&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;table&gt; TYPE STANDARD TABLE.

  w_pos_deb_nom = 2.
  WHILE p_json+w_pos_fin_val CS &apos;&quot;:&apos;.
    w_pos_fin_nom = w_pos_fin_val + sy-fdpos.
    w_pos_deb_val = w_pos_fin_nom + 2.
    PERFORM get_offset_close USING p_json w_pos_deb_val CHANGING w_pos_fin_val.
    w_lenfield = w_pos_fin_nom - w_pos_deb_nom.
    w_field = p_json+w_pos_deb_nom(w_lenfield).
    CONCATENATE &apos;p_struc-&apos; w_field INTO w_field.
    w_lenvalue = w_pos_fin_val - w_pos_deb_val.
    w_value = p_json+w_pos_deb_val(w_lenvalue).
    ASSIGN (w_field) TO &lt;champ&gt;. &quot;if sy-subrc &lt;&gt; 0 that mean: field don&apos;t exist in the structure
    IF sy-subrc EQ 0.
      DESCRIBE FIELD &lt;champ&gt; INTO i_table_desc.
      READ TABLE i_table_desc-types INTO w_type INDEX 1.
      CASE w_type-table_kind.
        WHEN &apos;T&apos;.
          ASSIGN (w_field) TO &lt;table&gt;.
          REFRESH &lt;table&gt;.
          CALL FUNCTION &apos;Z_JSON_IN&apos;
            EXPORTING
              json = w_value
            TABLES
              itab = &lt;table&gt;.
          &lt;champ&gt; = &lt;table&gt;.
        WHEN OTHERS.
          CALL FUNCTION &apos;Z_JSON_IN&apos;
            EXPORTING
              json  = w_value
            IMPORTING
              struc = &lt;champ&gt;.
      ENDCASE.
*     w_pos_deb_nom = w_pos_fin_val + 2. &quot;YOA11072008
    ENDIF.
    w_pos_deb_nom = w_pos_fin_val + 2. &quot;YOA11072008
  ENDWHILE.

ENDFORM.                    &quot;json_to_struc


*&amp;---------------------------------------------------------------------*
*&amp;      Form  json_to_itab
*&amp;---------------------------------------------------------------------*
FORM json_to_itab TABLES p_itab USING p_json.

  DATA w_pos_deb_line TYPE i.
  DATA w_pos_fin_line TYPE i.
  DATA w_lenline TYPE i.
  DATA w_line TYPE string.

  CLEAR p_itab. &quot;ADDING CBO
  REFRESH p_itab. &quot;ADDING CBO
  WHILE p_json+w_pos_fin_line CS &apos;{&apos;.
    CLEAR p_itab. &quot;ADDING CBO
    w_pos_deb_line = w_pos_fin_line + sy-fdpos.
    PERFORM get_offset_close USING p_json w_pos_deb_line CHANGING w_pos_fin_line.
    w_lenline = w_pos_fin_line - w_pos_deb_line.
    w_line = p_json+w_pos_deb_line(w_lenline).
    PERFORM json_to_struc USING w_line CHANGING p_itab.
    APPEND p_itab TO p_itab.
  ENDWHILE.

ENDFORM.                    &quot;json_to_itab


*&amp;---------------------------------------------------------------------*
*&amp;      Form  json_to_array
*&amp;---------------------------------------------------------------------*
FORM json_to_array TABLES p_itab USING p_json.

  DATA w_pos_deb_val TYPE i.
  DATA w_pos_fin_val TYPE i.
  DATA w_pos_deb_lit TYPE i.
  DATA w_lenvalue TYPE i.
  DATA w_field TYPE string.
  DATA w_value TYPE string.

  FIELD-SYMBOLS &lt;champ&gt; TYPE ANY.

  REFRESH p_itab. &quot;ADDING CBO : a little clear and refresh to avoid getting the last values
  WHILE p_json+w_pos_fin_val CS &apos;&quot;&apos;.
    CLEAR p_itab.&quot;ADDING CBO
    w_pos_deb_val = sy-fdpos + w_pos_fin_val.
    PERFORM get_offset_close USING p_json w_pos_deb_val CHANGING w_pos_fin_val.
    w_lenvalue = w_pos_fin_val - w_pos_deb_val.
    w_value = p_json+w_pos_deb_val(w_lenvalue).
    CALL FUNCTION &apos;Z_JSON_IN&apos;
      EXPORTING
        json  = w_value
      IMPORTING
        struc = p_itab.
    APPEND p_itab TO p_itab.
    w_pos_fin_val = w_pos_fin_val + 1.
  ENDWHILE.

ENDFORM.                    &quot;json_to_array


*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_offset_close
*&amp;---------------------------------------------------------------------*
FORM get_offset_close USING p_json p_offset_open CHANGING p_offset_close.

  DATA w_offset TYPE i.
  DATA w_copen TYPE c.
  DATA w_cclose TYPE c.
  DATA w_pos_echap TYPE i.
  DATA i_result_tabopen TYPE match_result_tab.
  DATA w_result_tabopen TYPE LINE OF match_result_tab.
  DATA i_result_tabclose TYPE match_result_tab.
  DATA w_result_tabclose TYPE LINE OF match_result_tab.
  DATA w_offsetclose_old TYPE i.

  CONSTANTS : c_echap TYPE c VALUE &apos;\&apos;.

  w_copen = p_json+p_offset_open(1).
  CASE w_copen.
    WHEN &apos;&quot;&apos;. w_cclose = &apos;&quot;&apos;.
    WHEN &apos;{&apos;. w_cclose = &apos;}&apos;.
    WHEN &apos;[&apos;. w_cclose = &apos;]&apos;.
  ENDCASE.
  w_offset = p_offset_open + 1.
  IF w_copen EQ &apos;&quot;&apos;.
    FIND ALL OCCURRENCES OF w_cclose IN p_json+w_offset RESULTS i_result_tabclose.
    LOOP AT i_result_tabclose INTO w_result_tabclose.
      w_pos_echap = w_offset + w_result_tabclose-offset - 1.
      CHECK p_json+w_pos_echap(1) NE c_echap.
      EXIT.
    ENDLOOP.
    p_offset_close = w_offset + w_result_tabclose-offset + 1. &quot;CBO due to change in the else statement
  ELSE.
    FIND ALL OCCURRENCES OF w_copen IN p_json+w_offset RESULTS i_result_tabopen.
    PERFORM nettoyage TABLES i_result_tabopen USING p_json w_offset.
    FIND ALL OCCURRENCES OF w_cclose IN p_json+w_offset RESULTS i_result_tabclose.
    PERFORM nettoyage TABLES i_result_tabclose USING p_json w_offset.

*    LOOP AT i_result_tabclose INTO w_result_tabclose.
*      LOOP AT i_result_tabopen INTO w_result_tabopen WHERE offset BETWEEN w_offsetclose_old AND w_result_tabclose-offset.
*        EXIT.
*      ENDLOOP.
*      w_offsetclose_old = w_result_tabclose-offset.
*      CHECK sy-subrc NE 0.
*      EXIT.
*    ENDLOOP.

*   CHANGING CBO : We look to the first close where no open is set before
*                by removing each open corresponding of each close
    DATA w_last_idx LIKE sy-tabix.
    LOOP AT i_result_tabclose INTO w_result_tabclose.
      CLEAR: w_result_tabopen.
      w_last_idx = -1.
      LOOP AT i_result_tabopen INTO w_result_tabopen WHERE offset BETWEEN 0 AND w_result_tabclose-offset.
        w_last_idx = sy-tabix.
      ENDLOOP.
      IF NOT w_last_idx = -1 .
        DELETE i_result_tabopen INDEX w_last_idx.
      ELSE.
        p_offset_close = w_offset + w_result_tabclose-offset + 1.
        EXIT.
      ENDIF.
    ENDLOOP.

  ENDIF.
*  p_offset_close = w_offset + w_result_tabclose-offset + 1.
ENDFORM.                    &quot;get_offset_close


*&amp;---------------------------------------------------------------------*
*&amp;      Form  nettoyage
*&amp;---------------------------------------------------------------------*
FORM nettoyage TABLES i_tab USING p_json p_offset.

  DATA w_tab TYPE LINE OF match_result_tab.
  DATA w_len TYPE i.
  DATA i_result_tabguillemet TYPE match_result_tab.
  DATA w_result_tabguillemet TYPE LINE OF match_result_tab.
  DATA w_pos_echap TYPE i.
  DATA w_count TYPE i.
  DATA w_parite TYPE p DECIMALS 1.

  CONSTANTS : c_echap TYPE c VALUE &apos;\&apos;.

  LOOP AT i_tab INTO w_tab.
    FIND ALL OCCURRENCES OF &apos;&quot;&apos; IN p_json+p_offset(w_tab-offset) RESULTS i_result_tabguillemet.
    CLEAR w_count.
    LOOP AT i_result_tabguillemet INTO w_result_tabguillemet WHERE offset LT w_tab-offset.
      w_pos_echap = p_offset + w_result_tabguillemet-offset - 1.
      CHECK p_json+w_pos_echap(1) NE c_echap.
      w_count = w_count + 1.
    ENDLOOP.
    w_parite = FRAC( w_count / 2 ).
    CHECK w_parite IS NOT INITIAL.
    DELETE i_tab.
  ENDLOOP.

ENDFORM.                    &quot;nettoyage</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_JSON_OBJET" STEXT="CrÃ©er objet json">
    <importing PARAMETER="ENT" REFERENCE="X" TYP="STRING"/>
    <importing PARAMETER="TBL" REFERENCE="X" TYP="ZGY_0004"/>
    <exporting PARAMETER="RET" REFERENCE="X" TYP="STRING"/>
    <documentation PARAMETER="ENT" KIND="P" INDEX=" 001"/>
    <documentation PARAMETER="TBL" KIND="P" STEXT="Table JSON OBJET" INDEX=" 002"/>
    <documentation PARAMETER="RET" KIND="P" INDEX=" 003"/>
    <fm_source>DATA w_tbl TYPE zgs_0004.
  DATA w_sep.
  DATA w_lng TYPE i.

  CONCATENATE &apos;&quot;&apos; ent &apos;&quot;:{&apos; INTO ret.
  DESCRIBE TABLE tbl LINES w_lng.

  LOOP AT tbl INTO w_tbl.
    CONCATENATE ret &apos;&quot;&apos; w_tbl-id &apos;&quot;:&quot;&apos; w_tbl-tx &apos;&quot;&apos; INTO ret.
    IF sy-tabix &lt; w_lng.
      CONCATENATE ret &apos;,&apos; INTO ret.
    ENDIF.
  ENDLOOP.

  CONCATENATE ret &apos;}&apos; INTO ret.

*+---------------------------------------------------------------------
FORM pf_objadd USING p_id p_tx i_tbl TYPE zgy_0004.
*+-------------------------------------------------------------------
  DATA w_tbl TYPE zgs_0004.

  w_tbl-id = p_id.
  w_tbl-tx = p_tx.
  APPEND w_tbl TO i_tbl.

ENDFORM.                    &quot;pf_json_objet_add
*+---------------------------------------------------------------------
FORM pf_json_begin USING p_id p_ret.
*+-------------------------------------------------------------------

  CONCATENATE p_ret &apos;{&apos; INTO p_ret.

ENDFORM.
*+---------------------------------------------------------------------
FORM pf_json_end USING p_id p_ret.
*+-------------------------------------------------------------------

  CONCATENATE p_ret &apos;}&apos; INTO p_ret.

ENDFORM.
*+---------------------------------------------------------------------
FORM pf_json_sep USING p_id p_ret.
*+-------------------------------------------------------------------

  CONCATENATE p_ret &apos;,&apos; INTO p_ret.

ENDFORM.
*+---------------------------------------------------------------------
FORM pf_json_open USING p_id p_ret.
*+-------------------------------------------------------------------

  CONCATENATE p_ret &apos;&quot;&apos; p_id &apos;&quot;:{&apos; INTO p_ret.

ENDFORM.
*+---------------------------------------------------------------------
FORM pf_json_add USING p_id p_txt p_ret.
*+-------------------------------------------------------------------

  CONCATENATE p_ret &apos;&quot;&apos; p_id &apos;&quot;:&quot;&apos; p_txt &apos;&quot;&apos; INTO p_ret.

ENDFORM.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_JSON_FORMATER_VALUE" STEXT="Formater la valeur du champ">
    <changing PARAMETER="STR" REFERENCE="X" TYP="ANY"/>
    <documentation PARAMETER="STR" KIND="P" INDEX=" 001"/>
    <fm_source_new>REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;cr_lf IN str WITH &apos;\n&apos;.

* OH OH... en entrÃ©e il peut dÃ©jÃ  y avoir \&quot; et dans ce cas il deviendrait \\&quot; donc on dÃ©fait et refait.
  REPLACE ALL OCCURRENCES OF &apos;\&quot;&apos; IN str WITH &apos;&quot;&apos;.
  REPLACE ALL OCCURRENCES OF &apos;&quot;&apos; IN str WITH &apos;\&quot;&apos;.</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_JSON_DEFORMATER_VALUE" STEXT="DÃ©formater la valeur du champ">
    <changing PARAMETER="STR" REFERENCE="X"/>
    <documentation PARAMETER="STR" KIND="P" INDEX=" 001"/>
    <fm_source_new>DATA: elemdescr TYPE REF TO cl_abap_elemdescr.
* Description of element
  elemdescr ?= cl_abap_elemdescr=&gt;describe_by_data( STR ).

  CHECK elemdescr-&gt;TYPE_KIND &lt;&gt; &apos;P&apos; and elemdescr-&gt;TYPE_KIND &lt;&gt; &apos;I&apos;.

  REPLACE ALL OCCURRENCES OF &apos;\n&apos; IN str WITH cl_abap_char_utilities=&gt;cr_lf.

  REPLACE ALL OCCURRENCES OF &apos;\&quot;&apos; IN str WITH &apos;&quot;&apos;.</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_JSON_COMPIL_JSONS" STEXT="Compilation de plusieurs JSONs">
    <exporting PARAMETER="JSON" REFERENCE="X" TYP="STRING"/>
    <tables PARAMETER="JSONS" TYP="ZGY_0004"/>
    <documentation PARAMETER="JSON" KIND="P" INDEX=" 001"/>
    <documentation PARAMETER="JSONS" KIND="P" STEXT="Table JSON OBJET" INDEX=" 002"/>
    <fm_source>DATA w_jsons TYPE zgs_0004.
  CLEAR json.

  LOOP AT jsons INTO w_jsons.

    CONCATENATE json &apos;,&quot;&apos; w_jsons-id &apos;&quot;:&apos; w_jsons-tx INTO json.

  ENDLOOP.

  SHIFT json.

  CONCATENATE  &apos;{&apos; json &apos;}&apos; INTO json.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <PROG NAME="YNOT_TOBJ" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Maintenance Object - Data Retrive &amp; HTML Conversion Routines" LENGTH="66 "/>
   </language>
  </textPool>
  <source>***************** Definition of a Maintenance and Transport Object Begin *****************
FORM getdata_tobj USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tobj TYPE s_tobj,
        ls_tvdir TYPE tvdir,
        lv_len   TYPE i,
        ls_tddat TYPE tddat.

  MOVE-CORRESPONDING is_obj_header TO ls_tobj.
  lv_len = strlen( ls_tobj-obj_name ) - 1.
  SELECT SINGLE * FROM tvdir INTO ls_tvdir WHERE tabname = ls_tobj-obj_name(lv_len).
  IF sy-subrc NE 0.
    IF ls_tobj-obj_name+lv_len(1) EQ &apos;C&apos;.
      &quot; maintenance object also exists for view cluster and will be ignored
      PERFORM add_obj_gen_msg USING is_obj_header &apos;W&apos; &apos;&apos;.
    ELSE.
      PERFORM add_obj_gen_msg USING is_obj_header &apos;E&apos; text_tobj-msg_obj_invalid.
    ENDIF.
    RETURN.
  ENDIF.

  MOVE-CORRESPONDING ls_tvdir TO ls_tobj.
  ls_tobj-maint_type = ls_tvdir-type.
  ls_tobj-devclass = ls_tvdir-devclass.
  SELECT SINGLE * FROM tddat INTO ls_tddat WHERE tabname = ls_tvdir-tabname.
  MOVE-CORRESPONDING ls_tddat TO ls_tobj.
  SELECT * FROM tvimf INTO CORRESPONDING FIELDS OF TABLE ls_tobj-events WHERE tabname = ls_tobj-tabname.

  APPEND ls_tobj TO gt_tobj.
ENDFORM.

FORM get_additional_html_tobj USING ls_tobj TYPE s_tobj CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_tobj &apos;S_TOBJ&apos; &apos;TABNAME|CCLASS|AREA|DEVCLASS|MAINT_TYPE|LISTE|DETAIL&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_tobj USING ls_tobj TYPE s_tobj CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  CHECK ls_tobj-events IS NOT INITIAL.
  PERFORM get_small_title_html USING text_tobj-label_events CHANGING ct_html.
  PERFORM get_paragraph_html USING text_tobj-txt_mt_event CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; ls_tobj-events &apos;TVIMF&apos; &apos;EVENT|FORMNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Definition of a Maintenance and Transport Object Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_TRAN" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Transaction - Data Retrive &amp; HTML Conversion Routines" LENGTH="59 "/>
   </language>
  </textPool>
  <source>***************** Transaction Begin *****************
FORM getdata_tran USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tran     TYPE s_tran,
        lv_tcode    TYPE tcode,
        lt_gui_attr TYPE TABLE OF tstcc.

  MOVE-CORRESPONDING is_obj_header TO ls_tran.
  lv_tcode = ls_tran-obj_name.
* basic attributes, gui, param, authority, uiclass, short text
  SELECT SINGLE * FROM tstcv INTO ls_tran-basic_info WHERE tcode = lv_tcode AND sprsl = sy-langu.
* tstcc may not be retrieved from db directly, call RPY_TRANSACTION_READ
  CALL FUNCTION &apos;RPY_TRANSACTION_READ&apos;
    EXPORTING
      transaction      = lv_tcode
    TABLES
      gui_attributes   = lt_gui_attr
    EXCEPTIONS
      permission_error = 1
      cancelled        = 2
      not_found        = 3
      object_not_found = 4
      OTHERS           = 5.                                 &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0.
  READ TABLE lt_gui_attr INTO ls_tran-gui_attributes INDEX 1.
  ls_tran-gui_attributes-s_webgui = boolc( ls_tran-gui_attributes-s_webgui EQ &apos;1&apos; ).

  SELECT SINGLE param FROM tstcp INTO ls_tran-param WHERE tcode = lv_tcode.
  SELECT * FROM tstca INTO TABLE ls_tran-authority WHERE tcode = lv_tcode.
  SELECT SINGLE * FROM tstcclass INTO ls_tran-uiclass WHERE tcode = lv_tcode.
  ls_tran-short_text = ls_tran-basic_info-ttext.
* determine transaction type
  IF ls_tran-basic_info-cinfo EQ &apos;04&apos;.
    ls_tran-transaction_type = c_trans_type-dialog.
  ELSEIF ls_tran-basic_info-cinfo EQ &apos;80&apos;.
    ls_tran-transaction_type = c_trans_type-report.
  ELSEIF ls_tran-basic_info-cinfo EQ &apos;08&apos;.
    ls_tran-transaction_type = c_trans_type-oo.
  ELSEIF ls_tran-basic_info-cinfo EQ &apos;02&apos; AND ls_tran-param IS NOT INITIAL.
    CALL FUNCTION &apos;RS_TRANSACTION_SINGLE_GET&apos;
      EXPORTING
        parameter_tcode = lv_tcode
      IMPORTING
        tcode           = ls_tran-transaction.
    IF ls_tran-transaction IS NOT INITIAL.
      &quot; OO transaction
      IF ls_tran-transaction EQ &apos;OS_APPLICATION&apos;.
        ls_tran-transaction_type = c_trans_type-oo.
        &quot; transaction with variant
      ELSEIF ls_tran-param(2) EQ &apos;@@&apos;.
        ls_tran-transaction_type = c_trans_type-trans_with_variant.
        &quot; transaction with parameter
      ELSEIF ls_tran-param(2) EQ &apos;/*&apos; OR ls_tran-param(2) EQ &apos;/N&apos;.
        ls_tran-transaction_type = c_trans_type-trans_with_param.
      ENDIF.
    ELSEIF ls_tran-param(1) EQ &apos;\&apos;.
      ls_tran-transaction_type = c_trans_type-oo.
    ENDIF.

    PERFORM split_param2table USING ls_tran-param CHANGING ls_tran-param_values.
  ENDIF.

  APPEND ls_tran TO gt_tran.
ENDFORM.

FORM get_additional_html_tran USING ls_tran TYPE s_tran CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: lv_tp_txt      TYPE ddtext,
        lv_html         TYPE string.

  PERFORM get_value_desc USING &apos;TRANSACTION_TYPE&apos; ls_tran-transaction_type CHANGING lv_tp_txt.
  PERFORM get_2column_value_html USING text_tran-label_type lv_tp_txt CHANGING ct_html.
  CASE ls_tran-transaction_type.
    WHEN c_trans_type-dialog.
      PERFORM get_dialog_value_html USING ls_tran CHANGING ct_html.
    WHEN c_trans_type-report.
      PERFORM get_report_value_html USING ls_tran CHANGING ct_html.
    WHEN c_trans_type-oo.
      PERFORM get_oo_value_html USING ls_tran-param ls_tran-param_values CHANGING ct_html.
    WHEN c_trans_type-trans_with_variant.
      PERFORM get_trans_variant_value_html USING ls_tran-param CHANGING ct_html.
    WHEN c_trans_type-trans_with_param.
      PERFORM get_2column_value_html USING text_tran-label_transaction ls_tran-transaction CHANGING ct_html.
      PERFORM get_2column_value_html USING text_tran-label_skip_init_screen &apos;X&apos; CHANGING ct_html.
      PERFORM table2tr USING text_tran-label_default_values ls_tran-param_values &apos;S_TRAN_DEFAULT_VALUE&apos; &apos;SCREEN_FIELD|VALUE&apos; CHANGING ct_html.
  ENDCASE.

  PERFORM get_classfication_html USING ls_tran CHANGING lv_html.
  PERFORM get_2column_right_table_html USING text_tran-label_classification lv_html CHANGING ct_html.
ENDFORM.

FORM split_param2table USING iv_tcode_param TYPE s_tran-param CHANGING ct_param_values TYPE STANDARD TABLE.
  DATA: lv_dummy      TYPE string,
        lv_fld_values TYPE string,
        lt_dfvalue    TYPE TABLE OF string,
        ls_param      TYPE s_tran_default_value,
        lt_param      TYPE TABLE OF s_tran_default_value.
  FIELD-SYMBOLS: &lt;fs_dfvalue&gt; TYPE string.

  CHECK iv_tcode_param IS NOT INITIAL.
  SPLIT iv_tcode_param AT space INTO lv_dummy lv_fld_values.
  SPLIT lv_fld_values AT &apos;;&apos; INTO TABLE lt_dfvalue.
  CHECK lt_dfvalue IS NOT INITIAL.

  LOOP AT lt_dfvalue ASSIGNING &lt;fs_dfvalue&gt;.
    SPLIT &lt;fs_dfvalue&gt; AT &apos;=&apos; INTO ls_param-screen_field ls_param-value.
    APPEND ls_param TO lt_param.
    CLEAR ls_param.
  ENDLOOP.

  CLEAR ct_param_values.
  ct_param_values = lt_param.
ENDFORM.

FORM get_classfication_html USING is_tran TYPE s_tran CHANGING cv_html TYPE string.
  DATA: lt_html TYPE TABLE OF string.

  APPEND gcv_table_begin TO lt_html.
  &quot; TODO: replace hardcoded values
  PERFORM get_2column_value_html USING text_tran-label_inherit_gui &apos;X&apos; CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_prof_user &apos;X&apos; CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_easy_web &apos;&apos;  CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_service  is_tran-gui_attributes-s_service CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_pervasive is_tran-gui_attributes-s_pervas CHANGING lt_html.
  PERFORM data2rows_common USING is_tran-gui_attributes &apos;TSTCC&apos; &apos;S_WEBGUI|S_PLATIN|S_WIN32&apos; abap_false CHANGING lt_html.
  APPEND gcv_table_end TO lt_html.

  PERFORM join_str USING lt_html CHANGING cv_html.
ENDFORM.

FORM get_dialog_value_html USING is_tran TYPE s_tran CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_value_html4dialog_report USING c_trans_type-dialog is_tran CHANGING ct_html.
ENDFORM.

FORM get_value_html4dialog_report USING iv_trans_type TYPE c is_tran TYPE s_tran CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_tstca TYPE tstca.

  PERFORM data2rows USING is_tran-basic_info &apos;TSTC&apos; &apos;PGMNA|DYPNO&apos; CHANGING ct_html.
  IF is_tran-authority IS NOT INITIAL.
    READ TABLE is_tran-authority INTO ls_tstca INDEX 1.
    PERFORM data2rows USING ls_tstca &apos;TSTCA&apos; &apos;OBJCT&apos; CHANGING ct_html.
    PERFORM table2tr USING text_tran-label_auth_values is_tran-authority &apos;TSTCA&apos; &apos;FIELD|VALUE&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_report_value_html USING is_tran TYPE s_tran CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_value_html4dialog_report USING c_trans_type-report is_tran CHANGING ct_html.
ENDFORM.

FORM get_oo_value_html USING iv_param TYPE s_tran-param it_param_values TYPE t_tran_default_value CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lt_html    TYPE TABLE OF string,
        lv_oo_mode TYPE c,
        lv_text    TYPE ddtext.
  FIELD-SYMBOLS: &lt;fs_pv&gt; TYPE s_tran_default_value.

  APPEND gcv_table_begin TO lt_html.
  lv_oo_mode = boolc( iv_param(1) NE &apos;\&apos; ).
  PERFORM get_2column_value_html USING text_tran-label_oo_mode lv_oo_mode CHANGING lt_html.

  LOOP AT it_param_values ASSIGNING &lt;fs_pv&gt;.
    CASE &lt;fs_pv&gt;-screen_field.
      WHEN &apos;CLASS&apos;.
        PERFORM get_2column_value_html USING text_tran-label_oo_clas &lt;fs_pv&gt;-value CHANGING lt_html.
      WHEN &apos;METHOD&apos;.
        PERFORM get_2column_value_html USING text_tran-label_oo_meth &lt;fs_pv&gt;-value CHANGING lt_html.
      WHEN &apos;PROGRAM&apos;.
        PERFORM get_2column_value_html USING text_tran-label_oo_local_prog &lt;fs_pv&gt;-value CHANGING lt_html.
      WHEN &apos;UPDATE_MODE&apos;.
        PERFORM get_value_desc USING &apos;UPDATE_MODE&apos; &lt;fs_pv&gt;-value CHANGING lv_text.
        PERFORM get_2column_value_html USING text_tran-label_oo_update_mode lv_text CHANGING lt_html.
    ENDCASE.
  ENDLOOP.
  APPEND gcv_table_end TO lt_html.
  APPEND LINES OF lt_html TO ct_html.
ENDFORM.

FORM get_trans_variant_value_html USING iv_param TYPE s_tran-param CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tcode TYPE string,
        lv_vari  TYPE string.
  SPLIT iv_param AT space INTO lv_tcode lv_vari.
  SHIFT lv_tcode BY 2 PLACES.

  PERFORM get_2column_value_html USING text_tran-label_transaction lv_tcode CHANGING ct_html.
  PERFORM get_2column_value_html USING text_tran-label_transaction_variant lv_vari CHANGING ct_html.
ENDFORM.
***************** Transaction Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_TTYP" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Table Type - Data Retrive &amp; HTML Conversion Routines" LENGTH="58 "/>
   </language>
  </textPool>
  <source>***************** Table Type Begin *****************
FORM getdata_ttyp USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_ttyp_reuse USING is_obj_header.
ENDFORM.

FORM getdata_ttyp_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_ttyp TYPE s_ttyp,
        lv_ttype_name TYPE ddobjname,
        ls_dd40v      TYPE dd40v.

  lv_ttype_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
    EXPORTING
      name          = lv_ttype_name
      langu         = sy-langu
    IMPORTING
      dd40v_wa      = ls_dd40v
    TABLES
      dd42v_tab     = ls_ttyp-primary_key
      dd43v_tab     = ls_ttyp-secondary_key
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd40v IS NOT INITIAL.
  MOVE-CORRESPONDING is_obj_header TO ls_ttyp.

  MOVE-CORRESPONDING ls_dd40v TO ls_ttyp.
  PERFORM get_activity USING ls_dd40v-as4date CHANGING ls_ttyp-activity.
  ls_ttyp-short_text = ls_dd40v-ddtext.

  IF ls_ttyp-object EQ &apos;TTYP&apos;.
    APPEND ls_ttyp TO gt_ttyp.
  ELSEIF ls_ttyp-object EQ &apos;TTYD&apos;.
    ls_ttyp-activity = gcv_act_update.
    APPEND ls_ttyp TO gt_ttyd.
  ENDIF.
ENDFORM.

FORM get_additional_html_ttyp USING is_ttyp TYPE s_ttyp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_2column_value_html USING text_ttyp-label_row_type is_ttyp-rowtype CHANGING ct_html.
ENDFORM.
***************** Table Type Close *****************

***************** Table Type Definition Begin *****************
FORM getdata_ttyd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_ttyp_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_ttyd USING is_ttyd TYPE s_ttyd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_ttyp USING is_ttyd CHANGING ct_html.
ENDFORM.
***************** Table Type Definition Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_TYPES" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Supported Object Types Definition &amp; Constants &amp; Global Data" LENGTH="65 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------Types Definition: utility types-----------------*
TYPE-POOLS: icon, trwbo.
TYPES: BEGIN OF s_objtype_order,
       object          TYPE trobjtype,
       sort_no         TYPE i,
       show_basic_attr TYPE abap_bool,
       END OF s_objtype_order.
TYPES: ht_objtype_order TYPE HASHED TABLE OF s_objtype_order WITH UNIQUE KEY object.

TYPES: BEGIN OF s_object_instruction,
       object      TYPE trobjtype,
       instruction TYPE string,
       END OF s_object_instruction.
TYPES: ht_object_instruction TYPE HASHED TABLE OF s_object_instruction WITH UNIQUE KEY object.

TYPES: BEGIN OF s_lintype,
       line(1024) TYPE x,
       END OF s_lintype.
TYPES: t_linetype TYPE STANDARD TABLE OF s_lintype WITH DEFAULT KEY.
TYPES: t_string TYPE STANDARD TABLE OF string WITH DEFAULT KEY.

TYPES: BEGIN OF s_obj_header,
       pgmid          TYPE  pgmid,
       object         TYPE trobjtype,
       obj_name	      TYPE sobj_name,
       primary_sort   TYPE i,
       secondary_sort TYPE numc2,
       devclass       TYPE devclass,
       short_text     TYPE ddtext,
       screenshots    TYPE int1,
       activity       TYPE char6,
       END OF s_obj_header.

TYPES: BEGIN OF s_value_desc,
       fieldname   TYPE fieldname,
       ddfixvalues TYPE ddfixvalues,
       END OF s_value_desc.

TYPES: BEGIN OF s_common_msg,
       msgty TYPE sy-msgty,
       msg TYPE string,
       END OF s_common_msg.

TYPES: BEGIN OF s_obj_gen_msg.
        INCLUDE TYPE s_obj_header.
        INCLUDE TYPE s_common_msg.
TYPES: END OF s_obj_gen_msg.
*&amp;--Types for supported kinds of objects, Naming Convention: s_{objtype}--*
TYPES: t_package_interface TYPE TABLE OF vintf WITH DEFAULT KEY.
TYPES: BEGIN OF s_devc.
        INCLUDE TYPE s_obj_header.
TYPES: parentcl               TYPE parentcl.
TYPES: pdevclass              TYPE devlayer.
TYPES: component              TYPE uffctr.
TYPES: dlvunit                TYPE dlvunit.
TYPES: applicat               TYPE trdevcappl.
TYPES: mainpack               TYPE mainpack.
TYPES: korrflag               TYPE korrflag.
TYPES: project_id             TYPE pak_project_id.
TYPES: translation_relevance  TYPE c LENGTH 60.
TYPES: use_accesses           TYPE permis_tab.
TYPES: interfaces             TYPE t_package_interface.
TYPES: END OF s_devc.

TYPES: BEGIN OF s_devp.
        INCLUDE TYPE s_devc.
TYPES: END OF s_devp.

TYPES: BEGIN OF s_pinf.
        INCLUDE TYPE s_obj_header.
        INCLUDE STRUCTURE vintf.
TYPES: END OF s_pinf.

TYPES: BEGIN OF s_fugr.
        INCLUDE TYPE s_obj_header.
TYPES: END OF s_fugr.

TYPES: BEGIN OF s_fugt.
        INCLUDE TYPE s_fugr.
TYPES: END OF s_fugt.

TYPES: t_dd07v TYPE STANDARD TABLE OF dd07v WITH DEFAULT KEY.
TYPES: BEGIN OF s_doma.
        INCLUDE TYPE s_obj_header.
TYPES: datatype    TYPE datatype_d.
TYPES: leng        TYPE ddleng.
TYPES: outputlen   TYPE outputlen.
TYPES: decimals    TYPE decimals.
TYPES: lowercase   TYPE lowercase.
TYPES: signflag    TYPE signflag.
TYPES: valexi      TYPE valexi.
TYPES: entitytab   TYPE entitytab.
TYPES: value_range TYPE t_dd07v.
TYPES: END OF s_doma.

TYPES: BEGIN OF s_domd.
        INCLUDE TYPE s_doma.
TYPES: END OF s_domd.

TYPES: BEGIN OF s_dtel.
        INCLUDE TYPE s_obj_header.
TYPES: domname   TYPE domname.
TYPES: headlen   TYPE headlen.
TYPES: scrlen1   TYPE scrlen_s.
TYPES: scrlen2   TYPE scrlen_m.
TYPES: scrlen3   TYPE scrlen_l.
TYPES: reptext   TYPE reptext.
TYPES: scrtext_s TYPE scrtext_s.
TYPES: scrtext_m TYPE scrtext_m.
TYPES: scrtext_l TYPE scrtext_l.
TYPES: datatype  TYPE datatype_d.
TYPES: leng      TYPE ddleng.
TYPES: END OF s_dtel.

TYPES: BEGIN OF s_dted.
        INCLUDE TYPE s_dtel.
TYPES: END OF s_dted.

TYPES: BEGIN OF s_tabl_fk_def,
        fieldname   TYPE  forfield,
        fortable    TYPE  fortable,
        forkey      TYPE  forkey,
        checktable  TYPE  checktable,
        checkfield  TYPE  fieldname,
        generic     TYPE  c,
        constant    TYPE  c LENGTH 30,
       END OF s_tabl_fk_def.
TYPES: t_tabl_fk_def TYPE TABLE OF s_tabl_fk_def WITH DEFAULT KEY.

TYPES: BEGIN OF s_tabl_field,
       fieldname    TYPE fieldname,
       keyflag      TYPE keyflag,
       rollname     TYPE rollname,
       checktable   TYPE checktable,
       shlpname     TYPE shlpname,
       typing_method TYPE string,
       END OF s_tabl_field.
TYPES: t_tabl_field TYPE STANDARD TABLE OF s_tabl_field WITH DEFAULT KEY.

TYPES: BEGIN OF s_tabl_index,
       indexname TYPE indexid,
       isextind  TYPE ddisextind,
       ddtext    TYPE ddtext,
       uniqueflag TYPE uniqueflag,
       dbindex    TYPE dbindex_d,
       dbstate    TYPE ddixdbstat,
       dbinclexcl TYPE ddixincex,
       index_fields TYPE string,
       END OF s_tabl_index.
TYPES: t_tabl_index TYPE STANDARD TABLE OF s_tabl_index WITH DEFAULT KEY.

TYPES: BEGIN OF s_tabl.
        INCLUDE TYPE s_obj_header.
TYPES:  tabclass  TYPE  tabclass.
TYPES:  contflag  TYPE  contflag.
TYPES:  mainflag  TYPE  maintflag.
TYPES:  fields    TYPE  t_tabl_field.
TYPES:  tech_setting  TYPE  dd09v.
TYPES:  namespace     TYPE  db6tresc_tab.
TYPES:  foreign_key_header  TYPE  dd08vttyp.
TYPES:  foreign_keys  TYPE  t_tabl_fk_def.
TYPES:  assignments   TYPE  dd35vttyp.
TYPES:  index         TYPE  t_tabl_index.
TYPES: END OF s_tabl.

TYPES: BEGIN OF s_tabd.
        INCLUDE TYPE s_tabl.
TYPES: END OF s_tabd.

TYPES: t_table_join          TYPE STANDARD TABLE OF dd26v WITH DEFAULT KEY.
TYPES: t_view_fields         TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY.
TYPES: t_join_condition      TYPE STANDARD TABLE OF dd28j WITH DEFAULT KEY.
TYPES: t_selection_condition TYPE STANDARD TABLE OF dd28v WITH DEFAULT KEY.

TYPES: BEGIN OF s_view.
        INCLUDE TYPE s_obj_header.
TYPES:  viewclass   TYPE  viewclass.
TYPES:  customauth  TYPE  contflag.
TYPES:  viewgrant   TYPE  viewgrant.
TYPES:  globalflag  TYPE  maintflag.
TYPES:  table_join  TYPE  t_table_join.
TYPES:  fields      TYPE  t_view_fields.
TYPES:  join_condition       TYPE  t_join_condition.
TYPES:  selection_condition  TYPE  t_selection_condition.
TYPES:  tech_setting         TYPE  dd09v.
TYPES: END OF s_view.

TYPES: BEGIN OF s_vied.
        INCLUDE TYPE s_view.
TYPES: END OF s_vied.

TYPES: t_vclstruc TYPE STANDARD TABLE OF v_vclstruc WITH DEFAULT KEY.
TYPES: t_vclstdep TYPE STANDARD TABLE OF  v_vclstdep WITH DEFAULT KEY.
TYPES: t_maintenance_events TYPE STANDARD TABLE OF tvimf WITH DEFAULT KEY.
TYPES: t_viewcluster_events TYPE STANDARD TABLE OF v_vclmf WITH DEFAULT KEY.

TYPES: BEGIN OF s_vcls.
        INCLUDE TYPE s_obj_header.
TYPES:  hieropsoff  TYPE  sychar01.
TYPES:  readkind    TYPE  sychar01.
TYPES:  basevcl     TYPE  vcl_name.
TYPES:  exitprog    TYPE  programm.
TYPES:  object_stru TYPE  t_vclstruc.
TYPES:  field_dep   TYPE  t_vclstdep.
TYPES:  events      TYPE  t_viewcluster_events.
TYPES: END OF s_vcls.

TYPES: BEGIN OF s_tobj.
        INCLUDE TYPE s_obj_header.
TYPES:  tabname TYPE  vim_name.
TYPES:  area    TYPE  funct_pool.
TYPES:  maint_type    TYPE  maint_type.
TYPES:  liste   TYPE  list_scr.
TYPES:  detail  TYPE  single_scr.
TYPES:  mclass  TYPE  ddmclass.
TYPES:  cclass  TYPE  dicbercls.
TYPES:  events  TYPE  t_maintenance_events.
TYPES: END OF s_tobj.

TYPES: BEGIN OF s_shlp.
        INCLUDE TYPE s_obj_header.
TYPES:  issimple   TYPE  ddshsimple.
TYPES:  selmethod  TYPE  selmethod.
TYPES:  selmtype   TYPE  selmtype.
TYPES:  selmexit   TYPE  ddshselext.
TYPES:  hotkey     TYPE  ddshhotkey.
TYPES:  dialogtype TYPE  ddshdiatyp.
TYPES:  params     TYPE  rsdg_t_dd32p.
TYPES: END OF s_shlp.

TYPES: BEGIN OF s_shld.
        INCLUDE TYPE s_shlp.
TYPES: END OF s_shld.

TYPES: t_base_table TYPE STANDARD TABLE OF dd26e WITH DEFAULT KEY.
TYPES: t_lock_param TYPE STANDARD TABLE OF ddena WITH DEFAULT KEY.
TYPES: BEGIN OF s_enqu.
        INCLUDE TYPE s_obj_header.
TYPES:  rfcenable    TYPE  rfcenable.
TYPES:  base_tables  TYPE  t_base_table.
TYPES:  lock_params  TYPE  t_lock_param.
TYPES: END OF s_enqu.

TYPES: BEGIN OF s_enqd.
        INCLUDE TYPE s_enqu.
TYPES: END OF s_enqd.

TYPES: t_dd42v TYPE STANDARD TABLE OF dd42v WITH DEFAULT KEY.
TYPES: t_dd43v TYPE STANDARD TABLE OF dd43v WITH DEFAULT KEY.
TYPES: BEGIN OF s_ttyp.
        INCLUDE TYPE s_obj_header.
TYPES:  rowtype     TYPE  ttrowtype.
TYPES:  accessmode  TYPE  accessmode.
TYPES:  keydef   TYPE  ttypkeydef.
TYPES:  keykind  TYPE  keykind.
TYPES:  keyfdcount  TYPE  keyfdcnt.
TYPES:  generic     TYPE  typgeneric.
TYPES:  typelen     TYPE  ddleng.
TYPES:  ttypkind    TYPE  ttypkind.
TYPES:  range_ctyp  TYPE  range_ctyp.
TYPES:  reftype     TYPE  ddreftype.
TYPES:  occurs      TYPE  ddoccurs.
TYPES:  primary_key    TYPE  t_dd42v.
TYPES:  secondary_key  TYPE  t_dd43v.
TYPES: END OF s_ttyp.

TYPES: BEGIN OF s_ttyd.
        INCLUDE TYPE s_ttyp.
TYPES: END OF s_ttyd.

TYPES: BEGIN OF s_nrob.
        INCLUDE TYPE s_obj_header.
TYPES:  txt  TYPE  nrobjtxt.
TYPES:  dtelsobj    TYPE  nrsobjnam.
TYPES:  domlen      TYPE  nrlendom.
TYPES:  percentage  TYPE  nrperc.
TYPES:  code        TYPE  nrcode.
TYPES:  buffer      TYPE  nrbuffer.
TYPES:  noivbuffer  TYPE  nrivbuffer.
TYPES:  nonrswap    TYPE  nrswap.
TYPES:  yearind     TYPE  nryearind.
TYPES: END OF s_nrob.

TYPES: BEGIN OF s_msg_txt.
        INCLUDE TYPE t100.
TYPES: self_explanatory TYPE c.
TYPES: END  OF s_msg_txt.
TYPES: t_message_txt TYPE STANDARD TABLE OF s_msg_txt WITH DEFAULT KEY.

TYPES: t_tline TYPE STANDARD TABLE OF tline WITH DEFAULT KEY.
TYPES: BEGIN OF s_long_text.
        INCLUDE TYPE t100.
TYPES: long_text TYPE t_tline.
TYPES: END OF  s_long_text.
TYPES: t_long_text TYPE STANDARD TABLE OF s_long_text WITH DEFAULT KEY.

TYPES: BEGIN OF s_msad.
        INCLUDE TYPE s_obj_header.
TYPES:  message_texts  TYPE t_message_txt.
TYPES:  long_texts     TYPE t_long_text.
TYPES: END OF s_msad.

TYPES: BEGIN OF s_msag.
        INCLUDE TYPE s_msad.
TYPES: END OF s_msag.

TYPES: BEGIN OF s_mess.
        INCLUDE TYPE s_obj_header.
        INCLUDE TYPE s_msg_txt.
TYPES: long_text TYPE t_tline.
TYPES: END OF s_mess.

TYPES: BEGIN OF s_docu.
        INCLUDE TYPE s_obj_header.
TYPES: long_text TYPE t_tline.
TYPES: END OF s_docu.

TYPES: t_primary_key TYPE STANDARD TABLE OF e071k  WITH DEFAULT KEY.
TYPES: t_field_info  TYPE STANDARD TABLE OF e071kf WITH DEFAULT KEY.
TYPES: BEGIN OF s_vdat.
        INCLUDE TYPE s_obj_header.
TYPES: primary_keys TYPE t_primary_key.
TYPES: field_info   TYPE t_field_info.
TYPES: END OF s_vdat.
TYPES: t_vdat TYPE STANDARD TABLE OF s_vdat WITH DEFAULT KEY.

TYPES: BEGIN OF s_cdat.
        INCLUDE TYPE s_vdat.
TYPES:  object_stru TYPE t_vclstruc.
TYPES: END OF s_cdat.

TYPES: BEGIN OF s_vdat_ignore,
        vcls_name TYPE sobj_name,
        obj_name TYPE sobj_name,
       END OF s_vdat_ignore.

TYPES: BEGIN OF s_tabu.
        INCLUDE TYPE s_vdat.
TYPES: END OF s_tabu.

TYPES: t_tcode_authority TYPE STANDARD TABLE OF tstca WITH DEFAULT KEY.
TYPES: BEGIN OF s_tran_default_value,
       screen_field TYPE eu_para_fn,
       value        TYPE eu_para_vl,
       END OF s_tran_default_value.
TYPES: t_tran_default_value TYPE STANDARD TABLE OF s_tran_default_value WITH DEFAULT KEY.
TYPES: BEGIN OF s_tran.
        INCLUDE TYPE s_obj_header.
TYPES: transaction_type TYPE  c.
TYPES: authority        TYPE  t_tcode_authority.
TYPES: basic_info       TYPE  tstcv.
TYPES: gui_attributes   TYPE  tstcc.
TYPES: uiclass          TYPE  tstcclass.
TYPES: param            TYPE  tcdparam.
TYPES: param_values     TYPE  t_tran_default_value.
TYPES: transaction      TYPE  tcode.
TYPES: END OF s_tran.</source>
 </PROG>
 <PROG NAME="YNOT_UI" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: UI Specific Routines" LENGTH="26 "/>
   </language>
  </textPool>
  <source>FORM f4_request.
  DATA: ls_selected_request TYPE trwbo_request_header,
        lv_organizer_type   TYPE trwbo_calling_organizer VALUE &apos;W&apos;,
        ls_selection        TYPE trwbo_selection.

  ls_selection-reqstatus = &apos;R&apos;.
  CALL FUNCTION &apos;TR_PRESENT_REQUESTS_SEL_POPUP&apos;
    EXPORTING
      iv_organizer_type   = lv_organizer_type
      is_selection        = ls_selection
    IMPORTING
      es_selected_request = ls_selected_request.

  so_trans-low = ls_selected_request-trkorr.
ENDFORM.

FORM f4_exclude_objects.
  DATA: lt_objects TYPE TABLE OF s_obj_header,
        lt_ddsh    TYPE TABLE OF ddshretval.

  PERFORM collect_objects_header_in_tr CHANGING lt_objects.
  CHECK lt_objects IS NOT INITIAL.
  SORT lt_objects BY object obj_name ASCENDING.

  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;OBJ_NAME&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      dynprofield     = &apos;SO_EXCLU&apos;
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lt_objects
      return_tab      = lt_ddsh
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
ENDFORM.

FORM select_download_dir CHANGING cv_dir TYPE string.
  cl_gui_frontend_services=&gt;directory_browse(
    CHANGING
      selected_folder      =     cv_dir
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4
      ).

  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
ENDFORM.

FORM select_transport_file CHANGING cv_file TYPE string.
  DATA: lv_desktop_path TYPE string,
        lt_filetable    TYPE filetable,
        lv_user_action  TYPE i,
        lv_msg          TYPE string,
        lv_rc           TYPE i.

  cl_gui_frontend_services=&gt;get_desktop_directory(
    CHANGING
      desktop_directory = lv_desktop_path
    ).

  cl_gui_frontend_services=&gt;file_open_dialog(
    EXPORTING
      default_extension       = &apos;*.zip&apos;                     &quot;#EC NOTEXT
      initial_directory       = lv_desktop_path
      file_filter             = cl_gui_frontend_services=&gt;filetype_all
      multiselection          = abap_false
    CHANGING
      file_table              = lt_filetable
      user_action             = lv_user_action
      rc                      = lv_rc
    EXCEPTIONS
      file_open_dialog_failed = 1
      cntl_error              = 2
      error_no_gui            = 3
      not_supported_by_gui    = 4
      OTHERS                  = 5
    ).

  IF sy-subrc EQ 0.
    READ TABLE lt_filetable INDEX 1 INTO cv_file.
  ELSE.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
    MESSAGE e208(00) WITH lv_msg.
  ENDIF.
ENDFORM.

FORM scenario_switch.
  DATA: lv_hide_id1 TYPE c LENGTH 3,
        lv_hide_id2 TYPE c LENGTH 3.

  IF export EQ abap_true.
    lv_hide_id1 = &apos;IMP&apos;.
    lv_hide_id2 = &apos;COD&apos;.
  ELSEIF import EQ abap_true.
    lv_hide_id1 = &apos;EXP&apos;.
    lv_hide_id2 = &apos;COD&apos;.
  ELSEIF code EQ abap_true.
    lv_hide_id1 = &apos;EXP&apos;.
    lv_hide_id2 = &apos;IMP&apos;.
  ENDIF.

  LOOP AT SCREEN.
    IF screen-group1 EQ lv_hide_id1 OR screen-group1 EQ lv_hide_id2.
      screen-active = &apos;0&apos;.
      screen-invisible = &apos;1&apos;.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
ENDFORM.

FORM validate_params CHANGING cv_msg TYPE string.
  CLEAR cv_msg.

  IF export EQ abap_true.
    IF so_trans IS INITIAL.
      cv_msg = &apos;Please select transport request&apos;.
      RETURN.
    ELSE.
      DATA: lt_e070 TYPE TABLE OF e070,
            ls_e070 TYPE e070.

      SELECT * FROM e070 INTO TABLE lt_e070 WHERE trkorr IN so_trans AND trstatus EQ &apos;R&apos; ORDER BY as4date ASCENDING.
      LOOP AT so_trans.
        READ TABLE lt_e070 WITH KEY trkorr = so_trans-low TRANSPORTING NO FIELDS.
        IF sy-subrc NE 0.
          CONCATENATE &apos;Request &apos; so_trans-low &apos; does not exist or is not released yet.&apos; INTO cv_msg RESPECTING BLANKS.
          RETURN.
        ENDIF.
      ENDLOOP.

      READ TABLE lt_e070 INTO ls_e070 INDEX 1.
      gv_tr_date = ls_e070-as4date.
    ENDIF.

    IF p_dir IS INITIAL.
      cv_msg = &apos;Please select export folder&apos;.
      RETURN.
    ENDIF.

    IF p_doc IS INITIAL.
      cv_msg = &apos;Please input document title&apos;.
      RETURN.
    ENDIF.
  ENDIF.

  IF import EQ abap_true.
    IF p_file IS INITIAL.
      cv_msg = &apos;Please upload a transport zip file&apos;.
      RETURN.
    ELSE.
      PERFORM check_transport_zip CHANGING cv_msg.
      IF cv_msg IS NOT INITIAL.
        RETURN.
      ENDIF.
    ENDIF.
  ENDIF.

  IF code EQ abap_true.
    DATA: lv_confirm_msg TYPE string,
          lv_answer      TYPE c.

    CLEAR gt_objtype2codes.

    LOOP AT so_objt.
      READ TABLE gt_ko100 WITH TABLE KEY object = so_objt-low TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        CONCATENATE so_objt-low &apos; is a invalid object type, please check it.&apos; INTO cv_msg RESPECTING BLANKS.
        RETURN.
      ENDIF.

      READ TABLE gt_objtype_desc WITH TABLE KEY object = so_objt-low TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        CONCATENATE &apos;Object Type &apos; so_objt-low &apos; has been supported already, do you still want to print code template?&apos;
          INTO lv_confirm_msg RESPECTING BLANKS.

        CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
          EXPORTING
            text_question = lv_confirm_msg
          IMPORTING
            answer        = lv_answer.

        IF lv_answer EQ &apos;1&apos;.
          APPEND so_objt-low TO gt_objtype2codes.
        ENDIF.
        CLEAR lv_confirm_msg.
      ELSE.
        APPEND so_objt-low TO gt_objtype2codes.
      ENDIF.
    ENDLOOP.

    IF gt_objtype2codes IS INITIAL.
      cv_msg = &apos;Please select at least one valid object type&apos;.
      RETURN.
    ENDIF.
  ENDIF.
ENDFORM.

FORM response.
  DATA: lv_msg   TYPE string,
        lv_start TYPE i,
        lv_end   TYPE i,
        lv_str   TYPE string,
        lv_cost  TYPE p DECIMALS 2,
        lv_file  TYPE string.

  PERFORM validate_params CHANGING lv_msg.
  IF lv_msg IS NOT INITIAL.
    MESSAGE s208(00) WITH lv_msg.
    RETURN.
  ENDIF.

  GET RUN TIME FIELD lv_start.
  IF export EQ abap_true.
    PERFORM prepare_html_head.
    PERFORM prepare_html_body.
    IF gt_html IS NOT INITIAL.
      APPEND LINES OF gt_html TO gt_html_all.
      PERFORM prepare_html_tail.
      PERFORM export_docu CHANGING lv_file.
    ENDIF.
    IF p_bin EQ abap_true.
      PERFORM export_transport_files.
    ENDIF.

    CHECK p_test NE abap_true.
    PERFORM display_result.
    PERFORM open_html_in_msword USING lv_file.
  ENDIF.

  IF import EQ abap_true.
    PERFORM upload_transport_files.
  ENDIF.

  IF code EQ abap_true.
    PERFORM initialize_code_template.
    PERFORM print_template_codes.
  ENDIF.

  CHECK p_test NE abap_true.

  GET RUN TIME FIELD lv_end.
  lv_cost = ( lv_end - lv_start ) / 1000000.
  lv_str = lv_cost.
  lv_msg = text_common-time_cost.
  REPLACE FIRST OCCURRENCE OF &apos;$TIME&apos; IN lv_msg WITH lv_str.
  WRITE: / icon_time AS ICON, lv_msg.
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_UPLOAD_TR" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Upload Transport File Routines" LENGTH="36 "/>
   </language>
  </textPool>
  <source>FORM upload_transport_files.
  DATA: lv_slah       TYPE c,
        lv_filename   TYPE c LENGTH 1024,
        lv_answer     TYPE c,
        lv_len        TYPE i,
        lv_contents   TYPE xstring,
        lt_data       TYPE t_linetype,
        lt_msg        TYPE TABLE OF s_common_msg,
        lv_msg        TYPE string,
        lv_stms       TYPE abap_bool VALUE abap_true.

  FIELD-SYMBOLS: &lt;fs_file&gt; TYPE cl_abap_zip=&gt;t_file,
                 &lt;fs_msg&gt;  TYPE s_common_msg.

  lv_slah = gv_trans_dir(1).
  LOOP AT go_zip-&gt;files ASSIGNING &lt;fs_file&gt;.
    CLEAR: lv_filename, lv_contents, lt_data, lv_msg, lv_len, lv_answer.

    IF &lt;fs_file&gt;-name(1) EQ &apos;K&apos;.
      CONCATENATE gv_trans_dir lv_slah &apos;cofiles&apos; lv_slah &lt;fs_file&gt;-name INTO lv_filename RESPECTING BLANKS.
    ELSEIF &lt;fs_file&gt;-name(1) EQ &apos;R&apos;.
      CONCATENATE gv_trans_dir lv_slah &apos;data&apos; lv_slah &lt;fs_file&gt;-name INTO lv_filename RESPECTING BLANKS.
    ENDIF.
    lv_len = strlen( lv_filename ).

    go_zip-&gt;get(
      EXPORTING
        name                    = &lt;fs_file&gt;-name
      IMPORTING
        content                 = lv_contents
      EXCEPTIONS
        zip_index_error         = 1
        zip_decompression_error = 2
        OTHERS                  = 3
      ).

    IF sy-subrc NE 0.
      PERFORM get_sys_error_msg CHANGING lv_msg.
      CONCATENATE &apos;Unable to get &apos; &lt;fs_file&gt;-name &apos; in zip file &apos; p_file &apos;.Reason: &apos; lv_msg INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING lt_msg.
    ELSE.
      CONCATENATE &apos;Unzip file &apos; p_file &apos; and get &apos; &lt;fs_file&gt;-name &apos; successfully.&apos; INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;S&apos; lv_msg CHANGING lt_msg.
    ENDIF.

    CLEAR lv_msg.
    PERFORM convert_zip2tbl1024 USING lv_contents CHANGING lt_data.
    PERFORM upload_overwrite_confirm USING lv_filename CHANGING lv_answer.
    IF lv_answer NE &apos;1&apos;.
      CONCATENATE lv_filename(lv_len) &apos; exists in server already and you choose to ignore.&apos; INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;W&apos; lv_msg CHANGING lt_msg.
      CONTINUE.
    ENDIF.

    CALL FUNCTION &apos;SCMS_DOWNLOAD&apos;
      EXPORTING
        filename = lv_filename
        filesize = &lt;fs_file&gt;-size
        binary   = &apos;X&apos;
        frontend = &apos; &apos;
      TABLES
        data     = lt_data
      EXCEPTIONS
        error    = 1
        OTHERS   = 2.

    IF sy-subrc &lt;&gt; 0.
      PERFORM get_sys_error_msg CHANGING lv_msg.
      CONCATENATE &apos;Failed to upload &apos; p_file &apos; to server: &apos; lv_filename(lv_len) &apos;.Reason: &apos; lv_msg INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING lt_msg.
    ELSE.
      CONCATENATE &apos;Upload &apos; p_file &apos; to server address &apos; lv_filename(lv_len) &apos; successfully.&apos; INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;S&apos; lv_msg CHANGING lt_msg.
    ENDIF.
  ENDLOOP.

  WRITE: / icon_icon_list AS ICON, &apos;Dear&apos;, gv_username, &apos;, here is transport file upload report:&apos;.
  SKIP.
  LOOP AT lt_msg ASSIGNING &lt;fs_msg&gt;.
    PERFORM print_msg USING &lt;fs_msg&gt;-msgty &lt;fs_msg&gt;-msg.
    IF &lt;fs_msg&gt;-msgty NE &apos;S&apos;.
      lv_stms = abap_false.
    ENDIF.
  ENDLOOP.
  SKIP.
  WRITE: / icon_tools AS ICON, text_common-thanks.

  CHECK lv_stms EQ abap_true.
  MESSAGE &apos;Now you can import the transport request.&apos; TYPE &apos;I&apos;.
  CALL TRANSACTION &apos;STMS_IMPORT&apos; AND SKIP FIRST SCREEN.
  &quot;TODO: if target system and client was provided, then we can call API
  &quot;CTS_API_IMPORT_CHANGE_REQUEST to import the change request automatically
ENDFORM.

FORM append_common_msg USING iv_msgty TYPE sy-msgty iv_msg TYPE string CHANGING ct_msg TYPE STANDARD TABLE.
  DATA ls_common_msg TYPE s_common_msg.
  ls_common_msg-msgty = iv_msgty.
  ls_common_msg-msg = iv_msg.
  APPEND ls_common_msg TO ct_msg.
ENDFORM.

FORM upload_overwrite_confirm USING iv_server_file TYPE c CHANGING cv_answer TYPE c.
  CLEAR cv_answer.

  OPEN DATASET iv_server_file FOR INPUT IN BINARY MODE.
  IF sy-subrc EQ 0.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        text_question = &apos;This file exists on server already, do you really want to overwrite?&apos;
      IMPORTING
        answer        = cv_answer.
  ELSE.
    cv_answer = &apos;1&apos;.
  ENDIF.
  CLOSE DATASET iv_server_file.
ENDFORM.

FORM convert_zip2tbl1024 USING iv_xstr TYPE xstring CHANGING ct_tabl TYPE t_linetype.
  CONSTANTS: c_length_segment   TYPE i VALUE 1024.
  DATA: lv_line(1024) TYPE x,
        ls_line       TYPE s_lintype,
        len_src       TYPE i,
        len_wa        TYPE i,
        offset        TYPE i.

  offset = 0.
  len_src = xstrlen( iv_xstr ).

  WHILE offset &lt; len_src.
    len_wa = len_src - offset.
    IF len_wa &gt; c_length_segment.
      lv_line = iv_xstr+offset(c_length_segment).
      ls_line-line = lv_line.
      APPEND ls_line TO ct_tabl.
      offset = offset + c_length_segment.
    ELSE.
      lv_line = iv_xstr+offset(len_wa).
      ls_line-line = lv_line.
      APPEND ls_line TO ct_tabl.
      offset = offset + len_wa.
    ENDIF.
  ENDWHILE.
ENDFORM.

FORM check_transport_zip CHANGING cv_msg TYPE string.
  DATA: lv_str TYPE xstring,
        lt_tab TYPE solix_tab.

  CALL METHOD cl_gui_frontend_services=&gt;file_exist
    EXPORTING
      file                 = p_file
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      wrong_parameter      = 3
      not_supported_by_gui = 4
      OTHERS               = 5.
  IF sy-subrc &lt;&gt; 0.
    PERFORM get_sys_error_msg CHANGING cv_msg.
    RETURN.
  ENDIF.

  CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
    EXPORTING
      text = &apos;Upload transport zip file...&apos;.

  CALL METHOD cl_gui_frontend_services=&gt;gui_upload
    EXPORTING
      filename                = p_file
      filetype                = &apos;BIN&apos;
    CHANGING
      data_tab                = lt_tab
    EXCEPTIONS
      file_open_error         = 1
      file_read_error         = 2
      no_batch                = 3
      gui_refuse_filetransfer = 4
      invalid_type            = 5
      no_authority            = 6
      unknown_error           = 7
      bad_data_format         = 8
      header_not_allowed      = 9
      separator_not_allowed   = 10
      header_too_long         = 11
      unknown_dp_error        = 12
      access_denied           = 13
      dp_out_of_memory        = 14
      disk_full               = 15
      dp_timeout              = 16
      not_supported_by_gui    = 17
      error_no_gui            = 18
      OTHERS                  = 19.
  IF sy-subrc &lt;&gt; 0.
    PERFORM get_sys_error_msg CHANGING cv_msg.
    RETURN.
  ELSE.
    lv_str = cl_bcs_convert=&gt;solix_to_xstring( it_solix  = lt_tab ).
  ENDIF.

  IF go_zip IS NOT BOUND.
    CREATE OBJECT go_zip.
    CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
      EXPORTING
        percentage = 2
        text       = &apos;Load and parse transport zip file...&apos;.

    go_zip-&gt;load(
      EXPORTING
        zip = lv_str
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
      ).
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
    ENDIF.

    &quot; if validity check passed but count of files mod 2 ne 0, give a warning message
    IF lines( go_zip-&gt;files ) MOD 2 NE 0.
      cv_msg = &apos;There should a K/R file missing for a certain transport request, please check your zip file&apos;.
    ENDIF.

    FIELD-SYMBOLS: &lt;fs_file&gt; TYPE cl_abap_zip=&gt;t_file.
    LOOP AT go_zip-&gt;files ASSIGNING &lt;fs_file&gt;.
      &quot;TODO: replace by regex match
      IF &lt;fs_file&gt;-name(1) NE &apos;K&apos; AND &lt;fs_file&gt;-name(1) NE &apos;R&apos; AND strlen( &lt;fs_file&gt;-name ) NE 11.
        CONCATENATE &apos;Invalid file name in zip: &apos; &lt;fs_file&gt;-name INTO cv_msg RESPECTING BLANKS.
        RETURN.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_VCLS" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: View Cluster - Data Retrive &amp; HTML Conversion Routines" LENGTH="60 "/>
   </language>
  </textPool>
  <source>***************** View cluster Begin *****************
FORM getdata_vcls USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_vcls         TYPE s_vcls.

  PERFORM get_vcls_reuse USING is_obj_header CHANGING ls_vcls.
  CHECK sy-subrc EQ 0.
  APPEND ls_vcls TO gt_vcls.
ENDFORM.

FORM get_vcls_reuse USING is_obj_header TYPE s_obj_header CHANGING cs_vcls TYPE s_vcls.
  DATA: lv_vcls_name TYPE vcl_name,
        ls_vcldir    TYPE v_vcldir.

  CLEAR cs_vcls.
  READ TABLE gt_vcls INTO cs_vcls WITH KEY object = &apos;VCLS&apos; obj_name = is_obj_header-obj_name.
  CHECK sy-subrc NE 0.

  lv_vcls_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;VIEWCLUSTER_GET_DEFINITION&apos;
    EXPORTING
      vclname                = lv_vcls_name
    IMPORTING
      vcldir_entry           = ls_vcldir
    TABLES
      vclstruc_tab           = cs_vcls-object_stru
      vclstrudep_tab         = cs_vcls-field_dep
      vclmf_tab              = cs_vcls-events
    EXCEPTIONS
      viewcluster_not_found  = 1
      incomplete_viewcluster = 2
      OTHERS                 = 3.                           &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  CHECK is_obj_header-object EQ &apos;VCLS&apos;.
  MOVE-CORRESPONDING is_obj_header TO cs_vcls.
  PERFORM get_activity USING ls_vcldir-changedate CHANGING cs_vcls-activity.
  cs_vcls-short_text = ls_vcldir-text.
ENDFORM.

FORM get_additional_html_vcls USING ls_vcls TYPE s_vcls CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  DATA: lv_low       TYPE ddfixvalue-low,
        lv_hierarchy TYPE ddtext,
        lv_readtype  TYPE string.

  lv_low = ls_vcls-hieropsoff.
  PERFORM get_value_desc USING &apos;VCLS_HIERARCHY&apos; lv_low CHANGING lv_hierarchy.
  PERFORM get_2column_value_html USING text_vcls-label_hier lv_hierarchy CHANGING ct_html.
  IF ls_vcls-readkind EQ &apos;T&apos;.
    lv_readtype = text_vcls-txt_type_sub.
  ELSE.
    lv_readtype = text_vcls-txt_type_comp.
  ENDIF.
  PERFORM get_2column_value_html USING text_vcls-label_type lv_readtype CHANGING ct_html.
  PERFORM data2rows USING ls_vcls &apos;VCLDIR&apos; &apos;EXITPROG&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_vcls USING is_vcls TYPE s_vcls CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM table2html USING text_vcls-title_obj_stru is_vcls-object_stru &apos;V_VCLSTRUC&apos;
        &apos;OBJECT|OBJECTTEXT|PREDOBJECT|DEPENDENCY|OBJPOS|STARTOBJ|SUPPRESS|CARDINAL|SWITCH_ID&apos; abap_true &apos;SUPPRESS|CARDINAL|SWITCH_ID&apos; CHANGING ct_html.

  PERFORM table2html USING text_vcls-title_fld_dep is_vcls-field_dep &apos;V_VCLSTDEP&apos;
        &apos;OBJECT|OBJFIELD|PREDOBJECT|PREDFIELD|NOKEYFIELD&apos; abap_true &apos;NOKEYFIELD&apos; CHANGING ct_html.

  CHECK is_vcls-events IS NOT INITIAL.
  PERFORM get_small_title_html USING text_vcls-title_events CHANGING ct_html.
  PERFORM get_paragraph_html USING text_vcls-txt_mt_event CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; is_vcls-events &apos;V_VCLMF&apos; &apos;EVENT|FORMNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** View cluster Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_VDAT" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: View Maintenance Data - Data Retrive &amp; HTML Conversion Routines" LENGTH="69 "/>
   </language>
  </textPool>
  <source>***************** View Cluster Maintenance: Data Begin *****************
FORM getdata_cdat USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_cdat TYPE s_cdat,
        ls_vcls TYPE s_vcls,
        ls_vdat TYPE s_vdat.

  MOVE-CORRESPONDING is_obj_header TO ls_cdat.
  PERFORM get_vcls_reuse USING is_obj_header CHANGING ls_vcls.
  CHECK sy-subrc EQ 0 AND ls_vcls IS NOT INITIAL.
  ls_cdat-object_stru = ls_vcls-object_stru.

  PERFORM getdata_tabu_reuse USING is_obj_header CHANGING ls_vdat.
  CHECK sy-subrc EQ 0 AND ls_vdat IS NOT INITIAL.
  ls_cdat-primary_keys = ls_vdat-primary_keys.
  ls_cdat-field_info = ls_vdat-field_info.

  APPEND ls_cdat TO gt_cdat.
ENDFORM.

FORM get_special_html_cdat USING is_cdat TYPE s_cdat CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: ls_vdat_ignore TYPE s_vdat_ignore,
        ls_vdat        TYPE s_vdat,
        ls_objheader   TYPE s_obj_header,
        lv_fields      TYPE string,
        lr_data        TYPE REF TO data,
        lv_msg         TYPE string.
  FIELD-SYMBOLS: &lt;fs_obj_stru&gt; TYPE v_vclstruc,
                 &lt;fs_contents&gt; TYPE STANDARD TABLE.

  LOOP AT is_cdat-object_stru ASSIGNING &lt;fs_obj_stru&gt;.
    CLEAR: lr_data, ls_vdat, ls_objheader, lv_fields, ls_vdat_ignore.
    UNASSIGN &lt;fs_contents&gt;.

    CHECK &lt;fs_obj_stru&gt;-object IS NOT INITIAL.
    TRY.
        CREATE DATA lr_data TYPE TABLE OF (&lt;fs_obj_stru&gt;-object).
        ASSIGN lr_data-&gt;* TO &lt;fs_contents&gt;.
      CATCH cx_sy_create_data_error.
        MESSAGE e208(00) WITH &apos;DDIC &apos; &lt;fs_obj_stru&gt;-object &apos; is invalid, please check it.&apos; INTO lv_msg.
        PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
        RETURN.
    ENDTRY.

    PERFORM get_vdat_info_via_cdat USING &lt;fs_obj_stru&gt;-object is_cdat CHANGING ls_vdat.
    PERFORM get_complete_entries USING ls_vdat CHANGING &lt;fs_contents&gt;.
    CHECK &lt;fs_contents&gt; IS NOT INITIAL.

    MOVE-CORRESPONDING ls_vdat TO ls_objheader.
    PERFORM get_maintable_flds USING ls_objheader CHANGING lv_fields.
    CHECK lv_fields IS NOT INITIAL.

    PERFORM get_vcls_node_title USING &lt;fs_obj_stru&gt;-objecttext CHANGING ct_html.
    PERFORM table2html USING &apos;&apos; &lt;fs_contents&gt; ls_vdat-obj_name lv_fields abap_false &apos;&apos; CHANGING ct_html.

    READ TABLE gt_vdat_ignore WITH TABLE KEY obj_name = &lt;fs_obj_stru&gt;-object TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.
    ls_vdat_ignore-vcls_name = is_cdat-obj_name.
    ls_vdat_ignore-obj_name = &lt;fs_obj_stru&gt;-object.
    INSERT ls_vdat_ignore INTO TABLE gt_vdat_ignore.
  ENDLOOP.
ENDFORM.

FORM get_vcls_node_title USING iv_objtext TYPE v_vclstruc-objecttext CHANGING ct_html TYPE t_string.
  DATA: lv_txt  TYPE string.
  CONCATENATE text_tabu-txt_maint_node &apos;&lt;b&gt;&apos; iv_objtext &apos;&lt;/b&gt;&apos; INTO lv_txt RESPECTING BLANKS.
  PERFORM get_paragraph_html USING lv_txt CHANGING ct_html.
ENDFORM.

FORM get_vdat_info_via_cdat USING iv_objname TYPE vim_name is_cdat TYPE s_cdat CHANGING cs_vdat TYPE s_vdat.
  CLEAR cs_vdat.
  TYPES: BEGIN OF s_e071kf_obj,
          objname TYPE tabname,
         END OF s_e071kf_obj.
  DATA: ls_object TYPE s_e071kf_obj,
        lt_object TYPE HASHED TABLE OF s_e071kf_obj WITH UNIQUE KEY objname.
  FIELD-SYMBOLS: &lt;fs_e071k&gt;  TYPE e071k,
                 &lt;fs_e071kf&gt; TYPE e071kf.

  cs_vdat-obj_name = iv_objname.
  LOOP AT is_cdat-primary_keys ASSIGNING &lt;fs_e071k&gt; WHERE objname EQ iv_objname OR viewname EQ iv_objname.
    APPEND &lt;fs_e071k&gt; TO cs_vdat-primary_keys.
    IF &lt;fs_e071k&gt;-viewname IS INITIAL.
      cs_vdat-object = &apos;TABU&apos;.
    ELSE.
      cs_vdat-object = &apos;VDAT&apos;.
    ENDIF.

    READ TABLE lt_object WITH TABLE KEY objname = &lt;fs_e071k&gt;-objname TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    ls_object-objname = &lt;fs_e071k&gt;-objname.
    INSERT ls_object INTO TABLE lt_object.
  ENDLOOP.

  LOOP AT is_cdat-field_info ASSIGNING &lt;fs_e071kf&gt;.
    READ TABLE lt_object WITH TABLE KEY objname = &lt;fs_e071kf&gt;-objname TRANSPORTING NO FIELDS.
    CHECK sy-subrc EQ 0.
    APPEND &lt;fs_e071kf&gt; TO cs_vdat-field_info.
  ENDLOOP.
ENDFORM.
***************** View Cluster Maintenance: Data Close *****************

***************** View Maintenance: Data Begin *****************
FORM getdata_vdat USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_vdat TYPE s_vdat.
  PERFORM getdata_tabu_reuse USING is_obj_header CHANGING ls_vdat.
  CHECK ls_vdat IS NOT INITIAL.
  APPEND ls_vdat TO gt_vdat.
ENDFORM.

FORM getdata_tabu_reuse USING is_obj_header TYPE s_obj_header CHANGING cs_tabu TYPE s_vdat.
* if vdat/tabu has been included in cdat already, then ignore
  READ TABLE gt_vdat_ignore WITH TABLE KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  DATA: lv_ddobj TYPE ddobjname,
        lv_rc    TYPE sy-subrc.
  lv_ddobj = is_obj_header-obj_name.

* filter system level data of view cluster/view maintenance/table contents
  IF is_obj_header-object EQ &apos;VDAT&apos;.
    IF is_obj_header-obj_name EQ &apos;V_TVIMF&apos; OR is_obj_header-obj_name EQ &apos;V_TVDIR&apos;.
      PERFORM add_obj_gen_msg USING is_obj_header &apos;W&apos; &apos;&apos;.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;DB_EXISTS_TABLE&apos;
      EXPORTING
        tabname = lv_ddobj
      IMPORTING
        subrc   = lv_rc.
  ELSEIF is_obj_header-object EQ &apos;TABU&apos;.
    IF is_obj_header-obj_name EQ &apos;TDDAT&apos; OR is_obj_header-obj_name EQ &apos;TRESC&apos; OR
          is_obj_header-obj_name EQ &apos;TVDIR&apos; OR is_obj_header-obj_name EQ &apos;TVIMF&apos;.
      PERFORM add_obj_gen_msg USING is_obj_header &apos;W&apos; &apos;&apos;.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;DB_EXISTS_VIEW&apos;
      EXPORTING
        viewname = lv_ddobj
      IMPORTING
        subrc    = lv_rc.
  ELSEIF is_obj_header-object EQ &apos;CDAT&apos;.
    &quot;TODO
  ENDIF.
* check validity of table/view
  sy-subrc = lv_rc.
  PERFORM handle_rc USING is_obj_header.
  CHECK lv_rc EQ 0.

  MOVE-CORRESPONDING is_obj_header TO cs_tabu.
  SELECT * FROM e071k INTO TABLE cs_tabu-primary_keys
    WHERE trkorr IN so_trans AND mastertype EQ cs_tabu-object AND mastername EQ cs_tabu-obj_name.
* only after change request was released key field info will be filled into table e071kf
  SELECT * FROM e071kf INTO TABLE cs_tabu-field_info
    FOR ALL ENTRIES IN cs_tabu-primary_keys
    WHERE trkorr IN so_trans AND objname EQ cs_tabu-primary_keys-objname.
ENDFORM.

FORM convert_vdat.                                          &quot;#EC CALLED
  PERFORM convert_vdat_reuse USING &apos;VDAT&apos; gt_vdat.
ENDFORM.

FORM convert_vdat_reuse USING iv_object TYPE trobjtype it_tab TYPE t_vdat.
  CHECK it_tab IS NOT INITIAL.
  ADD 1 TO gv_header_no.

  DATA: lv_cnt TYPE i.
  FIELD-SYMBOLS: &lt;fs_vdat&gt; TYPE s_vdat.

  lv_cnt = lines( it_tab ).
  PERFORM add_header_html USING iv_object CHANGING gt_html.
  PERFORM add_object_instruction_html USING iv_object CHANGING gt_html.

  LOOP AT it_tab ASSIGNING &lt;fs_vdat&gt;.
    &lt;fs_vdat&gt;-secondary_sort = sy-tabix.
    PERFORM convert_single_vdat2html USING &lt;fs_vdat&gt; lv_cnt CHANGING gt_html.
  ENDLOOP.
ENDFORM.

FORM convert_single_vdat2html USING is_vdat TYPE s_vdat iv_cnt TYPE i CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lr_view_data  TYPE REF TO data,
        lv_fields     TYPE string,
        ls_obj_header TYPE s_obj_header,
        lv_msg        TYPE string.
  FIELD-SYMBOLS: &lt;fs_view_contents&gt; TYPE STANDARD TABLE.

  MOVE-CORRESPONDING is_vdat TO ls_obj_header.
  PERFORM get_maintable_flds USING ls_obj_header CHANGING lv_fields.
  CHECK lv_fields IS NOT INITIAL.

  TRY .
      CREATE DATA lr_view_data TYPE TABLE OF (is_vdat-obj_name).
      ASSIGN lr_view_data-&gt;* TO &lt;fs_view_contents&gt;.
    CATCH cx_sy_create_data_error.
      MESSAGE e208(00) WITH &apos;DDIC &apos; is_vdat-obj_name &apos; is invalid, please check it.&apos; INTO lv_msg.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
      RETURN.
  ENDTRY.

  PERFORM get_complete_entries USING is_vdat CHANGING &lt;fs_view_contents&gt;.
  PERFORM add_title_html USING is_vdat iv_cnt CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; &lt;fs_view_contents&gt; is_vdat-obj_name lv_fields abap_true &apos;&apos; CHANGING ct_html.
  PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
ENDFORM.

FORM get_complete_entries USING is_vdat TYPE s_vdat CHANGING ct_contents TYPE STANDARD TABLE.
  DATA: lr_view_data  TYPE REF TO data,
        lr_table_data TYPE REF TO data,
        lr_view_row   TYPE REF TO data,
        lt_where      TYPE TABLE OF string,
        lt_e071k      TYPE TABLE OF e071k,
        lv_where      TYPE string,
        lv_result     TYPE string,
        lv_msg        TYPE string,
        lv_index      TYPE i.
  FIELD-SYMBOLS: &lt;fs_e071kf&gt;      TYPE e071kf,
                 &lt;fs_e071k&gt;       TYPE e071k,
                 &lt;fs_tab_conts&gt;   TYPE STANDARD TABLE,
                 &lt;fs_tab_cont&gt;    TYPE any,
                 &lt;fs_view_conts&gt;  TYPE STANDARD TABLE,
                 &lt;fs_view_cont&gt;   TYPE any,
                 &lt;fs_value&gt;       TYPE any.

  TRY.
      CREATE DATA lr_view_data TYPE TABLE OF (is_vdat-obj_name).
      ASSIGN lr_view_data-&gt;* TO &lt;fs_view_conts&gt;.
    CATCH cx_sy_create_data_error.
      MESSAGE e208(00) WITH &apos;DDIC &apos; is_vdat-obj_name &apos; is invalid, please check it.&apos; INTO lv_msg.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
      RETURN.
  ENDTRY.

  lt_e071k = is_vdat-primary_keys.
  SORT lt_e071k BY objname ASCENDING.

  LOOP AT lt_e071k ASSIGNING &lt;fs_e071k&gt;.
    IF &lt;fs_tab_conts&gt; IS NOT ASSIGNED.
      TRY.
          CREATE DATA lr_table_data TYPE TABLE OF (&lt;fs_e071k&gt;-objname).
          ASSIGN lr_table_data-&gt;* TO &lt;fs_tab_conts&gt;.
        CATCH cx_sy_create_data_error.
          CLEAR lv_msg.
          MESSAGE e208(00) WITH &apos;DDIC &apos; &lt;fs_e071k&gt;-objname &apos; is invalid, please check it.&apos; INTO lv_msg.
          PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
          RETURN.
      ENDTRY.
    ENDIF.

    &quot; get table contents
    LOOP AT is_vdat-field_info ASSIGNING &lt;fs_e071kf&gt; WHERE objname EQ &lt;fs_e071k&gt;-objname.
      ASSIGN &lt;fs_e071k&gt;-tabkey+&lt;fs_e071kf&gt;-offset(&lt;fs_e071kf&gt;-dblength) TO &lt;fs_value&gt;.
      CHECK &lt;fs_value&gt; IS ASSIGNED AND &lt;fs_value&gt; IS NOT INITIAL.

      IF &lt;fs_e071kf&gt;-exid NE &apos;C&apos;.
        DATA lo_datadescr TYPE REF TO cl_abap_datadescr.
        lo_datadescr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;fs_value&gt; ).
        CHECK lo_datadescr-&gt;type_kind EQ &lt;fs_e071kf&gt;-exid.
        CLEAR lo_datadescr.
      ENDIF.

      CONCATENATE &lt;fs_e071kf&gt;-fieldname &apos; = &apos;&apos;&apos; &lt;fs_value&gt; &apos;&apos;&apos; &apos; INTO lv_where RESPECTING BLANKS.
      APPEND lv_where TO lt_where.
      UNASSIGN &lt;fs_value&gt;.
    ENDLOOP.
    CONCATENATE LINES OF lt_where INTO lv_result SEPARATED BY &apos; AND &apos; RESPECTING BLANKS.

    SELECT * FROM (&lt;fs_e071k&gt;-objname) APPENDING TABLE &lt;fs_tab_conts&gt; WHERE (lv_result).
    CLEAR: lv_where, lt_where, lv_result.

    AT END OF objname.
      ADD 1 TO lv_index.
      &quot; move table contents to view contents(similar as join)
      LOOP AT &lt;fs_tab_conts&gt; ASSIGNING &lt;fs_tab_cont&gt;.
        CREATE DATA lr_view_row TYPE (is_vdat-obj_name).
        ASSIGN lr_view_row-&gt;* TO &lt;fs_view_cont&gt;.

        MOVE-CORRESPONDING &lt;fs_tab_cont&gt; TO &lt;fs_view_cont&gt;.
        &quot; if current table is primary table, then just insert
        IF lv_index LE 1.
          APPEND &lt;fs_view_cont&gt; TO &lt;fs_view_conts&gt;.
        &quot; if primary table contents has been transferred to view contents, then other table contents should be appended as delta
        ELSE.
          MODIFY &lt;fs_view_conts&gt; FROM &lt;fs_view_cont&gt; INDEX sy-tabix.
        ENDIF.

        CLEAR lr_view_row.
        UNASSIGN &lt;fs_view_cont&gt;.
      ENDLOOP.

      CLEAR: lr_table_data.
      UNASSIGN: &lt;fs_tab_conts&gt;, &lt;fs_tab_cont&gt;.
    ENDAT.
  ENDLOOP.

  CLEAR ct_contents.
  ct_contents = &lt;fs_view_conts&gt;.
ENDFORM.

FORM get_maintable_flds USING is_objheader TYPE s_obj_header CHANGING cv_fldnames TYPE string.
  DATA: lv_ddobjname TYPE ddobjname,
        ls_obj_head  TYPE s_obj_header,
        lt_view_fld  TYPE t_view_fields,
        lt_tabl_fld  TYPE dd03ttyp.
  FIELD-SYMBOLS: &lt;fs_view_fld&gt; TYPE dd27p,
                 &lt;fs_tabl_fld&gt; TYPE dd03p.

  CLEAR cv_fldnames.
  lv_ddobjname = is_objheader-obj_name.

  IF is_objheader-object EQ &apos;VDAT&apos;.
    CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
      EXPORTING
        name          = lv_ddobjname
        state         = &apos;A&apos;
      TABLES
        dd27p_tab     = lt_view_fld
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.                                  &quot;#EC FB_RC
    PERFORM handle_rc USING ls_obj_head.
    CHECK sy-subrc EQ 0 AND lt_view_fld IS NOT INITIAL.
    &quot; only those available fields in maintenance view will be fetched
    LOOP AT lt_view_fld ASSIGNING &lt;fs_view_fld&gt; WHERE rdonly IS INITIAL.
      CONCATENATE cv_fldnames &apos;|&apos; &lt;fs_view_fld&gt;-fieldname INTO cv_fldnames.
    ENDLOOP.
    SHIFT cv_fldnames.
  ELSEIF is_objheader-object EQ &apos;TABU&apos;.
    CALL FUNCTION &apos;DDIF_TABL_GET&apos;
      EXPORTING
        name          = lv_ddobjname
        state         = &apos;A&apos;
      TABLES
        dd03p_tab     = lt_tabl_fld
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.                                  &quot;#EC FB_RC
    PERFORM handle_rc USING ls_obj_head.
    CHECK sy-subrc EQ 0 AND lt_tabl_fld IS NOT INITIAL.

    LOOP AT lt_tabl_fld ASSIGNING &lt;fs_tabl_fld&gt;.
      CONCATENATE cv_fldnames &apos;|&apos; &lt;fs_tabl_fld&gt;-fieldname INTO cv_fldnames.
    ENDLOOP.
    SHIFT cv_fldnames.
  ENDIF.
ENDFORM.
***************** View Maintenance: Data Close *****************

***************** Table Contents Begin *****************
FORM getdata_tabu USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tabu TYPE s_tabu.
  PERFORM getdata_tabu_reuse USING is_obj_header CHANGING ls_tabu.
  CHECK ls_tabu IS NOT INITIAL.
  APPEND ls_tabu TO gt_tabu.
ENDFORM.

FORM convert_tabu.                                          &quot;#EC CALLED
  PERFORM convert_vdat_reuse USING &apos;TABU&apos; gt_tabu.
ENDFORM.
***************** Table Contents Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_VIEW" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: View - Data Retrive &amp; HTML Conversion Routines" LENGTH="53 "/>
   </language>
  </textPool>
  <source>***************** View Begin *****************
FORM getdata_view USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_view_reuse USING is_obj_header.
ENDFORM.

FORM getdata_view_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_view  TYPE s_view,
        lv_view_name TYPE ddobjname,
        ls_dd25v TYPE dd25v.

  MOVE-CORRESPONDING is_obj_header TO ls_view.
  lv_view_name = ls_view-obj_name.
  CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
    EXPORTING
      name          = lv_view_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v
      dd09l_wa      = ls_view-tech_setting
    TABLES
      dd26v_tab     = ls_view-table_join
      dd27p_tab     = ls_view-fields
      dd28j_tab     = ls_view-join_condition
      dd28v_tab     = ls_view-selection_condition
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd25v IS NOT INITIAL.

  MOVE-CORRESPONDING ls_dd25v TO ls_view.
  PERFORM get_activity USING ls_dd25v-as4date CHANGING ls_view-activity.
  ls_view-short_text = ls_dd25v-ddtext.

  IF ls_view-object EQ &apos;VIEW&apos;.
    APPEND ls_view TO gt_view.
  ELSEIF ls_view-object EQ &apos;VIED&apos;.
    ls_view-activity = gcv_act_update.
    APPEND ls_view TO gt_vied.
  ENDIF.
ENDFORM.

FORM get_additional_html_view USING ls_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_view &apos;S_VIEW&apos; &apos;VIEWGRANT|CUSTOMAUTH|GLOBALFLAG&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_view USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_jointable_html USING is_view CHANGING ct_html.
  PERFORM get_view_fields_html USING is_view CHANGING ct_html.
  PERFORM get_selcondition_html USING is_view CHANGING ct_html.

  DATA lt_dd09v TYPE TABLE OF dd09v.
  CHECK is_view-tech_setting IS NOT INITIAL.
  APPEND is_view-tech_setting TO lt_dd09v.
  PERFORM table2html USING text_tabl-title_tech lt_dd09v &apos;DD09V&apos; &apos;BUFALLOW|PUFFERUNG&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.

FORM get_jointable_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tmp  TYPE string.
  FIELD-SYMBOLS: &lt;fs_tb&gt; TYPE dd26v.

  LOOP AT is_view-table_join ASSIGNING &lt;fs_tb&gt;.
    CONCATENATE lv_tmp &apos;, &apos; &lt;fs_tb&gt;-tabname INTO lv_tmp RESPECTING BLANKS.
  ENDLOOP.
  SHIFT lv_tmp BY 2 PLACES.
  CONCATENATE text_view-title_tables lv_tmp INTO lv_tmp RESPECTING BLANKS.
  PERFORM get_paragraph_html USING lv_tmp CHANGING ct_html.

  IF is_view-join_condition IS INITIAL.
    PERFORM get_paragraph_html USING text_view-note_join_cond CHANGING ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ELSE.
    PERFORM table2html USING text_view-title_join_conds is_view-join_condition &apos;DD28J&apos; &apos;LTAB|LFIELD|OPERATOR|RTAB|RFIELD&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_view_fields_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM table2html USING text_view-title_fields is_view-fields &apos;DD27P&apos;
          &apos;VIEWFIELD|TABNAME|FIELDNAME|RDONLY|KEYFLAG|ROLLCHANGE&apos; abap_true &apos;RDONLY|ROLLCHANGE&apos; CHANGING ct_html.
ENDFORM.

FORM get_selcondition_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_small_title_html USING text_view-title_sel_conds CHANGING ct_html.
  IF is_view-selection_condition IS INITIAL.
    PERFORM get_paragraph_html USING text_view-note_sel_cond CHANGING ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ELSE.
    PERFORM table2html USING &apos;&apos; is_view-selection_condition &apos;DD28V&apos; &apos;TABNAME|FIELDNAME|OPERATOR|CONSTANTS|AND_OR&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** View Close *****************

***************** View Definition Begin *****************
FORM getdata_vied USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  READ TABLE gt_view WITH KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  PERFORM getdata_view_reuse USING is_obj_header.
ENDFORM.

FORM get_special_html_vied USING is_vied TYPE s_vied CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_special_html_view USING is_vied CHANGING ct_html.
ENDFORM.
***************** View Definition Close *****************

TYPES: BEGIN OF s_viet.
        INCLUDE TYPE s_obj_header.
TYPES: tech_setting TYPE dd09v.
TYPES: END OF s_viet.
DATA gt_viet TYPE TABLE OF s_viet.                          &quot;#EC NEEDED

***************** Technical Attributes of a View Begin *****************
FORM getdata_viet USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_viet  TYPE s_viet,
        lv_ddobj TYPE ddobjname.

  READ TABLE gt_view WITH KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  READ TABLE gt_vied WITH KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.

  MOVE-CORRESPONDING is_obj_header TO ls_viet.
  lv_ddobj = ls_viet-obj_name.
  CALL FUNCTION &apos;DDIF_VIET_GET&apos;
    EXPORTING
      name          = lv_ddobj
    IMPORTING
      dd09l_wa      = ls_viet-tech_setting
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_viet-tech_setting IS NOT INITIAL.
  ls_viet-activity = gcv_act_update.
  APPEND ls_viet TO gt_viet.
ENDFORM.

FORM get_special_html_viet USING is_viet TYPE s_viet CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA lt_dd09v TYPE TABLE OF dd09v.
  APPEND is_viet-tech_setting TO lt_dd09v.
  PERFORM table2html USING &apos;&apos; lt_dd09v &apos;DD09V&apos; &apos;TABNAME|BUFALLOW|PUFFERUNG&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Technical Attributes of a View Close *****************</source>
 </PROG>
 <PROG NAME="ZABAPDOC" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Generate XML For ABAP Repository Objects" LENGTH="40 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZABAPDOC                                                       *
*&amp;                                                                     *
*&amp;---------------------------------------------------------------------*
*
* APAP - Generate javadoc-style documentation for SAP repository objects
* Copyright (C) 2007  Björn Harmen Gerth
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the
* Free Software Foundation, Inc.
* 51 Franklin Street
* Fifth Floor
* Boston, MA 02110-1301
* USA
*&amp;---------------------------------------------------------------------*
REPORT  ZABAPDOC NO STANDARD PAGE HEADING LINE-SIZE 255.

DEFINE transl.
  if ic_name eq &amp;1.
    check &amp;2 ne space.
    ec_name = &amp;2.
  endif.
END-OF-DEFINITION.

TYPES:
  BEGIN OF ys_selopt,
    sign   TYPE bapisign,
    option TYPE bapioption,
    low    TYPE tadir-object,
    high   TYPE tadir-object,
  END OF ys_selopt,
  yl_selopt TYPE TABLE OF ys_selopt,
  yl_devc   TYPE TABLE OF tdevc-devclass.
*----------------------------------------------------------------------*
*       CLASS ycl_generator DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ycl_generator DEFINITION.

  PUBLIC SECTION.
    TYPE-POOLS:
      abap,
      seoc,
      seor,
      seos.

    DATA:
      mt_output   TYPE sotr_texts,
      mr_output   TYPE REF TO string,
      mt_tags     TYPE sotr_texts,
      mc_langu    TYPE sy-langu,
      mt_selopt   TYPE yl_selopt,
      mt_packages TYPE yl_devc,
      mb_recurse  TYPE abap_bool.

    METHODS:
      constructor
        IMPORTING
          ic_langu   TYPE sy-langu
          it_selopt  TYPE yl_selopt OPTIONAL
          ib_recurse TYPE abap_bool DEFAULT abap_false,
     process_packages
       IMPORTING it_packages TYPE yl_devc,
     process_clas
       IMPORTING ic_name TYPE c,
     process_devc
       IMPORTING ic_name TYPE c,
     process_dtel
       IMPORTING ic_name TYPE c,
     process_doma
       IMPORTING ic_name TYPE c,
     process_fugr
       IMPORTING ic_name TYPE c,
     process_func
       IMPORTING ic_name TYPE c,
     process_prog
       IMPORTING ic_name TYPE c,
     process_msag
       IMPORTING ic_name TYPE c,
     process_enqu
       IMPORTING ic_name TYPE c,
     process_intf
       IMPORTING ic_name TYPE c,
     process_tabl
       IMPORTING ic_name TYPE c,
     process_ttyp
       IMPORTING ic_name TYPE c.

  PROTECTED SECTION.
    TYPES BEGIN OF ys_attrdescr.
    INCLUDE TYPE abap_attrdescr.
    TYPES description TYPE string.
    TYPES END OF ys_attrdescr.

    TYPES BEGIN OF ys_methdescr.
    INCLUDE TYPE abap_methdescr.
    TYPES description TYPE string.
    TYPES END OF ys_methdescr.

    TYPES BEGIN OF ys_parmdescr.
    INCLUDE TYPE abap_parmdescr.
    TYPES description TYPE string.
    TYPES END OF ys_parmdescr.

    TYPES BEGIN OF ys_excpdescr.
    INCLUDE TYPE abap_excpdescr.
    TYPES description TYPE string.
    TYPES END OF ys_excpdescr.

    TYPES BEGIN OF ys_evntdescr.
    INCLUDE TYPE abap_evntdescr.
    TYPES description TYPE string.
    TYPES END OF ys_evntdescr.

    METHODS:
      process_object_body
        IMPORTING ic_name  TYPE c,
      process_parameter
        IMPORTING
          ic_function  TYPE c
          ic_tag       TYPE string
          it_docu      TYPE rsfb_fdo
          it_parameter TYPE STANDARD TABLE
          ic_parmkind  TYPE funct-kind DEFAULT &apos;P&apos;
        CHANGING
          cs_wa        TYPE any,
      process_documentation
        IMPORTING
          ic_name  TYPE c
          ic_dokid TYPE c
          ic_type  TYPE dokhl-typ DEFAULT &apos;E&apos;,
      get_attribute_value
        IMPORTING
          ic_name  TYPE any
          i_field  TYPE any
        RETURNING
          value(ec_value) TYPE string,
      convert_entities
        IMPORTING ic_value TYPE any
        RETURNING value(ec_value) TYPE string,
      get_attribute_name
        IMPORTING ic_name TYPE c
        RETURNING value(ec_name) TYPE string,
      write_attribute
        IMPORTING ic_name TYPE c i_field TYPE any
        RETURNING value(ec_attribute) TYPE string,
      write_attributes
        IMPORTING is_struc TYPE any
        RETURNING value(ec_attr) TYPE string,
      end_tag,
      get_tag RETURNING value(ec_tag) TYPE string,
      write_tag
        IMPORTING
          ic_tag   TYPE string
          is_struc TYPE any OPTIONAL
          ib_end   TYPE abap_bool DEFAULT abap_true,
      write_table
        IMPORTING
          ic_tag   TYPE string
          it_table TYPE ANY TABLE,
      get_table_content
        IMPORTING ic_name TYPE c,
      get_superclass
        IMPORTING ic_classname TYPE any
        RETURNING value(ec_superclass) TYPE seoclsname.
ENDCLASS.                    &quot;ycl_generator DEFINITION

DATA gc_devc   TYPE tdevc-devclass.
PARAMETERS:
* text: &apos;Application name&apos;
  p_appl       TYPE cvers_ref-desc_text.
SELECT-OPTIONS:
* text Dev Class
  s_devcls     FOR gc_devc OBLIGATORY.
PARAMETERS:
* text: &apos;Recursively select subpackages&apos;
  p_recurs     TYPE abap_bool AS CHECKBOX,
* text: &apos;Language&apos;
  p_langu      TYPE sy-langu  DEFAULT sy-langu,
* text: &apos;Download to&apos;
  p_file       TYPE rlgrap-filename.

* Add all supported repository objects here
SELECTION-SCREEN BEGIN OF BLOCK bl1 WITH FRAME TITLE text-rep.
PARAMETERS:
* text: &apos;Table / structure&apos;
  p_tabl   TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN BEGIN OF BLOCK bl2 WITH FRAME.
PARAMETERS:
* text: &apos;Include system table content&apos;
  p_syscnt TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN END OF BLOCK bl2.
PARAMETERS:
* text: &apos;Table type&apos;
  p_ttyp   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Data element&apos;
  p_dtel   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Domain&apos;
  p_doma   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Enqueue object&apos;
  p_enqu   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Class&apos;
  p_clas   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Interface&apos;
  p_intf   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Function group&apos;
  p_fugr   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
  p_prog   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
  p_msag   TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN END OF BLOCK bl1.

SELECTION-SCREEN BEGIN OF BLOCK bl3.
PARAMETERS: p_disp TYPE abap_bool AS CHECKBOX DEFAULT abap_false,
            p_down TYPE abap_bool AS CHECKBOX DEFAULT abap_false.
SELECTION-SCREEN END OF BLOCK bl3.

DATA:
  gr_generator TYPE REF TO ycl_generator,
  gt_selopt    TYPE TABLE OF ys_selopt,
  gs_selopt    LIKE LINE OF gt_selopt,
  gt_packages  TYPE yl_devc,
  gc_file      TYPE string,
  gc_path      TYPE string,
  gc_fullpath  TYPE string,
  gi_action    TYPE i,
  &quot; 列出无效的repository object待后续清理
  lt_invalid_obj TYPE TABLE OF tadir-obj_name.

FIELD-SYMBOLS:
  &lt;t&gt;          LIKE LINE OF gr_generator-&gt;mt_output,
  &lt;fs_invalid_obj&gt; TYPE tadir-obj_name.

*-----------------------------------------------------------------------
* Display a file picker window
*-----------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
  CALL METHOD cl_gui_frontend_services=&gt;file_save_dialog
    EXPORTING
*      WINDOW_TITLE         =
       default_extension    = &apos;xml&apos;
*      DEFAULT_FILE_NAME    =
       file_filter          = &apos;*.xml&apos;
*      INITIAL_DIRECTORY    =
*      WITH_ENCODING        =
*      PROMPT_ON_OVERWRITE  = &apos;X&apos;
    CHANGING
      filename             = gc_file
      path                 = gc_path
      fullpath             = gc_fullpath
      user_action          = gi_action
    EXCEPTIONS
      OTHERS               = 1.
  IF sy-subrc NE 0.
    WRITE: / &apos;An error has occured picking a file&apos;.
    EXIT.
  ENDIF.

  IF gi_action EQ cl_gui_frontend_services=&gt;action_ok.
    p_file = gc_fullpath.
  ENDIF.

START-OF-SELECTION.
* Add all supported repository objects here
  gs_selopt-sign   = &apos;I&apos;.
  gs_selopt-option = &apos;EQ&apos;.
  IF p_tabl EQ abap_true.
    gs_selopt-low    = &apos;TABL&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_ttyp EQ abap_true.
    gs_selopt-low    = &apos;TTYP&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_dtel EQ abap_true.
    gs_selopt-low    = &apos;DTEL&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_doma EQ abap_true.
    gs_selopt-low    = &apos;DOMA&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_enqu EQ abap_true.
    gs_selopt-low    = &apos;ENQU&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_clas EQ abap_true.
    gs_selopt-low    = &apos;CLAS&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_intf EQ abap_true.
    gs_selopt-low    = &apos;INTF&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_fugr EQ abap_true.
    gs_selopt-low    = &apos;FUGR&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  &quot; 加入对Program、Message Class等的支持
  IF p_prog EQ abap_true.
    gs_selopt-low    = &apos;PROG&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_msag EQ abap_true.
    gs_selopt-low    = &apos;MSAG&apos;.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.

  IF gt_selopt IS INITIAL.
*   Add a dummy select option. Otherwise the table is empty, which would
*   result in the selection of ALL possible repository objects.
    gs_selopt-low    = space.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.

  CREATE OBJECT gr_generator EXPORTING ic_langu   = p_langu
                                       it_selopt  = gt_selopt
                                       ib_recurse = p_recurs.

  APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&apos; TO gr_generator-&gt;mt_output.
  IF p_appl IS INITIAL.
    APPEND &apos;&lt;application&gt;&apos; TO gr_generator-&gt;mt_output.
  ELSE.
    CLEAR gc_file.
    CONCATENATE &apos;&lt;application name=&quot;&apos; p_appl &apos;&quot;&gt;&apos; INTO gc_file.
    APPEND gc_file TO gr_generator-&gt;mt_output.
  ENDIF.

  SELECT devclass FROM tdevc
            INTO TABLE gt_packages
                 WHERE devclass IN s_devcls.
  CALL METHOD gr_generator-&gt;process_packages( gt_packages ).

  APPEND &apos;&lt;/application&gt;&apos; TO gr_generator-&gt;mt_output.

  IF lt_invalid_obj IS NOT INITIAL.
    WRITE / &apos;Invalid Object List:&apos;.
    LOOP AT lt_invalid_obj ASSIGNING &lt;fs_invalid_obj&gt;.
      WRITE: / &lt;fs_invalid_obj&gt;.
    ENDLOOP.
  ENDIF.

  IF p_disp EQ abap_true.
    LOOP AT gr_generator-&gt;mt_output ASSIGNING &lt;t&gt;.
      WRITE / &lt;t&gt;.
    ENDLOOP.
  ENDIF.

  IF NOT p_file IS INITIAL AND p_down EQ abap_true.
    gc_fullpath = p_file.
    CALL METHOD cl_gui_frontend_services=&gt;gui_download
      EXPORTING
        filename = gc_fullpath
      CHANGING
        data_tab = gr_generator-&gt;mt_output
      EXCEPTIONS
        OTHERS   = 0.
  ENDIF.

*----------------------------------------------------------------------*
*       CLASS ycl_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ycl_generator IMPLEMENTATION.

  METHOD constructor.

    FIELD-SYMBOLS &lt;s&gt; LIKE LINE OF mt_selopt.

    mc_langu   = ic_langu.
    mt_selopt  = it_selopt.
    mb_recurse = ib_recurse.

*   The TADIR entry of a package XY contains itself as development class
*   =&gt; endless loop, so exclude package from selection
    INSERT INITIAL LINE INTO mt_selopt INDEX 1 ASSIGNING &lt;s&gt;.
    &lt;s&gt;-sign   = &apos;E&apos;.
    &lt;s&gt;-option = &apos;EQ&apos;.
    &lt;s&gt;-low    = &apos;DEVC&apos;.

  ENDMETHOD.                    &quot;constructor

  METHOD process_packages.

    FIELD-SYMBOLS &lt;p&gt; LIKE LINE OF mt_packages.

    mt_packages = it_packages.
    LOOP AT mt_packages ASSIGNING &lt;p&gt;.
      CALL METHOD process_devc( &lt;p&gt; ).
    ENDLOOP.

  ENDMETHOD.                    &quot;process_packages

  METHOD process_clas.

    DATA:
      BEGIN OF ls_spr,
        clsname     TYPE seoclskey-clsname,
*       This will be useful for sorting the superclass by distance
*       to the actual class
        dist        TYPE sy-index,
      END OF ls_spr,
      ls_clskey     TYPE seoclskey,
      ls_class      TYPE seoc_class_r,
      lt_subclasses TYPE seor_inheritance_keys.

    ls_clskey-clsname = ic_name.
    CALL FUNCTION &apos;SEO_CLASS_READ&apos;
      EXPORTING
        clskey          = ls_clskey
        version         = seoc_version_active
        master_language = space
        modif_language  = mc_langu
      IMPORTING
        class           = ls_class.
    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;class&apos;
        is_struc = ls_class
        ib_end   = abap_false.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;CL&apos;.

    ls_spr-clsname = ic_name.
    DO.
      ls_spr-dist = sy-index.
      ls_spr-clsname = get_superclass( ls_spr-clsname ).
      IF ls_spr-clsname IS INITIAL.
        EXIT.
      ENDIF.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;superclass&apos;
          is_struc = ls_spr.
    ENDDO.

    CALL FUNCTION &apos;SEO_CLASS_GET_ALL_SUBS&apos;
      EXPORTING
        clskey  = ls_clskey
      IMPORTING
        inhkeys = lt_subclasses
      EXCEPTIONS
        OTHERS  = 0.

    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;subclass&apos;
        it_table = lt_subclasses.

    CALL METHOD process_object_body
      EXPORTING
        ic_name = ic_name.

    CALL METHOD end_tag. &quot;class

  ENDMETHOD.                    &quot;process_clas

  METHOD process_devc.
    DATA:
      ls_tadir    TYPE tadir,
      ls_tdevc    TYPE tdevc,
      lc_devclass TYPE tdevc-devclass.
    FIELD-SYMBOLS &lt;lb_deleted&gt; TYPE c.

    CALL FUNCTION &apos;TR_DEVCLASS_GET&apos;
      EXPORTING
        iv_devclass = ic_name
        iv_langu    = mc_langu
      IMPORTING
        es_tdevc    = ls_tdevc
      EXCEPTIONS
        OTHERS      = 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;package&apos;
        is_struc = ls_tdevc
        ib_end   = abap_false.

*   list all subpackages with descriptions
    SELECT devclass FROM tdevc
                    INTO lc_devclass
                   WHERE parentcl EQ ic_name.
      CALL FUNCTION &apos;TR_DEVCLASS_GET&apos;
        EXPORTING
          iv_devclass = lc_devclass
          iv_langu    = mc_langu
        IMPORTING
          es_tdevc    = ls_tdevc
        EXCEPTIONS
          OTHERS      = 0.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;subpackage&apos;
          is_struc = ls_tdevc.

*     If recursion is enabled, append subpackages to package list if
*     not yet included
      IF mb_recurse EQ abap_true.
        COLLECT lc_devclass INTO mt_packages.
      ENDIF.
    ENDSELECT.

*   Process all contained repository objects
    DATA lt_tadir TYPE TABLE OF tadir.
    SELECT * FROM tadir
*            INTO ls_tadir
*   解决此处的游标关闭问题引发的dump
            INTO TABLE lt_tadir
            WHERE object   IN mt_selopt
              AND devclass EQ ic_name.
    LOOP AT lt_tadir INTO ls_tadir.
      &quot; Seems field TADIR-DELFLAG was introduced with SAP 6.0
      ASSIGN COMPONENT &apos;DELFLAG&apos; OF STRUCTURE ls_tadir TO &lt;lb_deleted&gt;.
      CHECK sy-subrc &lt;&gt; 0 OR &lt;lb_deleted&gt; = abap_false.

      &quot; 先校验对应的Object是否确实存在，但上面的代码实际无效，再猥琐一下
      cl_abap_typedescr=&gt;describe_by_name(
        EXPORTING
          p_name         =     ls_tadir-obj_name
        EXCEPTIONS
          type_not_found = 1
          others         = 2
      ).
      IF sy-subrc &lt;&gt; 0.
        APPEND ls_tadir-obj_name TO lt_invalid_obj.
        CONTINUE.
      ENDIF.

      CASE ls_tadir-object.
        WHEN &apos;CLAS&apos;.
          CALL METHOD process_clas
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;DOMA&apos;.
          CALL METHOD process_doma
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;DTEL&apos;.
          CALL METHOD process_dtel
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;ENQU&apos;.
          CALL METHOD process_enqu
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;FUGR&apos;.
          CALL METHOD process_fugr
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;INTF&apos;.
          CALL METHOD process_intf
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;TABL&apos;.
          CALL METHOD process_tabl
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;TTYP&apos;.
          CALL METHOD process_ttyp
            EXPORTING
              ic_name = ls_tadir-obj_name.
        &quot; 待支持类型：program、structure、message class、transaction、shared object等
        &quot; 加入对Program类型的支持
        WHEN &apos;PROG&apos;.
          CALL METHOD process_prog
            EXPORTING
               ic_name = ls_tadir-obj_name.
        WHEN &apos;MSAG&apos;.
          CALL METHOD process_msag
            EXPORTING
               ic_name = ls_tadir-obj_name.
      ENDCASE.
    ENDLOOP.
*    ENDSELECT.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_package

  METHOD process_doma.

    DATA:
      lc_name TYPE ddobjname,
      ls_dd01 TYPE dd01v,
      lt_dd07 TYPE TABLE OF dd07v.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd01v_wa  = ls_dd01
      TABLES
        dd07v_tab = lt_dd07
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd01 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;domain&apos;
        is_struc = ls_dd01
        ib_end   = abap_false.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;fixed-value&apos;
        it_table = lt_dd07.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;DO&apos;
        ic_type  = &apos;T&apos;.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_domain


  METHOD process_dtel.
    DATA:
      lc_name TYPE ddobjname,
      ls_dd04 TYPE dd04v.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
      EXPORTING
        name                = lc_name
       langu               = mc_langu
     IMPORTING
       dd04v_wa            = ls_dd04
*     TPARA_WA            =
     EXCEPTIONS
       OTHERS              = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd04 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;dataelem&apos;
        is_struc = ls_dd04
        ib_end   = abap_false.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;DE&apos;.

    CALL METHOD end_tag.
  ENDMETHOD.                    &quot;process_dataelem

  METHOD process_enqu.
    DATA:
      lc_name    TYPE ddobjname,
      ls_dd25    TYPE dd25v,
      lt_dd26    TYPE TABLE OF dd26e,
      lt_dd27    TYPE TABLE OF dd27p,
      lt_dden    TYPE TABLE OF ddena.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd25v_wa  = ls_dd25
      TABLES
        dd26e_tab = lt_dd26
        dd27p_tab = lt_dd27
        ddena_tab = lt_dden
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd25 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;enqueue-object&apos;
        is_struc = ls_dd25
        ib_end   = abap_false.

    CALL METHOD write_table EXPORTING ic_tag = :
      &apos;base-table&apos;     it_table = lt_dd26,
      &apos;lock-parameter&apos; it_table = lt_dd27,
      &apos;lock-argument&apos;  it_table = lt_dden.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_enqu

  METHOD process_fugr.

    DATA:
      ls_libg  TYPE info_fugrz,
      lt_funcs TYPE TABLE OF rs38l_incl.
    FIELD-SYMBOLS:
      &lt;f&gt;      LIKE LINE OF lt_funcs.

    SELECT SINGLE * FROM info_fugrz
                    INTO ls_libg
                   WHERE area EQ ic_name.                   &quot;#EC *
    CHECK sy-subrc EQ 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;function-group&apos;
        is_struc = ls_libg
        ib_end   = abap_false.
    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;RE&apos;.

    CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
      EXPORTING
        function_pool = ls_libg-area
      TABLES
        functab       = lt_funcs
      EXCEPTIONS
        OTHERS        = 0.

    LOOP AT lt_funcs ASSIGNING &lt;f&gt;.
      CALL METHOD process_func
        EXPORTING
          ic_name = &lt;f&gt;-funcname.
    ENDLOOP.

    CALL METHOD end_tag.
  ENDMETHOD.                    &quot;process_fugr

  METHOD process_func.
    DATA:
      ls_func   TYPE v_fdirt,
      lt_docu   TYPE TABLE OF funct,
      lt_exc    TYPE TABLE OF rsexc,
      lt_exp    TYPE TABLE OF rsexp,
      lt_imp    TYPE TABLE OF rsimp,
      lt_cha    TYPE TABLE OF rscha,
      lt_tbl    TYPE TABLE OF rstbl,
      BEGIN OF ls_exc.
    INCLUDE TYPE rsexc.
    DATA:
        description TYPE funct-stext,
      END OF ls_exc,
      BEGIN OF ls_exp.
    INCLUDE TYPE rsexp.
    DATA:
        description TYPE funct-stext,
      END OF ls_exp,
      BEGIN OF ls_imp.
    INCLUDE TYPE rsimp.
    DATA:
        description TYPE funct-stext,
      END OF ls_imp,
      BEGIN OF ls_cha.
    INCLUDE TYPE rscha.
    DATA:
        description TYPE funct-stext,
      END OF ls_cha,
      BEGIN OF ls_tbl.
    INCLUDE TYPE rstbl.
    DATA:
        description TYPE funct-stext,
      END OF ls_tbl.

*   First SELECT statement is with arbitrary language so we make sure
*   we get an entry of the function if there is one. If we would
*   pass MC_LANGU at this point, the SELECT may fail altogether.
    SELECT SINGLE * FROM v_fdirt
                    INTO ls_func
                   WHERE funcname EQ ic_name.               &quot;#EC *
    CHECK sy-subrc EQ 0.
    IF ls_func-spras NE mc_langu.
*     Try to update the language-dependent fields with requested
*     language. If not available, the fields keep the content from the
*     previous SELECT statement.
      SELECT SINGLE spras stext FROM v_fdirt
                    INTO (ls_func-spras, ls_func-stext)
                   WHERE funcname EQ ic_name
                     AND spras    EQ mc_langu.              &quot;#EC *
    ENDIF.

    CALL FUNCTION &apos;FUNCTION_IMPORT_DOKU&apos;
      EXPORTING
        funcname           = ic_name
        language           = mc_langu
      TABLES
        dokumentation      = lt_docu
        exception_list     = lt_exc
        export_parameter   = lt_exp
        import_parameter   = lt_imp
        changing_parameter = lt_cha
        tables_parameter   = lt_tbl
      EXCEPTIONS
        OTHERS             = 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;function-module&apos;
        is_struc = ls_func
        ib_end   = abap_false.

    CALL METHOD process_parameter
      EXPORTING
        ic_function  = ls_func-funcname
        it_docu      = lt_docu
        :
        it_parameter = lt_imp
        ic_tag       = &apos;importing&apos;
      CHANGING
        cs_wa        = ls_imp,
        it_parameter = lt_exp
        ic_tag       = &apos;exporting&apos;
      CHANGING
        cs_wa        = ls_exp,
        it_parameter = lt_cha
        ic_tag       = &apos;changing&apos;
      CHANGING
        cs_wa        = ls_cha,
        it_parameter = lt_tbl
        ic_tag       = &apos;tables&apos;
      CHANGING
        cs_wa        = ls_tbl,
        it_parameter = lt_exc
        ic_parmkind  = &apos;X&apos;
        ic_tag       = &apos;exception&apos;
      CHANGING
        cs_wa        = ls_exc.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;FU&apos;
        ic_type  = &apos;T&apos;.

    CALL METHOD end_tag.
  ENDMETHOD.                    &quot;process_func

  METHOD process_prog.
  ENDMETHOD.

  METHOD process_msag.
  ENDMETHOD.

  METHOD process_parameter.

    DATA lc_dok TYPE dokhl-object.
    FIELD-SYMBOLS:
      &lt;docu&gt; LIKE LINE OF it_docu,
      &lt;parname&gt; TYPE ANY,
      &lt;desc&gt; TYPE ANY,
      &lt;parm&gt; TYPE ANY.

    LOOP AT it_parameter ASSIGNING &lt;parm&gt;.
      MOVE-CORRESPONDING &lt;parm&gt; TO cs_wa.
      ASSIGN COMPONENT &apos;DESCRIPTION&apos; OF STRUCTURE cs_wa TO &lt;desc&gt;.
      IF ic_parmkind EQ &apos;X&apos;.
        ASSIGN COMPONENT &apos;EXCEPTION&apos; OF STRUCTURE &lt;parm&gt; TO &lt;parname&gt;.
      ELSE.
        ASSIGN COMPONENT &apos;PARAMETER&apos; OF STRUCTURE &lt;parm&gt; TO &lt;parname&gt;.
      ENDIF.
      READ TABLE it_docu ASSIGNING &lt;docu&gt;
        WITH KEY spras     = mc_langu
                 parameter = &lt;parname&gt;
                 kind      = ic_parmkind
                 version   = &apos;0001&apos;.
      IF sy-subrc EQ 0.
        &lt;desc&gt; = &lt;docu&gt;-stext.
      ELSE.
        CLEAR &lt;desc&gt;.
      ENDIF.

      CALL METHOD write_tag
        EXPORTING
          ic_tag   = ic_tag
          is_struc = cs_wa
          ib_end   = abap_false.
      lc_dok    = ic_function.
      lc_dok+30 = &lt;parname&gt;.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = lc_dok
          ic_dokid = &apos;FU&apos;
          ic_type  = &apos;T&apos;.
      CALL METHOD end_tag.
    ENDLOOP.
  ENDMETHOD.                    &quot;process_parameter

  METHOD process_intf.
    DATA:
      ls_clskey     TYPE seoclskey,
      ls_interface  TYPE seoc_interface_r.

    ls_clskey-clsname = ic_name.

    CALL FUNCTION &apos;SEO_INTERFACE_READ&apos;
      EXPORTING
        intkey          = ls_clskey
        version         = seoc_version_active
        master_language = space
        modif_language  = mc_langu
      IMPORTING
        interface       = ls_interface.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;interface&apos;
        is_struc = ls_interface
        ib_end   = abap_false.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;IF&apos;.

    CALL METHOD process_object_body
      EXPORTING
        ic_name = ic_name.

    CALL METHOD end_tag. &quot;interface
  ENDMETHOD.                    &quot;process_intf

  METHOD process_tabl.
    DATA:
      lc_name    TYPE ddobjname,
      ls_dd02    TYPE dd02v,
      ls_dd09    TYPE dd09l,
      lt_dd03    TYPE TABLE OF dd03p.
    FIELD-SYMBOLS &lt;dd03&gt; LIKE LINE OF lt_dd03.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_TABL_GET&apos;
      EXPORTING
        name                = lc_name
       langu               = mc_langu
     IMPORTING
       dd02v_wa            = ls_dd02
       dd09l_wa            = ls_dd09
     TABLES
       dd03p_tab           = lt_dd03
*     DD05M_TAB           =
*     DD08V_TAB           =
*     DD12V_TAB           =
*     DD17V_TAB           =
*     DD35V_TAB           =
*     DD36M_TAB           =
     EXCEPTIONS
       OTHERS              = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd02 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;table&apos;
        is_struc = ls_dd02
        ib_end   = abap_false.
    IF NOT ls_dd09 IS INITIAL.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;technical-settings&apos;
          is_struc = ls_dd09.
    ENDIF.

    LOOP AT lt_dd03 ASSIGNING &lt;dd03&gt;.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;component&apos;
          is_struc = &lt;dd03&gt;
          ib_end   = abap_false.
*     Especially for customising table it might be valuable to display
*     the data element documentation
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = &lt;dd03&gt;-rollname
          ic_dokid = &apos;DE&apos;.
      CALL METHOD end_tag.
    ENDLOOP.

    IF p_syscnt         EQ abap_true AND
       ls_dd02-contflag EQ &apos;S&apos;. &quot;system customising table
      CALL METHOD get_table_content
        EXPORTING
          ic_name = ic_name.
    ENDIF.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;TB&apos;.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_tabl

  METHOD process_ttyp.
    DATA:
      lc_name TYPE ddobjname,
      ls_dd40 TYPE dd40v,
      lt_dd42 TYPE TABLE OF dd42v.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd40v_wa  = ls_dd40
      TABLES
        dd42v_tab = lt_dd42
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd40 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;table-type&apos;
        is_struc = ls_dd40
        ib_end   = abap_false.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;key&apos;
        it_table = lt_dd42.
    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_ttyp

  METHOD process_documentation.
    DATA:
      lt_tline  TYPE tlinetab,
      lc_object TYPE dokhl-object,
      lt_docu   TYPE sotr_texts.
    FIELD-SYMBOLS:
      &lt;t&gt;       LIKE LINE OF lt_tline,
      &lt;d&gt;       LIKE LINE OF lt_docu.

    lc_object = ic_name.
    CALL FUNCTION &apos;DOCU_GET&apos;
      EXPORTING
        id     = ic_dokid
        langu  = mc_langu
        object = lc_object
        typ    = ic_type
      TABLES
        line   = lt_tline
      EXCEPTIONS
        OTHERS = 0.
    CHECK NOT lt_tline[] IS INITIAL.

* Idea: Use CONVERT_ITF_TO_* here...

    LOOP AT lt_tline ASSIGNING &lt;t&gt;.
      IF sy-tabix     EQ 1 AND
       ( &lt;t&gt;-tdformat EQ space OR &lt;t&gt;-tdformat EQ &apos;=&apos; ).
*       Don&apos;t know how the first line of documentation can have such
*       a format, but it happens. So better change the format,
*       otherwise we&apos;ll get a short dump &apos;field symbol not assigned&apos; in
*       the following CASE statement.
        &lt;t&gt;-tdformat = &apos;*&apos;.
      ENDIF.

      CASE &lt;t&gt;-tdformat.
        WHEN space.
          CONCATENATE &lt;d&gt; &lt;t&gt;-tdline INTO &lt;d&gt; SEPARATED BY space.
        WHEN &apos;=&apos;.
          CONCATENATE &lt;d&gt; &lt;t&gt;-tdline INTO &lt;d&gt;.
        WHEN OTHERS.
          APPEND INITIAL LINE TO lt_docu ASSIGNING &lt;d&gt;.
          &lt;d&gt; = &lt;t&gt;-tdline.
      ENDCASE.

    ENDLOOP.


    CALL METHOD write_tag
      EXPORTING
        ic_tag = &apos;documentation&apos;
        ib_end = abap_false.
    LOOP AT lt_docu ASSIGNING &lt;d&gt;.
      REPLACE ALL OCCURRENCES OF &apos;&amp;VLINE&amp;&apos; IN &lt;d&gt; WITH &apos;|&apos;.
      IF &lt;d&gt; CP &apos;&amp;*&amp;&apos;.
        IF get_tag( ) NE &apos;documentation&apos;. CALL METHOD end_tag. ENDIF.
        SHIFT &lt;d&gt; LEFT DELETING LEADING &apos;&amp;&apos;.
        REPLACE &apos;&amp;&apos; IN &lt;d&gt; WITH space.
        TRANSLATE &lt;d&gt; TO LOWER CASE.                      &quot;#EC SYNTCHAR
        CALL METHOD write_tag
          EXPORTING
            ic_tag = &lt;d&gt;
            ib_end = abap_false.
      ELSE.
        &lt;d&gt; = convert_entities( &lt;d&gt; ).
        APPEND &lt;d&gt; TO mt_output REFERENCE INTO mr_output.
      ENDIF.
    ENDLOOP.
    IF get_tag( ) NE &apos;documentation&apos;. CALL METHOD end_tag. ENDIF.
    CALL METHOD end_tag.
  ENDMETHOD.                    &quot;process_documentation

  METHOD process_object_body.
    DATA:
      BEGIN OF ls_doku,
        id          TYPE doku_id,
        object      TYPE doku_obj,
      END OF ls_doku,
      lr_descr      TYPE REF TO cl_abap_objectdescr,
      ls_clifkey    TYPE seoclskey,
      lt_clifkey    TYPE TABLE OF seoclskey,
      lt_attrs      TYPE TABLE OF vseoattrib,
      ls_attr       TYPE vseoattrib,
      lt_meth       TYPE TABLE OF vseomethod,
      ls_meth       TYPE vseomethod,
      lt_evt        TYPE TABLE OF vseoevent,
      ls_event      TYPE vseoevent,
      lt_methpar    TYPE TABLE OF vseoparam,
      lt_methexc    TYPE TABLE OF vseoexcep,
      ls_reltype    TYPE seocpdkey,
      ls_cmpkey     TYPE seocmpkey,
      ls_relkey     TYPE seorelkey,
*      ls_class      TYPE seoc_class_r,
      lt_methpar2   TYPE seos_parameters_r,
      lt_methexc2   TYPE seos_exceptions_r,
      ls_attd       TYPE ys_attrdescr,
      ls_mthd       TYPE ys_methdescr,
      ls_pard       TYPE ys_parmdescr,
      ls_excd       TYPE ys_excpdescr,
      ls_evtd       TYPE ys_evntdescr.
    FIELD-SYMBOLS:
      &lt;pr&gt;          LIKE LINE OF ls_mthd-parameters,
      &lt;ex&gt;          LIKE LINE OF ls_mthd-exceptions,
      &lt;par&gt;         LIKE LINE OF lt_methpar,
      &lt;exc&gt;         LIKE LINE OF lt_methexc,
      &lt;evt&gt;         LIKE LINE OF lr_descr-&gt;events,
      &lt;att&gt;         LIKE LINE OF lr_descr-&gt;attributes,
      &lt;mth&gt;         LIKE LINE OF lr_descr-&gt;methods.

    &quot; 这里的问题是，在tadir中存在的记录，对应的object不一定实际存在，会导致dump
    lr_descr ?= cl_abap_typedescr=&gt;describe_by_name( ic_name ).

    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;interface&apos;
        it_table = lr_descr-&gt;interfaces.

    ls_clifkey-clsname = ic_name.
    APPEND ls_clifkey TO lt_clifkey.
    CALL FUNCTION &apos;SEO_COMPONENTS_SELECT&apos;
      EXPORTING
        langu              = mc_langu
      TABLES
        clif_keys          = lt_clifkey
        comp_attributes    = lt_attrs
        comp_methods       = lt_meth
        comp_events        = lt_evt
        subcomp_parameters = lt_methpar
        subcomp_exceptions = lt_methexc
      EXCEPTIONS
        OTHERS             = 0.

    LOOP AT lr_descr-&gt;attributes ASSIGNING &lt;att&gt;.

      CLEAR: ls_attr, ls_relkey, ls_cmpkey.
      IF NOT &lt;att&gt;-alias_for IS INITIAL.
*       ...
      ELSEIF &lt;att&gt;-is_inherited  EQ abap_true OR
           ( &lt;att&gt;-is_interface  EQ abap_true AND
             lr_descr-&gt;type_kind NE lr_descr-&gt;typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = &lt;att&gt;-name.
        CALL FUNCTION &apos;SEO_COMPONENT_BY_INHERITANCE&apos;
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION &apos;SEO_ATTRIBUTE_GET&apos;
          EXPORTING
            attkey    = ls_cmpkey
          IMPORTING
            attribute = ls_attr
          EXCEPTIONS
            OTHERS    = 0.
      ELSE.
        READ TABLE lt_attrs INTO ls_attr
          WITH KEY cmpname = &lt;att&gt;-name.                    &quot;#EC *
      ENDIF.

      MOVE-CORRESPONDING &lt;att&gt; TO ls_attd.
      ls_attd-description = ls_attr-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;attribute&apos;
          is_struc = ls_attd
          ib_end   = abap_false.
      IF NOT ls_attr IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = &apos;att-ddic&apos;
            is_struc = ls_attr.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;inheritance&apos;
              is_struc = ls_relkey.
        ENDIF.
      ENDIF.

      IF &lt;att&gt;-is_interface EQ abap_true.
        ls_doku-id = &apos;IA&apos;.
      ELSE.
        ls_doku-id = &apos;CA&apos;.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = &lt;att&gt;-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. &quot;attribute
    ENDLOOP.



    LOOP AT lr_descr-&gt;methods ASSIGNING &lt;mth&gt;.
      CLEAR: ls_meth, ls_relkey.
      IF NOT &lt;mth&gt;-alias_for IS INITIAL.
*       ...
      ELSEIF &lt;mth&gt;-is_inherited  EQ abap_true OR
           ( &lt;mth&gt;-is_interface  EQ abap_true AND
             lr_descr-&gt;type_kind NE lr_descr-&gt;typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = &lt;mth&gt;-name.
        CALL FUNCTION &apos;SEO_COMPONENT_BY_INHERITANCE&apos;
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION &apos;SEO_METHOD_SIGNATURE_GET&apos;
          EXPORTING
            mtdkey     = ls_cmpkey
          IMPORTING
            method     = ls_meth
            PARAMETERS = lt_methpar2
            exceps     = lt_methexc2
          EXCEPTIONS
            OTHERS     = 0.
      ELSE.
        READ TABLE lt_meth INTO ls_meth
          WITH KEY cmpname = &lt;mth&gt;-name.                    &quot;#EC *
        REFRESH: lt_methpar2, lt_methexc2.
        LOOP AT lt_methpar ASSIGNING &lt;par&gt;
          WHERE cmpname EQ ls_meth-cmpname.
          APPEND &lt;par&gt; TO lt_methpar2.
        ENDLOOP.
        LOOP AT lt_methexc ASSIGNING &lt;exc&gt;
          WHERE cmpname EQ ls_meth-cmpname.
          APPEND &lt;exc&gt; TO lt_methexc2.
        ENDLOOP.
      ENDIF.

      MOVE-CORRESPONDING &lt;mth&gt; TO ls_mthd.
      ls_mthd-description = ls_meth-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;method&apos;
          is_struc = ls_mthd
          ib_end   = abap_false.
      IF NOT ls_meth IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = &apos;meth-ddic&apos;
            is_struc = ls_meth.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;inheritance&apos;
              is_struc = ls_relkey.
        ENDIF.

        LOOP AT &lt;mth&gt;-parameters ASSIGNING &lt;pr&gt;.
          READ TABLE lt_methpar2 ASSIGNING &lt;par&gt;
            WITH KEY clsname = ls_meth-clsname
                     cmpname = ls_meth-cmpname
                     sconame = &lt;pr&gt;-name.
          MOVE-CORRESPONDING &lt;pr&gt; TO ls_pard.
          ls_pard-description = &lt;par&gt;-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;parameter&apos;
              is_struc = ls_pard
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;par-ddic&apos;
              is_struc = &lt;par&gt;.
          CALL METHOD end_tag. &quot;method
        ENDLOOP.
        LOOP AT &lt;mth&gt;-exceptions ASSIGNING &lt;ex&gt;.
          READ TABLE lt_methexc2 ASSIGNING &lt;exc&gt;
            WITH KEY clsname = ls_meth-clsname
                     cmpname = ls_meth-cmpname
                     sconame = &lt;ex&gt;-name.
          MOVE-CORRESPONDING &lt;ex&gt; TO ls_excd.
          ls_excd-description = &lt;exc&gt;-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;exception&apos;
              is_struc = ls_excd
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;exc-ddic&apos;
              is_struc = &lt;exc&gt;.
          CALL METHOD end_tag. &quot; exception
        ENDLOOP.
      ENDIF.

      IF &lt;mth&gt;-is_interface EQ abap_true.
        ls_doku-id = &apos;IO&apos;.
      ELSE.
        ls_doku-id = &apos;CO&apos;.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = &lt;mth&gt;-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. &quot;method
    ENDLOOP.

    LOOP AT lr_descr-&gt;events ASSIGNING &lt;evt&gt;.
      CLEAR: ls_event, ls_relkey, ls_cmpkey.
      IF NOT &lt;evt&gt;-alias_for IS INITIAL.
*       ...
      ELSEIF &lt;evt&gt;-is_inherited  EQ abap_true OR
           ( &lt;evt&gt;-is_interface  EQ abap_true AND
             lr_descr-&gt;type_kind NE lr_descr-&gt;typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = &lt;evt&gt;-name.
        CALL FUNCTION &apos;SEO_COMPONENT_BY_INHERITANCE&apos;
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION &apos;SEO_EVENT_SIGNATURE_GET&apos;
          EXPORTING
            evtkey     = ls_cmpkey
          IMPORTING
            event      = ls_event
            PARAMETERS = lt_methpar2
          EXCEPTIONS
            OTHERS     = 0.
      ELSE.
        READ TABLE lt_evt INTO ls_event
          WITH KEY cmpname = &lt;evt&gt;-name.                    &quot;#EC *
        REFRESH lt_methpar2.
        LOOP AT lt_methpar ASSIGNING &lt;par&gt;
          WHERE cmpname EQ ls_event-cmpname.
          APPEND &lt;par&gt; TO lt_methpar2.
        ENDLOOP.
      ENDIF.
      APPEND INITIAL LINE TO lt_methpar2 ASSIGNING &lt;par&gt;.
      IF NOT ls_cmpkey IS INITIAL.
        MOVE-CORRESPONDING ls_cmpkey TO &lt;par&gt;.
      ELSE.
        MOVE-CORRESPONDING ls_event TO &lt;par&gt;.
      ENDIF.
      &lt;par&gt;-sconame    = &apos;SENDER&apos;.
      &lt;par&gt;-version    = &apos;1&apos;. &quot;active
      &lt;par&gt;-langu      = mc_langu.
      &lt;par&gt;-descript   = &apos;Implicitly added sender of the event&apos;(001).
      &lt;par&gt;-cmptype    = &apos;2&apos;. &quot;method
      &lt;par&gt;-mtdtype    = &apos;0&apos;. &quot;regular method
      &lt;par&gt;-editorder  = &apos;0&apos;.
      &lt;par&gt;-dispid     = &apos;0&apos;.
      &lt;par&gt;-author     = ls_event-author.
      &lt;par&gt;-createdon  = ls_event-createdon.
      &lt;par&gt;-changedby  = ls_event-changedby.
      &lt;par&gt;-changedon  = ls_event-changedon.
      &lt;par&gt;-pardecltyp = &apos;1&apos;. &quot;always exporting
      &lt;par&gt;-parpasstyp = &apos;0&apos;. &quot;always by-value
      &lt;par&gt;-typtype    = &apos;3&apos;. &quot;TYPE REF TO
      &lt;par&gt;-type       = ic_name.
*      &lt;par&gt;-TABLEOF
*      &lt;par&gt;-PARVALUE
*      &lt;par&gt;-PAROPTIONL
*      &lt;par&gt;-PARPREFERD
*      &lt;par&gt;-LOCKED

      MOVE-CORRESPONDING &lt;evt&gt; TO ls_evtd.
      ls_evtd-description = ls_event-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;event&apos;
          is_struc = ls_evtd
          ib_end   = abap_false.
      IF NOT ls_event IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = &apos;evt-ddic&apos;
            is_struc = ls_event.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;inheritance&apos;
              is_struc = ls_relkey.
        ENDIF.

        LOOP AT &lt;evt&gt;-parameters ASSIGNING &lt;pr&gt;.
          READ TABLE lt_methpar2 ASSIGNING &lt;par&gt;
            WITH KEY clsname = ls_event-clsname
                     cmpname = ls_event-cmpname
                     sconame = &lt;pr&gt;-name.
          MOVE-CORRESPONDING &lt;pr&gt; TO ls_pard.
          ls_pard-description = &lt;par&gt;-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;parameter&apos;
              is_struc = ls_pard
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;par-ddic&apos;
              is_struc = &lt;par&gt;.
          CALL METHOD end_tag. &quot;method
        ENDLOOP.
      ENDIF.

      IF &lt;evt&gt;-is_interface EQ abap_true.
        ls_doku-id = &apos;IE&apos;.
      ELSE.
        ls_doku-id = &apos;CE&apos;.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = &lt;evt&gt;-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. &quot;method
    ENDLOOP.

  ENDMETHOD.                    &quot;process_object_body



  METHOD get_table_content.

    DATA:
      lr_content TYPE REF TO data.
    FIELD-SYMBOLS:
      &lt;content&gt;  TYPE ANY.

    CREATE DATA lr_content TYPE (ic_name).
    ASSIGN lr_content-&gt;* TO &lt;content&gt;.
    SELECT * FROM (ic_name) INTO &lt;content&gt;.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;entry&apos;
          is_struc = &lt;content&gt;.
    ENDSELECT.

  ENDMETHOD.                    &quot;get_table_content



  METHOD write_table.

    FIELD-SYMBOLS &lt;l&gt; TYPE ANY.

    LOOP AT it_table ASSIGNING &lt;l&gt;.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = ic_tag
          is_struc = &lt;l&gt;.
    ENDLOOP.

  ENDMETHOD.                    &quot;write_table

  METHOD write_tag.
    DATA lc_str TYPE string.

    APPEND INITIAL LINE TO mt_output REFERENCE INTO mr_output.
    INSERT ic_tag INTO mt_tags INDEX 1.

    IF is_struc IS SUPPLIED.
      lc_str = write_attributes( is_struc ).
    ENDIF.

    IF ib_end EQ abap_true.
      CONCATENATE &apos;&lt;&apos; ic_tag lc_str &apos;/&gt;&apos; INTO mr_output-&gt;*.
      DELETE mt_tags INDEX 1.
    ELSE.
      CONCATENATE &apos;&lt;&apos; ic_tag lc_str &apos;&gt;&apos; INTO mr_output-&gt;*.
    ENDIF.
  ENDMETHOD.                    &quot;write_tag


  METHOD end_tag.

    DATA lc_tag TYPE string.

    APPEND INITIAL LINE TO mt_output REFERENCE INTO mr_output.
    lc_tag = get_tag( ).
    CONCATENATE &apos;&lt;/&apos; lc_tag &apos;&gt;&apos; INTO mr_output-&gt;*.
    DELETE mt_tags INDEX 1.

  ENDMETHOD.                    &quot;end_tag


  METHOD get_tag.
    READ TABLE mt_tags INTO ec_tag INDEX 1.
  ENDMETHOD .                    &quot;get_tag


*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_attributes
*&amp;---------------------------------------------------------------------*
  METHOD write_attributes.

    DATA:
      lr_descr TYPE REF TO cl_abap_structdescr,
      lc_attr  TYPE string.
    FIELD-SYMBOLS:
      &lt;c&gt;      LIKE LINE OF lr_descr-&gt;components,
      &lt;f&gt;      TYPE ANY.

    lr_descr ?= cl_abap_typedescr=&gt;describe_by_data( is_struc ).

    LOOP AT lr_descr-&gt;components ASSIGNING &lt;c&gt;.
      CLEAR lc_attr.
      ASSIGN COMPONENT &lt;c&gt;-name OF STRUCTURE is_struc TO &lt;f&gt;.
      lc_attr = write_attribute( ic_name = &lt;c&gt;-name i_field = &lt;f&gt; ).
      CHECK NOT lc_attr IS INITIAL.
      CONCATENATE ec_attr lc_attr INTO ec_attr SEPARATED BY space.
    ENDLOOP.

  ENDMETHOD.                    &quot;write_attributes

*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_attribute
*&amp;---------------------------------------------------------------------*
  METHOD write_attribute.

    DATA:
      lc_name  TYPE string,
      lc_value TYPE string.
*      li_len   TYPE i.

    lc_name = get_attribute_name( ic_name ).
    CHECK NOT lc_name IS INITIAL.
  lc_value = get_attribute_value( ic_name = lc_name i_field = i_field ).
    CHECK NOT lc_value IS INITIAL.
    CONCATENATE lc_name &apos;=&apos; lc_value INTO ec_attribute.

  ENDMETHOD.                    &quot;write_attribute

*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_attribute_name
*&amp;---------------------------------------------------------------------*
  METHOD get_attribute_name.

    IF get_tag( ) NE &apos;entry&apos;.
      CHECK ic_name NE: &apos;DDLANGUAGE&apos;, &apos;SPRAS&apos;, &apos;LANGU&apos;,
                        &apos;INTLENGTH&apos;, &apos;EDITORDER&apos;, &apos;R3RELEASE&apos;, &apos;DISPID&apos;,
                        &apos;UUID&apos;.
    ENDIF.

    transl &apos;DDTEXT&apos; &apos;description&apos;.
    transl &apos;DESCRIPT&apos; &apos;description&apos;.
    transl &apos;AS4USER&apos; &apos;changedby&apos;.
    transl &apos;AS4DATE&apos; &apos;changedon&apos;.
    transl &apos;AS4USER&apos; &apos;changedby&apos;.


    CASE get_tag( ).
      WHEN &apos;package&apos; OR &apos;subpackage&apos;.
        transl &apos;DEVCLASS&apos; &apos;name&apos;.
        transl &apos;CTEXT&apos; &apos;description&apos;.
      WHEN &apos;class&apos; OR &apos;subclass&apos; OR &apos;superclass&apos;.
        CHECK ic_name NE: &apos;LANGU&apos;, &apos;REFCLSNAME&apos;.
        transl &apos;CLSNAME&apos; &apos;name&apos;.
      WHEN &apos;attribute&apos;. &quot;of a class
        CHECK ic_name NE: &apos;LENGTH&apos;, &apos;DECIMALS&apos;.
*        transl &apos;CMPNAME&apos; &apos;name&apos;.
*        transl &apos;ATTDECLTYP&apos; &apos;scope&apos;.
      WHEN &apos;method&apos;. &quot;of a class
        CHECK ic_name NE: &apos;PARAMETERS&apos;, &apos;EXCEPTIONS&apos;.
*        CHECK ic_name NE: &apos;CLSNAME&apos;.
        transl &apos;CMPNAME&apos; &apos;name&apos;.
        transl &apos;MTDDECLTYP&apos; &apos;scope&apos;.
      WHEN &apos;parameter&apos;. &quot;of a function module or class
        CHECK ic_name NE: &apos;POSITION&apos;, &apos;CLSNAME&apos;, &apos;CMPNAME&apos;, &apos;LENGTH&apos;,
                          &apos;DECIMALS&apos;.
        transl &apos;SCONAME&apos; &apos;name&apos;.   &quot;class
        transl &apos;TABNAME&apos; &apos;type&apos;.
        transl &apos;PARAMTEXT&apos; &apos;description&apos;.
      WHEN &apos;event&apos;.
        CHECK ic_name NE &apos;PARAMETERS&apos;.
      WHEN &apos;dataelem&apos;.
        transl &apos;ROLLNAME&apos; &apos;name&apos;.
      WHEN &apos;domain&apos;.
        transl &apos;DOMNAME&apos; &apos;name&apos;.
      WHEN &apos;fixed-value&apos;. &quot;of domain
        CHECK ic_name NE: &apos;DOMNAME&apos;, &apos;VALPOS&apos;.
      WHEN &apos;enqueue-object&apos;.
        transl &apos;VIEWNAME&apos; &apos;name&apos;.
      WHEN &apos;base-table&apos;. &quot;of an enqueue object
        CHECK ic_name NE &apos;VIEWNAME&apos;.
        transl &apos;TABNAME&apos; &apos;type&apos;.
      WHEN &apos;lock-argument&apos;. &quot;of an enqueue object
        CHECK ic_name NE &apos;VIEWNAME&apos;.
      WHEN &apos;lock-parameter&apos;. &quot;of an enqueue object
        CHECK ic_name NE &apos;VIEWNAME&apos;.
      WHEN &apos;function-group&apos;.
        CHECK ic_name NE &apos;DEVCLASS&apos;.
        transl &apos;AREA&apos; &apos;name&apos;.
        transl &apos;AREAT&apos; &apos;description&apos;.
      WHEN &apos;function-module&apos;.
        CHECK ic_name NE &apos;AREA&apos;.
        transl &apos;FUNCNAME&apos; &apos;name&apos;.
        transl &apos;STEXT&apos; &apos;description&apos;.
      WHEN &apos;importing&apos; OR &apos;exporting&apos; OR &apos;changing&apos; OR &apos;tables&apos;.
        transl &apos;PARAMETER&apos; &apos;name&apos;.
        transl &apos;TYP&apos; &apos;type&apos;.
        transl &apos;DBFIELD&apos; &apos;type&apos;.
        transl &apos;DBSTRUCT&apos; &apos;type&apos;.
      WHEN &apos;exception&apos;.
        transl &apos;EXCEPTION&apos; &apos;name&apos;.
      WHEN &apos;interface&apos;.
        transl &apos;CLSNAME&apos; &apos;name&apos;.
      WHEN &apos;table&apos;.
        transl &apos;TABNAME&apos; &apos;name&apos;.
        transl &apos;ROLLNAME&apos; &apos;type&apos;.
      WHEN &apos;component&apos;. &quot;of a table or structure
        CHECK ic_name NE: &apos;TABNAME&apos;, &apos;POSITION&apos;, &apos;OFFSET&apos;.
        transl &apos;FIELDNAME&apos; &apos;name&apos;.
        transl &apos;ROLLNAME&apos; &apos;type&apos;.
      WHEN &apos;table-type&apos;.
        transl &apos;TYPENAME&apos; &apos;name&apos;.
        transl &apos;ROWTYPE&apos; &apos;type&apos;.
      WHEN &apos;key&apos;. &quot;of table-type.
        CHECK ic_name NE &apos;TYPENAME&apos;.

    ENDCASE.

    IF ec_name IS INITIAL. &quot;none of previous translations applied
      ec_name = ic_name.
      TRANSLATE ec_name TO LOWER CASE.
    ENDIF.

  ENDMETHOD.                    &quot;write_attribute_name


*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_attribute_value
*&amp;---------------------------------------------------------------------*
  METHOD get_attribute_value.

    DATA:
      lc(100) TYPE c,
      ls_address TYPE bapiaddr3,
      lt_return TYPE bapiret2_t.

    WRITE i_field TO lc LEFT-JUSTIFIED.

    IF lc IS INITIAL. &quot;initial in character mode, i.e. lc is space

      CHECK get_tag( ) EQ &apos;fixed-value&apos; OR
            get_tag( ) EQ &apos;entry&apos;.

      ec_value = &apos;&quot; &quot;&apos;.
      EXIT.

    ELSEIF lc EQ &apos;00.00.0000&apos;.
*     Ignore initial dates
      EXIT.

    ELSEIF ic_name EQ &apos;author&apos; OR
           ic_name EQ &apos;changedby&apos;.

      CALL FUNCTION &apos;BAPI_USER_GET_DETAIL&apos;
        EXPORTING
          username = i_field
        IMPORTING
          address  = ls_address
        TABLES
          return   = lt_return.
      IF NOT ls_address-firstname IS INITIAL OR
         NOT ls_address-lastname IS INITIAL.
        CONCATENATE ls_address-firstname ls_address-lastname INTO lc
          SEPARATED BY space.
        CONDENSE lc.
      ENDIF.

    ENDIF.

    ec_value = convert_entities( lc ).
    CONCATENATE &apos;&quot;&apos; ec_value &apos;&quot;&apos; INTO ec_value.


  ENDMETHOD.                    &quot;get_attribute_value


  METHOD convert_entities.

    ec_value = ic_value.

    REPLACE ALL OCCURRENCES OF:
* the ampersand must be replaced first, otherwise it will also be
* replaced in following entity declarations (e.g. &gt; becomes &amp;amp;gt; ).

* 这里的转换#是有问题的，会导致最终生成的xml无法转换为html，不过貌似是有乱码问题?
* 解决方法，不用修改代码，直接将生成的xml中那一串玩意替换为#即可
      &apos;&amp;&apos;  IN ec_value WITH &apos;&amp;amp;&apos;,
      &apos;&lt;&apos;  IN ec_value WITH &apos;&amp;lt;&apos;,
      &apos;&gt;&apos;  IN ec_value WITH &apos;&amp;gt;&apos;,
      &apos;&quot;&apos;  IN ec_value WITH &apos;&amp;quot;&apos;,
      &apos;&apos;&apos;&apos; IN ec_value WITH &apos;&amp;apos;&apos;,
      &apos;±&apos;  IN ec_value WITH &apos;&amp;#177;&apos;,
      &apos;³&apos;  IN ec_value WITH &apos;&amp;#177;&apos;,
      &apos;¶&apos;  IN ec_value WITH &apos;&amp;#182;&apos;,
      &apos;¼&apos;  IN ec_value WITH &apos;&amp;#188;&apos;,
      &apos;¿&apos;  IN ec_value WITH &apos;&amp;#191;&apos;,
      &apos;Ä&apos;  IN ec_value WITH &apos;&amp;#196;&apos;,
      &apos;Ö&apos;  IN ec_value WITH &apos;&amp;#214;&apos;,
      &apos;Ü&apos;  IN ec_value WITH &apos;&amp;#220;&apos;,
      &apos;ß&apos;  IN ec_value WITH &apos;&amp;#223;&apos;,
      &apos;à&apos;  IN ec_value WITH &apos;&amp;#224;&apos;,
      &apos;á&apos;  IN ec_value WITH &apos;&amp;#225;&apos;,
      &apos;â&apos;  IN ec_value WITH &apos;&amp;#226;&apos;,
      &apos;ã&apos;  IN ec_value WITH &apos;&amp;#227;&apos;,
      &apos;ä&apos;  IN ec_value WITH &apos;&amp;#228;&apos;,
      &apos;æ&apos;  IN ec_value WITH &apos;&amp;#230;&apos;,
      &apos;ç&apos;  IN ec_value WITH &apos;&amp;#231;&apos;,
      &apos;è&apos;  IN ec_value WITH &apos;&amp;#233;&apos;,
      &apos;é&apos;  IN ec_value WITH &apos;&amp;#234;&apos;,
      &apos;ê&apos;  IN ec_value WITH &apos;&amp;#235;&apos;,
      &apos;ì&apos;  IN ec_value WITH &apos;&amp;#236;&apos;,
      &apos;í&apos;  IN ec_value WITH &apos;&amp;#237;&apos;,
      &apos;î&apos;  IN ec_value WITH &apos;&amp;#238;&apos;,
      &apos;ñ&apos;  IN ec_value WITH &apos;&amp;#241;&apos;,
      &apos;ó&apos;  IN ec_value WITH &apos;&amp;#243;&apos;,
      &apos;ô&apos;  IN ec_value WITH &apos;&amp;#244;&apos;,
      &apos;õ&apos;  IN ec_value WITH &apos;&amp;#245;&apos;,
      &apos;ö&apos;  IN ec_value WITH &apos;&amp;#246;&apos;,
      &apos;ù&apos;  IN ec_value WITH &apos;&amp;#249;&apos;,
      &apos;ú&apos;  IN ec_value WITH &apos;&amp;#250;&apos;,
      &apos;ü&apos;  IN ec_value WITH &apos;&amp;#252;&apos;.

  ENDMETHOD.                    &quot;convert_entities


  METHOD get_superclass .

    CLEAR ec_superclass.

    DATA:
      lr_descr TYPE REF TO cl_abap_typedescr,
      lr_class TYPE REF TO cl_abap_classdescr.

    CALL METHOD cl_abap_typedescr=&gt;describe_by_name
      EXPORTING
        p_name      = ic_classname
      RECEIVING
        p_descr_ref = lr_descr
      EXCEPTIONS
        OTHERS      = 1.
    CHECK sy-subrc EQ 0.

    CATCH SYSTEM-EXCEPTIONS move_cast_error = 1.
      lr_class ?= lr_descr.
    ENDCATCH.
    CHECK sy-subrc EQ 0.

    CALL METHOD lr_class-&gt;get_super_class_type
      RECEIVING
        p_descr_ref = lr_descr
      EXCEPTIONS
        OTHERS      = 1.
    CHECK: sy-subrc     EQ 0,
           NOT lr_descr IS INITIAL. &quot;no superclass

    ec_superclass = lr_descr-&gt;get_relative_name( ).

  ENDMETHOD.                    &quot;GET_SUPERCLASS

ENDCLASS.                    &quot;ycl_generator IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZABAPDOC_SINGLE" VARCL="X" SUBC="1" RSTAT="T" RMAND="100" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Generate Single Html File For Repository Objects" LENGTH="48 "/>
    <textElement ID="S" KEY="P_CCPRIV" ENTRY="        Private class components" LENGTH="32 "/>
    <textElement ID="S" KEY="P_CCPROT" ENTRY="        Protected class components" LENGTH="34 "/>
    <textElement ID="S" KEY="P_CLSCMP" ENTRY="        Class components" LENGTH="24 "/>
    <textElement ID="S" KEY="P_FHTML" ENTRY="        Output file name (html)" LENGTH="31 "/>
    <textElement ID="S" KEY="P_FSRC" ENTRY="        Source code file name" LENGTH="29 "/>
    <textElement ID="S" KEY="P_HTMLCM" ENTRY="        Comments include HTML tags" LENGTH="34 "/>
    <textElement ID="S" KEY="P_INCDET" ENTRY="        INCLUDES - details" LENGTH="26 "/>
    <textElement ID="S" KEY="P_INCHIE" ENTRY="        INCLUDES - hierarchy" LENGTH="28 "/>
    <textElement ID="S" KEY="P_PROG" ENTRY="        Analysed program name" LENGTH="29 "/>
    <textElement ID="S" KEY="P_TABLES" ENTRY="        Database tables" LENGTH="23 "/>
    <textElement ID="S" KEY="P_UNTDET" ENTRY="        Non-class code units" LENGTH="28 "/>
    <textElement ID="S" KEY="P_UNTHIE" ENTRY="        Code units - hierarchy" LENGTH="30 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZICDOC
*&amp;
*&amp;---------------------------------------------------------------------*
* @Author Ireneusz Cwir
* The main program of ZICDOC generator. It shows also how to call
* program analysis and HTML file generation from other code.

REPORT  zabapdoc_single LINE-SIZE 256.

* These texts are defined in properties of the program.
* You can uncomment them (optionally) and copy to right fields.
*
* Title (Goto -&gt; Attributes)
* ZICDOC - ABAP documentation generator
*
* Selection parametrs (Goto -&gt; Text elements -&gt; Selection texts):
*P_CCPRIV	Private class components
*P_CCPROT	Protected class components
*P_CLSCMP	Class components
*P_FHTML  Output file name (html)
*P_FSRC	Cource code file name
*P_HTMLCM	Comments include HTML tags
*P_INCDET	INCLUDES - details
*P_INCHIE	INCLUDES - hierarchy
*P_PROG	Analysed program name
*P_TABLES	Database tables
*P_UNTDET	Non-class code units
*P_UNTHIE	Code units - hierarchy


PARAMETERS: p_prog  LIKE trdir-name DEFAULT &apos;ZICDOC_TEST1&apos;,
            p_fsrc  LIKE rlgrap-filename DEFAULT &apos;d:\Z22IC002.txt&apos;.
SELECTION-SCREEN SKIP 1.
PARAMETERS: p_fhtml LIKE rlgrap-filename DEFAULT &apos;D:\ZICDOC_TEST1.html&apos;.

SELECTION-SCREEN SKIP 1.
PARAMETERS: p_inchie AS CHECKBOX DEFAULT &apos;X&apos;,
            p_incdet AS CHECKBOX DEFAULT &apos;X&apos;,
            p_tables AS CHECKBOX DEFAULT &apos;X&apos;,
            p_clscmp AS CHECKBOX DEFAULT &apos;X&apos;,
            p_untdet AS CHECKBOX DEFAULT &apos;X&apos;,
            p_unthie AS CHECKBOX DEFAULT &apos;X&apos;.

SELECTION-SCREEN SKIP 1.
PARAMETERS: p_ccprot AS CHECKBOX DEFAULT &apos;X&apos;,
            p_ccpriv AS CHECKBOX DEFAULT &apos;X&apos;.

SELECTION-SCREEN SKIP 1.
PARAMETERS: p_htmlcm AS CHECKBOX DEFAULT &apos;X&apos;.

*----------------------------------------------------------------------

* Include classe for code analysis and HTML file generation
INCLUDE zicdoc_cl_code_analysis_html.

*----------------------------------------------------------------------
* Reference to the main objectof analysis.
DATA: ref_html TYPE REF TO zcl_ic_code_analysis_html.

* Additional data
DATA: gv_str TYPE string.
DATA: gv_retcode TYPE i.

*----------------------------------------------------------------------
START-OF-SELECTION.

* Create object for code analysis
  CREATE OBJECT ref_html.

* Depending on parameters entered on selection screen, call method for
* anlysing code of program in the system or code uploaded
* from local file (from presentation server or PC).
  IF p_prog IS NOT INITIAL.

    gv_retcode = ref_html-&gt;analyse_program( p_prog ).

  ELSEIF p_fsrc IS NOT INITIAL.

    gv_str = p_fsrc.
    gv_retcode = ref_html-&gt;analyse_file( gv_str ).

  ELSE.

    WRITE:/ &apos;No program specified for analysis!&apos;.
    EXIT.

  ENDIF.

  IF gv_retcode &lt;&gt; 0.
    WRITE:/ &apos;Scan ERROR:&apos;, gv_retcode.
  ENDIF.
  CHECK gv_retcode = 0.

* Type conversion (output file name)
  gv_str = p_fhtml.

* Create HTML file with documentation.
  CALL METHOD ref_html-&gt;write_html_file
    EXPORTING
      i_filename                    = gv_str
      i_write_includes_hier         = p_inchie
      i_write_includes_details      = p_incdet
      i_write_class_components      = p_clscmp
      i_write_class_components_prot = p_ccprot
      i_write_class_components_priv = p_ccpriv
      i_write_code_units_hier       = p_unthie
      i_write_code_units_details    = p_untdet
      i_write_tables                = p_tables
      i_html_comments               = p_htmlcm
    RECEIVING
      ret_code                      = gv_retcode.


* Helper function for displaying tables with results of code scanning.
* Uncomment them if you are interested in further development of ZICDOC
* and you want to understand details of the code analysis.
  CALL METHOD ref_html-&gt;dump_statements.
  CALL METHOD ref_html-&gt;dump_statements_detailed.
  CALL METHOD ref_html-&gt;dump_tables_scan.</source>
 </PROG>
 <PROG NAME="ZDOC_CONSTANTS" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Note Documentation Constants and Types Definition" LENGTH="49 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZDOC_CONSTANTS
*&amp;---------------------------------------------------------------------*
TYPE-POOLS: icon.

CONSTANTS: cv_datasrc_js_name   TYPE c LENGTH 10 VALUE &apos;datasrc.js&apos;,    &quot;#EC NOTEXT
           &quot; maybe Lock Object, Index, Set/Get Parameter will be supported if needed in the future
*           cv_support_objects   TYPE string VALUE &apos;DEVC,FUGR,DOMA,DTEL,TABL,VIEW,VCLS,TOBJ,SHLP,TTYP,NROB,MSAD,MSAG,CDAT,VDAT,TABU,TRAN&apos;. &quot;#EC NOTEXT
           cv_support_objects   TYPE string VALUE &apos;DEVC,FUGR,DOMA,DTEL,TABL,VIEW,VCLS,TOBJ,SHLP,ENQU,TTYP,NROB,MSAD,MSAG,VDAT,TRAN&apos;. &quot;#EC NOTEXT


TYPES: BEGIN OF s_object_sort_no,
       object TYPE trobjtype,
       sort_no TYPE int1,
       END OF s_object_sort_no.
TYPES: t_object_sort_no TYPE HASHED TABLE OF s_object_sort_no WITH UNIQUE KEY object.
TYPES: BEGIN OF s_tadir_key_with_sn.
        INCLUDE STRUCTURE ztadir_key.
TYPES: sort_no  TYPE int1,
END OF s_tadir_key_with_sn.

TYPES: BEGIN OF s_template,
       include_name TYPE char20,
       mapping_file_name TYPE string,
       END OF s_template.

DATA: gt_object_sort_cache    TYPE t_object_sort_no,
      gt_objtype_desc         TYPE HASHED TABLE OF ko100 WITH UNIQUE KEY object,
      gt_templates            TYPE TABLE OF s_template,

      gt_packages             TYPE TABLE OF zpackage,
      gt_func_groups          TYPE TABLE OF zfunction_group,
      gt_domain               TYPE TABLE OF zdomain,
      gt_data_element         TYPE TABLE OF zdata_element,
      gt_table                TYPE TABLE OF ztable,
      gt_view                 TYPE TABLE OF zview,
      gt_view_cluster         TYPE TABLE OF zview_cluster,
      gt_table_types          TYPE TABLE OF ztable_type,
      gt_maintenace_view      TYPE TABLE OF zmaintenance_view,
      gt_search_help          TYPE TABLE OF zsearch_help,
      gt_locks                TYPE TABLE OF zlock_object,
      gt_table_contents       TYPE TABLE OF ztable_contents,
      gt_number_range         TYPE TABLE OF znumber_range,
      gt_msag                 TYPE TABLE OF zmessage,
      gt_msad                 TYPE TABLE OF zmessage,
      gt_transaction          TYPE TABLE OF ztransaction,

      gt_json_result          TYPE zgy_0004,
      gt_error_log            TYPE TABLE OF string.</source>
 </PROG>
 <PROG NAME="ZDOC_SUBROUTINES" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Note Documentation Subroutines" LENGTH="30 "/>
   </language>
  </textPool>
  <source>* initialize object type sort and desc buffer table
* initialize template file list we will export
FORM initialize_cache.
  PERFORM init_objtype_sort.
  PERFORM init_objtype_desc.
ENDFORM.

FORM init_objtype_sort.
  DATA: ls_obj_sort TYPE s_object_sort_no,
        lt_object   TYPE TABLE OF trobjtype,
        lv_object   TYPE trobjtype.

  SPLIT cv_support_objects AT &apos;,&apos; INTO TABLE lt_object.
  LOOP AT lt_object INTO lv_object.
    CONDENSE lv_object NO-GAPS.
    ls_obj_sort-object = lv_object.
    ls_obj_sort-sort_no = sy-tabix.

    INSERT ls_obj_sort INTO TABLE gt_object_sort_cache.
  ENDLOOP.
ENDFORM.

FORM init_objtype_desc.
  DATA lt_ko100 TYPE TABLE OF ko100.
  FIELD-SYMBOLS &lt;fs_ko100&gt; TYPE ko100.

  CALL FUNCTION &apos;TR_OBJECT_TABLE&apos;
    TABLES
      wt_object_text = lt_ko100.

* there are nearly thousands kinds of object type and we just fetch those in our change request
  LOOP AT lt_ko100 ASSIGNING &lt;fs_ko100&gt;.
    READ TABLE gt_object_sort_cache WITH TABLE KEY object = &lt;fs_ko100&gt;-object TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      INSERT &lt;fs_ko100&gt; INTO TABLE gt_objtype_desc.
    ENDIF.
  ENDLOOP.
ENDFORM.

* iv_template     - template name(actually the include program object name)
* iv_mapping_file - file name that will be exported to local
FORM init_template USING iv_template     TYPE string
                         iv_mapping_file TYPE string.
  DATA ls_template TYPE s_template.
  ls_template-include_name = iv_template.
  ls_template-mapping_file_name = iv_mapping_file.
  APPEND ls_template TO gt_templates.
ENDFORM.

FORM validate_params.
  DATA ls_e070 TYPE e070.
  IF p_tr IS INITIAL.
    MESSAGE &apos;Hey man, give me a valid change request...&apos; TYPE &apos;E&apos;. &quot;#EC NOTEXT
  ELSE.
    SELECT SINGLE * FROM e070 INTO ls_e070 WHERE trkorr = p_tr.
    IF sy-subrc NE 0.
      MESSAGE &apos;Come on Man! The change request does not exist...&apos; TYPE &apos;E&apos;. &quot;#EC NOTEXT
    ELSEIF ls_e070-trstatus NE &apos;R&apos;.
      MESSAGE &apos;Oh man, this change request is not released yet...&apos; TYPE &apos;E&apos;. &quot;#EC NOTEXT
    ENDIF.
  ENDIF.

  IF p_dir IS INITIAL.
    MESSAGE &apos;I got a eggache cause you do not select a local folder...&apos; TYPE &apos;E&apos;. &quot;#EC NOTEXT
  ENDIF.
ENDFORM.

FORM append_valuerange_json USING iv_tabname     TYPE ddobjname
                                  iv_fieldname   TYPE dfies-fieldname
                                  iv_lfield_name TYPE dfies-lfieldname
                         CHANGING ct_json        TYPE STANDARD TABLE.
  DATA: lv_mapping     TYPE string,
        lt_diff_values TYPE ddfixvalues,
        lv_len_v       TYPE i,
        lv_len_t       TYPE i,
        lv_value       TYPE string,
        lv_desc        TYPE string.
  FIELD-SYMBOLS &lt;fs_diff_value&gt;  TYPE ddfixvalue.

  CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
    EXPORTING
      tabname      = iv_tabname
      fieldname    = iv_fieldname
      lfieldname   = iv_lfield_name
    TABLES
      fixed_values = lt_diff_values.

  LOOP AT lt_diff_values ASSIGNING &lt;fs_diff_value&gt;.
    lv_value = lv_desc = &apos;&apos;.

    lv_len_v = strlen( &lt;fs_diff_value&gt;-low ).
    lv_len_t = strlen( &lt;fs_diff_value&gt;-ddtext ).

    IF lv_len_v GT 0.
      lv_value = &lt;fs_diff_value&gt;-low(lv_len_v).
    ENDIF.

    IF lv_len_t GT 0.
      lv_desc = &lt;fs_diff_value&gt;-ddtext(lv_len_t).
    ENDIF.

    CONCATENATE lv_mapping &apos;,&quot;&apos; lv_value &apos;&quot; : &quot;&apos; lv_desc &apos;&quot;&apos; INTO lv_mapping RESPECTING BLANKS. &quot;#EC NOTEXT
  ENDLOOP.
  SHIFT lv_mapping.

  CONCATENATE &apos;var &apos; iv_fieldname &apos; = {&apos; lv_mapping &apos;};&apos; INTO lv_mapping RESPECTING BLANKS. &quot;#EC NOTEXT
  APPEND lv_mapping TO ct_json.
ENDFORM.

FORM prepare_domvalue_json CHANGING ct_json TYPE STANDARD TABLE.
  PERFORM append_valuerange_json USING &apos;DD02L&apos; &apos;TABCLASS&apos; &apos;TABCLASS&apos;   CHANGING ct_json.
  PERFORM append_valuerange_json USING &apos;DD02L&apos; &apos;MAINFLAG&apos; &apos;MAINFLAG&apos;   CHANGING ct_json.
  PERFORM append_valuerange_json USING &apos;DD25L&apos; &apos;VIEWCLASS&apos; &apos;VIEWCLASS&apos; CHANGING ct_json.
  PERFORM append_valuerange_json USING &apos;DD25L&apos; &apos;VIEWGRANT&apos; &apos;VIEWGRANT&apos; CHANGING ct_json.
  PERFORM append_valuerange_json USING &apos;DD09L&apos; &apos;BUFALLOW&apos; &apos;BUFALLOW&apos;   CHANGING ct_json.
ENDFORM.

* TODO: refactor via dynamic coding, get json via internal table and the TWO given fields
FORM prepare_objtype_json CHANGING cv_json TYPE string.
  DATA: lv_mapping     TYPE string,
        lv_len         TYPE i.
  FIELD-SYMBOLS &lt;fs_objtype_txt&gt; TYPE ko100.

  CLEAR cv_json.
  LOOP AT gt_objtype_desc ASSIGNING &lt;fs_objtype_txt&gt;.
    lv_len = strlen( &lt;fs_objtype_txt&gt;-text ).
    CONCATENATE lv_mapping &apos;,&quot;&apos; &lt;fs_objtype_txt&gt;-object &apos;&quot; : &quot;&apos; &lt;fs_objtype_txt&gt;-text(lv_len) &apos;&quot;&apos; INTO lv_mapping RESPECTING BLANKS. &quot;#EC NOTEXT
  ENDLOOP.
  SHIFT lv_mapping.
  CONCATENATE &apos;{&apos; lv_mapping &apos;}&apos; INTO lv_mapping.           &quot;#EC NOTEXT
  cv_json = lv_mapping.
ENDFORM.

* prepare json data from abap repository objects
* TODO: support action type of delta modification or deletion
* TODO: not supported object type will be added to list and shown in final message
FORM prepare_jsondata USING iv_cr TYPE e070-trkorr.
  DATA: lt_tadir_key TYPE TABLE OF s_tadir_key_with_sn,
        lv_method    TYPE c LENGTH 11,
        ls_json      TYPE zgs_0004.

  FIELD-SYMBOLS: &lt;fs_tadir_key&gt;   TYPE s_tadir_key_with_sn,
                 &lt;fs_object_sort&gt; TYPE s_object_sort_no.

  SELECT pgmid object obj_name FROM e071              ##too_many_itab_fields
    INTO CORRESPONDING FIELDS OF TABLE lt_tadir_key
    FOR ALL ENTRIES IN gt_object_sort_cache
    WHERE trkorr = iv_cr AND objfunc NE &apos;D&apos; AND
          object = gt_object_sort_cache-object.

  LOOP AT lt_tadir_key ASSIGNING &lt;fs_tadir_key&gt;.
    READ TABLE gt_object_sort_cache WITH TABLE KEY object = &lt;fs_tadir_key&gt;-object ASSIGNING &lt;fs_object_sort&gt;.
    &lt;fs_tadir_key&gt;-sort_no = &lt;fs_object_sort&gt;-sort_no.
  ENDLOOP.

  SORT lt_tadir_key BY sort_no obj_name.

  LOOP AT lt_tadir_key ASSIGNING &lt;fs_tadir_key&gt;.
    &quot; convention over configuration/case/when/if/else: subroutine name should be &apos;HANDLE_{object}&apos;
    CONCATENATE &apos;HANDLE_&apos; &lt;fs_tadir_key&gt;-object INTO lv_method. &quot;#EC NOTEXT
    PERFORM (lv_method) IN PROGRAM (sy-repid) USING &lt;fs_tadir_key&gt; IF FOUND. &quot;#EC NOTEXT
    CLEAR lv_method.

    AT END OF object.
      ls_json-id = &lt;fs_tadir_key&gt;-object.
      PERFORM get_json USING &lt;fs_tadir_key&gt;-object CHANGING ls_json-tx.
      APPEND ls_json TO gt_json_result.

      CLEAR ls_json.
    ENDAT.
  ENDLOOP.
ENDFORM.

* get json from objects
FORM get_json USING iv_object TYPE trobjtype CHANGING cv_json_str TYPE string.
  FIELD-SYMBOLS: &lt;fs_tab&gt; TYPE STANDARD TABLE.
  CASE iv_object.
    WHEN &apos;DEVC&apos;. ASSIGN gt_packages TO &lt;fs_tab&gt;.
    WHEN &apos;FUGR&apos;. ASSIGN gt_func_groups TO &lt;fs_tab&gt;.
    WHEN &apos;DOMA&apos;. ASSIGN gt_domain TO &lt;fs_tab&gt;.
    WHEN &apos;DTEL&apos;. ASSIGN gt_data_element TO &lt;fs_tab&gt;.
    WHEN &apos;TABL&apos;. ASSIGN gt_table TO &lt;fs_tab&gt;.
    WHEN &apos;VIEW&apos;. ASSIGN gt_view TO &lt;fs_tab&gt;.
    WHEN &apos;VCLS&apos;. ASSIGN gt_view_cluster TO &lt;fs_tab&gt;.
    WHEN &apos;TOBJ&apos;. ASSIGN gt_maintenace_view TO &lt;fs_tab&gt;.
    WHEN &apos;SHLP&apos;. ASSIGN gt_search_help TO &lt;fs_tab&gt;.
    WHEN &apos;ENQU&apos;. ASSIGN gt_locks TO &lt;fs_tab&gt;.
    WHEN &apos;TTYP&apos;. ASSIGN gt_table_types TO &lt;fs_tab&gt;.
    WHEN &apos;NROB&apos;.
      ASSIGN gt_number_range TO &lt;fs_tab&gt;.
      &quot; MSAD/MSAG are nearly same in behavior yet differs in object
    WHEN &apos;MSAD&apos;. ASSIGN gt_msad TO &lt;fs_tab&gt;.
    WHEN &apos;MSAG&apos;.
      ASSIGN gt_msag TO &lt;fs_tab&gt;.
      &quot; TODO: CDAT/VDAT/TABU are nearly same in behavior yet differs in object
    WHEN &apos;CDAT&apos;. ASSIGN gt_table_contents TO &lt;fs_tab&gt;.
    WHEN &apos;VDAT&apos;. ASSIGN gt_table_contents TO &lt;fs_tab&gt;.
    WHEN &apos;TABU&apos;. ASSIGN gt_table_contents TO &lt;fs_tab&gt;.
    WHEN &apos;TRAN&apos;. ASSIGN gt_transaction TO &lt;fs_tab&gt;.
  ENDCASE.

  IF &lt;fs_tab&gt; IS ASSIGNED.
    CALL FUNCTION &apos;Z_JSON_OUT&apos;
      IMPORTING
        json = cv_json_str
      TABLES
        itab = &lt;fs_tab&gt;.

    UNASSIGN &lt;fs_tab&gt;.
  ELSE.
    MESSAGE &apos;Eggache: no content was assigned to be converted to json data&apos; TYPE &apos;E&apos;. &quot;#EC NOTEXT
  ENDIF.
ENDFORM.

* show error msg if return code is not 0, for those basic and important objects
FORM handle_rc.
  DATA: lv_msg TYPE string,
        lv_rc  TYPE sy-subrc.
  IF sy-subrc &lt;&gt; 0.
    IF sy-msgid IS NOT INITIAL AND sy-msgty IS NOT INITIAL AND sy-msgno IS NOT INITIAL.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
    ELSE.
      lv_msg = &apos;Hey man, we got a unexpected eggache here...&apos;. &quot;#EC NOTEXT
    ENDIF.
    APPEND lv_msg TO gt_error_log.

    sy-subrc = lv_rc.
  ENDIF.
ENDFORM.

FORM get_devclass USING iv_tadir_key TYPE s_tadir_key_with_sn CHANGING cv_devclass TYPE devclass.
  SELECT SINGLE devclass FROM tadir INTO cv_devclass
  WHERE pgmid = iv_tadir_key-pgmid AND object = iv_tadir_key-object AND obj_name = iv_tadir_key-obj_name.
ENDFORM.

*********************************Package Start*************************************
FORM handle_devc USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: lv_devclass     TYPE devclass,
        lo_package      TYPE REF TO if_package,
        ls_package_info TYPE zpackage.

  lv_devclass = iv_tadir_key-obj_name.
  cl_package_factory=&gt;load_package(
    EXPORTING
      i_package_name             =     lv_devclass
    IMPORTING
      e_package                  =     lo_package
    EXCEPTIONS
      object_not_existing        = 1
      unexpected_error           = 2
      intern_err                 = 3
      no_access                  = 4
      object_locked_and_modified = 5
      OTHERS                     = 6
      ).
  PERFORM handle_rc.

  MOVE-CORRESPONDING iv_tadir_key TO ls_package_info.
  PERFORM convert_devc USING lo_package CHANGING ls_package_info.
  APPEND ls_package_info TO gt_packages.
ENDFORM.

FORM convert_devc USING io_pack TYPE REF TO if_package CHANGING es_package TYPE zpackage.
  DATA: lt_permission TYPE tpak_permission_to_use_list.

  es_package-devclass = io_pack-&gt;package_name.
  es_package-short_text = io_pack-&gt;short_text.
  es_package-ext_attr-parentcl = io_pack-&gt;super_package_name.
  es_package-ext_attr-dlvunit = io_pack-&gt;software_component.
  es_package-ext_attr-applicat = io_pack-&gt;application_component_abbrev.
  es_package-ext_attr-project_id = io_pack-&gt;project_id.
  es_package-ext_attr-translation_depth_text = io_pack-&gt;translation_depth_text.
  es_package-ext_attr-mainpack =  io_pack-&gt;main_package.
  es_package-ext_attr-korrflag = io_pack-&gt;wbo_korr_flag.
  es_package-ext_attr-pdevclass = io_pack-&gt;transport_layer.

  io_pack-&gt;get_permissions_to_use(
    IMPORTING
      e_permissions    = lt_permission
    EXCEPTIONS
      object_invalid   = 1
      unexpected_error = 2
      OTHERS           = 3
    ).
  PERFORM handle_rc.

  PERFORM convert_permission USING lt_permission CHANGING es_package-ext_attr-use_accesses.
ENDFORM.

FORM convert_permission USING it_permission TYPE tpak_permission_to_use_list CHANGING et_use_access TYPE zt_package_use_access.
  DATA: lo_permission TYPE REF TO if_package_permission_to_use,
        ls_use_access TYPE zpackage_use_access.

  LOOP AT it_permission INTO lo_permission.
    ls_use_access-intf_name = lo_permission-&gt;package_interface_name.
    ls_use_access-devclass = lo_permission-&gt;publisher_package_name.
    ls_use_access-err_sever = lo_permission-&gt;error_severity.

    APPEND ls_use_access TO et_use_access.
  ENDLOOP.
ENDFORM.
*********************************Package   End*************************************

*********************************Function Group Start*************************************
FORM handle_fugr USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_fg TYPE zfunction_group.

  MOVE-CORRESPONDING iv_tadir_key TO ls_fg.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_fg-devclass.
  SELECT SINGLE areat FROM tlibt INTO ls_fg-short_text WHERE spras = sy-langu AND area = ls_fg-obj_name.

  APPEND ls_fg TO gt_func_groups.
ENDFORM.
*********************************Function Group  End*************************************

*********************************Domain Start*************************************
FORM handle_doma USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_dm          TYPE zdomain,
        lv_dm_name     TYPE ddobjname,
        ls_dd01v       TYPE dd01v,
        lt_dd07v       TYPE dd07v_tab,
        ls_value_range TYPE zdomain_value_range.
  FIELD-SYMBOLS: &lt;fs_dd07v&gt; TYPE dd07v.

  MOVE-CORRESPONDING iv_tadir_key TO ls_dm.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_dm-devclass.

  lv_dm_name = ls_dm-obj_name.
  CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
    EXPORTING
      name          = lv_dm_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd01v_wa      = ls_dd01v
    TABLES
      dd07v_tab     = lt_dd07v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc.

  LOOP AT lt_dd07v ASSIGNING &lt;fs_dd07v&gt;.
    MOVE-CORRESPONDING &lt;fs_dd07v&gt; TO ls_value_range.
    APPEND ls_value_range TO ls_dm-value_range.
  ENDLOOP.

  MOVE-CORRESPONDING ls_dd01v TO ls_dm.
  ls_dm-short_text = ls_dd01v-ddtext.
  APPEND ls_dm TO gt_domain.
ENDFORM.
*********************************Domain   End*************************************

*********************************Data Element Start*************************************
* for further more information of data element, refer to FM DDIF_DTEL_GET
FORM handle_dtel USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_de      TYPE zdata_element,
        lv_de_name TYPE ddobjname,
        ls_dd04v   TYPE dd04v,
        ls_tpara   TYPE tpara.

  MOVE-CORRESPONDING iv_tadir_key TO ls_de.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_de-devclass.

  lv_de_name = ls_de-obj_name.
  CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
    EXPORTING
      name          = lv_de_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd04v_wa      = ls_dd04v
      tpara_wa      = ls_tpara
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc.

  MOVE-CORRESPONDING ls_dd04v TO ls_de.
  MOVE-CORRESPONDING ls_dd04v TO ls_de-field_label.
  ls_de-short_text = ls_dd04v-ddtext.
  APPEND ls_de TO gt_data_element.
ENDFORM.
*********************************Data Element   End*************************************

*********************************Table Start*************************************
FORM handle_tabl USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_tabl    TYPE ztable,
        lv_tabname TYPE ddobjname,
        lt_dd03p   TYPE dd03ttyp,
        ls_field   TYPE ztable_field,
        ls_dd02v   TYPE dd02v,
        lt_dd36m   TYPE dd36mttyp.
  FIELD-SYMBOLS: &lt;fs_dd03p&gt; TYPE dd03p.

  MOVE-CORRESPONDING iv_tadir_key TO ls_tabl.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_tabl-devclass.
  lv_tabname = ls_tabl-obj_name.

  CALL FUNCTION &apos;DDIF_TABL_GET&apos;
    EXPORTING
      name          = lv_tabname
      langu         = sy-langu
    IMPORTING
      dd02v_wa      = ls_dd02v                      &quot; table header information
      dd09l_wa      = ls_tabl-tech_setting          &quot; technical setting
    TABLES
      dd03p_tab     = lt_dd03p                      &quot; fields
      dd05m_tab     = ls_tabl-foreign_keys          &quot; foreign key
      dd08v_tab     = ls_tabl-foreign_key_header    &quot; foreign key headers and texts
      dd12v_tab     = ls_tabl-index_header          &quot; indexes with text
      dd17v_tab     = ls_tabl-index_fields          &quot; secondary indexes
      dd35v_tab     = ls_tabl-assignments           &quot; assignment of structure fields and search helps
      dd36m_tab     = lt_dd36m                      &quot; interface structure for field assignments table-search help
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  &quot; dd03p is a little too fat and we will cut the useless fields off
  LOOP AT lt_dd03p ASSIGNING &lt;fs_dd03p&gt;.
    MOVE-CORRESPONDING &lt;fs_dd03p&gt; TO ls_field.
    APPEND ls_field TO ls_tabl-fields.
  ENDLOOP.

  IF sy-subrc NE 0.
    PERFORM add_log USING iv_tadir_key.
    RETURN.
  ENDIF.

* namespace reservation
  SELECT tabname fieldname keylow FROM tresc INTO TABLE ls_tabl-namespace
    WHERE object = ls_tabl-object AND tabname = ls_tabl-obj_name.

  MOVE-CORRESPONDING ls_dd02v TO ls_tabl.
  ls_tabl-short_text = ls_dd02v-ddtext.
  APPEND ls_tabl TO gt_table.
ENDFORM.

FORM conv2html_tabl CHANGING ct_tab TYPE STANDARD TABLE.
  DATA: lt_html TYPE TABLE OF string,
        ls_html TYPE string.

*&lt;p class=MsoListParagraphCxSpMiddle&gt;&lt;b&gt;&lt;span style=&apos;font-size:14.0pt;line-height:115%&apos;&gt;2.3 Table&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
*&lt;p class=MsoListParagraphCxSpMiddle&gt;&lt;b&gt;2.3.1&lt;/b&gt;&lt;b&gt;&lt;span style=&apos;font-size:14.0pt;line-height:115%&apos;&gt; &lt;/span&gt;&lt;/b&gt;Create Table &lt;b&gt;SEPA_STATUS_CUST&lt;/b&gt;&lt;/p&gt;

  ct_tab = lt_html.
ENDFORM.
*********************************Table   End*************************************

*********************************View Start*************************************
FORM handle_view USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_view  TYPE zview,
        lv_view_name TYPE ddobjname,
        ls_dd25v TYPE dd25v.

  MOVE-CORRESPONDING iv_tadir_key TO ls_view.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_view-devclass.

  lv_view_name = ls_view-obj_name.

  CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
    EXPORTING
      name          = lv_view_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v
    TABLES
      dd26v_tab     = ls_view-table_join
      dd27p_tab     = ls_view-fields
      dd28j_tab     = ls_view-join_condition
      dd28v_tab     = ls_view-selection_condition
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc.

  MOVE-CORRESPONDING ls_dd25v TO ls_view.
  ls_view-short_text = ls_dd25v-ddtext.
  APPEND ls_view TO gt_view.
ENDFORM.
*********************************View   End*************************************

*********************************View maintenance Start*************************************
FORM handle_tobj USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_maint TYPE zmaintenance_view,
        ls_tvdir TYPE tvdir,
        lv_len   TYPE i,
        ls_tddat TYPE tddat.

* maintenance view header info
  MOVE-CORRESPONDING iv_tadir_key TO ls_maint.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_maint-devclass.
  lv_len = strlen( ls_maint-obj_name ) - 1.
  SELECT SINGLE * FROM tvdir INTO ls_tvdir WHERE tabname = ls_maint-obj_name(lv_len).
  MOVE-CORRESPONDING ls_tvdir TO ls_maint.
  ls_maint-fg_devclass = ls_tvdir-devclass.
  SELECT SINGLE * FROM tddat INTO ls_tddat WHERE tabname = ls_tvdir-tabname.
  MOVE-CORRESPONDING ls_tddat TO ls_maint.
* events
  SELECT * FROM tvimf INTO CORRESPONDING FIELDS OF TABLE ls_maint-events WHERE tabname = ls_maint-obj_name.
* TODO : variants
  APPEND ls_maint TO gt_maintenace_view.
ENDFORM.
*********************************View maintenance   End*************************************

*********************************View cluster Start*************************************
FORM handle_vcls USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_vcls         TYPE zview_cluster,
        lv_vcls_name    TYPE vcl_name,
        ls_vcldir       TYPE v_vcldir,
        lt_struc        TYPE TABLE OF v_vclstruc,
        lt_strudep_tab  TYPE TABLE OF v_vclstdep,
        lt_vclmf_tab    TYPE TABLE OF v_vclmf,
        ls_event        TYPE zmaintenance_event.

  FIELD-SYMBOLS: &lt;fs_vclmf&gt; TYPE v_vclmf.

  MOVE-CORRESPONDING iv_tadir_key TO ls_vcls.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_vcls-devclass.

  lv_vcls_name = ls_vcls-obj_name.
  CALL FUNCTION &apos;VIEWCLUSTER_GET_DEFINITION&apos;
    EXPORTING
      vclname                = lv_vcls_name
    IMPORTING
      vcldir_entry           = ls_vcldir
    TABLES
      vclstruc_tab           = ls_vcls-object_stru
      vclstrudep_tab         = ls_vcls-field_dep
      vclmf_tab              = lt_vclmf_tab
    EXCEPTIONS
      viewcluster_not_found  = 1
      incomplete_viewcluster = 2
      OTHERS                 = 3.                           &quot;#EC FB_RC
  PERFORM handle_rc.
  CHECK sy-subrc EQ 0.

  ls_vcls-short_text = ls_vcldir-text.
  LOOP AT lt_vclmf_tab ASSIGNING &lt;fs_vclmf&gt;.
    MOVE-CORRESPONDING &lt;fs_vclmf&gt; TO ls_event.
    APPEND ls_event TO ls_vcls-events.
  ENDLOOP.

* TODO : variants
  APPEND ls_vcls TO gt_view_cluster.
ENDFORM.
*********************************View cluster   End*************************************

*********************************Search Help Start*************************************
FORM handle_shlp USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_shlp TYPE zsearch_help,
        lv_shlp_name TYPE ddobjname,
        ls_dd30v TYPE dd30v,
        lt_dd31v TYPE TABLE OF dd31v,
        lt_dd32p TYPE TABLE OF dd32p,
        lt_dd33v TYPE TABLE OF dd33v,
        ls_shlp_param TYPE zsearch_help_param.
  FIELD-SYMBOLS: &lt;fs_dd32p&gt; TYPE dd32p.

  MOVE-CORRESPONDING iv_tadir_key TO ls_shlp.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_shlp-devclass.

  lv_shlp_name = ls_shlp-obj_name.

  CALL FUNCTION &apos;DDIF_SHLP_GET&apos;
    EXPORTING
      name          = lv_shlp_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd30v_wa      = ls_dd30v
    TABLES
      dd31v_tab     = lt_dd31v
      dd32p_tab     = lt_dd32p
      dd33v_tab     = lt_dd33v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc.

  MOVE-CORRESPONDING ls_dd30v TO ls_shlp.
  ls_shlp-short_text = ls_dd30v-ddtext.

  LOOP AT lt_dd32p ASSIGNING &lt;fs_dd32p&gt;.
    MOVE-CORRESPONDING &lt;fs_dd32p&gt; TO ls_shlp_param.
    APPEND ls_shlp_param TO ls_shlp-params.
  ENDLOOP.

  APPEND ls_shlp TO gt_search_help.
ENDFORM.
*********************************Search Help   End*************************************

*********************************Lock Object Start*************************************
FORM handle_enqu USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_lock      TYPE zlock_object,
        ls_dd25v     TYPE dd25v,
        lt_dd26e     TYPE TABLE OF dd26e,
        lt_dd27p     TYPE TABLE OF dd27p,
        lt_ddena     TYPE TABLE OF ddena,
        lv_lock_name TYPE ddobjname.

  MOVE-CORRESPONDING iv_tadir_key TO ls_lock.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_lock-devclass.

  lv_lock_name = ls_lock-obj_name.
  CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
    EXPORTING
      name          = lv_lock_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v &quot;lock object attributes(similar as that of view)
    TABLES
      dd26e_tab     = lt_dd26e &quot;base tables
      dd27p_tab     = lt_dd27p &quot;view fields
      ddena_tab     = lt_ddena &quot;lock argument fields
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc.

  ls_lock-base_tables = lt_dd26e.
  ls_lock-lock_params = lt_ddena.
  ls_lock-short_text = ls_dd25v-ddtext.

  APPEND ls_lock TO gt_locks.
ENDFORM.
*********************************Lock Object   End*************************************

*********************************Table Type Start*************************************
FORM handle_ttyp USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_table_type TYPE ztable_type,
        lv_ttype_name TYPE ddobjname,
        ls_dd40v      TYPE dd40v.

  MOVE-CORRESPONDING iv_tadir_key TO ls_table_type.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_table_type-devclass.

  lv_ttype_name = ls_table_type-obj_name.
  CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
    EXPORTING
      name          = lv_ttype_name
      langu         = sy-langu
    IMPORTING
      dd40v_wa      = ls_dd40v
    TABLES
      dd42v_tab     = ls_table_type-primary_key
      dd43v_tab     = ls_table_type-secondary_key
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc.

  MOVE-CORRESPONDING ls_dd40v TO ls_table_type.
  ls_table_type-short_text = ls_dd40v-ddtext.
  APPEND ls_table_type TO gt_table_types.
ENDFORM.
*********************************Table Type   End*************************************

*********************************Number Range Objects Start*************************************
FORM handle_nrob USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_nrob   TYPE znumber_range,
        lv_object TYPE tnro-object,
        ls_tnro   TYPE tnro,
        ls_tnrot  TYPE tnrot.

  MOVE-CORRESPONDING iv_tadir_key TO ls_nrob.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_nrob-devclass.

  lv_object = ls_nrob-obj_name.
  CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_READ&apos;
    EXPORTING
      object            = lv_object
    IMPORTING
      object_attributes = ls_tnro
      object_text       = ls_tnrot
    EXCEPTIONS
      object_not_found  = 1
      OTHERS            = 2.
  PERFORM handle_rc.

  MOVE-CORRESPONDING ls_tnro TO ls_nrob.
  MOVE-CORRESPONDING ls_tnrot TO ls_nrob.
  ls_nrob-short_text = ls_tnrot-txtshort.
  ls_nrob-object = iv_tadir_key-object.

  APPEND ls_nrob TO gt_number_range.
ENDFORM.
*********************************Number Range Objects   End*************************************

*********************************Message Class Start*************************************
FORM handle_msad USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_msg TYPE zmessage.
  PERFORM get_msg_attr USING iv_tadir_key CHANGING ls_msg.
  APPEND ls_msg TO gt_msad.
ENDFORM.

FORM get_msg_attr USING iv_tadir_key TYPE s_tadir_key_with_sn CHANGING cs_msg TYPE zmessage.
  DATA: ls_msg TYPE zmessage,
        lt_txt TYPE zt_message_txt.

  MOVE-CORRESPONDING iv_tadir_key TO ls_msg.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_msg-devclass.
  SELECT SINGLE stext FROM t100t INTO ls_msg-short_text
    WHERE sprsl = sy-langu AND arbgb = ls_msg-obj_name.
* TODO: delta change records: not all message texts but only thoese we added or modified
  SELECT msgnr text FROM t100 INTO TABLE lt_txt
    WHERE sprsl = sy-langu AND arbgb = iv_tadir_key-obj_name.
  ls_msg-message_texts = lt_txt.

  cs_msg = ls_msg.
ENDFORM.

FORM handle_msag USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_msg TYPE zmessage.
  PERFORM get_msg_attr USING iv_tadir_key CHANGING ls_msg.
  APPEND ls_msg TO gt_msag.
ENDFORM.
*********************************Message Class   End*************************************

*********************************View maintenance/view cluster Data Start*************************************
FORM handle_vdat USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  PERFORM handle_tabu USING iv_tadir_key.
ENDFORM.

FORM handle_cdat USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  PERFORM handle_tabu USING iv_tadir_key.
ENDFORM.
*********************************View maintenance/view cluster Data   End*************************************

*********************************Table Contents Start*************************************
FORM handle_tabu USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_tabu TYPE ztable_contents.

  MOVE-CORRESPONDING iv_tadir_key TO ls_tabu.
* CDAT/VDATA/TABU are all stored in e071k as OBJECT = &apos;TABU&apos;, only master type and name differs
  SELECT e~tabkey FROM e071k AS e INTO TABLE ls_tabu-entries
    WHERE e~trkorr = p_tr AND e~pgmid = ls_tabu-pgmid AND e~object = &apos;TABU&apos; AND
          e~mastertype = ls_tabu-object AND e~mastername = ls_tabu-obj_name
    ORDER BY e~as4pos ASCENDING.

  APPEND ls_tabu TO gt_table_contents.
ENDFORM.
*********************************Table Contents   End*************************************

*********************************Transaction Start*************************************
FORM handle_tran USING iv_tadir_key TYPE s_tadir_key_with_sn. &quot;#EC CALLED
  DATA: ls_tran TYPE ztransaction.

  MOVE-CORRESPONDING iv_tadir_key TO ls_tran.
  PERFORM get_devclass USING iv_tadir_key CHANGING ls_tran-devclass.
  SELECT SINGLE * FROM tstcv INTO ls_tran-basic_info WHERE tcode = ls_tran-obj_name AND sprsl = sy-langu.
  SELECT SINGLE * FROM tstcc INTO ls_tran-ext_info WHERE tcode = ls_tran-obj_name.
  SELECT SINGLE param FROM tstcp INTO ls_tran-param WHERE tcode = ls_tran-obj_name.
  SELECT * FROM tstca INTO CORRESPONDING FIELDS OF TABLE ls_tran-authority WHERE tcode = ls_tran-obj_name.
  SELECT SINGLE * FROM tstcclass INTO ls_tran-uiclass WHERE tcode = ls_tran-obj_name.
  ls_tran-short_text = ls_tran-basic_info-ttext.

  APPEND ls_tran TO gt_transaction.
ENDFORM.
*********************************Transaction   End*************************************

* download replaced html file and util javascript to client folder
FORM export_jsondata.
  DATA: lt_data_js     TYPE TABLE OF string,
        lv_data        TYPE string,
        lv_js_filename TYPE string.
  CALL FUNCTION &apos;Z_JSON_COMPIL_JSONS&apos;
    IMPORTING
      json  = lv_data
    TABLES
      jsons = gt_json_result.
  CONCATENATE &apos;var dataSource = &apos; lv_data &apos;;&apos; INTO lv_data RESPECTING BLANKS. &quot;#EC NOTEXT
  APPEND lv_data TO lt_data_js.

  CLEAR lv_data.
  PERFORM prepare_objtype_json CHANGING lv_data.
  CONCATENATE &apos;var OBJTYPE_MAP = &apos; lv_data &apos;;&apos; INTO lv_data RESPECTING BLANKS. &quot;#EC NOTEXT
  APPEND lv_data TO lt_data_js.

  PERFORM prepare_domvalue_json CHANGING lt_data_js.

  CONCATENATE p_dir &apos;\&apos; cv_datasrc_js_name INTO lv_js_filename.
  PERFORM download_file USING lv_js_filename lt_data_js.
ENDFORM.

FORM export_templates.
  DATA: lt_content TYPE TABLE OF string,
        lv_filename TYPE string.
  FIELD-SYMBOLS: &lt;fs_template&gt; TYPE s_template.

  LOOP AT gt_templates ASSIGNING &lt;fs_template&gt;.
    READ REPORT &lt;fs_template&gt;-include_name INTO lt_content.
    CONCATENATE p_dir &apos;\&apos; &lt;fs_template&gt;-mapping_file_name INTO lv_filename. &quot;#EC NOTEXT
    PERFORM download_file USING lv_filename lt_content.

    CLEAR: lt_content, lv_filename.
  ENDLOOP.
ENDFORM.

FORM download_file USING iv_filename TYPE string it_tab TYPE STANDARD TABLE.
  cl_gui_frontend_services=&gt;gui_download(
    EXPORTING
      filename                  =     iv_filename
      confirm_overwrite         =     abap_false
    CHANGING
      data_tab                  =     it_tab
    EXCEPTIONS
      file_write_error          = 1
      no_batch                  = 2
      gui_refuse_filetransfer   = 3
      invalid_type              = 4
      no_authority              = 5
      unknown_error             = 6
      header_not_allowed        = 7
      separator_not_allowed     = 8
      filesize_not_allowed      = 9
      header_too_long           = 10
      dp_error_create           = 11
      dp_error_send             = 12
      dp_error_write            = 13
      unknown_dp_error          = 14
      access_denied             = 15
      dp_out_of_memory          = 16
      disk_full                 = 17
      dp_timeout                = 18
      file_not_found            = 19
      dataprovider_exception    = 20
      control_flush_error       = 21
      not_supported_by_gui      = 22
      error_no_gui              = 23
      OTHERS                     = 24
    ).
  PERFORM handle_rc.
ENDFORM.

FORM select_download_dir CHANGING cv_dir TYPE string.
  cl_gui_frontend_services=&gt;directory_browse(
    EXPORTING
      window_title         =     &apos;Select a folder or you will get a eggache...&apos; &quot;#EC NOTEXT
    CHANGING
      selected_folder      =     cv_dir
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4
    ).
  PERFORM handle_rc.
ENDFORM.

FORM add_log USING iv_tadir_key TYPE s_tadir_key_with_sn.
  DATA: lv_string TYPE string,
        ls_ko100  TYPE ko100,
        lv_len    TYPE i.

  READ TABLE gt_objtype_desc WITH TABLE KEY object = iv_tadir_key-object INTO ls_ko100.
  lv_len = strlen( ls_ko100-text ).
  CONCATENATE ls_ko100-text(lv_len) &apos; &apos; iv_tadir_key-obj_name &apos; failed to retrieve information.&apos; INTO lv_string RESPECTING BLANKS. &quot;#EC NOTEXT
  APPEND lv_string TO gt_error_log.
ENDFORM.

FORM download_cr_bin USING iv_tr TYPE e070-trkorr.
  DATA: gv_trans_dir  TYPE trtppvalue,
        server_file_k TYPE rlgrap-filename,
        server_file_r TYPE rlgrap-filename,
        local_file_k  TYPE string,
        local_file_r  TYPE string,
        lv_tr_no      TYPE e070-trkorr,
        lv_slah       TYPE c.

  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos; FIELD &apos;DIR_TRANS&apos; ID &apos;VALUE&apos; FIELD gv_trans_dir.
  lv_slah = gv_trans_dir(1).

  lv_tr_no = iv_tr.
  SHIFT lv_tr_no BY 4 PLACES LEFT.

* SI3K017810-&gt; K017810.SI3 &amp; R017810.SI3
  CONCATENATE gv_trans_dir lv_slah &apos;cofiles&apos; lv_slah  &apos;K&apos; lv_tr_no &apos;.&apos; iv_tr(3) INTO server_file_k. &quot;#EC NOTEXT
  CONCATENATE p_dir &apos;\K&apos; lv_tr_no &apos;.&apos; iv_tr(3) INTO local_file_k. &quot;#EC NOTEXT
  PERFORM download_data USING server_file_k local_file_k.

  CONCATENATE gv_trans_dir lv_slah &apos;data&apos; lv_slah &apos;R&apos; lv_tr_no &apos;.&apos; iv_tr(3) INTO server_file_r. &quot;#EC NOTEXT
  CONCATENATE p_dir &apos;\R&apos; lv_tr_no &apos;.&apos; iv_tr(3) INTO local_file_r. &quot;#EC NOTEXT
  PERFORM download_data USING server_file_r local_file_r.
ENDFORM.

* actually, call function ARCHIVFILE_SERVER_TO_CLIENT will be much simpler and maybe, better...
FORM download_data USING iv_server_file TYPE rlgrap-filename iv_local_file TYPE string.
  TYPES: BEGIN OF t_input,
         content(500) TYPE x,
         END OF t_input.
  DATA: wa_input      TYPE t_input,
        lt_input      TYPE STANDARD TABLE OF t_input.

  OPEN DATASET iv_server_file FOR INPUT IN BINARY MODE.
  IF sy-subrc NE 0.
    MESSAGE &apos;Hey man, I cannot get the transport file for you...&apos; TYPE &apos;E&apos;. &quot;#EC NOTEXT
  ENDIF.

  DO.
    READ DATASET iv_server_file INTO wa_input.
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ENDIF.
    APPEND wa_input TO lt_input.
    CLEAR wa_input.
  ENDDO.
  CLOSE DATASET iv_server_file.
* in case the last line is less than 500, sy-subrc will be 4, yet we need to append this line
  IF wa_input IS NOT INITIAL.
    APPEND wa_input TO lt_input.
  ENDIF.

  PERFORM export USING iv_local_file lt_input &apos;BIN&apos;.
ENDFORM.

FORM export USING iv_local_file TYPE string it_tab TYPE STANDARD TABLE iv_filetype TYPE char10.
  CALL METHOD cl_gui_frontend_services=&gt;gui_download
    EXPORTING
      filetype                = iv_filetype
      filename                = iv_local_file
    CHANGING
      data_tab                = it_tab
    EXCEPTIONS
      file_write_error        = 1
      no_batch                = 2
      gui_refuse_filetransfer = 3
      invalid_type            = 4
      no_authority            = 5
      unknown_error           = 6
      header_not_allowed      = 7
      separator_not_allowed   = 8
      filesize_not_allowed    = 9
      header_too_long         = 10
      dp_error_create         = 11
      dp_error_send           = 12
      dp_error_write          = 13
      unknown_dp_error        = 14
      access_denied           = 15
      dp_out_of_memory        = 16
      disk_full               = 17
      dp_timeout              = 18
      file_not_found          = 19
      dataprovider_exception  = 20
      control_flush_error     = 21
      not_supported_by_gui    = 22
      error_no_gui            = 23
      OTHERS                  = 24.                         &quot;#EC FB_RC

  PERFORM handle_rc.
ENDFORM.

FORM show_result.
  DATA lv_msg TYPE string.

  IF gt_error_log IS NOT INITIAL.
    LOOP AT gt_error_log INTO lv_msg.
      WRITE: / icon_red_light AS ICON, lv_msg.
    ENDLOOP.
    MESSAGE &apos;Job finished with error, please check related objects.&apos; TYPE &apos;S&apos;.
  ELSE.
    MESSAGE &apos;Job finished successfully.&apos; TYPE &apos;S&apos;.
  ENDIF.

ENDFORM.</source>
 </PROG>
 <PROG NAME="ZDOC_TEMPLATE" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Note Documentation Template" LENGTH="27 "/>
   </language>
  </textPool>
  <source>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Note Implementation Documentation&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot; id=&quot;container&quot; style=&quot;display:none;&quot;&gt;
  &lt;div&gt;&lt;p&gt;Notice: Please create objects in the below refer to this documentation and your own system settings(such as transport layer and etc).&lt;/p&gt;&lt;/div&gt;
  &lt;div id=&apos;DEVC&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;FUGR&apos;&gt;
    &lt;table&gt;
      &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
      &lt;tbody id=&apos;FUGR_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;DOMA&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;th&gt;Data Type&lt;/th&gt;&lt;th&gt;No.Characters&lt;/th&gt;&lt;th&gt;Output Length&lt;/th&gt;&lt;th&gt;Decimals&lt;/th&gt;&lt;th&gt;Lower Case&lt;/th&gt;&lt;th&gt;Sign Flag&lt;/th&gt;&lt;th&gt;Value Range/Value Table&lt;/th&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;DOMA_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;DTEL&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;th&gt;Domain&lt;/th&gt;&lt;th&gt;Field Label&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;DTEL_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;TABL&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;VIEW&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;VCLS&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;View Cluster&lt;/th&gt;&lt;th&gt;Header Entry&lt;/th&gt;&lt;th&gt;Object Structure&lt;/th&gt;&lt;th&gt;Field Dependence&lt;/th&gt;&lt;th&gt;Events&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;VCLS_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;TOBJ&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;View&lt;/th&gt;&lt;th&gt;Authorization Group&lt;/th&gt;&lt;th&gt;Function Group&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Maintenance type&lt;/th&gt;&lt;th&gt;Overview screen&lt;/th&gt;&lt;th&gt;Single screen&lt;/th&gt;&lt;th&gt;Events&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;TOBJ_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;SHLP&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short description&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Selection method&lt;/th&gt;&lt;th&gt;Dialog type&lt;/th&gt;&lt;th&gt;Hot key&lt;/th&gt;&lt;th&gt;Search help exit&lt;/th&gt;&lt;th&gt;Parameters&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;SHLP_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;ENQU&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short description&lt;/th&gt;&lt;th&gt;Allow RFC&lt;/th&gt;&lt;th&gt;Tables&lt;/th&gt;&lt;th&gt;Lock Parameter&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;ENQU_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;TTYP&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;th&gt;Line Type&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;TTYP_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;NROB&apos;&gt;
  &lt;/div&gt;
  &lt;div id=&apos;MSAD&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;th&gt;Messages&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;MSAD_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;MSAG&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;th&gt;Messages&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;MSAG_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;VDAT&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;View Name&lt;/th&gt;&lt;th&gt;Function&lt;/th&gt;&lt;th&gt;Entries&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;VDAT_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;CDAT&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;View Cluster Name&lt;/th&gt;&lt;th&gt;Function&lt;/th&gt;&lt;th&gt;Entries&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;CDAT_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;TABU&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Table Name&lt;/th&gt;&lt;th&gt;Function&lt;/th&gt;&lt;th&gt;Entries&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;TABU_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;TRAN&apos;&gt;
    &lt;table&gt;
       &lt;thead&gt;&lt;tr&gt;&lt;th&gt;TCode&lt;/th&gt;&lt;th&gt;Transaction Type&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Text&lt;/th&gt;&lt;th&gt;Classification&lt;/th&gt;&lt;th&gt;Other Attributes&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
       &lt;tbody id=&apos;TRAN_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;link href=&quot;http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;datasrc.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;render.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</source>
 </PROG>
 <PROG NAME="ZDOC_TEMPLATE_V2" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Note Documentation Template" LENGTH="27 "/>
   </language>
  </textPool>
  <source>&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=Content-Type content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;meta name=Generator content=&quot;Microsoft Word 14 (filtered)&quot;&gt;
&lt;style&gt;
&lt;!--
 /* Font Definitions */
 @font-face
  {font-family:宋体;
  panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
  {font-family:宋体;
  panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
  {font-family:Calibri;
  panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
  {font-family:Tahoma;
  panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
  {font-family:&quot;\@宋体&quot;;
  panose-1:2 1 6 0 3 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
  {margin-top:0in;
  margin-right:0in;
  margin-bottom:10.0pt;
  margin-left:0in;
  line-height:115%;
  font-size:11.0pt;
  font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
  {mso-style-link:&quot;批注框文本 Char&quot;;
  margin:0in;
  margin-bottom:.0001pt;
  font-size:8.0pt;
  font-family:&quot;Tahoma&quot;,&quot;sans-serif&quot;;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
  {margin-top:0in;
  margin-right:0in;
  margin-bottom:10.0pt;
  margin-left:.5in;
  line-height:115%;
  font-size:11.0pt;
  font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
  {margin-top:0in;
  margin-right:0in;
  margin-bottom:0in;
  margin-left:.5in;
  margin-bottom:.0001pt;
  line-height:115%;
  font-size:11.0pt;
  font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
  {margin-top:0in;
  margin-right:0in;
  margin-bottom:0in;
  margin-left:.5in;
  margin-bottom:.0001pt;
  line-height:115%;
  font-size:11.0pt;
  font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
  {margin-top:0in;
  margin-right:0in;
  margin-bottom:10.0pt;
  margin-left:.5in;
  line-height:115%;
  font-size:11.0pt;
  font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
span.Char
  {mso-style-name:&quot;批注框文本 Char&quot;;
  mso-style-link:批注框文本;
  font-family:&quot;Tahoma&quot;,&quot;sans-serif&quot;;}
.MsoChpDefault
  {font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}
.MsoPapDefault
  {margin-bottom:10.0pt;
  line-height:115%;}
 /* Page Definitions */
 @page WordSection1
  {size:8.5in 11.0in;
  margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
  {page:WordSection1;}
 /* List Definitions */
 ol
  {margin-bottom:0in;}
ul
  {margin-bottom:0in;}
--&gt;
&lt;/style&gt;
&lt;title&gt;Note Implementation Documentation&lt;/title&gt;
&lt;/head&gt;
&lt;body lang=EN-US&gt;
&lt;div class=WordSection1&gt;
  &lt;p class=MsoNormal&gt;&lt;b&gt;Notice:&lt;/b&gt; Please create objects in the below refer to this documentation and your own system settings(such as transport layer and etc).&lt;/p&gt;
  &lt;div id=&apos;DEVC&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;FUGR&apos;&gt;
    &lt;table&gt;
      &lt;tr&gt;&lt;td&gt;&lt;p&gt;Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Package&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Short Text&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
      &lt;tbody id=&apos;FUGR_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;DOMA&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;DTEL&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;TABL&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;VIEW&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;VCLS&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;TOBJ&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;SHLP&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;ENQU&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;TTYP&apos;&gt;
    &lt;table&gt;
       &lt;tr&gt;&lt;td&gt;&lt;p&gt;Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Package&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Short Text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Line Type&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
       &lt;tbody id=&apos;TTYP_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;NROB&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;MSAD&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;MSAG&apos;&gt;&lt;/div&gt;
  &lt;div id=&apos;VDAT&apos;&gt;
    &lt;table&gt;
       &lt;tr&gt;&lt;td&gt;&lt;p&gt;View Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Function&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Entries&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
       &lt;tbody id=&apos;VDAT_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;CDAT&apos;&gt;
    &lt;table&gt;
       &lt;tr&gt;&lt;td&gt;&lt;p&gt;View Cluster Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Function&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Entries&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
       &lt;tbody id=&apos;CDAT_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;TABU&apos;&gt;
    &lt;table&gt;
       &lt;tr&gt;&lt;td&gt;&lt;p&gt;Table Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Function&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Entries&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
       &lt;tbody id=&apos;TABU_CONTENTS&apos;&gt;&lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
  &lt;div id=&apos;TRAN&apos;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;datasrc.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;render.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</source>
 </PROG>
 <PROG NAME="ZDOC_UTIL_JS" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Document Generation Utils Javascript Code" LENGTH="41 "/>
   </language>
  </textPool>
  <source>/**
 * Global Configuration Constants Definition, Replaced By Backend ABAP Coding
 */
var CONSTANTS = {
  // development mode switch
  DEV_MODE : false,
  // screenshot css style: img-rounded, width 600px
  image_width : 600,
  // object type text mapping
  getObjectTypeLabel : function(objtype) {
    return OBJTYPE_MAP[objtype] || &apos;&lt;font color=red&gt;Object Type To Be Supported&lt;/font&gt;&apos;;
  }
}
// description differs from value range of domain PUFFERUNG, so manually maintain here...
var PUFFERUNG = {
  &quot;&quot; : &quot;&quot;,
  &quot;P&quot; : &quot;Single records buff.&quot;,
  &quot;G&quot; : &quot;Generic Area Buffered&quot;,
  &quot;X&quot; : &quot;Fully Buffered&quot;
}
var FRKART = {
  &quot;&quot; : &quot;Not Specified&quot;,
  &quot;OPT&quot; : &quot;Optional foreign key&quot;,
  &quot;OBL&quot; : &quot;Mandatory foreign key&quot;,
  &quot;ID&quot; : &quot;Identifying foreign key&quot;,
  &quot;TEXT&quot; : &quot;Key fields of a text table&quot;
}
/**
 * Base Repository Object Attributes, abstract class for sub class in the below follow by
 * @param {string} object            object type such as package, ddic, function group and etc...refer to field OBJECT in table TADIR
 * @param {string} obj_name          object name, refer to obj_name in table TADIR
 * @param {string} devclass          package that the object assigned to, refer to DEVCLASS in table TADIR
 * @param {string} short_text        short descrption of the object
 * @param {number} screenshots_cnt   screenshots count number of the object
 */
function BaseObject(object, obj_name, devclass, short_text, screenshots_cnt) {
  this.object = object;
  this.obj_name = obj_name;
  this.devclass = devclass;
  this.short_text = short_text;
  this.screenshots_cnt = screenshots_cnt;
  return this;
}
BaseObject.prototype = {
  fromJson : function(json) {
    this.object = json[&quot;OBJECT&quot;];
    this.obj_name = json[&quot;OBJ_NAME&quot;];
    this.devclass = json[&quot;DEVCLASS&quot;];
    this.short_text = json[&quot;SHORT_TEXT&quot;];
    this.screenshots_cnt = parseInt(json[&quot;SCREENSHOTS_CNT&quot;]) || 0;
    return this;
  },
  renderTitle : function(sort_no, arrayLen) {
    return arrayLen === 1 ? &apos;&apos; : (&apos;&lt;h4&gt;&apos; + sort_no + &apos;) Create &apos; + CONSTANTS.getObjectTypeLabel(this.object) + &apos; &apos; + this.obj_name + &apos;&lt;/h4&gt;&apos;);
  },
  renderAttributes : function() {
    return &apos;&lt;tr&gt;&lt;td&gt;Object Name&lt;/td&gt;&lt;td&gt;&apos; + this.obj_name + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;Package&lt;/td&gt;&lt;td&gt;&apos; + this.devclass + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;Short Text&lt;/td&gt;&lt;td&gt;&apos; + this.short_text + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
  },
  renderAdditionalAttributes : function() {
    return &apos;&apos;;
  },
  renderMisc : function() {
    return &apos;&apos;;
  },
  renderScreenshots : function() {
    var ret = &apos;&apos;;
    for(var i = 1; i &lt;= this.screenshots_cnt; i++ ) {
      // naming convention: {obj_name}_{object}_{serial_no}.jpg
      ret += &quot;&lt;img src=&apos;img/&quot; + this.obj_name + &apos;_&apos; + this.object + &apos;_&apos; + i + &apos;.jpg&apos; + &quot;&apos; /&gt;&lt;br&gt;&quot;;
    }
    return ret;
  },
  render : function(sort_no, arrayLen) {
    if($.isEmptyObject(this)) {
      return;
    }

    $(&apos;#&apos; + this.object).append(this.renderTitle(sort_no, arrayLen) +
                               &quot;&lt;table&gt;&quot; +
                               &quot;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Attribute&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/thead&gt;&quot; +
                               &quot;&lt;tbody&gt;&quot; +
                               this.renderAttributes() +
                               this.renderAdditionalAttributes() +
                               &quot;&lt;/tbody&gt;&quot; +
                               &quot;&lt;/table&gt;&quot; +
                               this.renderMisc() +
                               this.renderScreenshots());
  }
}

function Package(object, obj_name, devclass, short_text, screenshots, ext_info) {
  BaseObject.call(this, arguments);
  this.ext_info = ext_info;
  return this;
}
Package.prototype = new BaseObject();
Package.prototype.constructor = Package;
Package.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.ext_info = json[&quot;EXT_ATTR&quot;];
  return this;
}
Package.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;Application Component&lt;/td&gt;&lt;td&gt;&apos; + this.ext_info[&quot;APPLICAT&quot;]+ &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;Translation Relevance&lt;/td&gt;&lt;td&gt;&apos; + this.ext_info[&quot;TRANSLATION_DEPTH_TEXT&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         (this.ext_info[&quot;PARENTCL&quot;].trim() === &apos;&apos; ? &apos;&apos; : &apos;&lt;tr&gt;&lt;td&gt;Super Package&lt;/td&gt;&lt;td&gt;&apos; + this.ext_info[&quot;PARENTCL&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;)  +
         &quot;&lt;tr&gt;&lt;td&gt;Transport Layer&lt;/td&gt;&lt;td style=&apos;color:red;font-style:italic;&apos;&gt;Please fill in according to your own system landscape settings&lt;/td&gt;&lt;/tr&gt;&quot; +
         &apos;&lt;tr&gt;&lt;td&gt;Software Component&lt;/td&gt;&lt;td&gt;&apos; + this.ext_info[&quot;DLVUNIT&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;Record Object Changes in Transport Requests&lt;/td&gt;&lt;td&gt;&apos; + this.ext_info[&quot;KORRFLAG&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         (this.ext_info[&quot;PROJECT_ID&quot;].trim() === &apos;&apos; ? &apos;&apos; : &apos;&lt;tr&gt;&lt;td&gt;cProjects Project&lt;/td&gt;&lt;td&gt;&apos; + this.ext_info[&quot;PROJECT_ID&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;);
}
Package.prototype.getUseAccesses = function() {
  var ret = &apos;&apos;;
  $.each(this.ext_info[&quot;USE_ACCESSES&quot;], function(i, data) {
    ret += (&apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;INTF_NAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;DEVCLASS&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;ERR_SEVER&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;);
  });
  return ret;
}
Package.prototype.renderMisc = function() {
  return this.ext_info[&quot;USE_ACCESSES&quot;].length == 0 ? &apos;&apos; :
         &quot;&lt;table&gt;&quot; +
         &quot;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Package Interface&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Error Severity&lt;/th&gt;&lt;/thead&gt;&quot; +
         &quot;&lt;tbody&gt;&quot; +
         this.getUseAccesses() +
         &quot;&lt;/tbody&gt;&quot; +
         &quot;&lt;/table&gt;&quot;;
}

function FunctionGroup(object, obj_name, devclass, short_text, screenshots) {
  return BaseObject.call(this, arguments);
}
FunctionGroup.prototype = new BaseObject();
FunctionGroup.prototype.constructor = FunctionGroup;
FunctionGroup.prototype.render = function() {
  $(&apos;#FUGR_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;);
}

function Domain(object, obj_name, devclass, short_text, screenshots, DATATYPE, LENG, OUTPUTLEN, DECIMALS, LOWERCASE, SIGNFLAG, VALEXI, ENTITYTAB, VALUE_RANGE) {
  BaseObject.call(this, arguments);
  this.DATATYPE = DATATYPE;
  this.LENG = LENG;
  this.OUTPUTLEN = OUTPUTLEN;
  this.DECIMALS = DECIMALS;
  this.LOWERCASE = LOWERCASE;
  this.SIGNFLAG = SIGNFLAG;
  this.VALEXI = VALEXI;
  this.ENTITYTAB = ENTITYTAB;
  this.VALUE_RANGE = VALUE_RANGE;
  return this;
}
Domain.prototype = new BaseObject();
Domain.prototype.constructor = Domain;
Domain.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.DATATYPE = json[&quot;DATATYPE&quot;];
  this.LENG = parseInt(json[&quot;LENG&quot;]);
  this.OUTPUTLEN = parseInt(json[&quot;OUTPUTLEN&quot;]);
  this.DECIMALS = parseInt(json[&quot;DECIMALS&quot;]);
  this.LOWERCASE = json[&quot;LOWERCASE&quot;];
  this.SIGNFLAG = json[&quot;SIGNFLAG&quot;];
  this.VALEXI = json[&quot;VALEXI&quot;];
  this.ENTITYTAB = json[&quot;ENTITYTAB&quot;];
  this.VALUE_RANGE = json[&quot;VALUE_RANGE&quot;];
  return this;
}
Domain.prototype.render = function() {
  $(&apos;#DOMA_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&quot; +
    &quot;&lt;td&gt;&quot; + this.DATATYPE + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.LENG + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.OUTPUTLEN + &quot;&lt;/td&gt;&quot; + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.DECIMALS + &quot;&lt;/td&gt;&quot; +
    &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.LOWERCASE + &quot;&lt;/td&gt;&quot; + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.SIGNFLAG + &quot;&lt;/td&gt;&quot; +
    this.renderAdditionalAttributes() +
    &quot;&lt;/tr&gt;&quot;);
}
Domain.prototype.renderAdditionalAttributes = function() {
  var ret = &apos;&lt;td&gt;&apos;;
  if(this.VALEXI === &apos;X&apos;) {
    ret += &apos;&lt;table&gt;&apos;;
    ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Fix.Val.&lt;/th&gt;&lt;th&gt;Short Description&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
    ret += &apos;&lt;tobdy&gt;&apos;;
    $.each(this.VALUE_RANGE, function(i, data) {
      ret += (&apos;&lt;tr&gt;&lt;td&gt;&apos; + data.DOMVALUE_L + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data.DDTEXT + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;);
    })
    ret += &apos;&lt;/tobdy&gt;&apos;;
    ret += &apos;&lt;/table&gt;&apos;;
  } else {
    ret += this.ENTITYTAB;
  }
  ret += &apos;&lt;/td&gt;&apos;;
  return ret;
}

function DataElement(object, obj_name, devclass, short_text, screenshots, domain, field_label) {
  BaseObject.call(this, arguments);
  this.domain = domain;
  this.field_label = field_label;
  return this;
}
DataElement.prototype = new BaseObject();
DataElement.prototype.constructor = DataElement;
DataElement.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.domain = json[&quot;DOMNAME&quot;];
  this.field_label = json[&quot;FIELD_LABEL&quot;];
  return this;
}
DataElement.prototype.render = function() {
  $(&apos;#DTEL_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.domain + &quot;&lt;/td&gt;&quot; + this.renderAdditionalAttributes() + &quot;&lt;/tr&gt;&quot;);
}
DataElement.prototype.renderAdditionalAttributes = function() {
  var ret =  &apos;&lt;td&gt;&apos;;
      ret += &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Length&lt;/th&gt;&lt;th&gt;Field Label&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;Short&lt;/td&gt;&lt;td&gt;&apos; + parseInt(this.field_label[&quot;SCRLEN1&quot;]) + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.field_label[&quot;SCRTEXT_S&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;Medium&lt;/td&gt;&lt;td&gt;&apos; + parseInt(this.field_label[&quot;SCRLEN2&quot;]) + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.field_label[&quot;SCRTEXT_M&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;Long&lt;/td&gt;&lt;td&gt;&apos; + parseInt(this.field_label[&quot;SCRLEN3&quot;]) + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.field_label[&quot;SCRTEXT_L&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;Heading&lt;/td&gt;&lt;td&gt;&apos; + parseInt(this.field_label[&quot;HEADLEN&quot;]) + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.field_label[&quot;REPTEXT&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
      ret += &apos;&lt;/td&gt;&apos;;
  return ret;
}

function TableType(object, obj_name, devclass, short_text, screenshots, rowType, ext_info) {
  BaseObject.call(this, arguments);
  this.rowType = rowType;
  this.ext_info = ext_info;
  return this;
}
TableType.prototype = new BaseObject();
TableType.prototype.constructor = TableType;
TableType.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.rowType = json[&quot;ROWTYPE&quot;];
  this.ext_info = json[&quot;EXT_ATTR&quot;]
  return this;
}
TableType.prototype.render = function() {
  $(&apos;#TTYP_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.rowType + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;);
}

function SearchHelp(object, obj_name, devclass, short_text, screenshots, type, selectionMethod, dialogType, hotKey, exit, parameters) {
  BaseObject.call(this, arguments);
  this.type = type;
  this.selectionMethod = selectionMethod;
  this.dialogType = dialogType;
  this.hotKey = hotKey;
  this.exit = exit;
  this.parameters = parameters;
  return this;
}
SearchHelp.prototype = new BaseObject();
SearchHelp.prototype.constructor = SearchHelp;
SearchHelp.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.type = json[&quot;ISSIMPLE&quot;] === &apos;X&apos; ? &apos;Elementary&apos; : &apos;Collective&apos;;
  this.selectionMethod = json[&quot;SELMETHOD&quot;];
  this.dialogType = json[&quot;DIALOGTYPE&quot;];
  this.hotKey = json[&quot;HOTKEY&quot;];
  this.exit = json[&quot;SELMEXIT&quot;];
  this.parameters = json[&quot;PARAMS&quot;];
  return this;
}
SearchHelp.prototype.render = function() {
  $(&apos;#SHLP_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.type + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.selectionMethod + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.dialogType + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.hotKey +
&quot;&lt;/td&gt;&lt;td&gt;&quot; + this.exit + &quot;&lt;/td&gt;&quot; + this.renderAdditionalAttributes() + &quot;&lt;/tr&gt;&quot;);
}
SearchHelp.prototype.renderAdditionalAttributes = function() {
  var ret =  &apos;&lt;td&gt;&apos;;
      ret += &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Parameter&lt;/th&gt;&lt;th&gt;IMP&lt;/th&gt;&lt;th&gt;EXP&lt;/th&gt;&lt;th&gt;LPos&lt;/th&gt;&lt;th&gt;SPos&lt;/th&gt;&lt;th&gt;SDis&lt;/th&gt;&lt;th&gt;Data element&lt;/th&gt;&lt;th&gt;Modified&lt;/th&gt;&lt;th&gt;Default value&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.parameters, function(i, data) {
        ret += &apos;&lt;tr&gt;&apos;;
        ret += &apos;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;SHLPINPUT&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;SHLPOUTPUT&quot;] + &apos;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&apos; + data[&quot;SHLPSELPOS&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;SHLPLISPOS&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;SHLPSELDIS&quot;] + &apos;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&apos; + data[&quot;ROLLNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;ROLLCHANGE&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;DEFAULTVAL&quot;] + &apos;&lt;/td&gt;&apos;;
        ret += &apos;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
      ret += &apos;&lt;/td&gt;&apos;;
  return ret;
}

function LockObject(object, obj_name, devclass, short_text, screenshots, allowRFC, tables, parameters) {
  BaseObject.call(this, arguments);
  this.allowRFC = allowRFC;
  this.tables = tables;
  this.parameters = parameters;
  return this;
}
LockObject.prototype = new BaseObject();
LockObject.prototype.constructor = LockObject;
LockObject.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.allowRFC = json[&quot;RFCENABLE&quot;];
  this.tables = json[&quot;BASE_TABLES&quot;];
  this.parameters = json[&quot;LOCK_PARAMS&quot;];
  return this;
}
LockObject.prototype.render = function() {
  $(&apos;#ENQU_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.allowRFC + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.getTablesHtml() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.getParametersHtml() + &quot;&lt;/td&gt;&lt;tr&gt;&quot;);
}
LockObject.prototype.getTablesHtml = function() {
  ret = &apos;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Lock Mode&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&apos;;
  $.each(this.tables, function(i, data) {
    ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;TABPOS&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;ENQMODE&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret +=&apos;&lt;/tbody&gt;&lt;/table&gt;&apos;;
  return ret;
}
LockObject.prototype.getParametersHtml = function() {
  ret = &apos;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;W&lt;/th&gt;&lt;th&gt;Lock Parameter&lt;/th&gt;&lt;th&gt;Table&lt;/th&gt;&lt;th&gt;Field&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&apos;;
  $.each(this.tables, function(i, data) {
    ret += &apos;&lt;tr&gt;&lt;td&gt;X&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;VIEWFIELD&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret +=&apos;&lt;/tbody&gt;&lt;/table&gt;&apos;;
  return ret;
}

function Table(object, obj_name, devclass, short_text, screenshots, category, deliveryClass, maintFlag, fields, technicalSetting, nameSpace, foreignKeyHeader, foreignKeyFields, indexHeader, indexFields) {
  BaseObject.call(this, arguments);
  this.category = category;
  this.deliveryClass = deliveryClass;
  this.maintFlag = maintFlag;
  this.fields = fields;
  this.technicalSetting = technicalSetting;
  this.nameSpace = nameSpace;
  this.foreignKeyHeader = foreignKeyHeader;
  this.foreignKeyFields = foreignKeyFields;
  this.indexHeader = indexHeader;
  this.indexFields = indexFields;
  return this;
}
Table.prototype = new BaseObject();
Table.prototype.constructor = Table;
Table.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.category = json[&quot;TABCLASS&quot;];
  this.deliveryClass = json[&quot;CONTFLAG&quot;];
  this.maintFlag = json[&quot;MAINFLAG&quot;];
  this.fields = json[&quot;FIELDS&quot;];
  this.technicalSetting = json[&quot;TECH_SETTING&quot;];
  this.nameSpace = json[&quot;NAMESPACE&quot;];
  this.foreignKeyHeader = json[&quot;FOREIGN_KEY_HEADER&quot;];
  this.foreignKeyFields = json[&quot;FOREIGN_KEYS&quot;];
  this.indexHeader = json[&quot;INDEX_HEADER&quot;];
  this.indexFields = json[&quot;INDEX_FIELDS&quot;];
  return this;
}
Table.prototype.isTransparentTable = function() {
  return this.category === &apos;TRANSP&apos;;
}
Table.prototype.renderTitle = function(sort_no, arrayLen) {
    return arrayLen === 1 ? &apos;&apos; : (&apos;&lt;h4&gt;&apos; + sort_no + &apos;) Create &apos; + TABCLASS[this.category] + &apos; &apos; + this.obj_name + &apos;&lt;/h4&gt;&apos;);
}
Table.prototype.renderAdditionalAttributes = function() {
  return this.isTransparentTable() ?
         (&apos;&lt;tr&gt;&lt;td&gt;Delivery Class&lt;/td&gt;&lt;td&gt;&apos; + this.deliveryClass + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;Data Browser/Table View Maint.&lt;/td&gt;&lt;td&gt;&apos; + MAINFLAG[this.maintFlag] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;) : &apos;&apos;;
}
Table.prototype.renderMisc = function() {
  return this.getFieldsHtml() + this.getTechnicalSettingHtml() + this.getForeignKeysHtml() + this.getIndexSettingHtml();
}
Table.prototype.getStructureComponentsHtml = function() {
  var ret =  &apos;&lt;h5&gt;Components:&lt;/h5&gt;&apos; +
             &apos;&lt;p&gt;Please notice that those components marked as blue and italic are contained in included structure/table and you don\&apos;t need to add them.&lt;/p&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Component&lt;/th&gt;&lt;th&gt;Typing Method&lt;/th&gt;&lt;th&gt;Data Element&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.fields, function(i, data) {
        var fontStyle = parseInt(data[&quot;ADMINFIELD&quot;]) === 1 ? &quot; style=&apos;color:blue;font-style:italic;&apos;&quot; : &quot;&quot;;
        ret += &apos;&lt;tr&apos; + fontStyle + &apos;&gt;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;KEYFLAG&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + (data[&quot;FIELDNAME&quot;] === &apos;.INCLUDE&apos; ? data[&quot;PRECFIELD&quot;] : data[&quot;ROLLNAME&quot;]) + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getFieldsHtml = function() {
  return this.category === &apos;INTTAB&apos; ? this.getStructureComponentsHtml() : this.getTableFieldsHtml();
}
Table.prototype.getTableFieldsHtml = function() {
  var ret =  &apos;&lt;h5&gt;Fields:&lt;/h5&gt;&apos; +
             &apos;&lt;p&gt;Please notice that those fields marked as blue and italic are contained in included structure/table and you don\&apos;t need to add them.&lt;/p&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field name&lt;/th&gt;&lt;th&gt;Key&lt;/th&gt;&lt;th&gt;Data Element&lt;/th&gt;&lt;th&gt;Check Table&lt;/th&gt;&lt;th&gt;Search Help&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.fields, function(i, data) {
        var fontStyle = parseInt(data[&quot;ADMINFIELD&quot;]) === 1 ? &quot; style=&apos;color:blue;font-style:italic;&apos;&quot; : &quot;&quot;;
        ret += &apos;&lt;tr&apos; + fontStyle + &apos;&gt;&apos;;
        ret += &apos;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;KEYFLAG&quot;] + &apos;&lt;/td&gt;&apos;;
        ret += &apos;&lt;td&gt;&apos; + (data[&quot;FIELDNAME&quot;] === &apos;.INCLUDE&apos; ? data[&quot;PRECFIELD&quot;] : data[&quot;ROLLNAME&quot;]) + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;CHECKTABLE&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;SHLPNAME&quot;] + &apos;&lt;/td&gt;&apos;
        ret += &apos;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getTechnicalSettingHtml = function() {
  if(!this.isTransparentTable()) {
    return &apos;&apos;;
  }
  var ret =  &apos;&lt;h5&gt;Technical Settings:&lt;/h5&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Data Class&lt;/th&gt;&lt;th&gt;Size Category&lt;/th&gt;&lt;th&gt;Buffering&lt;/th&gt;&lt;th&gt;Buffering Type&lt;/th&gt;&lt;th&gt;Log Data Changes&lt;/th&gt;&lt;th&gt;Write Access Only with Java&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + this.technicalSetting[&quot;TABART&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.technicalSetting[&quot;TABKAT&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + BUFALLOW[this.technicalSetting[&quot;BUFALLOW&quot;]] + &apos;&lt;/td&gt;&apos; +
             &apos;&lt;td&gt;&apos; + PUFFERUNG[this.technicalSetting[&quot;PUFFERUNG&quot;]] + (this.technicalSetting[&quot;PUFFERUNG&quot;] == &apos;G&apos; ? (&apos;&lt;br&gt;No. of key fields: &apos; + this.technicalSetting[&quot;SCHFELDANZ&quot;]) : &apos;&apos;) + &apos;&lt;/td&gt;&apos; +
             &apos;&lt;td&gt;&apos; + this.technicalSetting[&quot;PROTOKOLL&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.technicalSetting[&quot;JAVAONLY&quot;] + &apos;&lt;/td&gt;&apos; +
             &apos;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getFKDefinitionHtml = function(fieldName) {
  var ret =  &apos;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Check table&lt;/th&gt;&lt;th&gt;ChkTablFld&lt;/th&gt;&lt;th&gt;For.key table&lt;/th&gt;&lt;th&gt;Foreign Key Field&lt;/th&gt;&lt;th&gt;Generic&lt;/th&gt;&lt;th&gt;Constant&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
  $.each(this.foreignKeyFields, function(i, data) {
    if(data[&quot;FIELDNAME&quot;] === fieldName) {
      ret += &apos;&lt;tr&gt;&apos;;
      ret += &apos;&lt;td&gt;&apos; + data[&quot;CHECKTABLE&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;CHECKFIELD&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + (data[&quot;FORKEY&quot;] != &apos;&apos; ? data[&quot;FORTABLE&quot;] : &apos;&apos;) + &apos;&lt;/td&gt;&apos; +
             &apos;&lt;td&gt;&apos; + data[&quot;FORKEY&quot;] + &apos;&lt;/td&gt;&apos; +
             //when FORKEY is blank, there might be generic or constant setting, * means generic while constant value is FORTABLE
             &apos;&lt;td&gt;&apos; + (data[&quot;FORTABLE&quot;] === &apos;*&apos; ? &apos;X&apos; : &apos;&apos;) + &apos;&lt;/td&gt;&lt;td&gt;&apos; + (data[&quot;FORKEY&quot;] === &apos;&apos; &amp;&amp; data[&quot;FORTABLE&quot;] != &apos;*&apos; ? data[&quot;FORTABLE&quot;] : &apos;&apos;) + &apos;&lt;/td&gt;&apos;;
      ret += &apos;&lt;/tr&gt;&apos;;
    }
  })
  ret += &apos;&lt;/tbody&gt;&apos;;
  ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getForeignKeysHtml = function() {
  if(!this.isTransparentTable() ||
     !this.foreignKeyHeader || this.foreignKeyHeader.length === 0 ||
     !this.foreignKeyFields || this.foreignKeyFields.length === 0) {
    return &apos;&apos;;
  }
  var me = this;
  var ret =  &apos;&lt;h5&gt;Foreign Keys:&lt;/h5&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field Name&lt;/th&gt;&lt;th&gt;Check Table&lt;/th&gt;&lt;th&gt;Foreign Key Fields&lt;/th&gt;&lt;th&gt;Screen check&lt;/th&gt;&lt;th&gt;Semantic attributes&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.foreignKeyHeader, function(i, data) {
        ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;CHECKTABLE&quot;] + &apos;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&apos; + me.getFKDefinitionHtml(data[&quot;FIELDNAME&quot;]) + &apos;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;Check required: &apos; + data[&quot;CHECKFLAG&quot;] + &apos;&lt;br&gt;MsgNo: &apos; + data[&quot;MSGNR&quot;] + &apos;&lt;br&gt;AArea:&apos; + data[&quot;ARBGB&quot;] + &apos;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;Foreign key field type: &apos; + FRKART[data[&quot;FRKART&quot;]] + &apos;&lt;br&gt;Cardinality:[&apos; + data[&quot;CARDLEFT&quot;] + &apos; : &apos; + data[&quot;CARD&quot;] + &apos;]&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;DDTEXT&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getIndexSettingHtml = function() {
  if(!this.isTransparentTable() || this.indexHeader.length === 0 || this.indexFields.length === 0) {
    return &apos;&apos;;
  }
  var me = this;
  var ret =  &apos;&lt;h5&gt;Indexes:&lt;/h5&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Index Name&lt;/th&gt;&lt;th&gt;Ext.Index&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;th&gt;Unique&lt;/th&gt;&lt;th&gt;DB index name&lt;/th&gt;&lt;th&gt;DB status&lt;/th&gt;&lt;th&gt;Inclusion/Exclusion&lt;/th&gt;&lt;th&gt;Index Flds&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.indexHeader, function(i ,data) {
        ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;INDEXNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;ISEXTIND&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;DDTEXT&quot;] + &apos;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&apos; + data[&quot;UNIQUEFLAG&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;DBINDEX&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;DBSTATE&quot;] + &apos;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&apos; + data[&quot;DBINCLEXCL&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + me.getIndexFieldHtml(data[&quot;INDEXNAME&quot;]) + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getIndexFieldHtml = function(indexName) {
  var ret = &apos;&apos;, i = 0;
  $.each(this.indexFields, function(i, data) {
    if(data[&quot;INDEXNAME&quot;] === indexName) {
      i += 1;
      ret += (i == 1 ? &apos;&apos; : &apos;&lt;br&gt;&apos;) + data[&quot;FIELDNAME&quot;];
    }
  })
  return ret;
}
Table.prototype.getNamespaceHtml = function() {
  // only transparent table with delivery class E need to display namespace maintainance settings
  if(!this.isTransparentTable() || this.deliveryClass != &apos;E&apos; || this.nameSpace.length === 0) {
    return &apos;&apos;;
  }
  var ret =  &apos;&lt;h5&gt;Maintain Customer Namespace:&lt;/h5&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Key Field&lt;/th&gt;&lt;th&gt;Namespace&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.nameSpace, function(i ,data) {
        ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;KEYLOW&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      });
      ret += &apos;&lt;/tbody&gt;&apos;
      ret += &apos;&lt;/table&gt;&apos;
  return ret;
}

function View(object, obj_name, devclass, short_text, screenshots, category, deliveryClass, maintStatus, maintFlag, tableJoin, fields, joinCondition, selectionCondition) {
  BaseObject.call(this, arguments);
  this.category = category;
  this.deliveryClass = deliveryClass;
  this.maintStatus = maintStatus;
  this.maintFlag = maintFlag;
  this.tableJoin = tableJoin;
  this.fields = fields;
  this.joinCondition = joinCondition;
  this.selectionCondition = selectionCondition;
  return this;
}
View.prototype = new BaseObject();
View.prototype.constructor = View;
View.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.category = json[&quot;VIEWCLASS&quot;];
  this.deliveryClass = json[&quot;CUSTOMAUTH&quot;];
  this.maintStatus = json[&quot;VIEWGRANT&quot;];
  this.maintFlag = json[&quot;GLOBALFLAG&quot;];
  this.tableJoin = json[&quot;TABLE_JOIN&quot;];
  this.fields = json[&quot;FIELDS&quot;];
  this.joinCondition = json[&quot;JOIN_CONDITION&quot;];
  this.selectionCondition = json[&quot;SELECTION_CONDITION&quot;];
  return this;
}
View.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;Access&lt;/td&gt;&lt;td&gt;&apos; + VIEWGRANT[this.maintStatus] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;Delivery Class&lt;/td&gt;&lt;td&gt;&apos; + this.deliveryClass + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;Data Browser/Table View Maint.&lt;/td&gt;&lt;td&gt;&apos; + MAINFLAG[this.maintFlag] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
}
View.prototype.renderTitle = function(sort_no, arrayLen) {
    return arrayLen === 1 ? &apos;&apos; : (&apos;&lt;h4&gt;&apos; + sort_no + &apos;) Create &apos; + VIEWCLASS[this.category] + &apos; &apos; + this.obj_name + &apos;&lt;/h4&gt;&apos;);
}
View.prototype.renderMisc = function() {
  return this.getTableJoin() + this.getFieldsHtml() + this.getSelectionConditionHtml();
}
View.prototype.getTableJoin = function() {
  var ret =  &apos;&lt;h5&gt;Table/Join Conditions:&lt;/h5&gt;&apos; +
             &apos;&lt;p&gt;&lt;b&gt;Tables:&lt;/b&gt;&lt;/p&gt;&apos;;
      ret += &apos;&lt;p&gt;&apos;;
      $.each(this.tableJoin, function(i, data) {
        ret += (i == 0 ? &apos;&apos; : &apos;&lt;br&gt;&apos;) + data[&quot;TABNAME&quot;];
      });
      ret += &apos;&lt;/p&gt;&apos;;
      ret += &apos;&lt;p&gt;&lt;b&gt;Join Conditions:&lt;/b&gt;&lt;/p&gt;&apos;;
      if(this.joinCondition &amp;&amp; this.joinCondition.length &gt; 0) {
        ret += &apos;&lt;table&gt;&apos;;
        ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Table&lt;/th&gt;&lt;th&gt;Field Name&lt;/th&gt;&lt;th&gt;=&lt;/th&gt;&lt;th&gt;Table&lt;/th&gt;&lt;th&gt;Field Name&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
        ret += &apos;&lt;tbody&gt;&apos;;
        $.each(this.joinCondition, function(i ,data) {
          if(data[&quot;RFIELD&quot;] === &apos;&apos;)
            return;

          ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;LTAB&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;LFIELD&quot;] + &apos;&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;RTAB&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;RFIELD&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
        });
        ret += &apos;&lt;/tbody&gt;&apos;;
        ret += &apos;&lt;/table&gt;&apos;;
      }
      else {
        ret += &apos;&lt;p&gt;&lt;i&gt;No additional join condition needs to be maintained here.&lt;/i&gt;&lt;/p&gt;&apos;;
      }
  return ret;
}
View.prototype.getFieldsHtml = function() {
  var ret =  &apos;&lt;h5&gt;View Flds:&lt;/h5&gt;&apos;;
      ret += &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;View Field&lt;/th&gt;&lt;th&gt;Table&lt;/th&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;P&lt;/th&gt;&lt;th&gt;Key&lt;/th&gt;&lt;th&gt;Mod&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.fields, function(i ,data) {
        ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;VIEWFIELD&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;RDONLY&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;KEYFLAG&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;ROLLCHANGE&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
      });
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
View.prototype.getSelectionConditionHtml = function() {
  var ret =  &apos;&lt;h5&gt;Selection conditions:&lt;/h5&gt;&apos;;
  if(this.selectionCondition &amp;&amp; this.selectionCondition.length &gt; 0) {
    ret += &apos;&lt;table&gt;&apos;;
    ret += &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Table&lt;/th&gt;&lt;th&gt;Field name&lt;/th&gt;&lt;th&gt;Operator&lt;/th&gt;&lt;th&gt;Comparison value&lt;/th&gt;&lt;th&gt;AND/OR&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos;;
    ret += &apos;&lt;tbody&gt;&apos;;
    $.each(this.selectionCondition, function(i ,data) {
      ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;OPERATOR&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;CONSTANTS&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;AND_OR&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
    });
    ret += &apos;&lt;/tbody&gt;&apos;;
    ret += &apos;&lt;/table&gt;&apos;;
  }
  else {
    ret += &apos;&lt;p&gt;&lt;i&gt;No additional selection condition needs to be maintained here.&lt;i&gt;&lt;/p&gt;&apos;;
  }
  return ret;
}

function ViewMaintenance(object, obj_name, devclass, short_text, screenshots, view, authGroup, funcGroup, package, maintenanceType, overviewScreen, singleScreen, events) {
  BaseObject.call(this, arguments);
  this.view = view;
  this.authGroup = authGroup;
  this.funcGroup = funcGroup;
  this.package = package;
  this.maintenanceType = maintenanceType;
  this.overviewScreen = overviewScreen;
  this.singleScreen = singleScreen;
  this.events = events;
  return this;
}
ViewMaintenance.prototype = new BaseObject();
ViewMaintenance.prototype.constructor = ViewMaintenance;
ViewMaintenance.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.view = json[&quot;TABNAME&quot;];
  this.authGroup = json[&quot;CCLASS&quot;];
  this.funcGroup = json[&quot;AREA&quot;];
  this.package = json[&quot;FG_DEVCLASS&quot;];
  this.maintenanceType = json[&quot;TYPE&quot;] === &apos;1&apos; ? &apos;one step&apos; : &apos;two step&apos;;
  this.overviewScreen = json[&quot;LISTE&quot;];
  this.singleScreen = json[&quot;DETAIL&quot;];
  this.events = json[&quot;EVENTS&quot;];
  return this;
}
ViewMaintenance.prototype.getEventsHtml = function() {
  var ret =  &apos;&lt;td&gt;&apos;;
      $.each(this.events, function(i, data) {
        ret += (data[&quot;EVENT&quot;] + &apos;   &apos; + data[&quot;FORMNAME&quot;] + &apos;&lt;br&gt;&apos;);
      })
      ret += &apos;&lt;/td&gt;&apos;
  return ret;
}
ViewMaintenance.prototype.render = function() {
  $(&apos;#TOBJ_CONTENTS&apos;).append(&apos;&lt;tr&gt;&lt;td&gt;&apos; + this.view + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.authGroup + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.funcGroup + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.package + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.maintenanceType + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.overviewScreen + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.singleScreen +
&apos;&lt;/td&gt;&apos; + this.getEventsHtml() + &apos;&lt;/tr&gt;&apos;);
}


function ViewCluster(object, obj_name, devclass, short_text, screenshots, hierarchy, readType, objectStructure, fieldDependence, events) {
  BaseObject.call(this, arguments);
  this.hierarchy = hierarchy;
  this.readType = readType;
  this.objectStructure = objectStructure;
  this.fieldDependence = fieldDependence;
  this.events = events;
  return this;
}
ViewCluster.prototype = new BaseObject();
ViewCluster.prototype.constructor = ViewCluster;
ViewCluster.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.hierarchy = json[&quot;HIEROPSOFF&quot;];
  this.readType = json[&quot;READKIND&quot;];
  this.objectStructure = json[&quot;OBJECT_STRU&quot;];
  this.fieldDependence = json[&quot;FIELD_DEP&quot;];
  this.events = json[&quot;EVENTS&quot;];
  return this;
}
ViewCluster.prototype.render = function() {
  $(&apos;#VCLS_CONTENTS&apos;).append(&apos;&lt;tr&gt;&apos; +
                               &apos;&lt;td&gt;&apos; + this.obj_name + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.getHeaderEntryHtml() + &apos;&lt;/td&gt;&apos; +
                               &apos;&lt;td&gt;&apos; + this.getObjStruHtml() + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.getFieldDepHtml() + &apos;&lt;/td&gt;&apos; + this.getEventsHtml() +
                             &apos;&lt;/tr&gt;&apos;);
}
ViewCluster.prototype.getHeaderEntryHtml = function() {
  return &apos;&lt;p&gt;&apos; +
         &apos;Short Text : &apos; + this.short_text + &apos;&lt;br&gt;&apos; +
         &apos;Hierarchical Maintenance Operation Handling : &apos; + this.hierarchy + &apos;&lt;br&gt;&apos; +
         &apos;Read Type : &apos; + this.readType + &apos;&lt;br&gt;&apos; +
         &apos;Package : &apos; + this.devclass +
         &apos;&lt;/p&gt;&apos;;
}
ViewCluster.prototype.getObjStruHtml = function() {
  var ret =  &apos;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;View/Table&lt;/th&gt;&lt;th&gt;Short Text&lt;/th&gt;&lt;th&gt;Predecess&lt;/th&gt;&lt;th&gt;Dep&lt;/th&gt;&lt;th&gt;Pos&lt;/th&gt;&lt;th&gt;Start&lt;/th&gt;&lt;th&gt;Backgr&lt;/th&gt;&lt;th&gt;n:m&lt;/th&gt;&lt;th&gt;Switch&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos; +
             &apos;&lt;tbody&gt;&apos;;
      $.each(this.objectStructure, function(i, data) {
        ret +=  &apos;&lt;tr&gt;&apos; +
                   &apos;&lt;td&gt;&apos; + data[&quot;OBJECT&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;OBJECTTEXT&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;PREDOBJECT&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;DEPENDENCY&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;OBJPOS&quot;] + &apos;&lt;/td&gt;&apos; +
                   &apos;&lt;td&gt;&apos; + data[&quot;STARTOBJ&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;SUPPRESS&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;CARDINAL&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;SWITCH_ID&quot;] + &apos;&lt;/td&gt;&apos; +
                &apos;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/tbody&gt;&apos; +
             &apos;&lt;/table&gt;&apos;;
  return ret;
}
ViewCluster.prototype.getFieldDepHtml = function() {
  var ret =  &apos;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;View/Table&lt;/th&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;Predecess&lt;/th&gt;&lt;th&gt;Pred.field&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos; +
             &apos;&lt;tbody&gt;&apos;;
      $.each(this.objectStructure, function(i, data) {
        ret +=  &apos;&lt;tr&gt;&apos; +
                   &apos;&lt;td&gt;&apos; + data[&quot;OBJECT&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;OBJFIELD&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;PREDOBJECT&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;PREDFIELD&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;NOKEYFIELD&quot;] + &apos;&lt;/td&gt;&apos; +
                &apos;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/tbody&gt;&apos; +
             &apos;&lt;/table&gt;&apos;;
  return ret;
}
ViewCluster.prototype.getEventsHtml = function() {
  return ViewMaintenance.prototype.getEventsHtml.call(this);
}

function TableContents(object, obj_name, devclass, short_text, screenshots, objFunc, entries) {
  BaseObject.call(this, arguments);
  this.objFunc = objFunc;
  this.entries = entries;
  return this;
}
TableContents.prototype = new BaseObject();
TableContents.prototype.constructor = TableContents;
TableContents.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.objFunc = json[&quot;OBJFUNC&quot;];
  this.entries = json[&quot;ENTRIES&quot;];
  return this;
}
TableContents.prototype.render = function() {
  $(&apos;#&apos; + this.object + &quot;_CONTENTS&quot;).append(&apos;&lt;tr&gt;&lt;td&gt;&apos; + this.obj_n + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.objFunc + &apos;&lt;/td&gt;&lt;td&gt;&apos; + this.getEntriesHtml() + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;);
}
TableContents.prototype.getEntriesHtml = function() {
  ret = &apos;&lt;table&gt;&lt;theade&gt;&lt;tr&gt;&lt;th&gt;View Name&lt;/th&gt;&lt;th&gt;Table Name&lt;/th&gt;&lt;th&gt;Table Keys&lt;/th&gt;&lt;/tr&gt;&lt;/theade&gt;&lt;tobdy&gt;&apos;;
  $.each(this.entries, function(i, data) {
    ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[&quot;&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;&quot;] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + data[&quot;&quot;] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret += &apos;&lt;/tobdy&gt;&lt;/table&gt;&apos;;
}

function NumberRange(object, obj_name, devclass, short_text, screenshots, long_text, subObject_dataElement, numberLengthDomain, warning_percentage, toYear, noRolling, tcode, buffering, bufferNo) {
  BaseObject.call(this, arguments);
  this.long_text = long_text;
  this.subObject_dataElement = subObject_dataElement;
  this.numberLengthDomain = numberLengthDomain;
  this.warning_percentage = warning_percentage;
  this.toYear = toYear;
  this.noRolling = noRolling;
  this.tcode = tcode;
  this.buffering = buffering;
  this.bufferNo = bufferNo;
  return this;
}
NumberRange.prototype = new BaseObject();
NumberRange.prototype.constructor = NumberRange;
NumberRange.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.long_text = json[&quot;TXT&quot;];
  this.subObject_dataElement = json[&quot;DTELSOBJ&quot;];
  this.numberLengthDomain = json[&quot;DOMLEN&quot;];
  this.warning_percentage = json[&quot;PERCENTAGE&quot;];
  this.toYear = json[&quot;YEARIND&quot;];
  this.noRolling = json[&quot;NONRSWAP&quot;];
  this.tcode = json[&quot;CODE&quot;];
  this.buffering = json[&quot;BUFFER&quot;];
  this.bufferNo = parseInt(json[&quot;NOIVBUFFER&quot;]);
  return this;
}
NumberRange.prototype.renderAdditionalAttributes = function() {
  return  &apos;&lt;tr&gt;&lt;td&gt;Long text&lt;/td&gt;&lt;td&gt;&apos; + this.long_text + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;Subobject Data Element&lt;/td&gt;&lt;td&gt;&apos; + this.subObject_dataElement + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;Number Length Domain&lt;/td&gt;&lt;td&gt;&apos; + this.numberLengthDomain + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;% Warning&lt;/td&gt;&lt;td&gt;&apos; + this.warning_percentage + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;To-year Flag&lt;/td&gt;&lt;td&gt;&apos; + this.toYear + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;No rolling &lt;/td&gt;&lt;td&gt;&apos; + this.noRolling + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;NR Transaction&lt;/td&gt;&lt;td&gt;&apos; + this.tcode + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;Buffering&lt;/td&gt;&lt;td&gt;&apos; + this.buffering + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;No. of Numbers in Buffer&lt;/td&gt;&lt;td&gt;&apos; + this.bufferNo + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
}

function Transaction(object, obj_name, devclass, short_text, screenshots, basicInfo, uiClass, extInfo, parameters, authority) {
  BaseObject.call(this, arguments);
  this.basicInfo = basicInfo;
  this.uiClass = uiClass;
  this.extInfo = extInfo;
  this.parameters = parameters;
  this.authority = authority;
  return this;
}
Transaction.prototype = new BaseObject();
Transaction.prototype.constructor = Transaction;
Transaction.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.basicInfo = json[&quot;BASIC_INFO&quot;];
  this.uiClass = json[&quot;UICLASS&quot;];
  this.extInfo = json[&quot;EXT_INFO&quot;];
  this.parameters = json[&quot;PARAM&quot;];
  this.authority = json[&quot;AUTHORITY&quot;];
  return this;
}
Transaction.prototype.render = function() {
  $(&apos;#TRAN_CONTENTS&apos;).append(&quot;&lt;tr&gt;&quot; +
                                 &quot;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.getType() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&quot; +
                                 &quot;&lt;td&gt;&quot; + this.getClassificationHtml() + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.getMiscAttributesHtml() + &quot;&lt;/td&gt;&quot; +
                             &quot;&lt;/tr&gt;&quot;);
  $(&apos;#TRAN&apos;).append(this.renderScreenshots());
}
Transaction.prototype.getType = function() {
  //TODO get transaction type description
  return &apos;&apos;;
}
Transaction.prototype.getClassificationHtml = function() {
  return &apos;&lt;h5&gt;Classfication&lt;/h5&gt;&apos; +
         // TODO get some values via calculation...
         &apos;Inherit GUI Attributes : &apos; + &apos;&lt;br&gt;&apos; +
         &apos;&lt;h6&gt;Transaction Classfication&lt;/h6&gt;&apos; +
         &apos;Professional User Transaction : &apos; + this.extInfo[&quot;&quot;] + &apos;&lt;br&gt;&apos; +
         &apos;Easy Web Transaction : &apos; + this.extInfo[&quot;&quot;] + &apos;Service : &apos; + this.extInfo[&quot;S_SERVICE&quot;] + &apos;&lt;br&gt;&apos; +
         &apos;Pervasive enabled : &apos; + this.extInfo[&quot;S_PERVAS&quot;] + &apos;&lt;br&gt;&apos; +
         &apos;&lt;h6&gt;GUI support&lt;/h6&gt;&apos; +
         &apos;SAPGUI for html : &apos; + this.extInfo[&quot;S_WEBGUI&quot;] + &apos;&lt;br&gt;&apos; +
         &apos;SAPGUI for Java : &apos; + this.extInfo[&quot;S_PLATIN&quot;] + &apos;&lt;br&gt;&apos; +
         &apos;SAPGUI for Windows : &apos; + this.extInfo[&quot;S_WIN32&quot;];
}
Transaction.prototype.getMiscAttributesHtml = function() {
  var arr = this.parameters.split(&apos; &apos;);
  var dv4Tcode = arr[0], params = arr[1].split(&apos;;&apos;);

  ret = &apos;&lt;h5&gt;Default Values for&lt;/h5&gt;&apos; +
         &apos;&lt;p&gt;&apos; + dv4Tcode.substring(2) + &apos;&lt;/p&gt;&apos; +
         // TODO: get initial screen value
         &apos;&lt;p&gt;Skip initial screen : &apos; + &apos;X&apos; + &apos;&lt;/p&gt;&apos; +
         &apos;&lt;h5&gt;Default Values&lt;/h5&gt;&apos; +
         &apos;&lt;table&gt;&apos; +
         &apos;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name of screen field&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&apos; +
         &apos;&lt;tbody&gt;&apos;;
  $.each(params, function(i, data) {
    if(data.trim() === &apos;&apos;)
      return;

    var tmp_arr = data.split(&apos;=&apos;);
    ret += &apos;&lt;tr&gt;&lt;td&gt;&apos; + tmp_arr[0] + &apos;&lt;/td&gt;&lt;td&gt;&apos; + tmp_arr[1] + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret += &apos;&lt;/tbody&gt;&apos; +
         &apos;&lt;/table&gt;&apos;;
  return ret;
}

function Message(object, obj_name, devclass, short_text, screenshots, messages) {
  BaseObject.call(this, arguments);
  this.messages = messages;
  return this;
}
Message.prototype = new BaseObject();
Message.prototype.constructor = Message;
Message.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.messages = json[&quot;MESSAGE_TEXTS&quot;];
  return this;
}
Message.prototype.getMessageTextHtml = function() {
  var ret = &apos;&apos;;
  $.each(this.messages, function(i, msg) {
    if(CONSTANTS.DEV_MODE &amp;&amp; i &gt;= 3)
      return;
    ret += (msg[&quot;MSGNR&quot;] + &apos;   &apos; + msg[&quot;TEXT&quot;] + &apos;&lt;br&gt;&apos;);
  });
  return ret;
}
Message.prototype.render = function() {
  $(&apos;#&apos; + this.object + &apos;_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&quot; + this.obj_name + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.devclass + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.short_text + &quot;&lt;/td&gt;&lt;td&gt;&quot; + this.getMessageTextHtml() + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;);
  $(&apos;#&apos; + this.object).append(this.renderScreenshots());
}

$(function() {
  //TODO : reuse same instance and only change the attribute value if performance got a eggache due to this...
  function getObjectInstance(objtype, jsonObj) {
    var result;
    if(objtype === &apos;DEVC&apos;) {
      result = new Package();
    }
    else if(objtype === &apos;MSAD&apos; || objtype === &apos;MSAG&apos;) {
      result = new Message();
    }
    else if(objtype === &apos;FUGR&apos;) {
      result = new FunctionGroup();
    }
    else if(objtype === &apos;DOMA&apos;) {
      result = new Domain();
    }
    else if(objtype === &apos;DTEL&apos;) {
      result = new DataElement();
    }
    else if(objtype === &apos;TABL&apos;) {
      result = new Table();
    }
    else if(objtype === &apos;VIEW&apos;) {
      result = new View();
    }
    else if(objtype === &apos;VCLS&apos;) {
      result = new ViewCluster();
    }
    else if(objtype === &apos;TOBJ&apos;) {
      result = new ViewMaintenance();
    }
    else if(objtype === &apos;SHLP&apos;) {
      result = new SearchHelp();
    }
    else if(objtype === &apos;ENQU&apos;) {
      result = new LockObject();
    }
    else if(objtype === &apos;TTYP&apos;) {
      result = new TableType();
    }
    else if(objtype === &apos;NROB&apos;) {
      result = new NumberRange();
    }
    else if(objtype === &apos;TABU&apos; || objtype === &apos;VDAT&apos; || objtype === &apos;CDAT&apos;) {
      result = new TableContents();
    }
    else if(objtype === &apos;TRAN&apos;) {
      result = new Transaction();
    }
    else {
      result = new BaseObject();
    }
    return result.fromJson(jsonObj);
  }

  $(&apos;#container&apos;).show();
  $.each($(&quot;div &gt; div&quot;), function(i, dom) {
    for(var k in dataSource) {
      if( k === dom.id)
        return;
    }

    $(&apos;#&apos; + dom.id).hide();
  });

  var index = 1, arrayLen = 0;
  $.each(dataSource, function(object, jsonArray) {
    if(!jsonArray || (arrayLen = jsonArray.length) === 0) {
      $(&apos;#&apos; + object).hide();
      return;
    }

    $(&apos;#&apos; + object).prepend(&apos;&lt;h3&gt;&apos; + (index++) + &apos;.&apos; + CONSTANTS.getObjectTypeLabel(object) + &apos;&lt;/h3&gt;&apos;);

    $.each(jsonArray, function(i, jsonObj) {
      if(CONSTANTS.DEV_MODE &amp;&amp; i &gt;=3)
        return;

      getObjectInstance(object, jsonObj).render(i + 1, arrayLen);
    })
  })

  $(&apos;div table&apos;).addClass(&apos;table table-striped table-bordered table-condensed&apos;);
  $(&apos;div img&apos;).addClass(&apos;img-rounded&apos;).attr(&apos;width&apos;, CONSTANTS.image_width);
  // $(&apos;div table&apos;).addClass(&apos;table-striped table-bordered table-condensed&apos;).attr(&quot;border&quot;, 1);
});</source>
 </PROG>
 <PROG NAME="ZDOC_UTIL_JS_V2" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Document Generation Utils Javascript Code" LENGTH="41 "/>
   </language>
  </textPool>
  <source>/**
 * Global Configuration Constants Definition, Replaced By Backend ABAP Coding
 */
var CONSTANTS = {
  // development mode switch
  DEV_MODE : false,
  // screenshot css style: img-rounded, width 600px
  image_width : 600,
  // object type text mapping
  getObjectTypeLabel : function(objtype) {
    return OBJTYPE_MAP[objtype] || &apos;&lt;font color=red&gt;Object Type To Be Supported&lt;/font&gt;&apos;;
  }
}
// description differs from value range of domain PUFFERUNG, so manually maintain here...
var PUFFERUNG = {
  &quot;&quot; : &quot;&quot;,
  &quot;P&quot; : &quot;Single records buff.&quot;,
  &quot;G&quot; : &quot;Generic Area Buffered&quot;,
  &quot;X&quot; : &quot;Fully Buffered&quot;
}
var FRKART = {
  &quot;&quot; : &quot;Not Specified&quot;,
  &quot;OPT&quot; : &quot;Optional foreign key&quot;,
  &quot;OBL&quot; : &quot;Mandatory foreign key&quot;,
  &quot;ID&quot; : &quot;Identifying foreign key&quot;,
  &quot;TEXT&quot; : &quot;Key fields of a text table&quot;
}
/**
 * Base Repository Object Attributes, abstract class for sub class in the below follow by
 * @param {string} object            object type such as package, ddic, function group and etc...refer to field OBJECT in table TADIR
 * @param {string} obj_name          object name, refer to obj_name in table TADIR
 * @param {string} devclass          package that the object assigned to, refer to DEVCLASS in table TADIR
 * @param {string} short_text        short descrption of the object
 * @param {object} sortInfo          sort information {&quot;Lvl1&quot; : &quot;XX&quot;, &quot;Lvl2&quot; : &quot;XX&quot;, &quot;Count&quot; : &quot;XX&quot;}
 * @param {number} screenshots_cnt   screenshots count number of the object
 */
function BaseObject(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt) {
  this.object = object;
  this.obj_name = obj_name;
  this.devclass = devclass;
  this.short_text = short_text;
  this.sortInfo = sortInfo;
  this.screenshots_cnt = screenshots_cnt;
  return this;
}
BaseObject.prototype = {
  fromJson : function(json) {
    this.object = json[&quot;OBJECT&quot;];
    this.obj_name = json[&quot;OBJ_NAME&quot;];
    this.devclass = json[&quot;DEVCLASS&quot;];
    this.short_text = json[&quot;SHORT_TEXT&quot;];
    this.screenshots_cnt = parseInt(json[&quot;SCREENSHOTS_CNT&quot;]) || 0;
    return this;
  },
  setSortInfo : function(sortInfo) {
    this.sortInfo = sortInfo;
    return this;
  },
  renderTitle : function(objTypeLabel, tail) {
    if(!this.sortInfo || this.sortInfo[&quot;Count&quot;] === 1)
      return &apos;&apos;;

    var typeLabel = objTypeLabel || CONSTANTS.getObjectTypeLabel(this.object);
    return &quot;&lt;p class=&apos;MsoNormal&apos;&gt;&lt;span style=&apos;font-size:16.0pt;line-height:115%&apos;&gt;&quot; +
           (this.sortInfo[&quot;Lvl2&quot;] &gt; 1 ? &quot;&lt;br&gt;&quot; : &quot;&quot;) +
           this.sortInfo[&quot;Lvl1&quot;] + &apos;.&apos; + this.sortInfo[&quot;Lvl2&quot;] + &apos;&amp;nbsp;Create&amp;nbsp;&apos; + typeLabel + &quot;&amp;nbsp;&lt;b&gt;&lt;i&gt;&quot; + this.obj_name + &quot;&lt;/i&gt;&lt;/b&gt;&quot; + (tail || &apos;&apos;) + &quot;&lt;/span&gt;&lt;/p&gt;&quot;;
  },
  renderAttributes : function() {
    return &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Object Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.obj_name + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Package&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.devclass + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Short Text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.short_text + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  },
  renderAdditionalAttributes : function() {
    return &apos;&apos;;
  },
  renderMisc : function() {
    return &apos;&apos;;
  },
  renderScreenshots : function() {
    var ret = &apos;&apos;;
    for(var i = 1; i &lt;= this.screenshots_cnt; i++ ) {
      // naming convention: {obj_name}_{object}_{serial_no}.jpg
      ret += &quot;&lt;img src=&apos;img/&quot; + this.obj_name + &apos;_&apos; + this.object + &apos;_&apos; + i + &apos;.jpg&apos; + &quot;&apos; /&gt;&lt;br&gt;&quot;;
    }
    return ret;
  },
  render : function() {
    if($.isEmptyObject(this)) {
      return;
    }

    $(&apos;#&apos; + this.object).append(this.renderTitle() +
                               &quot;&lt;table&gt;&quot; +
                               &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Attribute&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Value&lt;/p&gt;&lt;/td&gt;&quot; +
                               this.renderAttributes() +
                               this.renderAdditionalAttributes() +
                               &quot;&lt;/table&gt;&quot; +
                               this.renderMisc() +
                               this.renderScreenshots());
  }
}

function Package(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, ext_info) {
  BaseObject.call(this, arguments);
  this.ext_info = ext_info;
  return this;
}
Package.prototype = new BaseObject();
Package.prototype.constructor = Package;
Package.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.ext_info = json[&quot;EXT_ATTR&quot;];
  return this;
}
Package.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Application Component&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.ext_info[&quot;APPLICAT&quot;]+ &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Translation Relevance&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.ext_info[&quot;TRANSLATION_DEPTH_TEXT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         (this.ext_info[&quot;PARENTCL&quot;].trim() === &apos;&apos; ? &apos;&apos; : &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Super Package&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.ext_info[&quot;PARENTCL&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;)  +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Transport Layer&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;i style=&apos;mso-bidi-font-style:normal&apos;&gt;&lt;span style=&apos;color:red&apos;&gt;Please fill in according to your own system landscape settings&lt;/span&gt;&lt;/i&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Software Component&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.ext_info[&quot;DLVUNIT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Record Object Changes in Transport Requests&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.ext_info[&quot;KORRFLAG&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         (this.ext_info[&quot;PROJECT_ID&quot;].trim() === &apos;&apos; ? &apos;&apos; : &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;cProjects Project&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.ext_info[&quot;PROJECT_ID&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;);
}
Package.prototype.getUseAccesses = function() {
  var ret = &apos;&apos;;
  $.each(this.ext_info[&quot;USE_ACCESSES&quot;], function(i, data) {
    ret += (&apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;INTF_NAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DEVCLASS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;ERR_SEVER&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;);
  });
  return ret;
}
Package.prototype.renderMisc = function() {
  return this.ext_info[&quot;USE_ACCESSES&quot;].length == 0 ? &apos;&apos; :
         &quot;&lt;table&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;Package Interface&lt;/td&gt;&lt;td&gt;Package&lt;/td&gt;&lt;td&gt;Error Severity&lt;/td&gt;&quot; +
         this.getUseAccesses() +
         &quot;&lt;/table&gt;&quot;;
}

function FunctionGroup(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt) {
  return BaseObject.call(this, arguments);
}
FunctionGroup.prototype = new BaseObject();
FunctionGroup.prototype.constructor = FunctionGroup;
FunctionGroup.prototype.render = function() {
  $(&apos;#FUGR_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&quot; + this.obj_name + &quot;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.devclass + &quot;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.short_text + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot;);
}

function Domain(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, DATATYPE, LENG, OUTPUTLEN, DECIMALS, LOWERCASE, SIGNFLAG, VALEXI, ENTITYTAB, VALUE_RANGE) {
  BaseObject.call(this, arguments);
  this.DATATYPE = DATATYPE;
  this.LENG = LENG;
  this.OUTPUTLEN = OUTPUTLEN;
  this.DECIMALS = DECIMALS;
  this.LOWERCASE = LOWERCASE;
  this.SIGNFLAG = SIGNFLAG;
  this.VALEXI = VALEXI;
  this.ENTITYTAB = ENTITYTAB;
  this.VALUE_RANGE = VALUE_RANGE;
  return this;
}
Domain.prototype = new BaseObject();
Domain.prototype.constructor = Domain;
Domain.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.DATATYPE = json[&quot;DATATYPE&quot;];
  this.LENG = parseInt(json[&quot;LENG&quot;]);
  this.OUTPUTLEN = parseInt(json[&quot;OUTPUTLEN&quot;]);
  this.DECIMALS = parseInt(json[&quot;DECIMALS&quot;]);
  this.LOWERCASE = json[&quot;LOWERCASE&quot;];
  this.SIGNFLAG = json[&quot;SIGNFLAG&quot;];
  this.VALEXI = json[&quot;VALEXI&quot;];
  this.ENTITYTAB = json[&quot;ENTITYTAB&quot;];
  this.VALUE_RANGE = json[&quot;VALUE_RANGE&quot;];
  return this;
}
Domain.prototype.renderAdditionalAttributes = function() {
  return &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Data Type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.DATATYPE + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;No.Characters&lt;/p&gt;&lt;td&gt;&lt;p&gt;&quot; + this.LENG + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Output Length&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.OUTPUTLEN + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Decimals&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.DECIMALS + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Lower Case&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.LOWERCASE + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Sign Flag&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.SIGNFLAG + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         this.getValueRangeOrTableHtml();
}
Domain.prototype.getValueRangeOrTableHtml = function() {
  if(this.VALEXI === &apos;X&apos;) {
    ret = &quot;&lt;tr&gt;&quot; +
          &quot;    &lt;td&gt;&lt;p&gt;Value Range&lt;/p&gt;&lt;/td&gt;&quot; +
          &quot;    &lt;td&gt;&quot;
    ret += &apos;      &lt;table&gt;&apos;;
    ret += &apos;        &lt;tr&gt;&lt;td&gt;&lt;p&gt;Fix.Val.&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Short Description&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
    $.each(this.VALUE_RANGE, function(i, data) {
      ret += (&apos;     &lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data.DOMVALUE_L + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data.DDTEXT + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;);
    })
    ret += &apos;      &lt;/table&gt;&apos; +
          &quot;    &lt;/td&gt;&quot;;
  } else if(this.ENTITYTAB != &apos;&apos;){
    ret = &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Value Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.ENTITYTAB + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
  } else {
    ret = &apos;&apos;;
  }
  return ret;
}

function DataElement(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, domain, field_label) {
  BaseObject.call(this, arguments);
  this.domain = domain;
  this.field_label = field_label;
  return this;
}
DataElement.prototype = new BaseObject();
DataElement.prototype.constructor = DataElement;
DataElement.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.domain = json[&quot;DOMNAME&quot;];
  this.field_label = json[&quot;FIELD_LABEL&quot;];
  return this;
}
DataElement.prototype.renderAdditionalAttributes = function() {
  return &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Domain&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.domain + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Field Label&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&quot; + this.getFieldLabelHtml() + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;;
}
DataElement.prototype.getFieldLabelHtml = function() {
  return &apos;&lt;table&gt;&apos; +
            &apos;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Length&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Field Label&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
            &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Short&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + parseInt(this.field_label[&quot;SCRLEN1&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.field_label[&quot;SCRTEXT_S&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
            &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Medium&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + parseInt(this.field_label[&quot;SCRLEN2&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.field_label[&quot;SCRTEXT_M&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
            &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Long&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + parseInt(this.field_label[&quot;SCRLEN3&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.field_label[&quot;SCRTEXT_L&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
            &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Heading&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + parseInt(this.field_label[&quot;HEADLEN&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.field_label[&quot;REPTEXT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;/table&gt;&apos;;
}

function TableType(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, rowType, ext_info) {
  BaseObject.call(this, arguments);
  this.rowType = rowType;
  this.ext_info = ext_info;
  return this;
}
TableType.prototype = new BaseObject();
TableType.prototype.constructor = TableType;
TableType.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.rowType = json[&quot;ROWTYPE&quot;];
  this.ext_info = json[&quot;EXT_ATTR&quot;]
  return this;
}
TableType.prototype.render = function() {
  $(&apos;#TTYP_CONTENTS&apos;).append(&quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&quot; + this.obj_name + &quot;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.devclass + &quot;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.short_text + &quot;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.rowType + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot;);
}

function SearchHelp(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, type, selectionMethod, dialogType, hotKey, exit, parameters) {
  BaseObject.call(this, arguments);
  this.type = type;
  this.selectionMethod = selectionMethod;
  this.dialogType = dialogType;
  this.hotKey = hotKey;
  this.exit = exit;
  this.parameters = parameters;
  return this;
}
SearchHelp.prototype = new BaseObject();
SearchHelp.prototype.constructor = SearchHelp;
SearchHelp.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.type = json[&quot;ISSIMPLE&quot;] === &apos;X&apos; ? &apos;Elementary&apos; : &apos;Collective&apos;;
  this.selectionMethod = json[&quot;SELMETHOD&quot;];
  this.dialogType = json[&quot;DIALOGTYPE&quot;];
  this.hotKey = json[&quot;HOTKEY&quot;];
  this.exit = json[&quot;SELMEXIT&quot;];
  this.parameters = json[&quot;PARAMS&quot;];
  return this;
}
SearchHelp.prototype.renderAdditionalAttributes = function() {
  return &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.type + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Selection method&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.selectionMethod + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Dialog type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.dialogType + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Hot key&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.hotKey + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Search help exit&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.exit + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
}
SearchHelp.prototype.getParametersHtml = function() {
  if(this.parameters.length == 0) {
    return &apos;&apos;;
  }
  var ret = &apos;&lt;p&gt;&lt;b&gt;Parameters:&lt;/b&gt;&lt;/p&gt;&apos; +
            &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Parameter&lt;/p&gt;&lt;/td&gt;&lt;td&gt;IMP&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;EXP&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;LPos&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;SPos&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;SDis&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Data element&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Modified&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Default value&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      $.each(this.parameters, function(i, data) {
        ret += &apos;&lt;tr&gt;&apos;;
        ret += &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SHLPINPUT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SHLPOUTPUT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SHLPSELPOS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SHLPLISPOS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SHLPSELDIS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;ROLLNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;ROLLCHANGE&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DEFAULTVAL&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos;;
        ret += &apos;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}

function LockObject(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, allowRFC, tables, parameters) {
  BaseObject.call(this, arguments);
  this.allowRFC = allowRFC;
  this.tables = tables;
  this.parameters = parameters;
  return this;
}
LockObject.prototype = new BaseObject();
LockObject.prototype.constructor = LockObject;
LockObject.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.allowRFC = json[&quot;RFCENABLE&quot;];
  this.tables = json[&quot;BASE_TABLES&quot;];
  this.parameters = json[&quot;LOCK_PARAMS&quot;];
  return this;
}
LockObject.prototype.renderAdditionalAttributes = function() {
  return &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Allow RFC&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&quot; + this.allowRFC + &quot;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Tables&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&quot; + this.getTablesHtml() + &quot;&lt;/td&gt;&lt;/tr&gt;&quot; +
         &quot;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Lock Parameter&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&quot; + this.getParametersHtml() + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;;
}
LockObject.prototype.getTablesHtml = function() {
  ret = &apos;&lt;table&gt;&apos; +
        &apos;   &lt;tr&gt;&lt;td&gt;&lt;p&gt;Type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Lock Mode&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  $.each(this.tables, function(i, data) {
    ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;TABPOS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;ENQMODE&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret +=&apos;&lt;/table&gt;&apos;;
  return ret;
}
LockObject.prototype.getParametersHtml = function() {
  ret = &apos;&lt;table&gt;&apos; +
        &apos;   &lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;p&gt;W&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Lock Parameter&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Field&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  $.each(this.tables, function(i, data) {
    ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;X&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;VIEWFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret +=&apos;&lt;/tbody&gt;&lt;/table&gt;&apos;;
  return ret;
}

function Table(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, category, deliveryClass, maintFlag, fields, technicalSetting, nameSpace, foreignKeyHeader, foreignKeyFields, indexHeader, indexFields) {
  BaseObject.call(this, arguments);
  this.category = category;
  this.deliveryClass = deliveryClass;
  this.maintFlag = maintFlag;
  this.fields = fields;
  this.technicalSetting = technicalSetting;
  this.nameSpace = nameSpace;
  this.foreignKeyHeader = foreignKeyHeader;
  this.foreignKeyFields = foreignKeyFields;
  this.indexHeader = indexHeader;
  this.indexFields = indexFields;
  return this;
}
Table.prototype = new BaseObject();
Table.prototype.constructor = Table;
Table.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.category = json[&quot;TABCLASS&quot;];
  this.deliveryClass = json[&quot;CONTFLAG&quot;];
  this.maintFlag = json[&quot;MAINFLAG&quot;];
  this.fields = json[&quot;FIELDS&quot;];
  this.technicalSetting = json[&quot;TECH_SETTING&quot;];
  this.nameSpace = json[&quot;NAMESPACE&quot;];
  this.foreignKeyHeader = json[&quot;FOREIGN_KEY_HEADER&quot;];
  this.foreignKeyFields = json[&quot;FOREIGN_KEYS&quot;];
  this.indexHeader = json[&quot;INDEX_HEADER&quot;];
  this.indexFields = json[&quot;INDEX_FIELDS&quot;];
  return this;
}
Table.prototype.isTransparentTable = function() {
  return this.category === &apos;TRANSP&apos;;
}
Table.prototype.renderTitle = function() {
  return BaseObject.prototype.renderTitle.call(this, TABCLASS[this.category]);
}
Table.prototype.renderAdditionalAttributes = function() {
  return this.isTransparentTable() ?
         (&apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Delivery Class&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.deliveryClass + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Data Browser/Table View Maint.&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + MAINFLAG[this.maintFlag] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;) : &apos;&apos;;
}
Table.prototype.renderMisc = function() {
  return this.getFieldsHtml() + this.getTechnicalSettingHtml() + this.getForeignKeysHtml() + this.getIndexSettingHtml();
}
Table.prototype.getStructureComponentsHtml = function() {
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Components:&lt;/b&gt;&lt;/p&gt;&apos; +
             &apos;&lt;p&gt;Please notice that those components marked as blue and italic are contained in included structure/table and you don\&apos;t need to add them.&lt;/p&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Component&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Typing Method&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Data Element&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      $.each(this.fields, function(i, data) {
        var fontStyle = parseInt(data[&quot;ADMINFIELD&quot;]) === 1 ? &quot; style=&apos;color:blue;font-style:italic;&apos;&quot; : &quot;&quot;;
        ret += &apos;&lt;tr&apos; + fontStyle + &apos;&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;KEYFLAG&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + (data[&quot;FIELDNAME&quot;] === &apos;.INCLUDE&apos; ? data[&quot;PRECFIELD&quot;] : data[&quot;ROLLNAME&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/table&gt;&lt;br&gt;&apos;;
  return ret;
}
Table.prototype.getFieldsHtml = function() {
  return this.category === &apos;INTTAB&apos; ? this.getStructureComponentsHtml() : this.getTableFieldsHtml();
}
Table.prototype.getTableFieldsHtml = function() {
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Fields:&lt;/b&gt;&lt;/p&gt;&apos; +
             &apos;&lt;p&gt;Please notice that those fields marked as blue and italic are contained in included structure/table and you don\&apos;t need to add them.&lt;/p&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Field name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Key&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Data Element&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Check Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Search Help&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      $.each(this.fields, function(i, data) {
        var fontStyle = parseInt(data[&quot;ADMINFIELD&quot;]) === 1 ? &quot; style=&apos;color:blue;&apos;&quot; : &quot;&quot;;
        ret += &apos;&lt;tr&apos; + fontStyle + &apos;&gt;&apos;;
        ret += &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;KEYFLAG&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos;;
        ret += &apos;&lt;td&gt;&lt;p&gt;&apos; + (data[&quot;FIELDNAME&quot;] === &apos;.INCLUDE&apos; ? data[&quot;PRECFIELD&quot;] : data[&quot;ROLLNAME&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;CHECKTABLE&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SHLPNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos;
        ret += &apos;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/table&gt;&lt;br&gt;&apos;;
  return ret;
}
Table.prototype.getTechnicalSettingHtml = function() {
  if(!this.isTransparentTable()) {
    return &apos;&apos;;
  }
  //TODO attribute - value mode?
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Technical Settings:&lt;/b&gt;&lt;/p&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Data Class&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Size Category&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Buffering&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Buffering Type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Log Data Changes&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Write Access Only with Java&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + this.technicalSetting[&quot;TABART&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.technicalSetting[&quot;TABKAT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + BUFALLOW[this.technicalSetting[&quot;BUFALLOW&quot;]] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
             &apos;&lt;td&gt;&lt;p&gt;&apos; + PUFFERUNG[this.technicalSetting[&quot;PUFFERUNG&quot;]] + (this.technicalSetting[&quot;PUFFERUNG&quot;] == &apos;G&apos; ? (&apos;&lt;br&gt;No. of key fields: &apos; + this.technicalSetting[&quot;SCHFELDANZ&quot;]) : &apos;&apos;) + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
             &apos;&lt;td&gt;&lt;p&gt;&apos; + this.technicalSetting[&quot;PROTOKOLL&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.technicalSetting[&quot;JAVAONLY&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
             &apos;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&lt;br&gt;&apos;;
  return ret;
}
Table.prototype.getFKDefinitionHtml = function(fieldName) {
  var ret =  &apos;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Check table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;ChkTablFld&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;For.key table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Foreign Key Field&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Generic&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Constant&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  $.each(this.foreignKeyFields, function(i, data) {
    if(data[&quot;FIELDNAME&quot;] === fieldName) {
      ret += &apos;&lt;tr&gt;&apos;;
      ret += &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;CHECKTABLE&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;CHECKFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + (data[&quot;FORKEY&quot;] != &apos;&apos; ? data[&quot;FORTABLE&quot;] : &apos;&apos;) + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
             &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FORKEY&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
             //when FORKEY is blank, there might be generic or constant setting, * means generic while constant value is FORTABLE
             &apos;&lt;td&gt;&lt;p&gt;&apos; + (data[&quot;FORTABLE&quot;] === &apos;*&apos; ? &apos;X&apos; : &apos;&apos;) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + (data[&quot;FORKEY&quot;] === &apos;&apos; &amp;&amp; data[&quot;FORTABLE&quot;] != &apos;*&apos; ? data[&quot;FORTABLE&quot;] : &apos;&apos;) + &apos;&lt;/p&gt;&lt;/td&gt;&apos;;
      ret += &apos;&lt;/tr&gt;&apos;;
    }
  })
  ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getForeignKeysHtml = function() {
  if(!this.isTransparentTable() ||
     !this.foreignKeyHeader || this.foreignKeyHeader.length === 0 ||
     !this.foreignKeyFields || this.foreignKeyFields.length === 0) {
    return &apos;&apos;;
  }
  var me = this;
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Foreign Keys:&lt;/b&gt; define foreign key relationship for fields according to attribute values listed in the below&lt;/p&gt;&apos;;
  $.each(this.foreignKeyHeader, function(i, data) {
    ret += &apos;&lt;table&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Attribute&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Value&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Field Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Check Table&lt;/p&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;CHECKTABLE&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Foreign Key Fields&lt;/p&gt;&lt;td&gt;&lt;p&gt;&apos; + me.getFKDefinitionHtml(data[&quot;FIELDNAME&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Screen check&lt;/p&gt;&lt;td&gt;&lt;p&gt;Check required: &apos; + data[&quot;CHECKFLAG&quot;] + &apos;&lt;/p&gt;&lt;p&gt;MsgNo: &apos; + data[&quot;MSGNR&quot;] + &apos;&lt;/p&gt;&lt;p&gt;AArea:&apos; + data[&quot;ARBGB&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Semantic attributes&lt;/p&gt;&lt;td&gt;&lt;p&gt;Foreign key field type: &apos; + FRKART[data[&quot;FRKART&quot;]] + &apos;&lt;/p&gt;&lt;p&gt;Cardinality:[&apos; + data[&quot;CARDLEFT&quot;] + &apos; : &apos; + data[&quot;CARD&quot;] + &apos;]&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
           &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Short Text&lt;/p&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DDTEXT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;tr&gt;&apos; +
           &apos;&lt;/table&gt;&lt;br&gt;&apos;;
  });
  return ret;
}
Table.prototype.getIndexSettingHtml = function() {
  if(!this.isTransparentTable() || this.indexHeader.length === 0 || this.indexFields.length === 0) {
    return &apos;&apos;;
  }
  var me = this;
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Indexes:&lt;/b&gt;&lt;/p&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Index Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Ext.Index&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Short Text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Unique&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;DB index name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;DB status&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Inclusion/Exclusion&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Index Flds&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      $.each(this.indexHeader, function(i ,data) {
        ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;INDEXNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;ISEXTIND&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DDTEXT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;UNIQUEFLAG&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DBINDEX&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DBSTATE&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
               &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DBINCLEXCL&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + me.getIndexFieldHtml(data[&quot;INDEXNAME&quot;]) + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
Table.prototype.getIndexFieldHtml = function(indexName) {
  var ret = &apos;&apos;, i = 0;
  $.each(this.indexFields, function(i, data) {
    if(data[&quot;INDEXNAME&quot;] === indexName) {
      i += 1;
      ret += (i == 1 ? &apos;&apos; : &apos;&lt;br&gt;&apos;) + data[&quot;FIELDNAME&quot;];
    }
  })
  return ret;
}
Table.prototype.getNamespaceHtml = function() {
  // only transparent table with delivery class E need to display namespace maintainance settings
  if(!this.isTransparentTable() || this.deliveryClass != &apos;E&apos; || this.nameSpace.length === 0) {
    return &apos;&apos;;
  }
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Maintain Customer Namespace:&lt;/b&gt;&lt;/p&gt;&apos; +
             &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Key Field&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Namespace&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      $.each(this.nameSpace, function(i ,data) {
        ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;KEYLOW&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      });
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}

function View(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, category, deliveryClass, maintStatus, maintFlag, tableJoin, fields, joinCondition, selectionCondition) {
  BaseObject.call(this, arguments);
  this.category = category;
  this.deliveryClass = deliveryClass;
  this.maintStatus = maintStatus;
  this.maintFlag = maintFlag;
  this.tableJoin = tableJoin;
  this.fields = fields;
  this.joinCondition = joinCondition;
  this.selectionCondition = selectionCondition;
  return this;
}
View.prototype = new BaseObject();
View.prototype.constructor = View;
View.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.category = json[&quot;VIEWCLASS&quot;];
  this.deliveryClass = json[&quot;CUSTOMAUTH&quot;];
  this.maintStatus = json[&quot;VIEWGRANT&quot;];
  this.maintFlag = json[&quot;GLOBALFLAG&quot;];
  this.tableJoin = json[&quot;TABLE_JOIN&quot;];
  this.fields = json[&quot;FIELDS&quot;];
  this.joinCondition = json[&quot;JOIN_CONDITION&quot;];
  this.selectionCondition = json[&quot;SELECTION_CONDITION&quot;];
  return this;
}
View.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Access&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + VIEWGRANT[this.maintStatus] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Delivery Class&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.deliveryClass + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Data Browser/Table View Maint.&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + MAINFLAG[this.maintFlag] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
}
View.prototype.renderTitle = function() {
  return BaseObject.prototype.renderTitle.call(this, VIEWCLASS[this.category]);
}
View.prototype.renderMisc = function() {
  return this.getTableJoin() + this.getFieldsHtml() + this.getSelectionConditionHtml();
}
View.prototype.getTableJoin = function() {
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Table/Join Conditions:&lt;/b&gt;&lt;/p&gt;&apos; +
             &apos;&lt;p&gt;&lt;b&gt;Tables:&lt;/b&gt;&lt;/p&gt;&apos;;
      ret += &apos;&lt;p&gt;&apos;;
      $.each(this.tableJoin, function(i, data) {
        ret += (i == 0 ? &apos;&apos; : &apos;&lt;br&gt;&apos;) + data[&quot;TABNAME&quot;];
      });
      ret += &apos;&lt;/p&gt;&apos;;
      ret += &apos;&lt;p&gt;&lt;b&gt;Join Conditions:&lt;/b&gt;&lt;/p&gt;&apos;;
      if(this.joinCondition &amp;&amp; this.joinCondition.length &gt; 0) {
        ret += &apos;&lt;table&gt;&apos;;
        ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Field Name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;=&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Field Name&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
        $.each(this.joinCondition, function(i ,data) {
          if(data[&quot;RFIELD&quot;] === &apos;&apos;)
            return;

          ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;LTAB&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;LFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;=&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;RTAB&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;RFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
        });
        ret += &apos;&lt;/tbody&gt;&apos;;
        ret += &apos;&lt;/table&gt;&apos;;
      }
      else {
        ret += &apos;&lt;p&gt;&lt;i&gt;No additional join condition needs to be maintained here.&lt;/i&gt;&lt;/p&gt;&apos;;
      }
  return ret + &apos;&lt;br&gt;&apos;;
}
View.prototype.getFieldsHtml = function() {
  var ret =  &apos;&lt;p&gt;&lt;b&gt;View Flds:&lt;/b&gt;&lt;/p&gt;&apos;;
      ret += &apos;&lt;table&gt;&apos;;
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;View Field&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Field&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;P&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Key&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Mod&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      ret += &apos;&lt;tbody&gt;&apos;;
      $.each(this.fields, function(i ,data) {
        ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;VIEWFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;RDONLY&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;KEYFLAG&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;ROLLCHANGE&quot;] +
&apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      });
      ret += &apos;&lt;/tbody&gt;&apos;;
      ret += &apos;&lt;/table&gt;&apos;;
  return ret + &apos;&lt;br&gt;&apos;;
}
View.prototype.getSelectionConditionHtml = function() {
  var ret =  &apos;&lt;p&gt;&lt;b&gt;Selection conditions:&lt;/b&gt;&lt;/p&gt;&apos;;
  if(this.selectionCondition &amp;&amp; this.selectionCondition.length &gt; 0) {
    ret += &apos;&lt;table&gt;&apos;;
    ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Field name&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Operator&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Comparison value&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;AND/OR&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
    ret += &apos;&lt;tbody&gt;&apos;;
    $.each(this.selectionCondition, function(i ,data) {
      ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;TABNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;FIELDNAME&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;OPERATOR&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;CONSTANTS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;AND_OR&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
    });
    ret += &apos;&lt;/tbody&gt;&apos;;
    ret += &apos;&lt;/table&gt;&apos;;
  }
  else {
    ret += &apos;&lt;p&gt;&lt;i&gt;No additional selection condition needs to be maintained here.&lt;i&gt;&lt;/p&gt;&apos;;
  }
  return ret;
}

function ViewMaintenance(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, view, authGroup, funcGroup, package, maintenanceType, overviewScreen, singleScreen, events) {
  BaseObject.call(this, arguments);
  this.view = view;
  this.authGroup = authGroup;
  this.funcGroup = funcGroup;
  this.package = package;
  this.maintenanceType = maintenanceType;
  this.overviewScreen = overviewScreen;
  this.singleScreen = singleScreen;
  this.events = events;
  return this;
}
ViewMaintenance.prototype = new BaseObject();
ViewMaintenance.prototype.constructor = ViewMaintenance;
ViewMaintenance.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.view = json[&quot;TABNAME&quot;];
  this.authGroup = json[&quot;CCLASS&quot;];
  this.funcGroup = json[&quot;AREA&quot;];
  this.package = json[&quot;FG_DEVCLASS&quot;];
  this.maintenanceType = json[&quot;TYPE&quot;] === &apos;1&apos; ? &apos;one step&apos; : &apos;two step&apos;;
  this.overviewScreen = json[&quot;LISTE&quot;];
  this.singleScreen = json[&quot;DETAIL&quot;];
  this.events = json[&quot;EVENTS&quot;];
  return this;
}
ViewMaintenance.prototype.getEventsHtml = function() {
  if(this.events.length == 0)
    return &apos;&apos;;
  ret =  &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Events&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&apos;;
  $.each(this.events, function(i, data) {
    ret += &apos;&lt;p&gt;&apos; + data[&quot;EVENT&quot;] + &apos;&amp;nbsp;nbsp;&apos; + data[&quot;FORMNAME&quot;] + &apos;&lt;/p&gt;&apos;;
  })
  ret += &apos;&lt;/td&gt;&lt;/tr&gt;&apos;;
  return ret;
}
ViewMaintenance.prototype.renderAttributes = function() {
  return &apos;&apos;;
}
ViewMaintenance.prototype.renderTitle = function() {
  return BaseObject.prototype.renderTitle.call(this, &apos;Maintenance Object&apos;, &apos;&amp;nbsp; via TCODE SE54&apos;);
}
ViewMaintenance.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;View&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.view + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Authorization Group&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.view + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Function Group&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.funcGroup + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Package&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.package + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Maintenance type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.maintenanceType + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Overview screen&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.overviewScreen + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Single screen&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.singleScreen + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         this.getEventsHtml();
}


function ViewCluster(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, hierarchy, readType, objectStructure, fieldDependence, events) {
  BaseObject.call(this, arguments);
  this.hierarchy = hierarchy;
  this.readType = readType;
  this.objectStructure = objectStructure;
  this.fieldDependence = fieldDependence;
  this.events = events;
  return this;
}
ViewCluster.prototype = new BaseObject();
ViewCluster.prototype.constructor = ViewCluster;
ViewCluster.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.hierarchy = json[&quot;HIEROPSOFF&quot;];
  this.readType = json[&quot;READKIND&quot;];
  this.objectStructure = json[&quot;OBJECT_STRU&quot;];
  this.fieldDependence = json[&quot;FIELD_DEP&quot;];
  this.events = json[&quot;EVENTS&quot;];
  return this;
}
ViewCluster.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Hierarchical Maintenance Operation Handling&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.hierarchy + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Read Type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.readType + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Object Structure&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&apos; + this.getObjStruHtml() + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Field Dependence&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&apos; + this.getFieldDepHtml() + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         this.getEventsHtml();
}
ViewCluster.prototype.getObjStruHtml = function() {
var ret =  &apos;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;View/Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Short Text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Predecess&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Dep&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Pos&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Start&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Backgr&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;n:m&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Switch&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      $.each(this.objectStructure, function(i, data) {
        ret +=  &apos;&lt;tr&gt;&apos; +
                   &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;OBJECT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;OBJECTTEXT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;PREDOBJECT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;DEPENDENCY&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;OBJPOS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
                   &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;STARTOBJ&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SUPPRESS&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;CARDINAL&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;SWITCH_ID&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
                &apos;&lt;/tr&gt;&apos;;
      })
     ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
ViewCluster.prototype.getFieldDepHtml = function() {
  var ret =  &apos;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;View/Table&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Field&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Predecess&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Pred.field&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Type&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
      $.each(this.objectStructure, function(i, data) {
        ret +=  &apos;&lt;tr&gt;&apos; +
                   &apos;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;OBJECT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;OBJFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;PREDOBJECT&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;PREDFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;NOKEYFIELD&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&apos; +
                &apos;&lt;/tr&gt;&apos;;
      })
      ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}
ViewCluster.prototype.getEventsHtml = function() {
  return ViewMaintenance.prototype.getEventsHtml.call(this);
}

function TableContents(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, objFunc, entries) {
  BaseObject.call(this, arguments);
  this.objFunc = objFunc;
  this.entries = entries;
  return this;
}
TableContents.prototype = new BaseObject();
TableContents.prototype.constructor = TableContents;
TableContents.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.objFunc = json[&quot;OBJFUNC&quot;];
  this.entries = json[&quot;ENTRIES&quot;];
  return this;
}
TableContents.prototype.render = function() {
  $(&apos;#&apos; + this.object + &quot;_CONTENTS&quot;).append(&apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + this.obj_n + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.objFunc + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.getEntriesHtml() + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;);
}
TableContents.prototype.getEntriesHtml = function() {
  ret = &apos;&lt;table&gt;&lt;theade&gt;&lt;tr&gt;&lt;td&gt;View Name&lt;/td&gt;&lt;td&gt;Table Name&lt;/td&gt;&lt;td&gt;Table Keys&lt;/td&gt;&lt;/tr&gt;&lt;/theade&gt;&lt;tobdy&gt;&apos;;
  $.each(this.entries, function(i, data) {
    ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + data[&quot;&quot;] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret += &apos;&lt;/tobdy&gt;&lt;/table&gt;&apos;;
}

function NumberRange(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, long_text, subObject_dataElement, numberLengthDomain, warning_percentage, toYear, noRolling, tcode, buffering, bufferNo) {
  BaseObject.call(this, arguments);
  this.long_text = long_text;
  this.subObject_dataElement = subObject_dataElement;
  this.numberLengthDomain = numberLengthDomain;
  this.warning_percentage = warning_percentage;
  this.toYear = toYear;
  this.noRolling = noRolling;
  this.tcode = tcode;
  this.buffering = buffering;
  this.bufferNo = bufferNo;
  return this;
}
NumberRange.prototype = new BaseObject();
NumberRange.prototype.constructor = NumberRange;
NumberRange.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.long_text = json[&quot;TXT&quot;];
  this.subObject_dataElement = json[&quot;DTELSOBJ&quot;];
  this.numberLengthDomain = json[&quot;DOMLEN&quot;];
  this.warning_percentage = json[&quot;PERCENTAGE&quot;];
  this.toYear = json[&quot;YEARIND&quot;];
  this.noRolling = json[&quot;NONRSWAP&quot;];
  this.tcode = json[&quot;CODE&quot;];
  this.buffering = json[&quot;BUFFER&quot;];
  this.bufferNo = parseInt(json[&quot;NOIVBUFFER&quot;]);
  return this;
}
NumberRange.prototype.renderAdditionalAttributes = function() {
  return  &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Long text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.long_text + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Subobject Data Element&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.subObject_dataElement + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Number Length Domain&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.numberLengthDomain + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;% Warning&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.warning_percentage + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;To-year Flag&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.toYear + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;No rolling &lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.noRolling + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;NR Transaction&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.tcode + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Buffering&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.buffering + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
          &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;No. of Numbers in Buffer&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.bufferNo + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
}

function Transaction(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, basicInfo, uiClass, extInfo, parameters, authority) {
  BaseObject.call(this, arguments);
  this.basicInfo = basicInfo;
  this.uiClass = uiClass;
  this.extInfo = extInfo;
  this.parameters = parameters;
  this.authority = authority;
  return this;
}
Transaction.prototype = new BaseObject();
Transaction.prototype.constructor = Transaction;
Transaction.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.basicInfo = json[&quot;BASIC_INFO&quot;];
  this.uiClass = json[&quot;UICLASS&quot;];
  this.extInfo = json[&quot;EXT_INFO&quot;];
  this.parameters = json[&quot;PARAM&quot;];
  this.authority = json[&quot;AUTHORITY&quot;];
  return this;
}
Transaction.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Transaction Type&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.getType() + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Classfication&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&apos; + this.getClassificationHtml() + &apos;&lt;/td&gt;&lt;/tr&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Default Values&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.getMiscAttributesHtml() + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
}
Transaction.prototype.getType = function() {
  //TODO get transaction type description
  return &apos;&apos;;
}
Transaction.prototype.getClassificationHtml = function() {
  return &apos;&lt;p&gt;&lt;b&gt;Classfication&lt;/b&gt;&lt;/p&gt;&apos; +
         // TODO get some values via calculation...
         &apos;&lt;p&gt;Inherit GUI Attributes:&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;&lt;b&gt;Transaction Classfication&lt;/b&gt;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;Professional User Transaction : &apos; + this.extInfo[&quot;&quot;] + &apos;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;Easy Web Transaction : &apos; + this.extInfo[&quot;&quot;] + &apos;Service : &apos; + this.extInfo[&quot;S_SERVICE&quot;] + &apos;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;Pervasive enabled : &apos; + this.extInfo[&quot;S_PERVAS&quot;] + &apos;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;&lt;b&gt;GUI support&lt;/b&gt;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;SAPGUI for html : &apos; + this.extInfo[&quot;S_WEBGUI&quot;] + &apos;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;SAPGUI for Java : &apos; + this.extInfo[&quot;S_PLATIN&quot;] + &apos;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;SAPGUI for Windows : &apos; + this.extInfo[&quot;S_WIN32&quot;];
}
Transaction.prototype.getMiscAttributesHtml = function() {
  var arr = this.parameters.split(&apos; &apos;);
  var dv4Tcode = arr[0], params = arr[1].split(&apos;;&apos;);

  ret = &apos;&lt;p&gt;&lt;b&gt;Default Values for&lt;/b&gt;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;&apos; + dv4Tcode.substring(2) + &apos;&lt;/p&gt;&apos; +
         // TODO: get initial screen value
         &apos;&lt;p&gt;Skip initial screen : &apos; + &apos;X&apos; + &apos;&lt;/p&gt;&apos; +
         &apos;&lt;p&gt;&lt;b&gt;Default Values&lt;/b&gt;&lt;/p&gt;&apos; +
         &apos;&lt;table&gt;&apos; +
         &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Name of screen field&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;Value&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  $.each(params, function(i, data) {
    if(data.trim() === &apos;&apos;)
      return;

    var tmp_arr = data.split(&apos;=&apos;);
    ret += &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&apos; + tmp_arr[0] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + tmp_arr[1] + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
  });
  ret += &apos;&lt;/table&gt;&apos;;
  return ret;
}

function Message(object, obj_name, devclass, short_text, sortInfo, screenshots_cnt, messages) {
  BaseObject.call(this, arguments);
  this.messages = messages;
  return this;
}
Message.prototype = new BaseObject();
Message.prototype.constructor = Message;
Message.prototype.fromJson = function(json) {
  BaseObject.prototype.fromJson.call(this, json);
  this.messages = json[&quot;MESSAGE_TEXTS&quot;];
  return this;
}
Message.prototype.getMessageTextHtml = function() {
  var ret = &apos;&apos;;
  $.each(this.messages, function(i, msg) {
    if(CONSTANTS.DEV_MODE &amp;&amp; i &gt;= 3)
      return;
    ret += (msg[&quot;MSGNR&quot;] + &apos;   &apos; + msg[&quot;TEXT&quot;] + &apos;&lt;br&gt;&apos;);
  });
  return ret;
}
Message.prototype.renderAdditionalAttributes = function() {
  return &apos;&lt;tr&gt;&lt;td&gt;&lt;p&gt;Messages&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&apos; + this.getMessageTextHtml() + &apos;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&apos;;
}

$(function() {
  //TODO : reuse same instance and only change the attribute value if performance got a eggache due to this...
  function getObjectInstance(objtype, jsonObj) {
    var result;
    if(objtype === &apos;DEVC&apos;) {
      result = new Package();
    }
    else if(objtype === &apos;MSAD&apos; || objtype === &apos;MSAG&apos;) {
      result = new Message();
    }
    else if(objtype === &apos;FUGR&apos;) {
      result = new FunctionGroup();
    }
    else if(objtype === &apos;DOMA&apos;) {
      result = new Domain();
    }
    else if(objtype === &apos;DTEL&apos;) {
      result = new DataElement();
    }
    else if(objtype === &apos;TABL&apos;) {
      result = new Table();
    }
    else if(objtype === &apos;VIEW&apos;) {
      result = new View();
    }
    else if(objtype === &apos;VCLS&apos;) {
      result = new ViewCluster();
    }
    else if(objtype === &apos;TOBJ&apos;) {
      result = new ViewMaintenance();
    }
    else if(objtype === &apos;SHLP&apos;) {
      result = new SearchHelp();
    }
    else if(objtype === &apos;ENQU&apos;) {
      result = new LockObject();
    }
    else if(objtype === &apos;TTYP&apos;) {
      result = new TableType();
    }
    else if(objtype === &apos;NROB&apos;) {
      result = new NumberRange();
    }
    else if(objtype === &apos;TABU&apos; || objtype === &apos;VDAT&apos; || objtype === &apos;CDAT&apos;) {
      result = new TableContents();
    }
    else if(objtype === &apos;TRAN&apos;) {
      result = new Transaction();
    }
    else {
      result = new BaseObject();
    }
    return result.fromJson(jsonObj);
  }

  $(&apos;#container&apos;).show();
  // hide those object type div container if they are not included in
  $.each($(&quot;div &gt; div&quot;), function(i, dom) {
    for(var k in dataSource) {
      if( k === dom.id)
        return;
    }

    $(&apos;#&apos; + dom.id).hide();
  });

  var index = 0, arrayLen = 0;
  $.each(dataSource, function(object, jsonArray) {
    if(!jsonArray || (arrayLen = jsonArray.length) === 0) {
      $(&apos;#&apos; + object).hide();
      if($(&apos;#&apos; + object + &apos;_CONTENTS&apos;)) {
        $(&apos;#&apos; + object + &apos;_CONTENTS&apos;).hide();
      }
      return;
    }

    index++;
    $(&apos;#&apos; + object).prepend(&quot;&lt;p class=&apos;MsoNormal&apos;&gt;&lt;b&gt;&lt;span style=&apos;font-size:20.0pt;line-height:115%&apos;&gt;&quot; + index + &apos;.&apos; + CONSTANTS.getObjectTypeLabel(object) + &apos;&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;&apos;);

    $.each(jsonArray, function(i, jsonObj) {
      if(CONSTANTS.DEV_MODE &amp;&amp; i &gt;=3)
        return;

      getObjectInstance(object, jsonObj).setSortInfo( {&quot;Lvl1&quot; : index, &quot;Lvl2&quot; : i+1, &quot;Count&quot; : arrayLen} ).render();
    });

    $(&apos;#&apos; + object).append(&quot;&lt;br&gt;&quot;);
  })

  $(&apos;div table&apos;).addClass(&apos;MsoTableGrid&apos;).attr(&quot;border&quot;, 1).attr(&quot;cellspacing&quot;, 0).attr(&quot;cellpadding&quot;, 0).attr(&quot;width&quot;, &quot;100%&quot;).attr(&quot;style&quot;, &quot;100.0%;border-collapse:collapse;border:none&quot;);
  $(&apos;div p&apos;).addClass(&apos;MsoNormal&apos;).attr(&apos;style&apos;, &apos;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&apos;);
  $(&apos;td&apos;).attr(&quot;valign&quot;, &quot;top&quot;).attr(&quot;style&quot;, &quot;border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt&quot;);
  $(&apos;td p&apos;).addClass(&apos;MsoNormal&apos;).attr(&apos;style&apos;, &apos;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&apos;);
  $(&apos;div img&apos;).attr(&apos;width&apos;, CONSTANTS.image_width);
});</source>
 </PROG>
 <PROG NAME="ZF30_TEST_FORMS" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="F.30 Test Tool Subroutines" LENGTH="26 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZF30_TEST_FORMS
*&amp;---------------------------------------------------------------------*
FORM init_data.
  SELECT * FROM t060o INTO TABLE lt_t060o WHERE koart = &apos;D&apos; AND ( owner = p_ov OR owner = p_nv ).
  SELECT * FROM t060t INTO TABLE lt_t060t WHERE spras = sy-langu AND awtyp = p_awtyp AND ( owner = p_ov OR owner = p_nv ).

  SELECT * FROM t060 INTO TABLE lt_t060_old WHERE owner = p_ov AND awtyp = p_awtyp.
  IF lt_t060_old IS INITIAL.
    MESSAGE text-006 TYPE &apos;E&apos;.
  ENDIF.
  SORT lt_t060_old BY versn ASCENDING.

  SELECT * FROM t060 INTO TABLE lt_t060_new WHERE owner = p_nv AND awtyp = p_awtyp.
  IF lt_t060_new IS INITIAL.
    MESSAGE text-007 TYPE &apos;E&apos;.
  ENDIF.
  SORT lt_t060_new BY versn ASCENDING.

  SELECT kunnr name1 FROM kna1 INTO TABLE lt_kna1_lc.
ENDFORM.

FORM init_objec_tab.
  DATA: lt_object_tab TYPE tt_object_tab,
        ls_object_tab TYPE objec_tab.

  IMPORT objec_tab = lt_object_tab FROM DATABASE rfrr(rr) ID evalkey.
  LOOP AT lt_object_tab INTO ls_object_tab WHERE koart EQ &apos;D&apos; AND awtyp EQ p_awtyp AND owner EQ p_ov.
    APPEND ls_object_tab TO lt_objects.
  ENDLOOP.
ENDFORM.

FORM init_stru_metadata.
  CONCATENATE &apos;SUM_T_&apos; p_awtyp INTO lv_sum_stru.            &quot;#EC NOTEXT
  CONCATENATE &apos;TOP_N_&apos; p_awtyp INTO lv_top_stru.            &quot;#EC NOTEXT
  CONCATENATE &apos;TOP_N_TEXT_&apos; p_awtyp INTO lv_top_text_stru.  &quot;#EC NOTEXT
  TRY.
      lo_sum_stru_desc ?= cl_abap_typedescr=&gt;describe_by_name( lv_sum_stru ).
      lo_top_stru_desc ?= cl_abap_typedescr=&gt;describe_by_name( lv_top_stru ).
      lo_top_text_stru_desc ?= cl_abap_typedescr=&gt;describe_by_name( lv_top_text_stru ).
    CATCH cx_sy_move_cast_error.
  ENDTRY.

  CASE p_awtyp.
    WHEN &apos;01&apos;.
*    CASE SAVE_SPEZ3_S_GESAMT.
*      WHEN S-FAEL. lv_sum_sort_fld = &apos;SFAEL&apos;. lv_top_sort_fld = &apos;TFAEL&apos;.
*      WHEN S-NFAE. lv_sum_sort_fld = &apos;SNFAE&apos;. lv_top_sort_fld = &apos;TNFAE&apos;.
*      WHEN S-SUMO. lv_sum_sort_fld = &apos;SSUMO&apos;. lv_top_sort_fld = &apos;TSUMO&apos;.
*    ENDCASE.
    lv_sum_sort_fld = &apos;SSUMO&apos;. lv_top_sort_fld = &apos;TSUMO&apos;.
    &quot; Payment History and Currency Analysis
    WHEN &apos;02&apos;.  lv_sum_sort_fld = &apos;&apos;. lv_top_sort_fld = &apos;&apos;.
    WHEN &apos;03&apos;.  lv_sum_sort_fld = &apos;&apos;. lv_top_sort_fld = &apos;&apos;.
    WHEN &apos;04&apos;.
    &quot; over due items analysis
    lv_sum_sort_fld = &apos;&apos;. lv_top_sort_fld = &apos;&apos;.
    WHEN &apos;05&apos;.  lv_sum_sort_fld = &apos;SUDSO&apos;. lv_top_sort_fld = &apos;TODSO&apos;.
    WHEN &apos;06&apos;.  lv_sum_sort_fld = &apos;STSUD&apos;. lv_top_sort_fld = &apos;TTSUD&apos;.
  ENDCASE.
ENDFORM.

FORM validate_variants.
  DATA: lv_pass TYPE abap_bool,
        lv_subrc TYPE sy-subrc,
        lv_error_msg TYPE string.
  FIELD-SYMBOLS: &lt;fs_t060_old&gt; TYPE t060,
                 &lt;fs_t060_new&gt; TYPE t060,
                 &lt;fs_t060o_old&gt; TYPE t060o,
                 &lt;fs_t060o_new&gt; TYPE t060o.

  READ TABLE lt_t060o ASSIGNING &lt;fs_t060o_old&gt; WITH TABLE KEY owner = p_ov.
  READ TABLE lt_t060o ASSIGNING &lt;fs_t060o_new&gt; WITH TABLE KEY owner = p_nv.

  PERFORM compare_variants USING &lt;fs_t060o_old&gt;-slrep &lt;fs_t060o_old&gt;-slvar
                                 &lt;fs_t060o_new&gt;-slrep &lt;fs_t060o_new&gt;-slvar
                           CHANGING lv_pass.
  PERFORM display_variants USING &lt;fs_t060o_new&gt;-slrep &lt;fs_t060o_new&gt;-slvar.
  SKIP.

  IF lv_pass EQ abap_false.
    ADD 1 TO lv_subrc.
  ENDIF.

  LOOP AT lt_t060_old ASSIGNING &lt;fs_t060_old&gt;.
    READ TABLE lt_t060_new ASSIGNING &lt;fs_t060_new&gt; INDEX sy-tabix.
    IF &lt;fs_t060_new&gt; IS NOT ASSIGNED.
      CLEAR lv_error_msg.
      CONCATENATE &apos;New view &apos; p_nv &apos; does not have version &apos; &lt;fs_t060_old&gt;-versn
                  &apos; as old view &apos; p_ov &apos; thus comparison is impossible&apos; INTO lv_error_msg. &quot;#EC NOTEXT
      WRITE: / icon_yellow_light AS ICON, lv_error_msg.
      CONTINUE.
    ENDIF.

    PERFORM compare_variants USING &lt;fs_t060_old&gt;-exrep &lt;fs_t060_old&gt;-exvar
                                   &lt;fs_t060_new&gt;-exrep &lt;fs_t060_new&gt;-exvar
                             CHANGING lv_pass.
    IF lv_pass EQ abap_false.
      ADD 1 TO lv_subrc.
    ENDIF.
  ENDLOOP.

  sy-subrc = lv_subrc.
ENDFORM.

FORM handle_different_level USING iv_level TYPE i.
  DATA: lv_category TYPE string,
        lv_short TYPE c LENGTH 8,
        lv_key TYPE string.

  FIELD-SYMBOLS: &lt;fs_objec&gt; TYPE objec_tab.

  CASE iv_level.
    WHEN 10.  lv_category = &apos;BY GROUP&apos;. lv_short = &apos;GROUP&apos;.
    WHEN 20.  lv_category = &apos;BY CREDIT CONTROL AREA&apos;. lv_short = &apos;CCAREA&apos;.
    WHEN 30.  lv_category = &apos;BY COMPANY CODE&apos;. lv_short = &apos;CCODE&apos;.
    WHEN 40.  lv_category = &apos;BY BUSINESS AREA&apos;. lv_short = &apos;BAREA&apos;.
  ENDCASE.


  WRITE: / &apos;     //********************&apos;, lv_desc, &apos;[&apos;, lv_category COLOR COL_KEY, &apos;] START********************\\&apos;. &quot;#EC NOTEXT
  LOOP AT lt_objects ASSIGNING &lt;fs_objec&gt; WHERE versn EQ &lt;fs_t060_old&gt;-versn AND level EQ iv_level.
    CASE iv_level.
      WHEN 10.
        lv_tmp_hiebk = x_ff_hiebk.
        lv_tmp_hiegb = x_ff_hiegb.
        lv_tmp_spez2 = x_ff_spez2.
        CONCATENATE lv_short &apos;_&apos; sy-mandt INTO lv_temp_key.
      WHEN 20.
        lv_tmp_hiebk = x_ff_kkber.
        lv_tmp_hiegb = &lt;fs_objec&gt;-objec.
        IF lv_tmp_hiegb IS INITIAL.
          lv_key = &apos;NotAssigned&apos;.
        ELSE.
          lv_key = lv_tmp_hiegb.
        ENDIF.
        lv_tmp_spez2 = x_ff_spez2.
        CONCATENATE lv_short &apos;_&apos; lv_key INTO lv_temp_key.
      WHEN 30.
        lv_tmp_hiebk = &lt;fs_objec&gt;-objec.
        lv_tmp_hiegb = x_ff_hiegb.
        lv_tmp_spez2 = x_ff_spez2.
        CONCATENATE lv_short &apos;_&apos; lv_tmp_hiebk INTO lv_temp_key.
      WHEN 40.
        lv_tmp_hiebk = x_ff_hiebk.
        lv_tmp_hiegb = &lt;fs_objec&gt;-objec.
        IF lv_tmp_hiegb IS INITIAL.
          lv_key = &apos;NotAssigned&apos;.
        ELSE.
          lv_key = lv_tmp_hiegb.
        ENDIF.
        lv_tmp_spez2 = x_ff_spez2.
        lv_tmp_spez2 = x_ff_spez2.
        CONCATENATE lv_short &apos;_&apos; lv_key INTO lv_temp_key.
    ENDCASE.

    PERFORM compare_old_and_new_results.
    CLEAR lv_temp_key.
  ENDLOOP.

  IF lv_subrc NE 0 OR lv_subrc_detail NE 0.
    WRITE: / icon_red_light AS ICON, &apos;\\********************&apos;, lv_desc, &apos;[&apos;, lv_category, &apos;] ENDED&apos;, gc_error COLOR COL_NEGATIVE ,&apos;********************//&apos;, /. &quot;#EC NOTEXT
  ELSE.
    WRITE: / icon_green_light AS ICON, &apos;\\********************&apos;, lv_desc, &apos;[&apos;, lv_category, &apos;] ENDED&apos;, gc_success COLOR COL_POSITIVE ,&apos;********************//&apos;, /. &quot;#EC NOTEXT
  ENDIF.
  CLEAR: lv_subrc, lv_subrc_detail.
ENDFORM.

FORM compare_old_and_new_results.
  MOVE-CORRESPONDING &lt;fs_t060_old&gt; TO ls_rfrr_key_old.
  ls_rfrr_key_old-hiebk = lv_tmp_hiebk.
  ls_rfrr_key_old-hiegb = lv_tmp_hiegb.
  ls_rfrr_key_old-spez2 = lv_tmp_spez2.

  MOVE-CORRESPONDING &lt;fs_t060_new&gt; TO ls_rfrr_key_new.
  ls_rfrr_key_new-hiebk = lv_tmp_hiebk.
  ls_rfrr_key_new-hiegb = lv_tmp_hiegb.
  ls_rfrr_key_new-spez2 = lv_tmp_spez2.

  CASE p_awtyp.
    WHEN &apos;01&apos;.
      ls_rfrr_key_old-spez3 = lv_tmp_spez2.
      ls_rfrr_key_new-spez3 = lv_tmp_spez2.
    WHEN &apos;02&apos;.
    WHEN &apos;03&apos;.
    WHEN &apos;04&apos;.
    WHEN &apos;06&apos;.
      ls_rfrr_key_old-spez3 = lv_tmp_spez2.
      ls_rfrr_key_new-spez3 = lv_tmp_spez2.
  ENDCASE.

  IMPORT sum_t = &lt;fs_t_sum_old&gt; FROM DATABASE rfrr(rr) ID ls_rfrr_key_old.
  SORT &lt;fs_t_sum_old&gt; BY (lv_sum_sort_fld) DESCENDING.

  IMPORT sum_t = &lt;fs_t_sum_new&gt; FROM DATABASE rfrr(rr) ID ls_rfrr_key_new.
  SORT &lt;fs_t_sum_new&gt; BY (lv_sum_sort_fld) DESCENDING.

  IF p_down EQ abap_true AND p_dir IS NOT INITIAL.
    DATA lv_filename TYPE string.

    CONCATENATE ls_rfrr_key_old-versn &apos;_&apos; lv_temp_key &apos;_&apos; ls_rfrr_key_old-owner INTO lv_filename.
    PERFORM download_table USING &lt;fs_t_sum_old&gt; lv_filename gc_sum.
    CLEAR lv_filename.

    CONCATENATE ls_rfrr_key_new-versn &apos;_&apos; lv_temp_key &apos;_&apos; ls_rfrr_key_new-owner INTO lv_filename.
    PERFORM download_table USING &lt;fs_t_sum_new&gt; lv_filename gc_sum.
    CLEAR lv_filename.
  ENDIF.

  PERFORM compare_sum_results USING &lt;fs_t_sum_old&gt; &lt;fs_t_sum_new&gt; ls_rfrr_key_old ls_rfrr_key_new.
  CLEAR: ls_rfrr_key_old, ls_rfrr_key_new, lv_tmp_hiebk, lv_tmp_hiegb, lv_tmp_spez2.
ENDFORM.

* Before export to local file, there might be some calculation on sum results and top results such as terms offered/taken
FORM calc_sum_tab CHANGING it_sum TYPE STANDARD TABLE.
ENDFORM.

FORM calc_top_tab CHANGING it_top TYPE STANDARD TABLE.
ENDFORM.

FORM calc_sum CHANGING is_sum TYPE any.
ENDFORM.

FORM calc_top CHANGING is_top TYPE any.
ENDFORM.

FORM download_table USING it_tab TYPE STANDARD TABLE iv_keyinfo TYPE string iv_category TYPE category.
  IF it_tab IS INITIAL.
    EXIT.
  ENDIF.

  DATA lv_fullpath TYPE string.
  CONCATENATE p_dir &apos;\&apos; iv_category &apos;_&apos; iv_keyinfo &apos;.TXT&apos; INTO lv_fullpath.

  CALL METHOD cl_gui_frontend_services=&gt;gui_download
    EXPORTING
      write_field_separator   = &apos;X&apos;
      filename                = lv_fullpath
    CHANGING
      data_tab                = it_tab
    EXCEPTIONS
      file_write_error        = 1
      no_batch                = 2
      gui_refuse_filetransfer = 3
      invalid_type            = 4
      no_authority            = 5
      unknown_error           = 6
      header_not_allowed      = 7
      separator_not_allowed   = 8
      filesize_not_allowed    = 9
      header_too_long         = 10
      dp_error_create         = 11
      dp_error_send           = 12
      dp_error_write          = 13
      unknown_dp_error        = 14
      access_denied           = 15
      dp_out_of_memory        = 16
      disk_full               = 17
      dp_timeout              = 18
      file_not_found          = 19
      dataprovider_exception  = 20
      control_flush_error     = 21
      not_supported_by_gui    = 22
      error_no_gui            = 23
      OTHERS                  = 24.
ENDFORM.

FORM get_versn_dec USING is_t060 TYPE t060 CHANGING cv_desc TYPE string.
  FIELD-SYMBOLS: &lt;fs_t060t&gt; TYPE t060t.
  READ TABLE lt_t060t ASSIGNING &lt;fs_t060t&gt; WITH TABLE KEY owner = is_t060-owner koart = is_t060-koart
    awtyp = is_t060-awtyp versn = is_t060-versn.

  CLEAR cv_desc.
  IF &lt;fs_t060t&gt; IS ASSIGNED.
    cv_desc = &lt;fs_t060t&gt;-awbez.
    UNASSIGN &lt;fs_t060t&gt;.
  ELSE.
    cv_desc = is_t060-versn.
  ENDIF.
ENDFORM.

FORM validate_view USING iv_owner TYPE t060-owner iv_old TYPE abap_bool.
  DATA: lv_msg TYPE string,
        lv_str TYPE c LENGTH 3,
        ls_t060o TYPE t060o.

  IF iv_old EQ abap_true.
    lv_str = &apos;Old&apos;.
  ELSE.
    lv_str = &apos;New&apos;.
  ENDIF.

  IF iv_owner IS INITIAL.
    CONCATENATE &apos;Please Input &apos; lv_str &apos; Evaluation View Name!&apos; INTO lv_msg. &quot;#EC NOTEXT
    MESSAGE lv_msg TYPE &apos;E&apos;.
  ELSE.
    SELECT SINGLE * FROM t060o INTO ls_t060o WHERE owner = iv_owner.
    IF sy-subrc NE 0.
      CONCATENATE &apos;The &apos; lv_str &apos; Evaluation View Name you input does not exist!&apos; INTO lv_msg. &quot;#EC NOTEXT
      MESSAGE lv_msg TYPE &apos;E&apos;.
    ELSE.
      IF iv_old EQ abap_true AND ls_t060o-slrep NE &apos;RFDRRSEL&apos;.
        MESSAGE text-009 TYPE &apos;E&apos;.
      ENDIF.

      IF iv_old EQ abap_false AND ls_t060o-slrep EQ &apos;RFDRRSEL&apos;.
        MESSAGE text-010 TYPE &apos;E&apos;.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.

FORM validate_awtyp USING iv_awtyp TYPE t060-awtyp.
  DATA ls_t060 TYPE t060.

  IF iv_awtyp IS INITIAL.
    MESSAGE text-011 TYPE &apos;E&apos;.       &quot;#EC NOTEXT
  ELSEIF NOT ( iv_awtyp EQ &apos;01&apos; OR iv_awtyp EQ &apos;02&apos; OR iv_awtyp EQ &apos;03&apos; OR
               iv_awtyp EQ &apos;04&apos; OR iv_awtyp EQ &apos;05&apos; OR iv_awtyp EQ &apos;06&apos; ).
      MESSAGE text-012 TYPE &apos;E&apos;. &quot;#EC NOTEXT

      IF iv_awtyp EQ &apos;02&apos; OR iv_awtyp EQ &apos;03&apos;.
        MESSAGE &apos;Payment History and Currency Analysis Will Be Supported Next Takt.&apos; TYPE &apos;E&apos;. &quot;#EC NOTEXT
      ENDIF.
  ENDIF.
ENDFORM.

FORM select_download_dir CHANGING cv_dir TYPE string.
  cl_gui_frontend_services=&gt;directory_browse(
    EXPORTING
      window_title         =     &apos;Once Upon There Was A X MAN WHO Loves F.19&amp;F.30 So Much...&apos;
    CHANGING
      selected_folder      =     cv_dir
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4
  ).
  IF sy-subrc &lt;&gt; 0.
    MESSAGE text-013 TYPE &apos;E&apos;.
  ENDIF.
ENDFORM.

FORM compare_variants USING iv_old_repid TYPE rr_exrep iv_old_var TYPE rr_exvar
                            iv_new_repid TYPE rr_exrep iv_new_var TYPE rr_exvar
                      CHANGING cv_result TYPE abap_bool.
  DATA: lt_param_old TYPE t_params,
        lt_param_new TYPE t_params,
        del_tab TYPE t_params,
        add_tab TYPE t_params,
        mod_tab TYPE t_params,
        lv_error_msg TYPE string.

  CLEAR cv_result.

  CALL FUNCTION &apos;RS_VARIANT_CONTENTS&apos;
    EXPORTING
      report               = iv_old_repid
      variant              = iv_old_var
    TABLES
      valutab              = lt_param_old
    EXCEPTIONS
      variant_non_existent = 1
      variant_obsolete     = 2
      OTHERS               = 3.

  IF sy-subrc NE 0.
    CONCATENATE &apos;Read Variant &apos; iv_old_var &apos; of &apos; iv_old_repid &apos; failed, PLS CHECK it.&apos; INTO lv_error_msg. &quot;#EC NOTEXT
    WRITE: / icon_red_light AS ICON, lv_error_msg.
  ELSE.
    SORT lt_param_old BY selname ASCENDING.
  ENDIF.

  CALL FUNCTION &apos;RS_VARIANT_CONTENTS&apos;
    EXPORTING
      report               = iv_new_repid
      variant              = iv_new_var
    TABLES
      valutab              = lt_param_new
    EXCEPTIONS
      variant_non_existent = 1
      variant_obsolete     = 2
      OTHERS               = 3.

  IF sy-subrc NE 0.
    CLEAR lv_error_msg.
    CONCATENATE &apos;Read Variant &apos; iv_new_var &apos; of &apos; iv_new_repid &apos; failed, PLS CHECK it.&apos; INTO lv_error_msg. &quot;#EC NOTEXT
    WRITE: / icon_red_light AS ICON, lv_error_msg.
  ELSE.
    SORT lt_param_new BY selname ASCENDING.
  ENDIF.

  IF lt_param_old EQ lt_param_new.
    cv_result = abap_true.
  ELSE.
    CALL FUNCTION &apos;CTVB_COMPARE_TABLES&apos;
      EXPORTING
        table_old  = lt_param_old[]
        table_new  = lt_param_new[]
        key_length = 22
      IMPORTING
        table_del  = del_tab[]
        table_add  = add_tab[]
        table_mod  = mod_tab[].

    IF del_tab IS INITIAL AND add_tab IS INITIAL AND mod_tab IS INITIAL.
      cv_result = abap_true.
    ELSE.
      IF p_logd EQ abap_true.
        PERFORM display_vari_changes USING del_tab gc_deleted.
        PERFORM display_vari_changes USING add_tab gc_added.
        PERFORM dis_vari_mod_changes USING mod_tab lt_param_old.
      ENDIF.

      CLEAR lv_error_msg.
      CONCATENATE &apos;Variant&apos; iv_old_repid &apos;-&apos; iv_old_var &apos;DIFFERS FROM&apos;
                  iv_new_repid &apos;-&apos; iv_new_var &apos;, DO CHECK THEM!&apos; INTO lv_error_msg SEPARATED BY &apos; &apos;. &quot;#EC NOTEXT
      WRITE:/ icon_red_light AS ICON, lv_error_msg.
      ULINE.
    ENDIF.
  ENDIF.
ENDFORM.

FORM display_variants USING iv_repid TYPE rr_exrep iv_var TYPE rr_exvar.
  DATA: lt_sub_params TYPE t_params,
        ls_param TYPE rsparams,
        lv_index TYPE i.

  CALL FUNCTION &apos;RS_VARIANT_CONTENTS&apos;
    EXPORTING
      report  = iv_repid
      variant = iv_var
    TABLES
      valutab = lt_sub_params.

  CLEAR: lv_4group, lv_4cca, lv_4ccode, lv_4barea.

  DATA: lv_str TYPE string VALUE &apos;....&apos;. &quot;#EC NOTEXT
  CONCATENATE lv_str &apos;Variant [&apos; iv_repid &apos;-&apos; iv_var &apos;] detail:|&apos; INTO lv_str.

  LOOP AT lt_sub_params INTO ls_param.
    CASE ls_param-selname.
      WHEN &apos;PA_LEVLM&apos;.  lv_4group = ls_param-low.
      WHEN &apos;PA_LEVLK&apos;.  lv_4cca = ls_param-low.
      WHEN &apos;PA_LEVLB&apos;.  lv_4ccode = ls_param-low.
      WHEN &apos;PA_LEVLG&apos;.  lv_4barea = ls_param-low.
    ENDCASE.

    IF ls_param-low IS INITIAL AND ls_param-high IS INITIAL AND
       ls_param-option IS INITIAL AND ls_param-sign IS INITIAL.
      CONTINUE.
    ENDIF.

    CONCATENATE lv_str ls_param-selname &apos;:&apos; ls_param-low &apos;|&apos; INTO lv_str. &quot;#EC NOTEXT
    ADD 1 TO lv_index.

    IF lv_index EQ 10.
      WRITE: / lv_str.
      lv_str = &apos;~~~~&apos;.
      lv_index = 0.
    ENDIF.
  ENDLOOP.
  WRITE: / lv_str, &apos;....&apos;.                          &quot;#EC NOTEXT
ENDFORM.

FORM display_vari_changes USING it_tab TYPE t_params iv_tab_type TYPE change_type.
  IF it_tab IS NOT INITIAL.
    WRITE: / &apos;Compared to the old variants, &apos;, iv_tab_type COLOR COL_KEY ,&apos;results are listed in the below:&apos;. &quot;#EC NOTEXT

    DATA lv_str TYPE string.
    FIELD-SYMBOLS: &lt;fs_tab&gt; TYPE rsparams.
    LOOP AT it_tab ASSIGNING &lt;fs_tab&gt;.
      PERFORM vari_to_str USING &lt;fs_tab&gt; CHANGING lv_str.
      WRITE: / lv_str.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM dis_vari_mod_changes USING it_mod_tab TYPE t_params it_old TYPE t_params.
  IF it_mod_tab IS NOT INITIAL.
    WRITE: / &apos;Compared to the old variants, &apos;, gc_modified COLOR COL_KEY ,&apos;results are listed in the below:&apos;. &quot;#EC NOTEXT

    DATA: lv_old_str TYPE string,
          lv_new_str TYPE string.
    FIELD-SYMBOLS: &lt;fs_tab&gt; TYPE rsparams,
                   &lt;fs_old_tab&gt; TYPE rsparams.
    LOOP AT it_mod_tab ASSIGNING &lt;fs_tab&gt;.
      READ TABLE it_old ASSIGNING &lt;fs_old_tab&gt; WITH KEY selname = &lt;fs_tab&gt;-selname.
      IF &lt;fs_old_tab&gt; IS ASSIGNED.
        PERFORM vari_to_str USING &lt;fs_old_tab&gt; CHANGING lv_old_str.
        PERFORM vari_to_str USING &lt;fs_tab&gt; CHANGING lv_new_str.
        WRITE: / &apos;Old:&apos;, lv_old_str, &apos; | New:&apos;, lv_new_str. &quot;#EC NOTEXT
        UNASSIGN &lt;fs_old_tab&gt;.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM vari_to_str USING is_var TYPE rsparams CHANGING cv_str TYPE string.
  CLEAR cv_str.
  CONCATENATE &apos;[Name]:&apos; is_var-selname &apos;[Sign]:&apos; is_var-sign
              &apos;[Low]:&apos; is_var-low &apos;[High]:&apos; is_var-high &apos;[Option]:&apos; is_var-option INTO cv_str. &quot;#EC NOTEXT
ENDFORM.

FORM compare_results USING it_old TYPE STANDARD TABLE it_new TYPE STANDARD TABLE
                           iv_category TYPE category iv_header TYPE string.
  IF it_old EQ it_new.
    IF p_logc EQ abap_true.
      WRITE: / icon_green_light AS ICON, iv_header, &apos;......Congratulations!The &apos;, iv_category,&apos; results are exactly same!......&apos;. &quot;#EC NOTEXT
    ENDIF.
  ELSE.
    DATA: del_tab TYPE REF TO data,
          add_tab TYPE REF TO data,
          mod_tab TYPE REF TO data,
          lv_stru TYPE string.

    FIELD-SYMBOLS: &lt;fs_del_tab&gt;   TYPE ANY TABLE,
                   &lt;fs_add_tab&gt;   TYPE ANY TABLE,
                   &lt;fs_mod_tab&gt;   TYPE ANY TABLE.

    IF iv_category EQ gc_sum.
      lv_stru = lv_sum_stru.
    ELSE.
      lv_stru = lv_top_stru.
    ENDIF.

    CREATE DATA del_tab TYPE TABLE OF (lv_stru).
    ASSIGN del_tab-&gt;* TO &lt;fs_del_tab&gt;.

    CREATE DATA add_tab TYPE TABLE OF (lv_stru).
    ASSIGN add_tab-&gt;* TO &lt;fs_add_tab&gt;.

    CREATE DATA mod_tab TYPE TABLE OF (lv_stru).
    ASSIGN mod_tab-&gt;* TO &lt;fs_mod_tab&gt;.

    CALL FUNCTION &apos;CTVB_COMPARE_TABLES&apos;
      EXPORTING
        table_old  = it_old[]
        table_new  = it_new[]
        key_length = 22
      IMPORTING
        table_del  = &lt;fs_del_tab&gt;[]
        table_add  = &lt;fs_add_tab&gt;[]
        table_mod  = &lt;fs_mod_tab&gt;[].

    IF &lt;fs_del_tab&gt; IS NOT INITIAL OR &lt;fs_add_tab&gt; IS NOT INITIAL OR &lt;fs_mod_tab&gt; IS NOT INITIAL.
      WRITE: / icon_red_light AS ICON, iv_header, &apos;......OH NO!The &apos;, iv_category, &apos; results are not same!......&apos;. &quot;#EC NOTEXT
      IF iv_category EQ gc_sum.
        lv_subrc = 8.
      ELSE.
        lv_subrc_detail = 8.
      ENDIF.

      IF p_logd EQ abap_true.
        PERFORM display_changes USING &lt;fs_del_tab&gt; iv_category gc_deleted.
        PERFORM display_changes USING &lt;fs_add_tab&gt; iv_category gc_added.
        PERFORM display_mod_changes USING &lt;fs_mod_tab&gt; it_old iv_category.
        ULINE.
      ENDIF.
    ELSE.
      IF p_logc EQ abap_true.
        WRITE: / icon_green_light AS ICON, iv_header, &apos;......Congratulations!The &apos;, iv_category, &apos; results are exactly same!......&apos;. &quot;#EC NOTEXT
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.

FORM compare_sum_results  USING it_old TYPE STANDARD TABLE it_new TYPE STANDARD TABLE is_key_old TYPE rfrrkey is_key_new TYPE rfrrkey.
  DATA: lv_header TYPE string,
        ls_key_old TYPE rfrrkey,
        ls_key_new TYPE rfrrkey,
        lr_old TYPE REF TO data,
        lr_new TYPE REF TO data,
        lv_filename TYPE string,
        lv_comp_name TYPE c LENGTH 5 VALUE &apos;SPEZ2&apos;.

  FIELD-SYMBOLS: &lt;fs_t_old&gt; TYPE ANY TABLE,
                 &lt;fs_t_new&gt; TYPE ANY TABLE,
                 &lt;fs_old_sum&gt; TYPE any,
                 &lt;fs_new_sum&gt; TYPE any,
                 &lt;fs_spez2_old&gt; TYPE any,
                 &lt;fs_spez2_new&gt; TYPE any.

  CONCATENATE &apos;[&apos; lv_temp_key &apos;]&apos; INTO lv_header.
  PERFORM compare_results USING it_old it_new gc_sum lv_header.

  MOVE is_key_old TO ls_key_old.
  MOVE is_key_new TO ls_key_new.

  CASE p_awtyp.
    WHEN &apos;01&apos;.
      ls_key_old-spez3 = &apos;GESAMT&apos;.
      ls_key_new-spez3 = &apos;GESAMT&apos;.
    WHEN &apos;02&apos;.
    WHEN &apos;03&apos;.
    WHEN &apos;04&apos;.
    WHEN &apos;05&apos;.
    WHEN &apos;06&apos;.
      CLEAR: ls_key_old-spez3, ls_key_new-spez3.
  ENDCASE.

  LOOP AT it_old ASSIGNING &lt;fs_old_sum&gt;.
    CREATE DATA lr_old TYPE STANDARD TABLE OF (lv_top_stru).
    ASSIGN lr_old-&gt;* TO &lt;fs_t_old&gt;.

    CREATE DATA lr_new TYPE STANDARD TABLE OF (lv_top_stru).
    ASSIGN lr_new-&gt;* TO &lt;fs_t_new&gt;.

    ASSIGN COMPONENT lv_comp_name OF STRUCTURE &lt;fs_old_sum&gt; TO &lt;fs_spez2_old&gt;.
    IF &lt;fs_spez2_old&gt; IS ASSIGNED.
      ls_key_old-spez2 = &lt;fs_spez2_old&gt;.
    ELSE.
      CONTINUE.
    ENDIF.

    READ TABLE it_new ASSIGNING &lt;fs_new_sum&gt; WITH KEY (lv_comp_name) = &lt;fs_spez2_old&gt;.
    IF &lt;fs_new_sum&gt; IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    ASSIGN COMPONENT lv_comp_name OF STRUCTURE &lt;fs_new_sum&gt; TO &lt;fs_spez2_new&gt;.
    IF &lt;fs_spez2_new&gt; IS ASSIGNED.
      ls_key_new-spez2 = &lt;fs_spez2_new&gt;.
    ELSE.
      CONTINUE.
    ENDIF.

    IMPORT top_n = &lt;fs_t_old&gt; FROM DATABASE rfrr(rr) ID ls_key_old.
    SORT &lt;fs_t_old&gt; BY (lv_top_sort_fld) DESCENDING.

    IMPORT top_n = &lt;fs_t_new&gt; FROM DATABASE rfrr(rr) ID ls_key_new.
    SORT &lt;fs_t_new&gt; BY (lv_top_sort_fld) DESCENDING.

    IF p_down EQ abap_true AND p_dir IS NOT INITIAL.
      CONCATENATE ls_key_old-versn &apos;_&apos; lv_temp_key &apos;_&apos; ls_key_old-spez2 &apos;_&apos; ls_key_old-owner INTO lv_filename.
      PERFORM export_detail_reports USING &lt;fs_t_old&gt; lv_filename.
      CLEAR lv_filename.

      CONCATENATE ls_key_new-versn &apos;_&apos; lv_temp_key &apos;_&apos; ls_key_new-spez2 &apos;_&apos; ls_key_new-owner INTO lv_filename.
      PERFORM export_detail_reports USING &lt;fs_t_new&gt; lv_filename.
      CLEAR lv_filename.
    ENDIF.
    IF &lt;fs_spez2_old&gt; IS INITIAL.
      lv_header = &apos;  --NotAssigned&apos;.
    ELSE.
      CONCATENATE &apos;  --&apos; &lt;fs_spez2_old&gt; INTO lv_header.
    ENDIF.

    PERFORM compare_results USING &lt;fs_t_old&gt; &lt;fs_t_new&gt; gc_top lv_header.

    CLEAR: lr_old, lr_new.
    UNASSIGN: &lt;fs_t_old&gt;, &lt;fs_t_new&gt;, &lt;fs_spez2_old&gt;, &lt;fs_spez2_new&gt;.
  ENDLOOP.
ENDFORM.

FORM export_detail_reports USING it_top_n TYPE STANDARD TABLE iv_keyinfo TYPE string.
  DATA: lr_stru TYPE REF TO data,
        lr_top_n TYPE REF TO data,
        lr_top_n_text TYPE REF TO data,
        ls_kna1 TYPE kna1_lc,
        lv_fullpath TYPE string.

  FIELD-SYMBOLS: &lt;fs_top&gt; TYPE any,
                 &lt;fs_stru&gt; TYPE any,
                 &lt;fs_kunnr&gt; TYPE kunnr,
                 &lt;fs_text&gt; TYPE any,
                 &lt;fs_table&gt; TYPE STANDARD TABLE.

  CREATE DATA lr_top_n_text TYPE STANDARD TABLE OF (lv_top_text_stru).
  ASSIGN lr_top_n_text-&gt;* TO &lt;fs_table&gt;.

  CREATE DATA lr_top_n TYPE (lv_top_stru).
  ASSIGN lr_top_n-&gt;* TO &lt;fs_top&gt;.

  CREATE DATA lr_stru TYPE (lv_top_text_stru).
  ASSIGN lr_stru-&gt;* TO &lt;fs_stru&gt;.

  LOOP AT it_top_n ASSIGNING &lt;fs_top&gt;.
    PERFORM move_top_fs_values USING &lt;fs_top&gt; CHANGING &lt;fs_stru&gt;.
    ASSIGN COMPONENT gc_detail_text OF STRUCTURE &lt;fs_stru&gt; TO &lt;fs_text&gt;.
    CASE p_awtyp.
      WHEN &apos;01&apos;.
      WHEN &apos;02&apos;.
      WHEN &apos;03&apos;.
      WHEN &apos;04&apos;.
      WHEN &apos;05&apos; OR &apos;06&apos;.
        ASSIGN COMPONENT &apos;KUNNR&apos; OF STRUCTURE &lt;fs_top&gt; TO &lt;fs_kunnr&gt;.
        READ TABLE lt_kna1_lc INTO ls_kna1 WITH TABLE KEY kunnr = &lt;fs_kunnr&gt;.
        &lt;fs_text&gt; = ls_kna1-name1.
    ENDCASE.

    APPEND &lt;fs_stru&gt; TO &lt;fs_table&gt;.
  ENDLOOP.

  SORT &lt;fs_table&gt; BY (lv_top_sort_fld) DESCENDING (gc_detail_text) ASCENDING.
  PERFORM download_table USING &lt;fs_table&gt; iv_keyinfo gc_top.
ENDFORM.

FORM move_top_fs_values USING fs_1 TYPE any CHANGING fs_2 TYPE ANY.
  FIELD-SYMBOLS: &lt;comp&gt; TYPE abap_compdescr,
                 &lt;fs_c1&gt; type any,
                 &lt;fs_c2&gt; type any.

  LOOP AT lo_top_stru_desc-&gt;components ASSIGNING &lt;comp&gt;.
    ASSIGN COMPONENT &lt;comp&gt;-name OF STRUCTURE fs_1 to &lt;fs_c1&gt;.
    ASSIGN COMPONENT &lt;comp&gt;-name OF STRUCTURE fs_2 to &lt;fs_c2&gt;.
    &lt;fs_c2&gt; = &lt;fs_c1&gt;.
  ENDLOOP.
ENDFORM.

FORM get_components USING iv_category TYPE category CHANGING ct_compnents TYPE abap_compdescr_tab.
  CLEAR ct_compnents.

  CASE iv_category.
    WHEN gc_sum.  ct_compnents = lo_sum_stru_desc-&gt;components.
    WHEN gc_top.  ct_compnents = lo_top_stru_desc-&gt;components.
    WHEN gc_top_text.  ct_compnents = lo_top_text_stru_desc-&gt;components.
    WHEN OTHERS. ASSERT 1 = 0.
  ENDCASE.
ENDFORM.

FORM display_changes USING it_tab TYPE STANDARD TABLE iv_category TYPE category iv_tab_type TYPE change_type.
  DATA: lt_compnents TYPE abap_compdescr_tab,
        lv_str TYPE string.
  FIELD-SYMBOLS: &lt;fs_tab&gt; TYPE any.

  IF it_tab IS NOT INITIAL.
    WRITE: / &apos;Compared to the old&apos;, iv_category COLOR COL_KEY ,&apos;results, &apos;, iv_tab_type COLOR COL_KEY, &apos; results are listed in the below:&apos;. &quot;#EC NOTEXT
    PERFORM get_components USING iv_category CHANGING lt_compnents.
    LOOP AT it_tab ASSIGNING &lt;fs_tab&gt;.
      PERFORM display_components USING &lt;fs_tab&gt; lt_compnents lv_str.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM display_mod_changes USING it_mod_tab TYPE STANDARD TABLE it_old TYPE STANDARD TABLE iv_category TYPE category.
  IF it_mod_tab IS NOT INITIAL.
    WRITE: / &apos;Compared to the old &apos;, iv_category COLOR COL_KEY ,&apos; results, &apos;, gc_modified COLOR COL_KEY, &apos; results are listed in the below:&apos;. &quot;#EC NOTEXT

    DATA: lt_compnents TYPE abap_compdescr_tab,
          lv_str TYPE string,
          lv_fld_name TYPE c LENGTH 5.
    FIELD-SYMBOLS: &lt;fs_tab&gt; TYPE any,
                   &lt;fs_old_tab&gt; TYPE any,
                   &lt;fs_spez2&gt; TYPE any.

    PERFORM get_components USING iv_category CHANGING lt_compnents.

    IF iv_category EQ gc_sum.
      lv_fld_name = &apos;SPEZ2&apos;.
    ELSE.
      lv_fld_name = &apos;KUNNR&apos;.
    ENDIF.

    LOOP AT it_mod_tab ASSIGNING &lt;fs_tab&gt;.
      ASSIGN COMPONENT lv_fld_name OF STRUCTURE &lt;fs_tab&gt; TO &lt;fs_spez2&gt;.
      READ TABLE it_old ASSIGNING &lt;fs_old_tab&gt; WITH KEY (lv_fld_name) = &lt;fs_spez2&gt;.

      IF &lt;fs_old_tab&gt; IS ASSIGNED.
        lv_str = &apos;OLD:&apos;.
        PERFORM display_components USING &lt;fs_old_tab&gt; lt_compnents lv_str.

        lv_str = &apos;NEW:&apos;.
        PERFORM display_components USING &lt;fs_tab&gt; lt_compnents lv_str.
        UNASSIGN &lt;fs_old_tab&gt;.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.

FORM display_components USING is_data TYPE any it_component TYPE abap_compdescr_tab
                        CHANGING cv_str TYPE string.
  DATA: lv_index TYPE i,
        lv_tmp TYPE string.
  FIELD-SYMBOLS: &lt;fs_comp&gt; LIKE LINE OF it_component,
                 &lt;fs_fld&gt; TYPE any.

  LOOP AT it_component ASSIGNING &lt;fs_comp&gt;.
    ASSIGN COMPONENT &lt;fs_comp&gt;-name OF STRUCTURE is_data TO &lt;fs_fld&gt;.
    lv_tmp = &lt;fs_fld&gt;.
    CONCATENATE cv_str &lt;fs_comp&gt;-name &apos;:&apos; lv_tmp &apos;,&apos; INTO cv_str.

    ADD 1 TO lv_index.
    IF lv_index EQ 10.
      WRITE: / cv_str.
      cv_str = &apos;~~~~&apos;.
      lv_index = 0.
    ENDIF.
  ENDLOOP.
  WRITE: / cv_str.
  CLEAR: cv_str, lv_index.
ENDFORM.</source>
 </PROG>
 <PROG NAME="ZF30_TEST_TOOL" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="F30 Optimization Regression Test Tool : Are The Results Same?" LENGTH="61 "/>
   </language>
  </textPool>
  <source>REPORT zf30_test_tool.

INCLUDE zf30_test_top.

PARAMETERS: p_ov TYPE t060-owner,
            p_nv TYPE t060-owner,
            p_awtyp TYPE t060-awtyp,
            p_logc TYPE abap_bool AS CHECKBOX,
            p_logf TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
            p_logd TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
            p_down TYPE abap_bool AS CHECKBOX DEFAULT abap_false,
            p_dir TYPE string.

INITIALIZATION.
  high_value-high = cl_abap_char_utilities=&gt;maxchar.
  low_value-low   = cl_abap_char_utilities=&gt;minchar.
  TRANSLATE x_ff_kkber-ff USING high_value.
  TRANSLATE x_ff_hiebk    USING high_value.
  TRANSLATE x_ff_hiegb    USING high_value.
  TRANSLATE x_ff_spez2    USING high_value.
  TRANSLATE x_00_spez2    USING low_value.

AT SELECTION-SCREEN ON p_ov.
  PERFORM validate_view USING p_ov abap_true.

AT SELECTION-SCREEN ON p_nv.
  PERFORM validate_view USING p_nv abap_false.

AT SELECTION-SCREEN ON p_awtyp.
  PERFORM validate_awtyp USING p_awtyp.

AT SELECTION-SCREEN ON p_dir.
  IF p_down EQ abap_true AND p_dir IS INITIAL.
    MESSAGE text-001 TYPE &apos;E&apos;.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_dir.
  PERFORM select_download_dir CHANGING p_dir.

START-OF-SELECTION.
  PERFORM init_data.
  PERFORM validate_variants.
  IF sy-subrc NE 0.
    WRITE: / text-002.
    RETURN.
  ENDIF.
  PERFORM init_objec_tab.
  PERFORM init_stru_metadata.

  DATA: lt_t060_old TYPE TABLE OF t060,
        lt_t060_new TYPE TABLE OF t060,
        ls_rfrr_key_old TYPE rfrrkey,
        ls_rfrr_key_new TYPE rfrrkey,
        lt_objects TYPE tt_object_tab,
        lv_desc TYPE string,
        lv_4group TYPE abap_bool,
        lv_4cca TYPE abap_bool,
        lv_4ccode TYPE abap_bool,
        lv_4barea TYPE abaP_bool,
        lv_tmp_hiebk TYPE bukrs,
        lv_tmp_hiegb TYPE gsber,
        lv_tmp_spez2 TYPE rr_spez2,
        lv_subrc TYPE sy-subrc,
        lv_subrc_detail TYPE sy-subrc,
        lv_temp_key TYPE string,
        lt_sum_old TYPE REF TO DATA,
        lt_sum_new TYPE REF TO DATA.

  FIELD-SYMBOLS: &lt;fs_t060_old&gt; TYPE t060,
                 &lt;fs_t060_new&gt; TYPE t060,
                 &lt;fs_t_sum_old&gt; TYPE STANDARD TABLE,
                 &lt;fs_t_sum_new&gt; TYPE STANDARD TABLE,
                 &lt;fs_sum&gt; TYPE any,
                 &lt;fs_sum_fld&gt; TYPE any.

  CREATE DATA lt_sum_old TYPE TABLE OF (lv_sum_stru).
  ASSIGN lt_sum_old-&gt;* TO &lt;fs_t_sum_old&gt;.

  CREATE DATA lt_sum_new TYPE TABLE OF (lv_sum_stru).
  ASSIGN lt_sum_new-&gt;* TO &lt;fs_t_sum_new&gt;.

  LOOP AT lt_t060_old ASSIGNING &lt;fs_t060_old&gt;.
    READ TABLE lt_t060_new ASSIGNING &lt;fs_t060_new&gt; INDEX sy-tabix.
    IF &lt;fs_t060_new&gt; IS NOT ASSIGNED.
      CONTINUE.
    ENDIF.

    PERFORM get_versn_dec USING &lt;fs_t060_old&gt; CHANGING lv_desc.
    WRITE: / text-003, lv_desc COLOR COL_TOTAL , text-004.
    PERFORM display_variants USING &lt;fs_t060_old&gt;-exrep  &lt;fs_t060_old&gt;-exvar.

    IF lv_4group EQ abap_true.
      PERFORM handle_different_level USING 10.
    ENDIF.

    IF lv_4cca EQ abap_true.
      PERFORM handle_different_level USING 20.
    ENDIF.

    IF lv_4ccode EQ abap_true.
      PERFORM handle_different_level USING 30.
    ENDIF.

    IF lv_4barea EQ abap_true.
      PERFORM handle_different_level USING 40.
    ENDIF.
    WRITE: / text-003, lv_desc , text-005, /.
  ENDLOOP.

INCLUDE ZF30_TEST_FORMS.</source>
 </PROG>
 <PROG NAME="ZF30_TEST_TOP" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="F.30 Test Tool: Constants, Data and Types Definition" LENGTH="52 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZF30_TEST_TOP
*&amp;---------------------------------------------------------------------*
TYPE-POOLS: icon.

* sum_t and top_n types start, name convention is sum_t_&lt;awtyp&gt; and top_n_&lt;awtyp&gt;
TYPES: BEGIN OF sum_t_01,
        spez2 LIKE rfrrkey-spez2,
        sfae4 LIKE rfrrd01-sfae4,
        sfae3 LIKE rfrrd01-sfae3,
        sfae2 LIKE rfrrd01-sfae2,
        sfae1 LIKE rfrrd01-sfae1,
        snfa1 LIKE rfrrd01-snfa1,
        snfa2 LIKE rfrrd01-snfa2,
        snfa3 LIKE rfrrd01-snfa3,
        snfa4 LIKE rfrrd01-snfa4,
        sfael LIKE rfrrd01-sfael,
        snfae LIKE rfrrd01-snfae,
        ssumo LIKE rfrrd01-ssumo,
      END OF sum_t_01.
TYPES: BEGIN OF top_n_01,
        kunnr LIKE rfrrd01-kunnr,
        tfae4 LIKE rfrrd01-tfae4,
        tfae3 LIKE rfrrd01-tfae3,
        tfae2 LIKE rfrrd01-tfae2,
        tfae1 LIKE rfrrd01-tfae1,
        tnfa1 LIKE rfrrd01-tnfa1,
        tnfa2 LIKE rfrrd01-tnfa2,
        tnfa3 LIKE rfrrd01-tnfa3,
        tnfa4 LIKE rfrrd01-tnfa4,
        tfael LIKE rfrrd01-tfael,
        tnfae LIKE rfrrd01-tnfae,
        tsumo LIKE rfrrd01-tsumo,
      END OF top_n_01.
TYPES: BEGIN OF top_n_text_01,
        text1 TYPE c LENGTH 35,
        kunnr LIKE rfrrd01-kunnr,
        tfae4 LIKE rfrrd01-tfae4,
        tfae3 LIKE rfrrd01-tfae3,
        tfae2 LIKE rfrrd01-tfae2,
        tfae1 LIKE rfrrd01-tfae1,
        tnfa1 LIKE rfrrd01-tnfa1,
        tnfa2 LIKE rfrrd01-tnfa2,
        tnfa3 LIKE rfrrd01-tnfa3,
        tnfa4 LIKE rfrrd01-tnfa4,
        tfael LIKE rfrrd01-tfael,
        tnfae LIKE rfrrd01-tnfae,
        tsumo LIKE rfrrd01-tsumo,
      END OF top_n_text_01.

TYPES: BEGIN OF sum_t_02,
        spez2 LIKE rfrrkey-spez2,
        spez3 LIKE rfrrkey-spez3,
        stg01 LIKE rfrrd02-stg01,
        sbt01 LIKE rfrrd02-sbt01,
        szi01 LIKE rfrrd02-szi01,
        stg02 LIKE rfrrd02-stg02,
        sbt02 LIKE rfrrd02-sbt02,
        szi02 LIKE rfrrd02-szi02,
        stg03 LIKE rfrrd02-stg03,
        sbt03 LIKE rfrrd02-sbt03,
        szi03 LIKE rfrrd02-szi03,
      END OF sum_t_02.
TYPES: BEGIN OF top_n_02,
        kunnr LIKE rfrrd02-kunnr,
        ttg01 LIKE rfrrd02-ttg01,
        tbt01 LIKE rfrrd02-tbt01,
        tzi01 LIKE rfrrd02-tzi01,
        ttg02 LIKE rfrrd02-ttg02,
        tbt02 LIKE rfrrd02-tbt02,
        tzi02 LIKE rfrrd02-tzi02,
        ttg03 LIKE rfrrd02-ttg03,
        tbt03 LIKE rfrrd02-tbt03,
        tzi03 LIKE rfrrd02-tzi03,
      END OF top_n_02.
TYPES: BEGIN OF top_n_text_02,
        text1 TYPE c LENGTH 35,
        kunnr LIKE rfrrd02-kunnr,
        ttg01 LIKE rfrrd02-ttg01,
        tbt01 LIKE rfrrd02-tbt01,
        tzi01 LIKE rfrrd02-tzi01,
        ttg02 LIKE rfrrd02-ttg02,
        tbt02 LIKE rfrrd02-tbt02,
        tzi02 LIKE rfrrd02-tzi02,
        ttg03 LIKE rfrrd02-ttg03,
        tbt03 LIKE rfrrd02-tbt03,
        tzi03 LIKE rfrrd02-tzi03,
      END OF top_n_text_02.

TYPES: BEGIN OF sum_t_03,
        spez2 LIKE rfrrkey-spez2,
        spez3 LIKE rfrrkey-spez3,
        swrsh LIKE rfrrd03-sdmsh,
        sdmsh LIKE rfrrd03-swrsh,
        saksh LIKE rfrrd03-saksh,
        sdiff LIKE rfrrd03-sdiff,
      END OF sum_t_03.
TYPES: BEGIN OF top_n_03,
        kunnr LIKE rfrrd03-kunnr,
        tdmsh LIKE rfrrd03-tdmsh,
        twrsh LIKE rfrrd03-twrsh,
        taksh LIKE rfrrd03-taksh,
        tdiff LIKE rfrrd03-tdiff,
      END OF top_n_03.
TYPES: BEGIN OF top_n_text_03,
        kunnr LIKE rfrrd03-kunnr,
        tdmsh LIKE rfrrd03-tdmsh,
        twrsh LIKE rfrrd03-twrsh,
        taksh LIKE rfrrd03-taksh,
        tdiff LIKE rfrrd03-tdiff,
      END OF top_n_text_03.

TYPES: BEGIN OF sum_t_04,
        spez2 LIKE rfrrkey-spez2,
        svtag LIKE rfrrd04-svtag,
        szinz LIKE rfrrd04-szinz,
        sdms4 LIKE rfrrd04-sdms4,
      END OF sum_t_04.
TYPES: BEGIN OF top_n_04,
        bukrs LIKE rfrrd04-bukrs,
        belnr LIKE rfrrd04-belnr,
        gjahr LIKE rfrrd04-gjahr,
        buzei LIKE rfrrd04-buzei,
        kunnr LIKE rfrrd04-kunnr,
        tvtag LIKE rfrrd04-tvtag,
        tzinz LIKE rfrrd04-tzinz,
        tdms4 LIKE rfrrd04-tdms4,
        netdt LIKE rfrrd04-netdt,
      END OF top_n_04.
TYPES: BEGIN OF top_n_text_04,
        text1 TYPE c LENGTH 35,
        text2 TYPE c LENGTH 35,
        bukrs LIKE rfrrd04-bukrs,
        belnr LIKE rfrrd04-belnr,
        gjahr LIKE rfrrd04-gjahr,
        buzei LIKE rfrrd04-buzei,
        kunnr LIKE rfrrd04-kunnr,
        tvtag LIKE rfrrd04-tvtag,
        tzinz LIKE rfrrd04-tzinz,
        tdms4 LIKE rfrrd04-tdms4,
        netdt LIKE rfrrd04-netdt,
      END OF top_n_text_04.

TYPES: BEGIN OF sum_t_05,
        spez2 LIKE rfrrkey-spez2,
        susal LIKE rfrrd05-susal,
        suums LIKE rfrrd05-suums,
        sudso LIKE rfrrd05-sudso,
      END OF sum_t_05.
TYPES: BEGIN OF top_n_05,
        kunnr LIKE rfrrd05-kunnr,
        tosal LIKE rfrrd05-tosal,
        toums LIKE rfrrd05-toums,
        todso LIKE rfrrd05-todso,
      END OF top_n_05.
TYPES: BEGIN OF top_n_text_05,
        text1 TYPE c LENGTH 35,
        kunnr LIKE rfrrd05-kunnr,
        tosal LIKE rfrrd05-tosal,
        toums LIKE rfrrd05-toums,
        todso LIKE rfrrd05-todso,
      END OF top_n_text_05.

TYPES: BEGIN OF sum_t_06,
        spez2 LIKE rfrrkey-spez2,
        sbntv LIKE rfrrd06-sbntv,
        szntv LIKE rfrrd06-szntv,
        stntv LIKE rfrrd06-stntv,
        sbs2v LIKE rfrrd06-sbs2v,
        szs2v LIKE rfrrd06-szs2v,
        sts2v LIKE rfrrd06-sts2v,
        sbs1v LIKE rfrrd06-sbs1v,
        szs1v LIKE rfrrd06-szs1v,
        sts1v LIKE rfrrd06-sts1v,
        sbsuv LIKE rfrrd06-sbsuv,
        szsuv LIKE rfrrd06-szsuv,
        stsuv LIKE rfrrd06-stsuv,
        sbntr LIKE rfrrd06-sbntr,
        szntr LIKE rfrrd06-szntr,
        stntr LIKE rfrrd06-stntr,
        sbs2r LIKE rfrrd06-sbs2r,
        szs2r LIKE rfrrd06-szs2r,
        sts2r LIKE rfrrd06-sts2r,
        sbs1r LIKE rfrrd06-sbs1r,
        szs1r LIKE rfrrd06-szs1r,
        sts1r LIKE rfrrd06-sts1r,
        sbsur LIKE rfrrd06-sbsur,
        szsur LIKE rfrrd06-szsur,
        stsur LIKE rfrrd06-stsur,
        stntd LIKE rfrrd06-stntd,
        sts2d LIKE rfrrd06-sts2d,
        sts1d LIKE rfrrd06-sts1d,
        stsud LIKE rfrrd06-stsud,
      END OF sum_t_06.
TYPES: BEGIN OF top_n_06,
        kunnr LIKE rfrrd06-kunnr,
        tbntv LIKE rfrrd06-tbntv,
        tzntv LIKE rfrrd06-tzntv,
        ttntv LIKE rfrrd06-ttntv,
        tbs2v LIKE rfrrd06-tbs2v,
        tzs2v LIKE rfrrd06-tzs2v,
        tts2v LIKE rfrrd06-tts2v,
        tbs1v LIKE rfrrd06-tbs1v,
        tzs1v LIKE rfrrd06-tzs1v,
        tts1v LIKE rfrrd06-tts1v,
        tbsuv LIKE rfrrd06-tbsuv,
        tzsuv LIKE rfrrd06-tzsuv,
        ttsuv LIKE rfrrd06-ttsuv,
        tbntr LIKE rfrrd06-tbntr,
        tzntr LIKE rfrrd06-tzntr,
        ttntr LIKE rfrrd06-ttntr,
        tbs2r LIKE rfrrd06-tbs2r,
        tzs2r LIKE rfrrd06-tzs2r,
        tts2r LIKE rfrrd06-tts2r,
        tbs1r LIKE rfrrd06-tbs1r,
        tzs1r LIKE rfrrd06-tzs1r,
        tts1r LIKE rfrrd06-tts1r,
        tbsur LIKE rfrrd06-tbsur,
        tzsur LIKE rfrrd06-tzsur,
        ttsur LIKE rfrrd06-ttsur,
        ttntd LIKE rfrrd06-ttntd,
        tts2d LIKE rfrrd06-tts2d,
        tts1d LIKE rfrrd06-tts1d,
        ttsud LIKE rfrrd06-ttsud,
      END OF top_n_06.
TYPES: BEGIN OF top_n_text_06,
        text1 TYPE c LENGTH 35,
        kunnr LIKE rfrrd06-kunnr,
        tbntv LIKE rfrrd06-tbntv,
        tzntv LIKE rfrrd06-tzntv,
        ttntv LIKE rfrrd06-ttntv,
        tbs2v LIKE rfrrd06-tbs2v,
        tzs2v LIKE rfrrd06-tzs2v,
        tts2v LIKE rfrrd06-tts2v,
        tbs1v LIKE rfrrd06-tbs1v,
        tzs1v LIKE rfrrd06-tzs1v,
        tts1v LIKE rfrrd06-tts1v,
        tbsuv LIKE rfrrd06-tbsuv,
        tzsuv LIKE rfrrd06-tzsuv,
        ttsuv LIKE rfrrd06-ttsuv,
        tbntr LIKE rfrrd06-tbntr,
        tzntr LIKE rfrrd06-tzntr,
        ttntr LIKE rfrrd06-ttntr,
        tbs2r LIKE rfrrd06-tbs2r,
        tzs2r LIKE rfrrd06-tzs2r,
        tts2r LIKE rfrrd06-tts2r,
        tbs1r LIKE rfrrd06-tbs1r,
        tzs1r LIKE rfrrd06-tzs1r,
        tts1r LIKE rfrrd06-tts1r,
        tbsur LIKE rfrrd06-tbsur,
        tzsur LIKE rfrrd06-tzsur,
        ttsur LIKE rfrrd06-ttsur,
        ttntd LIKE rfrrd06-ttntd,
        tts2d LIKE rfrrd06-tts2d,
        tts1d LIKE rfrrd06-tts1d,
        ttsud LIKE rfrrd06-ttsud,
      END OF top_n_text_06.
* sum_t and top_n types ended
TYPES: BEGIN OF kna1_lc,
        kunnr TYPE kunnr,
        name1 LIKE kna1-name1,
       END OF kna1_lc.

TYPES: BEGIN OF objec_tab,
          owner      LIKE rfrrcat-owner,
          koart      LIKE rfrrcat-koart,
          awtyp      LIKE rfrrcat-awtyp,
          versn      LIKE rfrrcat-versn,
          level(2)   TYPE c,
          objec(4)   TYPE c,
          count_sum  TYPE i,
          count_top  TYPE i,
        END   OF objec_tab.
TYPES t_params TYPE TABLE OF rsparams.
TYPES tt_catalog TYPE STANDARD TABLE OF rfrrcat.
TYPES tt_object_tab TYPE TABLE OF objec_tab.
TYPES t_kna1_lc TYPE HASHED TABLE OF kna1_lc WITH UNIQUE KEY kunnr.
TYPES change_type TYPE c LENGTH 8.
TYPES category TYPE c LENGTH 5.

CLASS: cl_abap_char_utilities DEFINITION LOAD.
DATA: BEGIN OF high_value,
        space TYPE c,
        high  TYPE c,
      END   OF high_value.
DATA: BEGIN OF low_value,
        space TYPE c,
        low   TYPE c,
      END   OF low_value.
DATA: BEGIN OF x_ff_kkber,
        ff(2) TYPE c,
        kk(2) TYPE c VALUE &apos;KK&apos;,
      END OF x_ff_kkber.
DATA: BEGIN OF x_ff_hiebk,
        ff(4) TYPE c,
      END   OF x_ff_hiebk.
DATA: BEGIN OF x_ff_hiegb,
        ff(4) TYPE c,
      END   OF x_ff_hiegb.
DATA: BEGIN OF x_ff_spez2,
        ff(16) TYPE c,
      END   OF x_ff_spez2.
DATA: BEGIN OF x_00_spez2,
        00(16) TYPE c,
      END OF x_00_spez2.
DATA: BEGIN OF evalkey,
        rr(3)      TYPE c VALUE &apos;RR_&apos;,
        evalu(16)  TYPE c VALUE &apos;EVALUATION_LIST_&apos;,
        koart      LIKE t060-koart VALUE &apos;D&apos;,
      END   OF evalkey.
DATA: BEGIN OF rrcatky,
        catalog(8) TYPE c VALUE &apos;CATALOG_&apos;,
        owner      LIKE rfrrkey-owner,
        koart      LIKE rfrrkey-koart VALUE &apos;D&apos;,
        awtyp      LIKE rfrrkey-awtyp,
        versn      LIKE rfrrkey-versn,
      END OF rrcatky.
* buffer tables
DATA: lt_t060t TYPE HASHED TABLE OF t060t WITH UNIQUE KEY owner koart awtyp versn,
      lt_t060o TYPE HASHED TABLE OF t060o WITH UNIQUE KEY owner,
      lt_kna1_lc TYPE t_kna1_lc,
      lv_sum_stru TYPE c LENGTH 8,
      lv_top_stru TYPE c LENGTH 8,
      lv_top_text_stru TYPE c LENGTH 13,
      lo_sum_stru_desc TYPE REF TO cl_abap_structdescr,
      lo_top_stru_desc TYPE REF TO cl_abap_structdescr,
      lo_top_text_stru_desc TYPE REF TO cl_abap_structdescr,
      lv_sum_sort_fld TYPE string,
      lv_top_sort_fld TYPE string.
DATA: BEGIN OF S,
        COL1 LIKE RFRRKEY-SPEZ3 VALUE &apos;COL1&apos;,
        COL2 LIKE RFRRKEY-SPEZ3 VALUE &apos;COL2&apos;,
        COL3 LIKE RFRRKEY-SPEZ3 VALUE &apos;COL3&apos;,
        COL4 LIKE RFRRKEY-SPEZ3 VALUE &apos;COL4&apos;,
        FAEL LIKE RFRRKEY-SPEZ3 VALUE &apos;FAELLIG&apos;,
        NFAE LIKE RFRRKEY-SPEZ3 VALUE &apos;NICHT FAELL.&apos;,
        SUMO LIKE RFRRKEY-SPEZ3 VALUE &apos;GESAMT&apos;,
      END OF S.

CONSTANTS: gc_error TYPE c LENGTH 12 VALUE &apos; WITH ERROR.&apos;,
           gc_success TYPE c LENGTH 15 VALUE &apos; SUCCESSFULLY.&apos;,
           gc_added TYPE change_type VALUE &apos;ADDED&apos;,
           gc_deleted TYPE change_type VALUE &apos;DELETED&apos;,
           gc_modified TYPE change_type VALUE &apos;MODIFIED&apos;,
           gc_detail_text TYPE c LENGTH 5 VALUE &apos;TEXT1&apos;,
           gc_detail_text2 TYPE c LENGTH 5 VALUE &apos;TEXT2&apos;,
           gc_sum TYPE category VALUE &apos;SUM&apos;,
           gc_top TYPE category VALUE &apos;TOP&apos;,
           gc_top_text TYPE category VALUE &apos;TOPT&apos;,
           gc_fld_spez2 TYPE c LENGTH 5 VALUE &apos;SPEZ2&apos;.</source>
 </PROG>
 <PROG NAME="ZGENE_TYPES_CODE" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT History DDIC Structure Migration Tool" LENGTH="42 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZGENE_CODE
*&amp; Convert DDIC structure into local definition code so that they can
*&amp; be included in a single program to simplify usage*&amp;
*&amp;---------------------------------------------------------------------*
REPORT  zgene_types_code.

TYPES: BEGIN OF obj_ty,
       objtype  TYPE trobjtype,
       objname  TYPE ddobjname,
       END OF obj_ty.

DATA: objtype  TYPE trobjtype,
            str TYPE ddobjname.

DATA: lt_dd03p  TYPE TABLE OF dd03p,
      lt_objty TYPE TABLE OF obj_ty,
      lv_str   TYPE string.
FIELD-SYMBOLS: &lt;fs_dd03p&gt; TYPE dd03p,
               &lt;fs_objty&gt; TYPE obj_ty.

PERFORM set_table.

LOOP AT lt_objty ASSIGNING &lt;fs_objty&gt;.
  CALL FUNCTION &apos;DDIF_TABL_GET&apos;
    EXPORTING
      name      = &lt;fs_objty&gt;-objname
      langu     = sy-langu
    TABLES
      dd03p_tab = lt_dd03p.

  CONCATENATE &apos;TYPES: BEGIN OF s_&apos; &lt;fs_objty&gt;-objtype &apos;.&apos; into LV_STR RESPECTING BLANKS.
  WRITE: / lv_str.
  CLEAR lv_str.

  WRITE: / &apos;INCLUDE TYPE s_obj_header.&apos;.
  LOOP AT lt_dd03p ASSIGNING &lt;fs_dd03p&gt;.
    IF &lt;fs_dd03p&gt;-fieldname EQ &apos;.INCLUDE&apos; OR &lt;fs_dd03p&gt;-adminfield GT 0.
      CONTINUE.
    ENDIF.
    DATA: lv_len1 TYPE i, lv_len2 TYPE i.
    lv_len1 = strlen( &lt;fs_dd03p&gt;-fieldname ).
    lv_len2 = strlen( &lt;fs_dd03p&gt;-rollname ).
    WRITE: / &apos;TYPES: &apos;, &lt;fs_dd03p&gt;-fieldname(lv_len1) ,&apos; TYPE &apos;, &lt;fs_dd03p&gt;-rollname(lv_len2), &apos;.&apos;.
  ENDLOOP.

  CONCATENATE &apos;TYPES: END OF s_&apos; &lt;fs_objty&gt;-objtype &apos;.&apos; INTO LV_STR RESPECTING BLANKS.
  WRITE: / lv_str, /.
  CLEAR lv_str.
ENDLOOP.

FORM set_table.
  PERFORM append_obj USING &apos;TABL&apos; &apos;ZTABLE&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;VIEW&apos; &apos;ZVIEW&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;VCLS&apos; &apos;ZVIEW_CLUSTER&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;TOBJ&apos; &apos;ZMAINTENANCE_VIEW&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;SHLP&apos; &apos;ZSEARCH_HELP&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;ENQU&apos; &apos;ZLOCK_OBJECT&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;TTYP&apos; &apos;ZTABLE_TYPE&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;NROB&apos; &apos;ZNUMBER_RANGE&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;MSAD&apos; &apos;ZMESSAGE&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;MSAG&apos; &apos;ZMESSAGE&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;VDAT&apos; &apos;ZTABLE_CONTENTS&apos; CHANGING lt_objty.
  PERFORM append_obj USING &apos;TRAN&apos; &apos;ZTRANSACTION&apos; CHANGING lt_objty.
ENDFORM.

FORM append_obj USING iv_objtype TYPE trobjtype iv_objname TYPE ddobjname CHANGING ct_objs TYPE STANDARD TABLE.
  DATA ls_ty TYPE obj_ty.
  ls_ty-objtype = iv_objtype.
  ls_ty-objname = iv_objname.
  APPEND ls_ty TO ct_objs.
ENDFORM.</source>
 </PROG>
 <PROG NAME="ZINTERNALTABLES" VARCL="X" SUBC="1" APPL="*" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Internal Tables Test" LENGTH="20 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZINTERNALTABLES
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT  ZINTERNALTABLES.

DATA: lt_standard TYPE TABLE OF sbook,
      lt_sorted TYPE SORTED TABLE OF sbook
        WITH NON-UNIQUE KEY carrid connid fldate bookid,
      lt_hash TYPE HASHED TABLE OF sbook
        WITH UNIQUE KEY carrid connid fldate bookid.

FIELD-SYMBOLS: &lt;fs_sbook&gt; TYPE sbook.

SELECT * FROM sbook
  APPENDING TABLE lt_standard
  UP TO 10 ROWS.

LOOP AT lt_standard ASSIGNING &lt;fs_sbook&gt;.
  WRITE : / &lt;fs_sbook&gt;-carrid, &lt;fs_sbook&gt;-connid,
            &lt;fs_sbook&gt;-fldate, &lt;fs_sbook&gt;-bookid.
  INSERT &lt;fs_sbook&gt; INTO TABLE lt_hash.
ENDLOOP.

ULINE.

SELECT * FROM sbook INTO TABLE lt_sorted UP TO 10 ROWS
   ORDER BY carrid connid fldate bookid DESCENDING.
LOOP AT lt_sorted ASSIGNING &lt;fs_sbook&gt;.
  WRITE : / &lt;fs_sbook&gt;-carrid, &lt;fs_sbook&gt;-connid,
            &lt;fs_sbook&gt;-fldate, &lt;fs_sbook&gt;-bookid.
ENDLOOP.
UNASSIGN &lt;fs_sbook&gt;.

ULINE.

READ TABLE lt_hash
     WITH TABLE KEY carrid = &apos;LH&apos; connid = &apos;0400&apos;
                    fldate = &apos;19950228&apos; bookid = &apos;00000000&apos;
     ASSIGNING &lt;fs_sbook&gt;.

IF &lt;fs_sbook&gt; IS ASSIGNED.
  WRITE : / &lt;fs_sbook&gt;-carrid, &lt;fs_sbook&gt;-connid,
            &lt;fs_sbook&gt;-fldate, &lt;fs_sbook&gt;-bookid.
ELSE.
  WRITE : / &apos;Hey man, you can not coding like this...&apos;.
ENDIF.

DATA: ls_sbook TYPE sbook,
      lv_count TYPE i.
READ TABLE lt_hash INTO ls_sbook
     WITH TABLE KEY carrid = &apos;LH&apos; connid = &apos;0400&apos;
                    fldate = &apos;19950228&apos; bookid = &apos;00000000&apos;.
WRITE : / ls_sbook-carrid, ls_sbook-connid,
          ls_sbook-fldate, ls_sbook-bookid.

* To avoid duplicated primary key dump
CLEAR lt_hash.
SELECT * FROM sbook APPENDING TABLE lt_hash UP TO 25 ROWS
  ORDER BY carrid connid fldate bookid DESCENDING.

lv_count = lines( lt_hash ).
WRITE : / &apos;We have&apos;, lv_count, &apos;entries.&apos;.
ULINE.

AUTHORITY-CHECK OBJECT &apos;ZSBOOK&apos;
  ID &apos;CARRID&apos; FIELD &apos;LH&apos;
  ID &apos;ACTVT&apos;  FIELD &apos;03&apos;.

IF sy-subrc EQ 0.
  WRITE : / &apos;You can go through now.&apos;.
ELSE.
  WRITE : / &apos;Come on, you cannot enter yet.&apos;.
ENDIF.</source>
 </PROG>
 <PROG NAME="ZNOTE_DOCU" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT History Internal Version 1.0 (html with bootstrap style)" LENGTH="61 "/>
    <textElement ID="S" KEY="P_BIN" ENTRY="        Download Transport Files" LENGTH="32 "/>
    <textElement ID="S" KEY="P_DIR" ENTRY="        Export Folder" LENGTH="21 "/>
    <textElement ID="S" KEY="P_SRC" ENTRY="        Export Json Data Only" LENGTH="29 "/>
    <textElement ID="S" KEY="P_TR" ENTRY="D       ." LENGTH="20 "/>
   </language>
  </textPool>
  <programDocumentation OBJECT="ZNOTE_DOCU">
   <language SPRAS="E">
    <textLine TDFORMAT="U1" TDLINE="&amp;PURPOSE&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="This little tool allows you to generate a documentation for given"/>
    <textLine TDFORMAT="AS" TDLINE="requests linked to a certain note, thus to reduce the manual effort to"/>
    <textLine TDFORMAT="AS" TDLINE="collect those objects not supported to automatically applied in note."/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;INTEGRATION&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="Simply run this program, all will be there.After the html file was"/>
    <textLine TDFORMAT="AS" TDLINE="generated, you can either convert it to a word file manualy, or open it"/>
    <textLine TDFORMAT="AS" TDLINE="using Microsoft Office Word application and save as docx."/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;PREREQUISITES&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="It depends on ZJSON project to convert abap data to json."/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;FEATURES&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;SELECTION&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;STANDARD_VARIANTS&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;OUTPUT&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;ACTIVITIES&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;EXAMPLE&amp;"/>
    <textLine TDFORMAT="AS"/>
   </language>
  </programDocumentation>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZNOTE_DOCU
*&amp; Automatically generate documentation for a SAP note by Joker
*&amp;---------------------------------------------------------------------*
REPORT  znote_docu.
INCLUDE zdoc_constants.

PARAMETERS: p_tr  TYPE e070-trkorr,
            p_bin TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
            p_src TYPE abap_bool AS CHECKBOX DEFAULT abap_false,
            p_dir TYPE string.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_tr.
  CALL FUNCTION &apos;TR_F4_REQUESTS&apos;
    EXPORTING
      iv_trstatus         = &apos;R&apos;
    IMPORTING
      ev_selected_request = p_tr.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_dir.
  PERFORM select_download_dir CHANGING p_dir.

AT SELECTION-SCREEN.
  PERFORM validate_params.

INITIALIZATION.
  PERFORM initialize_cache.
  PERFORM init_template USING: &apos;ZDOC_UTIL_JS&apos; &apos;render.js&apos;,  &quot;#EC NOTEXT
                               &apos;ZDOC_TEMPLATE&apos; &apos;index.html&apos;. &quot;#EC NOTEXT

START-OF-SELECTION.
  PERFORM prepare_jsondata USING p_tr.

  PERFORM export_jsondata.
  IF p_src EQ abap_false.
    PERFORM export_templates.
  ENDIF.

  IF p_bin EQ abap_true.
    PERFORM download_cr_bin USING p_tr.
  ENDIF.
  PERFORM show_result.

INCLUDE zdoc_subroutines.</source>
 </PROG>
 <PROG NAME="ZNOTE_DOCU_V2" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT History Internal Version 1.1 (html with MS Word style)" LENGTH="59 "/>
    <textElement ID="S" KEY="P_BIN" ENTRY="        Download Transport Files" LENGTH="32 "/>
    <textElement ID="S" KEY="P_DIR" ENTRY="        Export Folder" LENGTH="21 "/>
    <textElement ID="S" KEY="P_SRC" ENTRY="        Export Json Data Only" LENGTH="29 "/>
    <textElement ID="S" KEY="P_TR" ENTRY="D       ." LENGTH="20 "/>
   </language>
  </textPool>
  <programDocumentation OBJECT="ZNOTE_DOCU_V2">
   <language SPRAS="E">
    <textLine TDFORMAT="U1" TDLINE="&amp;PURPOSE&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="This little tool allows you to generate a documentation for given"/>
    <textLine TDFORMAT="AS" TDLINE="requests linked to a certain note, thus to reduce the manual effort to"/>
    <textLine TDFORMAT="AS" TDLINE="collect those objects not supported to automatically applied in note."/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;INTEGRATION&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="Simply run this program, all will be there.After the html file was"/>
    <textLine TDFORMAT="AS" TDLINE="generated, you can either convert it to a word file manualy, or open it"/>
    <textLine TDFORMAT="AS" TDLINE="using Microsoft Office Word application and save as docx."/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;PREREQUISITES&amp;"/>
    <textLine TDFORMAT="AS" TDLINE="It depends on ZJSON project to convert abap data to json."/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;FEATURES&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;SELECTION&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;STANDARD_VARIANTS&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U2" TDLINE="&amp;OUTPUT&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;ACTIVITIES&amp;"/>
    <textLine TDFORMAT="AS"/>
    <textLine TDFORMAT="U1" TDLINE="&amp;EXAMPLE&amp;"/>
    <textLine TDFORMAT="AS"/>
   </language>
  </programDocumentation>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZNOTE_DOCU
*&amp; Automatically generate documentation for a SAP note by Joker
*&amp;---------------------------------------------------------------------*
REPORT  znote_docu_v2.
INCLUDE zdoc_constants.

PARAMETERS: p_tr  TYPE e070-trkorr,
            p_bin TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
            p_src TYPE abap_bool AS CHECKBOX DEFAULT abap_false,
            p_dir TYPE string.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_tr.
  CALL FUNCTION &apos;TR_F4_REQUESTS&apos;
    EXPORTING
      iv_trstatus         = &apos;R&apos;
    IMPORTING
      ev_selected_request = p_tr.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_dir.
  PERFORM select_download_dir CHANGING p_dir.

AT SELECTION-SCREEN.
  PERFORM validate_params.

INITIALIZATION.
  PERFORM initialize_cache.
  PERFORM init_template USING: &apos;ZDOC_UTIL_JS_V2&apos;  &apos;render.js&apos;,  &quot;#EC NOTEXT
                               &apos;ZDOC_TEMPLATE_V2&apos; &apos;index.html&apos;. &quot;#EC NOTEXT

START-OF-SELECTION.
  PERFORM prepare_jsondata USING p_tr.

  PERFORM export_jsondata.
  IF p_src EQ abap_false.
    PERFORM export_templates.
  ENDIF.

  IF p_bin EQ abap_true.
    PERFORM download_cr_bin USING p_tr.
  ENDIF.
  PERFORM show_result.

INCLUDE zdoc_subroutines.</source>
 </PROG>
 <PROG NAME="ZTEST_DOWNLOAD" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Download Repository Objects Tool" LENGTH="32 "/>
    <textElement ID="S" KEY="O_IACS" ENTRY="        IAC-Service(ITS)" LENGTH="24 "/>
    <textElement ID="S" KEY="O_LAN" ENTRY="        Documentation Language" LENGTH="30 "/>
    <textElement ID="S" KEY="O_BADIS" ENTRY="        Badi-Implementation" LENGTH="27 "/>
    <textElement ID="S" KEY="O_CLASS" ENTRY="        Classes" LENGTH="15 "/>
    <textElement ID="S" KEY="O_CMOD" ENTRY="        Enhancement Project" LENGTH="27 "/>
    <textElement ID="S" KEY="O_DEVCL" ENTRY="        Developmentclass" LENGTH="24 "/>
    <textElement ID="S" KEY="O_DYNP" ENTRY="        Dynpro" LENGTH="14 "/>
    <textElement ID="S" KEY="O_FKGRP" ENTRY="        Functiongroups" LENGTH="22 "/>
    <textElement ID="S" KEY="O_FUNC" ENTRY="        Functionmodule" LENGTH="22 "/>
    <textElement ID="S" KEY="O_IDOC" ENTRY="        IDoc/Enhancement" LENGTH="24 "/>
    <textElement ID="S" KEY="O_INC" ENTRY="        Include" LENGTH="15 "/>
    <textElement ID="S" KEY="O_INTF" ENTRY="        Interface" LENGTH="17 "/>
    <textElement ID="S" KEY="O_PROG" ENTRY="        Online-Program" LENGTH="22 "/>
    <textElement ID="S" KEY="O_TCODE" ENTRY="        Transactioncode" LENGTH="23 "/>
    <textElement ID="S" KEY="O_TRKORR" ENTRY="        Transport-Request" LENGTH="25 "/>
    <textElement ID="S" KEY="P_UNAME" ENTRY="        User" LENGTH="12 "/>
    <textElement ID="S" KEY="PFAD" ENTRY="        Existing path" LENGTH="21 "/>
    <textElement ID="S" KEY="P_APP1" ENTRY="        Data-File auf App-Server" LENGTH="32 "/>
    <textElement ID="S" KEY="P_APP2" ENTRY="        CO-File auf App-Server" LENGTH="30 "/>
    <textElement ID="S" KEY="P_ASC" ENTRY="        Asci Mode" LENGTH="17 "/>
    <textElement ID="S" KEY="P_BASIS" ENTRY="        Basistype" LENGTH="17 "/>
    <textElement ID="S" KEY="P_BIN" ENTRY="        Binary Mode" LENGTH="19 "/>
    <textElement ID="S" KEY="P_DEVC" ENTRY="        Selection via Developmentclass" LENGTH="38 "/>
    <textElement ID="S" KEY="P_DOWN" ENTRY="        Download vom R/3-Server" LENGTH="31 "/>
    <textElement ID="S" KEY="P_ENH" ENTRY="        Enhancement" LENGTH="19 "/>
    <textElement ID="S" KEY="P_FRONT" ENTRY="        Verzeichnis WS" LENGTH="22 "/>
    <textElement ID="S" KEY="P_LOGIC" ENTRY="        Logical Development" LENGTH="27 "/>
    <textElement ID="S" KEY="P_OVER" ENTRY="        Bestehende Dat. übeschr." LENGTH="32 "/>
    <textElement ID="S" KEY="P_SINGLE" ENTRY="        Selction via single Objects" LENGTH="35 "/>
    <textElement ID="S" KEY="P_TRFIL" ENTRY="        Handling of Transport Files" LENGTH="35 "/>
    <textElement ID="S" KEY="P_TRKOR1" ENTRY="        Transportauftrag" LENGTH="24 "/>
    <textElement ID="S" KEY="P_TRKORR" ENTRY="        Selection via Transportrequest" LENGTH="38 "/>
    <textElement ID="S" KEY="P_NSPACE" ENTRY="        Namespace" LENGTH="17 "/>
    <textElement ID="S" KEY="P_UP" ENTRY="        Upload zum R/3-Server" LENGTH="29 "/>
    <textElement ID="S" KEY="P_NODEP" ENTRY="        No Dep. Obj. (Cust. Namespace)" LENGTH="38 "/>
    <textElement ID="S" KEY="O_SIREPS" ENTRY="        Includes" LENGTH="16 "/>
    <textElement ID="S" KEY="O_SIFUNC" ENTRY="        Function Modules" LENGTH="24 "/>
    <textElement ID="S" KEY="O_SITABL" ENTRY="        Tables / Views / Structures" LENGTH="35 "/>
    <textElement ID="S" KEY="O_SITTYP" ENTRY="        Tabletypes" LENGTH="18 "/>
    <textElement ID="S" KEY="O_SITYPD" ENTRY="        Typepool" LENGTH="16 "/>
    <textElement ID="S" KEY="O_SIDTEL" ENTRY="        Dataelements" LENGTH="20 "/>
    <textElement ID="S" KEY="O_SIDOMA" ENTRY="        Domains" LENGTH="15 "/>
    <textElement ID="S" KEY="O_SIENQU" ENTRY="        Lock Object" LENGTH="19 "/>
    <textElement ID="S" KEY="O_SISUSO" ENTRY="        Authority Objects" LENGTH="25 "/>
    <textElement ID="S" KEY="O_SITRAN" ENTRY="        Transaction Codes" LENGTH="25 "/>
    <textElement ID="S" KEY="O_SRCHEP" ENTRY="        Search Help" LENGTH="19 "/>
    <textElement ID="S" KEY="O_ENHSPT" ENTRY="        Enhancement Spot" LENGTH="24 "/>
    <textElement ID="S" KEY="O_WEBD" ENTRY="        Web-Dyn Pro" LENGTH="19 "/>
    <textElement ID="S" KEY="O_BADI" ENTRY="        New Core BADI" LENGTH="21 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZTEST_DOWNLOAD
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;    SAP Custom Development
*&amp;    Program for Techical IP-Protection
*&amp;    SAP Releases greater 4.6C
*&amp;    Version 3, 20-March-2009
*&amp;---------------------------------------------------------------------*
REPORT  ztest_download LINE-SIZE 255.

*--Download tool provides three types of selection method:
*-1.  Selection on the basis of Single Objects:
*-2.  Selection on the basis of Transport Request
*-3.  Selection on the basis of Development Class

*-By providing the details of any single object its documentation
*-can be extracted, same as if the details of the transport request or
*-for the development class (Package) has been provided by the user there
*-documentation will then also be extracted at the desired location.

*-Following types of objects can be downloaded from download tool:
*-  Authorization object
*-  Business add-in (implementation)
*-  Data element
*-  Dialog module
*-  Domain
*-  Web-Dyn Pro
*-  Enhancement Spot
*-  Function module
*-  Function group
*-  GUI status
*-  GUI title
*-  IAC-Services (ITS)
*-  IAC-Templates (ITS)
*-  IDoc (basic type and extension)
*-  Include
*-  Interface in ABAP Objects
*-  Class in ABAP Objects
*-  Customer enhancement project
*-  Modification
*-  Module pool
*-  Message
*-  New Core BADI
*-  Report
*-  Set/get parameter
*-  Search Help
*-  Screen
*-  Lock object
*-  Structure
*-  Table
*-  Table append
*-  Table type
*-  Text element
*-  Type group
*-  Transaction code
*-  View
*&amp;---------------------------------------------------------------------

************************************************
*Constant for length of field &quot;Existing Path&quot;
CONSTANTS c_path_length TYPE i VALUE 200.
************************************************
******Variablen fuer Selektionsbildschirme
*Transaktionscodes
DATA: tacode TYPE tstc.
*Namen von Funktionsgruppen
DATA: fktgroup TYPE tlibg-area.
*Klassen und Interfaces
DATA: class TYPE vseoclass-clsname.
*Entwicklungsklassen
DATA devcl TYPE tadir-devclass.
*Definition fuer Selektion ueber Transportauftraege
DATA:  trkorr TYPE e071-trkorr.
*Definition fuer Badi-Implementierung
DATA:  badi_imp TYPE sxc_attr-imp_name.
*Definition fuer Kundenerweiterungsprojekte
DATA:  wa_cmod TYPE  modact.
DATA: gv_funcname TYPE rs38l_fnam.

*Definition fuer IDOCs
*Definition ueberi Tables-Anweisung wegen Suchhilfe
TABLES:  sed5struc.

*IAC-Service
TABLES: iachtml.

TABLES: d010inc,
        tfdir,
        info_tabl,
        dd40vv,
        rsrd1,
        info_dtel,
        info_doma,
        dd25l,
        info_suso,
        tstc,
        dd30l,
        enhspotobj,
        wdy_component,
        badi_impl.

*Modifikationselemente
DATA: modiname TYPE smodilog-sub_name.

*Tabellen mit den Includeobjekten
DATA: it_trdir TYPE TABLE OF trdir,
      wa_trdir LIKE LINE OF it_trdir.
DATA: report_name TYPE reposrc-progname.

*Sprachenfeld
DATA: language TYPE t002c-spras.

************************************************
*** Selektionsbildschirm.
************************************************
*Startselektionsbildschirm
SELECTION-SCREEN BEGIN OF BLOCK b80 WITH FRAME TITLE text059.
PARAMETERS: p_single RADIOBUTTON GROUP g0.
PARAMETERS: p_trkorr RADIOBUTTON GROUP g0.
PARAMETERS: p_devc RADIOBUTTON GROUP g0.

SELECTION-SCREEN END OF BLOCK b80.
*Sonstige Selektionsparameter
PARAMETERS: p_nspace TYPE namespace.
SELECTION-SCREEN SKIP 1.
*PARAMETERS:     pfad(7)  TYPE  c DEFAULT &apos;C:\temp&apos;.
PARAMETERS:     pfad(c_path_length)  TYPE  c DEFAULT &apos;C:\temp&apos;.
SELECT-OPTIONS: o_lan FOR language DEFAULT sy-langu NO INTERVALS.

SELECTION-SCREEN SKIP 1.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN POSITION 1.
PARAMETERS: p_nodep AS CHECKBOX.
SELECTION-SCREEN COMMENT 5(72) text075 FOR FIELD p_nodep.
SELECTION-SCREEN END OF LINE.

*Selektionsbildschirm fuer Selektion ueber den Transportauftrag
SELECTION-SCREEN BEGIN OF SCREEN 100.
SELECTION-SCREEN BEGIN OF BLOCK b0 WITH FRAME TITLE text057.
SELECT-OPTIONS: o_trkorr FOR trkorr  NO INTERVALS.
PARAMETERS: p_uname TYPE usr02-bname DEFAULT sy-uname.
SELECTION-SCREEN END OF BLOCK b0.
SELECTION-SCREEN END   OF SCREEN 100.


*Selektionsbildschrim fuer die Selektion ueber die Entwicklungsklasse
SELECTION-SCREEN BEGIN OF SCREEN 101.
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text052.
SELECT-OPTIONS: o_devcl FOR devcl  NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b1.
SELECTION-SCREEN END   OF SCREEN 101.


*Selektionsbildschirm fuer die Selektion von einzelnen Objekten
*und Selektion einer logischen Entwicklung
SELECTION-SCREEN BEGIN OF SCREEN 102.

PARAMETERS: p_logic(10) TYPE c.
SELECTION-SCREEN SKIP 2.

*Tabbed Block for objects
SELECTION-SCREEN BEGIN OF TABBED BLOCK tabb FOR 37 LINES.
SELECTION-SCREEN TAB (20) text073 USER-COMMAND main
                     DEFAULT SCREEN 120.
SELECTION-SCREEN TAB (20) text074 USER-COMMAND single
                     DEFAULT SCREEN 130.
SELECTION-SCREEN END OF BLOCK tabb.
SELECTION-SCREEN END   OF SCREEN 102.

*Subscreen for main objects
SELECTION-SCREEN BEGIN OF SCREEN 120 AS SUBSCREEN.

SELECTION-SCREEN BEGIN OF BLOCK b WITH FRAME TITLE text069.
*  Rahmenprogramme, Modulpoole
SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE text040.
SELECT-OPTIONS: o_prog FOR report_name NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b2.

*Transaktion
SELECTION-SCREEN BEGIN OF BLOCK b2a WITH FRAME TITLE text070.
SELECT-OPTIONS: o_tcode FOR tacode-tcode NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b2a.

*  Funktionsgruppen
SELECTION-SCREEN BEGIN OF BLOCK b3 WITH FRAME TITLE text041.
SELECT-OPTIONS: o_fkgrp FOR fktgroup NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b3.

*  Klassen, Classpools
SELECTION-SCREEN BEGIN OF BLOCK b4 WITH FRAME TITLE text042.
SELECT-OPTIONS: o_class FOR class NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b4.

*  Interfaces
SELECTION-SCREEN BEGIN OF BLOCK b4a WITH FRAME TITLE text067.
SELECT-OPTIONS: o_intf FOR class NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b4a.

*  IDOC&apos;s
*  Funktionsgruppen
SELECTION-SCREEN BEGIN OF BLOCK b5 WITH FRAME TITLE text048.
SELECT-OPTIONS: o_idoc FOR sed5struc-object  NO INTERVALS.
PARAMETERS: p_basis LIKE sed5struc-select_org  RADIOBUTTON GROUP g1.
PARAMETERS: p_enh LIKE sed5struc-select_ext RADIOBUTTON GROUP g1.
SELECTION-SCREEN END OF BLOCK b5.

*  *Kundenerweiterungsprojekte: CMOD
SELECTION-SCREEN BEGIN OF BLOCK b6 WITH FRAME TITLE text049.
SELECT-OPTIONS o_cmod FOR wa_cmod-name NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b6.

*  *Badiimplementierungen
SELECTION-SCREEN BEGIN OF BLOCK b7 WITH FRAME TITLE text054.
SELECT-OPTIONS o_badis FOR badi_imp NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b7.

*  Modifikationen
SELECTION-SCREEN BEGIN OF BLOCK b8 WITH FRAME TITLE text068.
SELECT-OPTIONS o_inc FOR modiname NO INTERVALS.
SELECT-OPTIONS o_func FOR modiname NO INTERVALS.
SELECT-OPTIONS o_dynp FOR modiname NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b8.

* IAC-Service
SELECTION-SCREEN BEGIN OF BLOCK b9 WITH FRAME TITLE text062.
SELECT-OPTIONS o_iacs FOR iachtml-service NO INTERVALS.
SELECTION-SCREEN END OF BLOCK b9.

SELECTION-SCREEN END OF BLOCK b.
*SELECTION-SCREEN END   OF SCREEN 102.
SELECTION-SCREEN END   OF SCREEN 120.

*Subscreen for single objects
SELECTION-SCREEN BEGIN OF SCREEN 130 AS SUBSCREEN.

* Includes
SELECT-OPTIONS: o_sireps FOR d010inc-include NO INTERVALS.

* Funktionsbauteine
SELECT-OPTIONS: o_sifunc FOR tfdir-funcname NO INTERVALS.

* Tabellen / Strukturen / Views / Appends
SELECT-OPTIONS: o_sitabl FOR info_tabl-tabname NO INTERVALS.

* Tabellentypen
SELECT-OPTIONS: o_sittyp FOR dd40vv-typename NO INTERVALS.

* Typgruppen
SELECT-OPTIONS: o_sitypd FOR rsrd1-tyma_val NO INTERVALS.

* Datenelmente
SELECT-OPTIONS: o_sidtel FOR info_dtel-rollname NO INTERVALS.

* Domänen
SELECT-OPTIONS: o_sidoma FOR info_doma-domname NO INTERVALS.

* Sperrobjekt
SELECT-OPTIONS: o_sienqu FOR dd25l-viewname NO INTERVALS.

* Berechtigungsobjkete
SELECT-OPTIONS: o_sisuso FOR info_suso-objct NO INTERVALS.

* Transaktionscodes
SELECT-OPTIONS: o_sitran FOR tstc-tcode NO INTERVALS.

*Addtion of code for search helps.
SELECT-OPTIONS: o_srchep FOR dd30l-shlpname NO INTERVALS.

*Addition of code for Enhancement spots
SELECT-OPTIONS: o_enhspt FOR enhspotobj-enhspot NO INTERVALS.

*Addition of code for Enhancement spots
SELECT-OPTIONS: o_badi FOR badi_impl-badi_name NO INTERVALS.

*Addition of code for Web Dynpro
SELECT-OPTIONS o_webd FOR wdy_component-component_name NO INTERVALS.

* Set / Get Parameter
SELECTION-SCREEN END   OF SCREEN 130.


************************************************
*******Datendeklarationen
************************************************

*Praefixe fuer Downloaddateinamen
CONSTANTS: ci(4) VALUE &apos;IN_&apos;, &quot;Filename für Includes
           cr(3) VALUE &apos;R_&apos;, &quot;Filename für Onlineprogramme
           ct(4) VALUE &apos;TAB_&apos;, &quot;Tables
           cv(5) VALUE &apos;View_&apos;, &quot;View
           cst(4) VALUE &apos;STR_&apos;, &quot;Strukturen
           cap(4) VALUE &apos;App_&apos;,   &quot;Appends
           cs(4) VALUE &apos;SC_&apos;, &quot;Filename für Screens
           ctg(4) VALUE &apos;TGR_&apos;, &quot;Typgruppen
           ccl(5) VALUE &apos;CLIN_&apos;, &quot;Klassenincludes
           cint(5) VALUE &apos;Intf_&apos;, &quot;Interfaceincludes
           eint(5) VALUE &apos;Enh_&apos;, &quot;Enhancementinclude
           cfunc(5) VALUE &apos;Func_&apos;.   &quot;einzelner Funktionsbaustein

*Target bei Verlinkung neuer Rahmen
CONSTANTS: c_target_new(7) VALUE &apos;_parent&apos;.

*** Namensraum
DATA: g_name(11)     TYPE c,
      g_savename     TYPE string.
DATA: g_nspace       TYPE string.
DATA: g_len_nspace   TYPE i.

*interne Tabelle und Arbeitsbereich fuer Sprache
DATA: it_lan TYPE STANDARD TABLE OF t002c-spras,
      wa_lan LIKE LINE OF it_lan.

*Einbindung des Typepools damit das kopierte Coding fuer die Bearbeitung
*der IDOC&apos;s funktioniert.
TYPE-POOLS  ledid.

*Type fuer Tabelle mit Includename
TYPES: BEGIN OF include,
        name TYPE trdir-name,
       END OF include.
TYPES: includetab TYPE STANDARD TABLE OF include.
*Typ fuer Performtabelle
TYPES: performtab TYPE STANDARD TABLE OF string.

*Tabllentype für download-Tabelle
FIELD-SYMBOLS: &lt;ty_downtab&gt; TYPE STANDARD TABLE.

*Verzeichnisname beim Anlegen des Verzeichnisses des Rahmenprogramms
FIELD-SYMBOLS &lt;new_dir&gt; TYPE ANY.
*DATA: new_dir(128) TYPE c.
DATA: new_dir  TYPE string.

*Bezugstabelle fuer Textpool-Parametertabelle
DATA: it_textpool TYPE STANDARD TABLE OF textpool.

DATA: g_single_limu(1) TYPE c.

*Zwischenspeicherugng Pfad fuer Klassen OO
DATA: lcl_it_path TYPE STANDARD TABLE OF  string.

*Eindeutiger Identifizierer Installation + System
DATA: instnr(30) TYPE c.

*Sichern des Rootverzeichnisses fuer spaetere Zugriffe
DATA: root TYPE string.

*Fag,ob Verzeichnis bereits angelegt worden ist.
DATA: direxists TYPE c.

*Tabelle mit abhängigen Includes des jeweiligen Rahmenprogramms
DATA: it_d010inc TYPE STANDARD TABLE OF d010inc.

*Tabelle mit abhängigen Includes des jeweiligen Rahmenprogramms
DATA: it_d020s TYPE STANDARD TABLE OF d020s,
      wa_d020s LIKE LINE OF it_d020s.
*Tabelle mit abhängigen Tabellen, Strukturen, Appends des jeweiligen
*Rahmenprogramms
DATA: it_d010tab TYPE STANDARD TABLE OF d010tab,
      wa_d010tab LIKE LINE OF it_d010tab.

*Generische Tabelle zum Download von Includes
*DATA: downtab TYPE STANDARD TABLE OF ababsource.
DATA: &quot;down_variable(255) type c,
      downtab LIKE STANDARD TABLE OF abaptxt255 .&quot;down_variable.
*String zum Schreiben der Ausgabeliste nach  Download
DATA: str_output TYPE string.

*Generischer Bezugsdatentyp für includename
DATA: c_includename(40) TYPE c.

*Stückliste für die Speicherung der Struktur des Rahmenprogramms
TYPES: BEGIN OF prog_stueckliste,
          type TYPE string, &quot;beliebige Laenge wegen sprechenden Namen
          name(75) TYPE c, &quot;Laenge wegen zusammengesetzten Namen
          obername TYPE trdir-name,
          instnr LIKE instnr,
          file_name(75) TYPE c, &quot;filename with replaced special chars
      END OF prog_stueckliste.

*allgemeine Stueckliste
DATA: it_prog_stueckliste TYPE STANDARD TABLE OF prog_stueckliste
                     WITH NON-UNIQUE KEY name obername.
DATA: wa_prog_stueckliste LIKE LINE OF it_prog_stueckliste.

*spezielle Stueckliste fuer logische Entwicklung
DATA: it_log_stueckliste TYPE STANDARD TABLE OF prog_stueckliste,
      wa_log_stueckliste LIKE LINE OF it_log_stueckliste.

*Tabelle für Strukturinformationen über Funktionsgruppen.
*Includename und wenn Fktbaustein, auch dessen Namen.
*Die Name der Fktgruppe wird im Dateinamen festgehalten
TYPES: BEGIN OF fkgrp_struktur,
          objecttype(20) TYPE c,
          objectname(75)  TYPE c, &quot;wegen zsammengesetzten Namen
          fktbstname TYPE tfdir-funcname,
          file_objectname(75) TYPE c,
      END OF fkgrp_struktur.
DATA: it_fkgrp_struktur TYPE STANDARD TABLE OF fkgrp_struktur,
      wa_fkgrp_struktur LIKE LINE OF it_fkgrp_struktur.


*** Dateiname für den Download
*DATA: filename LIKE rlgrap-filename.
DATA: filename TYPE string.


*** Dateigrösse des Donwloads
DATA: size TYPE i.

*Workarea fuer dd02l --&gt;Bestimmung der Tabellentypen
DATA:  wa_ddictypes TYPE dd02l.

*Bereiche fuer die Verarbeitung der Datenelemente
DATA: it_dataelements TYPE STANDARD TABLE OF dd04v,
      wa_dataelements LIKE LINE OF it_dataelements.

*Typ, der nur sinnvolle Informationen über Datenelemente
TYPES: BEGIN OF idd04v,
          rollname TYPE dd04v-rollname,
          ddlanguage TYPE dd04v-ddlanguage,
          domname TYPE dd04v-domname,
          memoryid TYPE dd04v-memoryid,
          logflag TYPE dd04v-logflag,
          headlen TYPE dd04v-headlen,
          scrlen1 TYPE dd04v-scrlen1,
          scrlen2 TYPE dd04v-scrlen2,
          scrlen3 TYPE dd04v-scrlen3,
          ddtext TYPE dd04v-ddtext,
          reptext TYPE dd04v-reptext,
          scrtext_s TYPE dd04v-scrtext_s,
          scrtext_m TYPE dd04v-scrtext_m,
          scrtext_l TYPE dd04v-scrtext_l,
          actflag TYPE dd04v-actflag,
          shlpname TYPE dd04v-shlpname,
          shlpfield TYPE dd04v-shlpfield,
       END OF idd04v.
*Bereiche fuer die Verarbeitung der Domaenen
DATA: it_dd01v TYPE STANDARD TABLE OF dd01v,
      wa_dd01v LIKE LINE OF it_dd01v,
      it_dd07v TYPE STANDARD TABLE OF dd07v,
      wa_dd07v LIKE LINE OF it_dd07v.

*Typ fuer Aussagefähigelder Felder fuer Menuexitcodes
TYPES: BEGIN OF icuatexts,
          prog TYPE cuatexts-prog,
          code TYPE cuatexts-code,
          sprsl TYPE cuatexts-sprsl,
          l_text TYPE cuatexts-l_text,
          s_text TYPE cuatexts-s_text,
          info_text TYPE cuatexts-info_text,
          icon_name TYPE cuatexts-icon_name,
       END OF icuatexts.

*Gesamttabelle fuer Messages
DATA: it_messages TYPE STANDARD TABLE OF t100
              WITH NON-UNIQUE KEY sprsl arbgb msgnr,
      wa_messages LIKE LINE OF it_messages.

*Feststellen, ob Includedownload erfolgreich war
DATA: ok TYPE c.

*globale Tabelle der Tabellentypen: Sammlung fuer Downlaod
DATA: it_tabletypes TYPE STANDARD TABLE OF dd40vv,
      wa_tabletypes LIKE LINE OF it_tabletypes.

*Typ der nur die wichtigen Infos zu Tabellentyp enthält
TYPES: BEGIN OF itabletypes,
          typename TYPE dd40vv-typename,
          rowtype TYPE dd40vv-rowtype,
          rowkind TYPE string,
          datatype TYPE dd40vv-datatype,
          leng TYPE dd40vv-leng,
          decimals TYPE dd40vv-decimals,
          accessmode  TYPE string,
          keydef TYPE string,
          keykind TYPE string,
          generic TYPE dd40vv-generic,
       END OF itabletypes.
*Typ fuer Schluesselfelder von Tabellentypen
TYPES: BEGIN OF idd42s,
          keyfdpos TYPE dd42s-keyfdpos,
          keyfield TYPE dd42s-keyfield,
       END OF idd42s.

*Tabelle fuer alle Tabellentypen
TYPES: BEGIN OF all_tabletypes,
          typename TYPE ddtypes-typename,
       END OF all_tabletypes.
DATA: it_all_tabletypes TYPE STANDARD TABLE OF all_tabletypes.


*Typ mit Joindedingungen im View
TYPES: BEGIN OF idd28j,
          ltab     TYPE dd28j-ltab,
          lfield   TYPE dd28j-lfield,
          operator TYPE dd28j-operator,
          rtab     TYPE dd28j-rtab,
          rfield   TYPE dd28j-rfield,
       END OF idd28j.

*Typ mit wichtigen Selektionsbedingungen fuer Views
*(Basis Tabelle dd28s)
TYPES: BEGIN OF idd28s,
          tabname TYPE dd28s-tabname,
          fieldname TYPE dd28s-fieldname,
          operator TYPE dd28s-operator,
          constants TYPE dd28s-constants,
       END OF idd28s.


*Typ mit wichtigen Felder der Viewfeler
*(Basis: dd27s)
TYPES: BEGIN OF idd27s,
          viewfield TYPE dd27s-viewfield,
          tabname  TYPE dd27s-tabname,
          fieldname TYPE dd27s-fieldname,
       END OF idd27s.
*Uebersicht der Berechtigungsobjekte
DATA: it_tobj TYPE STANDARD TABLE OF tobj,
      wa_tobj LIKE LINE OF it_tobj.
*Aktivitaeten zu den Berichtigungsobjekten
DATA: it_tactz TYPE STANDARD TABLE OF tactz,
      wa_tactz LIKE LINE OF it_tactz.

*Berechtigungsfelder
DATA: it_authx TYPE STANDARD TABLE OF authx,
      wa_authx LIKE LINE OF it_authx.
*Globale Bereiche für Titlebars
DATA: it_d347t TYPE STANDARD TABLE OF d347t,
      wa_d347t  LIKE LINE OF it_d347t.

*Übersichtstabelle über Zuordnung von Transaktionen
*zu Programmen
TYPES: BEGIN OF itstc,
          tcode TYPE tstc-tcode,
          pgmna TYPE tstc-pgmna ,
          dypno TYPE tstc-dypno,
       END OF itstc.
DATA: it_tstc TYPE STANDARD TABLE OF itstc,
      wa_tstc LIKE LINE OF it_tstc.

*Transaktionscodetabelle fuer Klassen (Parmetertabelle)
DATA: it_tstcp TYPE STANDARD TABLE OF tstcp,
      wa_tstcp LIKE LINE OF it_tstcp.

*Globale Tabellen für Menueaufbau Pfstatus
DATA: it_rsmpe_tree TYPE STANDARD TABLE OF rsmpe_tree,
      wa_rsmpe_tree LIKE LINE OF it_rsmpe_tree.

*Globale Tabelle für Functionkeys
DATA: it_rsmpe_keys TYPE STANDARD TABLE OF rsmpe_keys.

**********************************************************
*Addition of code for search help, Enhancement spots
**********************************************************

*----Global table for search help.
TYPES: BEGIN OF shelp,
        shlpname   TYPE shlpname,
        as4local   TYPE as4local,
        issimple   TYPE ddshsimple,
        selmethod  TYPE selmethod,
        selmexit   TYPE ddshselext,
        fieldname  TYPE shlpfield,
        flposition TYPE sfposition,
        rollname   TYPE shlpsparde,
        shlpinput  TYPE shlpinput,
        shlpoutput TYPE shlpoutput,
        shlpselpos TYPE shlplispos,
        shlplispos TYPE shlplispos,
        ddlanguage TYPE ddlanguage,
        ddtext     TYPE ddtext,
      END OF shelp.

DATA: it_dd30t TYPE STANDARD TABLE OF dd30t,
      wa_dd30t LIKE LINE OF it_dd30t.

DATA: it_dd32s TYPE STANDARD TABLE OF dd32s,
      wa_dd32s LIKE LINE OF it_dd32s.

DATA: it_dd30l TYPE STANDARD TABLE OF dd30l,
      wa_dd30l LIKE LINE OF it_dd30l.

DATA: it_serchlp TYPE STANDARD TABLE OF shelp,
      wa_serchlp LIKE LINE OF it_serchlp.


*----Enhancement spots

*Global table for search help.
TYPES: BEGIN OF enhspot,
         enhspot   TYPE enhspotname,
         version   TYPE r3state,
         obj_type  TYPE trobjtype,
         obj_name  TYPE char40,
         main_name TYPE eu_aname,
       END OF enhspot.

DATA: it_enhspot TYPE STANDARD TABLE OF enhspotobj,
      wa_enhspot LIKE LINE OF it_enhspot.


*----WEB-DynPro
TYPES: BEGIN OF web_dyn,
    component_name   TYPE wdy_component_name,
    cmp_controller   TYPE wdy_controller_name,
    cmp_interface    TYPE wdy_component_name,
    windows          TYPE wdy_view_name,
    view              TYPE wdy_view_name,
    application_name TYPE wdy_application_name,
      END OF web_dyn.

DATA: it_wdy_comp TYPE STANDARD TABLE OF wdy_component,
      it_wdy_view TYPE STANDARD TABLE OF wdy_view,
      it_wdy_appl TYPE STANDARD TABLE OF wdy_application,
      it_webdyn_f TYPE TABLE OF web_dyn,

      wa_webdyn_f LIKE LINE OF it_webdyn_f,
      wa_wdy_comp LIKE LINE OF it_wdy_comp,
      wa_wdy_view LIKE LINE OF it_wdy_view,
      wa_wdy_appl LIKE LINE OF it_wdy_appl.

*----New Core BADI.
TYPES: BEGIN OF ty_badi,
        badi_name      TYPE badi_name,
        interface_name TYPE classname,
        enhname        TYPE enhname,
        badi_impl      TYPE badi_impl_name,
        class_name     TYPE classname,
        is_default     TYPE char1,
      END OF ty_badi.

DATA: it_badi TYPE STANDARD TABLE OF ty_badi,
      wa_badi LIKE LINE OF it_badi.

DATA: it_badi_impl TYPE STANDARD TABLE OF badi_impl,
      wa_badi_impl LIKE LINE OF it_badi_impl.

DATA: it_badi_int TYPE STANDARD TABLE OF badi_main,
      wa_badi_int LIKE LINE OF it_badi_int.
**********************************************************

*Stückliste für Klassenliste
TYPES: BEGIN OF classlist,
         typus(20) TYPE c,
         inc TYPE trdir-name,
         meth TYPE tmdir-methodname ,
         file_inc TYPE trdir-name,
       END OF classlist.
DATA: it_classlist TYPE STANDARD TABLE OF  classlist,
      wa_classlist LIKE LINE OF it_classlist.

*Verarbeitung von verschachtelten Aufrufstrukturen
TYPES: BEGIN OF collectmains,
         typus(4) TYPE c,
         mainname(40) TYPE c,
       END OF collectmains.

DATA: it_collectmains TYPE STANDARD TABLE OF collectmains
                      WITH NON-UNIQUE KEY mainname,
      wa_collectmains LIKE LINE OF it_collectmains.

*Bereiche fuer Interface in einer Klass zu schreiben
DATA: it_vseoimplem TYPE STANDARD TABLE OF vseoimplem.

*Bereiche fuer Dialogbausteine
*1.) Zuordnung Dialogbaustein -&gt; Modulpool; Gesamttabelle
TYPES: BEGIN OF itdct,
          dnam TYPE tdct-dnam,
          prog TYPE tdct-prog,
          dynr TYPE tdct-dynr,
       END OF itdct.
DATA: it_tdct TYPE STANDARD TABLE OF itdct,
      wa_tdct LIKE LINE OF it_tdct.
*2.) Zuordnung der Parameter zu einem Funktionsbaustein; Gesamttabelle
DATA: it_diapar TYPE STANDARD TABLE OF diapar,
      wa_diapar LIKE LINE OF it_diapar.

*Bereiche fuer SET/GET Parameter; globale fuer jeweiliges Rahmenprogramm
DATA: it_tpara TYPE STANDARD TABLE OF tpara,
      wa_tpara LIKE LINE OF it_tpara.

*Bereiche fuer HTML-Tabellendatei (wird global fuer alle HTML-Dateien
*definiert
DATA: it_html TYPE STANDARD TABLE OF line,
      wa_html LIKE LINE OF it_html.
*global table for ABAP.xsl
DATA: it_abap_xsl TYPE STANDARD TABLE OF line.
*global table for formate.css
DATA: it_formate_css TYPE STANDARD TABLE OF line.
*global table for nav.xsl
DATA: it_nav_xsl TYPE STANDARD TABLE OF line.
*global table for table.xsl
DATA: it_table_xsl TYPE STANDARD TABLE OF line.
*global table for blank.xsl
DATA: it_blank_xsl TYPE STANDARD TABLE OF line.

*Datenobjekte für XSL-Files
DATA: it_xsl TYPE STANDARD TABLE OF line.

*Zusammenfassende Tabelle fuer Kunden erweiterungsprogjekt
TYPES: BEGIN OF enhancecomp,
          sapenh TYPE modsap-name,
          comp TYPE modsap-member,
          typus(20) TYPE c,
          internal(50) TYPE c,
          file_internal(50) TYPE c,
       END OF enhancecomp.

DATA: it_enhancecomp TYPE STANDARD TABLE OF enhancecomp,
      wa_enhancecomp LIKE LINE OF it_enhancecomp.

*Tabelle fuer Selektion ueber Entwicklungsklasse
DATA: it_tadir TYPE STANDARD TABLE OF tadir,
      wa_tadir LIKE LINE OF it_tadir.

*interne Tabelle fuer Wertehilfe bei Modinamen
DATA:  BEGIN OF it_f4_modi OCCURS 0,
          name LIKE smodilog-sub_name,
       END OF  it_f4_modi.


*interne Tabelle fuer Wertehilfe bei Klassen
DATA:  BEGIN OF it_f4_class OCCURS 0,
          name LIKE vseoclass-clsname,
       END OF  it_f4_class.

*interne Tabelle fuer Wertehilfe bei Interfaces
DATA:  BEGIN OF it_f4_intf OCCURS 0,
          name LIKE vseointerf-clsname,
       END OF  it_f4_intf.
*intern Tabelle fuer Wertehilfe bei Badiimplementierung
*interne Tabelle fuer Wertehilfe bei Enhancementprojekt
DATA:  BEGIN OF it_f4_cmod OCCURS 0,
          name LIKE modact-name,
       END OF  it_f4_cmod.
*intern Tabelle fuer Wertehilfe bei Badiimplementierung
DATA: BEGIN OF it_f4_badiimp OCCURS 0,
          name LIKE sxc_attr-imp_name,
      END OF it_f4_badiimp.
*globale tabelle um die heruntergeladenen Typgruppen von Customer-
*enhancements in die spezifische Enhancementstueckliste schreiben
*zu koennen
DATA: it_enh_d010inc TYPE STANDARD TABLE OF d010inc.

*Globale Tabelle um die heruntergeladenen Tabellen von Customer-
*enhancements in die spezifischen Enhancementstrueckliste schreiben
*zu koennen
TYPES: BEGIN OF enh_d010tab,
        tabname TYPE d010tab-tabname,
        typus(4) TYPE c,
      END OF  enh_d010tab.
DATA: it_enh_d010tab TYPE STANDARD TABLE OF enh_d010tab,
      wa_enh_d010tab LIKE LINE OF it_enh_d010tab.

*Globale Tabelle fuer Informationen von Menueexits
DATA: it_cuatexts TYPE STANDARD TABLE OF cuatexts.

*Tabelle fuer Rueckgabewert der ausprogrammierten F4-Hilfen
DATA: it_rueck TYPE STANDARD TABLE OF ddshretval,
      wa_rueck LIKE LINE OF it_rueck.

*Gesamttabelle einer Implementierung zur Uebersicht Badi zu
*Implementierung und Filterparameter
DATA: it_ges_sxc_exit TYPE STANDARD TABLE OF sxc_exit.

*Typ fuer Dialogbausteine
TYPES: BEGIN OF dialogmodule,
            header  LIKE tdct,
            par LIKE diapar,
       END OF dialogmodule.

*Typ zur Speicherung von Klassenhierarchien
TYPES: BEGIN OF inheritance,
          sub TYPE vseoextend-clsname,
          super TYPE vseoextend-clsname,
       END OF inheritance.
*Tabelle + Workarea fuer Vererbungshierachie
DATA: it_inheritance TYPE STANDARD TABLE OF inheritance,
      wa_inheritance LIKE LINE OF it_inheritance.

*Protokolltabelle fuer Ausgabe
TYPES: BEGIN OF protocol,
          typus TYPE c,
          objtype(20) TYPE c,
          objname(50) TYPE c,
          filename TYPE string,
       END OF protocol.

DATA: it_protocol TYPE STANDARD TABLE OF protocol,
      wa_protocol LIKE LINE OF it_protocol.

*Variable zum Zusammenbauen der Ueberschrift
DATA: header TYPE string.

*globale Tabelle fuer Haupttransportauftraege(Objekte haengen
*an Unterauftraegen
DATA: it_trkorr_ueber TYPE STANDARD TABLE OF e070-strkorr.

*Struktur zum Sichern der globalen Tabellen eines Rahmenprogramms
TYPES: BEGIN OF global_save,
        type TYPE c,
        name LIKE wa_trdir-name,
       END OF global_save.

*Bereiche zur Sicherung der globalen Tabellen eines Rahmenprogramms
DATA: it_global_save TYPE STANDARD TABLE OF global_save,
      wa_global_save LIKE LINE OF it_global_save.
*Arbeitsbereich zur temporaeren Speicherung der globalen Tabellen
DATA: it_tmpgs TYPE STANDARD TABLE OF global_save.

*Returncode fuer Methodenaufruf Directory_Create
DATA: rc TYPE i.

*Variable fuer globalen Namen des uebergeordneten Objektes
DATA: global_main_name LIKE wa_trdir-name.


*interner Typ fuer Domaenenattribute, der nur die notwendigen
*Werte enthaelt
TYPES: BEGIN OF idd01v,
          domname TYPE dd01v-domname,
          ddlanguage TYPE dd01v-ddlanguage,
          datatype TYPE dd01v-datatype,
          leng TYPE dd01v-leng,
          outputlen TYPE dd01v-outputlen,
          decimals TYPE dd01v-decimals,
          lowercase TYPE dd01v-lowercase,
          signflag TYPE dd01v-signflag,
          valexi TYPE dd01v-valexi,
          entitytab TYPE dd01v-entitytab,
          convexit TYPE dd01v-convexit,
          ddtext   TYPE dd01v-ddtext,
       END OF idd01v.

*interner Typ fuer Domaenenfestwert, der nur die notwendigen
*Werte enthaelt
TYPES: BEGIN OF directory_list,
        dir TYPE string,
       END OF directory_list.
DATA: it_directory_list TYPE STANDARD TABLE OF directory_list,
      wa_directory_list LIKE LINE OF it_directory_list.

*globaler Verzeichnisname
DATA: dir TYPE string.

*Verzeichnisname für Entwicklungsklassen
DATA: dc_path TYPE string.

*Verzeichnisname bei Transportauftraegen
DATA: tr_path TYPE string.


*Typ fuer Liste der Oberobjekte bei Einzelselektion
TYPES: BEGIN OF obj_list,
          name TYPE string,
       END OF obj_list.
*Bereiche fuer Liste der Einzelselektionen
DATA: it_obj_list TYPE STANDARD TABLE OF obj_list,
      wa_obj_list LIKE LINE OF it_obj_list.

*Variable für Pfadsuche.
FIELD-SYMBOLS: &lt;g_folder&gt; TYPE ANY.
*Flag, ob Externe Programmaufe abgearbeitet werden
DATA: extern TYPE c.

*Typ fuer Wetehilfe von Domänen
TYPES: BEGIN OF idd07v,
          domname TYPE dd07v-domname,
          valpos TYPE dd07v-valpos,
          ddlanguage TYPE dd07v-ddlanguage,
          domvalue_l TYPE dd07v-domvalue_l,
          domvalue_h TYPE dd07v-domvalue_h,
          ddtext TYPE dd07v-ddtext,
       END OF idd07v.


*Versionstabelle fuer Hilfe der Modifikationen
DATA: it_vrsd TYPE STANDARD TABLE OF vrsd,
      wa_vrsd LIKE LINE OF it_vrsd.

*Zwischentabelle fuer Selektion aus smodilog
TYPES: BEGIN OF such,
        sub_name TYPE smodilog-sub_name,
      END OF such.
DATA: it_such TYPE STANDARD TABLE OF such.

*Tabelle zur Aufnahme der Verzeichnis
*Typ fuer Tabelllen/View und  Appendstrukturen, der nur die notwendigen
*Informationen enthält
TYPES: BEGIN OF idd03p,
          tabname TYPE dd03p-tabname,
          fieldname TYPE dd03p-fieldname,
          shorttext TYPE dfies-fieldtext,
          position TYPE dd03p-position,
          keyflag TYPE dd03p-keyflag,
          mandatory TYPE dd03p-mandatory,
          rollname TYPE dd03p-rollname,
          checktable TYPE dd03p-checktable,
          adminfield TYPE dd03p-adminfield,
          reftable TYPE dd03p-reftable,
          precfield TYPE dd03p-precfield,
          notnull TYPE dd03p-notnull,
          datatype TYPE dd03p-datatype,
          leng   TYPE dd03p-leng,
          decimals TYPE dd03p-decimals,
       END OF idd03p.

DATA: g_nodep(1) TYPE c.

*Variablen zur Belegung initialer Textelemente
DATA: text001 TYPE string,
      text002 TYPE string,
      text003 TYPE string,
      text004 TYPE string,
      text005 TYPE string,
      text006 TYPE string,
      text007 TYPE string,
      text008 TYPE string,
      text009 TYPE string,
      text010 TYPE string,
      text011 TYPE string,
      text012 TYPE string,
      text013 TYPE string,
      text014 TYPE string,
      text015 TYPE string,
      text016 TYPE string,
      text017 TYPE string,
      text018 TYPE string,
      text019 TYPE string,
      text020 TYPE string,
      text021 TYPE string,
      text022 TYPE string,
      text023 TYPE string,
      text024 TYPE string,
      text025 TYPE string,
      text026 TYPE string,
      text027 TYPE string,
      text028 TYPE string,
      text029 TYPE string,
      text030 TYPE string,
      text031 TYPE string,
      text032 TYPE string,
      text033 TYPE string,
      text034 TYPE string,
      text035 TYPE string,
      text036 TYPE string,
      text037 TYPE string,
      text038 TYPE string,
      text039 TYPE string,
      text043 TYPE string,
      text044 TYPE string,
      text045 TYPE string,
      text046 TYPE string,
      text047 TYPE string,
      text050 TYPE string,
      text051 TYPE string,
      text055 TYPE string,
      text056 TYPE string,
      text058 TYPE string,
      text060 TYPE string,
      text061 TYPE string,
      text066 TYPE string,
      text071 TYPE string,
      text072 TYPE string.


*Variablen zur Steuerung der Belegung der Selektionstexte
DATA: program TYPE sy-cprog,
      it_tp TYPE STANDARD TABLE OF textpool,
      wa_tp LIKE LINE OF it_tp.
DATA tp_flag(1) TYPE c.

DATA: g_order_prog  TYPE string VALUE  10,
      g_order_fugr  TYPE string VALUE  20,
      g_order_class TYPE string VALUE  30,
      g_order_intf  TYPE string VALUE  40,
      g_order_tran  TYPE string VALUE  50,
      g_order_iasp  TYPE string VALUE  60,
      g_order_idoc  TYPE string VALUE  70,
      g_order_iext  TYPE string VALUE  80,
      g_order_sxci  TYPE string VALUE 90,
      g_order_cmod  TYPE string VALUE  100,
      g_order_modis TYPE string VALUE  110,
      g_order_msag  TYPE string VALUE  130,
      g_order_func  TYPE string VALUE  210,
      g_order_meth  TYPE string VALUE  220,
      g_order_class_main  TYPE string VALUE  230,
      g_order_cpri  TYPE string VALUE  240,
      g_order_cpro  TYPE string VALUE  250,
      g_order_cpub  TYPE string VALUE  260,
      g_order_intf_main TYPE string VALUE  270,
      g_order_reps  TYPE string VALUE  280,
      g_order_dynp  TYPE string VALUE  290,
      g_order_cuad_key TYPE string VALUE  300,
      g_order_cuad_menu TYPE string VALUE  300,
      g_order_cuad_pf TYPE string VALUE  300,
      g_order_ddic_main TYPE string VALUE  310,
      g_order_tabl_tab  TYPE string VALUE  320,
      g_order_tabl_struc  TYPE string VALUE  330,
      g_order_tabl_app  TYPE string VALUE  340,
      g_order_view  TYPE string VALUE  350,
      g_order_ttyp  TYPE string VALUE  360,
      g_order_typd  TYPE string VALUE  370,
      g_order_dtel  TYPE string VALUE  380,
      g_order_doma  TYPE string VALUE  390,
      g_order_shlp  type string VALUE  392, &quot;DNE_KW11
      g_order_enqu  TYPE string VALUE  400,
      g_order_suso  TYPE string VALUE  410,
      g_order_auth  TYPE string VALUE  420,
      g_order_exit_func TYPE string VALUE  430,
      g_order_mess  TYPE string VALUE  440,
      g_order_tran_main TYPE string VALUE  450,
      g_order_rept  TYPE string VALUE  460,
      g_order_iact  TYPE string VALUE  470,
      g_order_para  TYPE string VALUE  480,
      g_order_func_call TYPE string VALUE  610,
      g_order_class_used  TYPE string VALUE  620,
      g_order_intf_used TYPE string VALUE  630,
      g_order_prog_ext  TYPE string VALUE  640,
      g_order_enh_spot type string VALUE 700,   &quot;DNE_KW11
      g_order_core_badi type string VALUE 710,  &quot;DNE_KW11
      g_order_webd type string VALUE 700,       &quot;DNE_KW11
      g_order_iext_filter TYPE string VALUE  810,
      g_order_exit_reps TYPE string VALUE  910,
      g_order_exit_dynp TYPE string VALUE  920,
      g_order_exit_cuad TYPE string VALUE  930,
      g_order_exit_reps_used  TYPE string VALUE  940,
      g_order_modi_dynp TYPE string VALUE  1030,
      g_order_modi_func TYPE string VALUE  1020,
      g_order_modi_reps TYPE string VALUE  1010,
      g_order_class_rel TYPE string VALUE  1210,
      g_order_fugr_rel  TYPE string VALUE  1220,
      g_order_dial  TYPE string VALUE  1410,
      g_order_prog_dial TYPE string VALUE  1420,
      g_order_sys_info  TYPE string VALUE  9999.

************************************************
*
*Initialisierungen
*************************************************
INITIALIZATION.

*Belegung der Selektionstexte nach erstem Start
  program = sy-cprog.
  READ TEXTPOOL program INTO it_tp LANGUAGE sy-langu.
  DELETE it_tp WHERE entry = &apos;&apos; AND id = &apos;S&apos;.
  READ TABLE it_tp INTO wa_tp WITH KEY key = &apos;O_LAN&apos;.
  IF NOT wa_tp-entry = &apos;        Documentation Language&apos;.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_IACS&apos;.
    wa_tp-entry = &apos;        IAC-Service(ITS)&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_LAN&apos;.
    wa_tp-entry = &apos;        Documentation Language&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_BADIS&apos;.
    wa_tp-entry = &apos;        Badi-Implementation&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_CLASS&apos;.
    wa_tp-entry = &apos;        Classes&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_CMOD&apos;.
    wa_tp-entry = &apos;        Enhancement Project&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_DEVCL&apos;.
    wa_tp-entry = &apos;        Developmentclass&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_DYNP&apos;.
    wa_tp-entry = &apos;        Dynpro&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_FKGRP&apos;.
    wa_tp-entry = &apos;        Functiongroups&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_FUNC&apos;.
    wa_tp-entry = &apos;        Functionmodule&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_IDOC&apos;.
    wa_tp-entry = &apos;        IDoc/Enhancement&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_INC&apos;.
    wa_tp-entry = &apos;        Include&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_INTF&apos;.
    wa_tp-entry = &apos;        Interface&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_PROG&apos;.
    wa_tp-entry = &apos;        Online-Program&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_TCODE&apos;.
    wa_tp-entry = &apos;        Transactioncode&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_TRKORR&apos;.
    wa_tp-entry = &apos;        Transport-Request&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_UNAME&apos;.
    wa_tp-entry = &apos;        User&apos;.
    APPEND wa_tp TO it_tp.


    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;PFAD&apos;.
    wa_tp-entry = &apos;        Existing path&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_APP1&apos;.
    wa_tp-entry = &apos;        Data-File auf App-Server&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_APP2&apos;.
    wa_tp-entry = &apos;        CO-File auf App-Server&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_ASC&apos;.
    wa_tp-entry = &apos;        Asci Mode&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_BASIS&apos;.
    wa_tp-entry = &apos;        Basistype&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_BIN&apos;.
    wa_tp-entry = &apos;        Binary Mode&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_DEVC&apos;.
    wa_tp-entry = &apos;        Selection via Developmentclass&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_DOWN&apos;.
    wa_tp-entry = &apos;        Download vom R/3-Server&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_ENH&apos;.
    wa_tp-entry = &apos;        Enhancement&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_FRONT&apos;.
    wa_tp-entry = &apos;        Verzeichnis WS&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_LOGIC&apos;.
    wa_tp-entry = &apos;        Logical Development&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_OVER&apos;.
    wa_tp-entry = &apos;        Bestehende Dat. übeschr.&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_SINGLE&apos;.
    wa_tp-entry = &apos;        Selction via single Objects&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_TRFIL&apos;.
    wa_tp-entry = &apos;        Handling of Transport Files&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_TRKOR1&apos;.
    wa_tp-entry = &apos;        Transportauftrag&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_TRKORR&apos;.
    wa_tp-entry = &apos;        Selection via Transportrequest&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_NSPACE&apos;.
    wa_tp-entry = &apos;        Namespace&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_UP&apos;.
    wa_tp-entry = &apos;        Upload zum R/3-Server&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;P_NODEP&apos;.
    wa_tp-entry = &apos;        No Dep. Obj. (Cust. Namespace)&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SIREPS&apos;.
    wa_tp-entry = &apos;        Includes&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SIFUNC&apos;.
    wa_tp-entry = &apos;        Function Modules&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SITABL&apos;.
    wa_tp-entry = &apos;        Tables / Views / Structures&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SITTYP&apos;.
    wa_tp-entry = &apos;        Tabletypes&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SITYPD&apos;.
    wa_tp-entry = &apos;        Typepool&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SIDTEL&apos;.
    wa_tp-entry = &apos;        Dataelements&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SIDOMA&apos;.
    wa_tp-entry = &apos;        Domains&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SIENQU&apos;.
    wa_tp-entry = &apos;        Lock Object&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SISUSO&apos;.
    wa_tp-entry = &apos;        Authority Objects&apos;.
    APPEND wa_tp TO it_tp.

    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SITRAN&apos;.
    wa_tp-entry = &apos;        Transaction Codes&apos;.
    APPEND wa_tp TO it_tp.

*Addition of code for search help, enhancement spot, Webdynpro

*----Search Help.
    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_SRCHEP&apos;.
    wa_tp-entry = &apos;        Search Help&apos;.
    APPEND wa_tp TO it_tp.

*----Enhancement Spot
    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_ENHSPT&apos;.
    wa_tp-entry = &apos;        Enhancement Spot&apos;.
    APPEND wa_tp TO it_tp.

*----Webdynpro
    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_WEBD&apos;.
    wa_tp-entry = &apos;        Web-Dyn Pro&apos;.
    APPEND wa_tp TO it_tp.

*----New core BADI
    wa_tp-id = &apos;S&apos;. wa_tp-key = &apos;O_BADI&apos;.
    wa_tp-entry = &apos;        New Core BADI&apos;.
    APPEND wa_tp TO it_tp.
***************************************************************

    INSERT textpool program FROM it_tp LANGUAGE sy-langu.
    tp_flag = &apos;X&apos;.
*Stautusmeldung als Hinweis fuer Neustart
    MESSAGE i888(sabapdocu) WITH
     &apos;This is the first time you start this report.&apos;
    &apos;After the next start the &apos;
     &apos;selectiontexts are initialized!&apos;.
  ENDIF.
***************************************************************

*Initialisierung der Bezeichnungsfelder;
*Zum besseren Upload werden die Textelemente mit den Inhalten der
*Variablen gefuellt, wenn die Textelemente nicht belegt sind.
  text001 =&apos;SUBRC&apos;(001).
  text002 = &apos;by reading object list for&apos;(002).
  text003 = &apos;by write file&apos;(003).
  text004 = &apos;saved as&apos;(004).
  text005 = &apos;Continue ?&apos;(005).
  text006 = &apos;More then 50 programs found.&apos;(006).
  text007 =  &apos;Information&apos;(007).
  text008 = &apos;Object list&apos;(008).
  text009 = &apos;Table/View&apos;(009).
  text010 = &apos;Maininclude&apos;(010).
  text011 = &apos;Include&apos;(011).
  text012 = &apos;Objectlist&apos;(012).
  text013 = &apos;not saved as&apos;(013).
  text014 = &apos;Download error...&apos;(014).
  text015 = &apos;Directory exists ?&apos;(015).
  text016 = &apos;Summary&apos;(016).
  text017 = &apos;Screen&apos;(017).
  text018 = &apos;Textelements&apos;(018).
  text019 = &apos;Parts List&apos;(019).
  text020 = &apos;Messagetable&apos;(020).
  text021 = &apos;Fktgroupstructure&apos;(021).
  text022 = &apos;Dataelements&apos;(022).
  text023 = &apos;DomainHeader&apos;(023).
  text024 = &apos;DomainValues&apos;(024).
  text025 = &apos;Typegroup&apos;(025).
  text026 = &apos;Structure&apos;(026).
  text027 = &apos;Append&apos;(027).
  text028 = &apos;Directory exists Already&apos;(028).
  text029 = &apos;Yes for next Main-program!&apos;(029).
  text030 = &apos;No for stop !&apos;(030).
  text031 = &apos;Autthorityobjects&apos;(031).
  text032 = &apos;Author. Acti&apos;(032).
  text033 =	&apos;Titlebar&apos;(033).
  text034 = &apos;Tacodelist&apos;(034).
  text035 = &apos;Menulist&apos;(035).
  text036 = &apos;Functionkeylist&apos;(036).
  text037 = &apos;Classinclude&apos;(037).
  text038 = &apos;Interfaceinclude&apos;(038).
  text039 = &apos;Classlist&apos;(039).
  text040 = &apos;Reports / Modulepools&apos;(040).
  text041 = &apos;Functiongroups&apos;(041).
  text042 = &apos;Classes&apos;(042).
  text043 = &apos;Dlgmd_to_Modpool_&apos;(043).
  text044 = &apos;Dlgmoduleparams&apos;(044).
  text045 = &apos;System Info&apos;(045).
  text046 = &apos;Lockobject&apos;(046).
  text047 = &apos;Set/Get-Parameter&apos;(047).
  text048 = &apos;IDOC&apos;(048).
  text049 = &apos;Customer Enhancements&apos;(049).
  text050 = &apos;Enhancementinclude&apos;(050).
  text051 = &apos;EnhOverview&apos;(051).
  text052 = &apos;via Developmentclass&apos;(052).
  text054 = &apos;Badi-Implementation&apos;(054).
  text055 = &apos;BadiImpFilter&apos;(055).
  text056 = &apos;Menuexitlist&apos;(056).
  text057 = &apos;via Transport-Request&apos;.
  text058 = &apos;Functionmodule&apos;(058).
  text059 = &apos;Selection Method&apos;(059).
  text060 = &apos;View&apos;(060).
  text061 = &apos;Authorityfields&apos;(061).
  text062 = &apos;IAC-Service(ITS)&apos;(062).

  text066 = &apos;Transport request does not exist in the source system&apos;(066)
  .
  text067 = &apos;Interfaces&apos;(067).
  text068 = &apos;Modification&apos;(068).
  text069 = &apos;Mainobjects of Workbench&apos;(069).
  text070 = &apos;Transactioncode&apos;(070).
  text071 = &apos;Messageclass&apos;(071).
  text072 = &apos;Tabletype&apos;(072).
  text073 = &apos;Main Objects&apos;(073).
  text074 = &apos;Single Objects&apos;(074).
  text075 =
&apos;Do not consider dependent / called main objects in customer nam&apos; &amp;
&apos;espace!&apos;(075)
  .

************************************************
*F4-Hilfe fuer Wahl des Basisverzeichnis
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR pfad.
*Dummyvariablen zur Zuweisung je nach Release
  DATA: lcl_char LIKE rlgrap-filename,
        lcl_string TYPE string.
*Längenbestimmung
  DATA: lcl_len TYPE i.

*Bereich fuer Lesen der Parameter
  DATA: lcl_wa_vseoparam TYPE vseoparam.

*Verarbeitung unterscheiden je nach Release:
*Typisierung nach string oder char.

*Pruefen wie der Parameter Directory der Methode  typisiert ist
  SELECT SINGLE * FROM vseoparam INTO lcl_wa_vseoparam
      WHERE clsname = &apos;CL_GUI_FRONTEND_SERVICES&apos;
       AND cmpname = &apos;DIRECTORY_BROWSE&apos;
       AND sconame = &apos;SELECTED_FOLDER&apos;.
  IF lcl_wa_vseoparam-type = &apos;C&apos;.
    ASSIGN lcl_char TO &lt;g_folder&gt;.
  ELSEIF lcl_wa_vseoparam-type = &apos;STRING&apos;.
    ASSIGN lcl_string TO &lt;g_folder&gt;.
  ENDIF.


  CALL METHOD cl_gui_frontend_services=&gt;directory_browse
    EXPORTING
      window_title    = &apos;Selection of Basis Folder&apos;
      initial_folder  = &apos;C:\&apos;
    CHANGING
      selected_folder = &lt;g_folder&gt;
    EXCEPTIONS
      cntl_error      = 1
*      ERROR_NO_GUI    = 2
*      others          = 3
          .
  IF sy-subrc = 0.
    CALL METHOD cl_gui_cfw=&gt;flush
      EXCEPTIONS
        cntl_system_error = 1
        cntl_error        = 2
        OTHERS            = 3.
    IF sy-subrc = 0.
      lcl_len = STRLEN( &lt;g_folder&gt; ).
      IF lcl_len &lt;= c_path_length.
        pfad = &lt;g_folder&gt;.
      ELSE.
        MESSAGE i888(sabapdocu) WITH
       &apos;Only&apos; c_path_length &apos;characters allowed!&apos;
       &apos;Reselect a path!&apos;.

      ENDIF.
    ENDIF.
  ENDIF.

************************************************
*F4-Hilfe fuer Wahl des Transportaufträge
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_trkorr-low.
  DATA: lcl_it_e070 TYPE STANDARD TABLE OF e070.

  IF p_uname IS INITIAL.
    SELECT * FROM e070 INTO TABLE lcl_it_e070.
  ELSE.
    SELECT * FROM e070 INTO TABLE lcl_it_e070
                       WHERE as4user  = p_uname.
  ENDIF.

  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;TRKORR&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = lcl_it_e070
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_trkorr-low = wa_rueck-fieldval.
  ENDIF.
  REFRESH lcl_it_e070.

************************************************
*F4-Hilfe fuer Modifizierte Includes
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_inc-low.
*Bereiche fuer Kundenenhancementtabelle
  DATA: lcl_it_smodilog  TYPE STANDARD TABLE OF smodilog-sub_name,
        lcl_wa_smodilog  LIKE LINE OF lcl_it_smodilog.

* Create search string for partner namespace
* Take customer name space if initial
  IF p_nspace IS INITIAL.
    p_nspace = &apos;Z&apos;.
  ENDIF.
  CONCATENATE p_nspace &apos;%&apos; INTO g_name.
  CONDENSE g_name NO-GAPS.

*Initialisieren der Tabellen
  REFRESH lcl_it_smodilog. CLEAR lcl_wa_smodilog.

  REFRESH it_such. REFRESH it_vrsd.
*Relevante Daten aus der Versionverwaltung lesen.
  SELECT * FROM vrsd INTO TABLE it_vrsd
      WHERE objtype = &apos;REPS&apos;
        AND  versno = &apos;00000&apos;
        AND  objname NOT LIKE &apos;Z%&apos;
        AND  objname NOT LIKE &apos;Y%&apos;
        AND  objname NOT LIKE g_name
        AND  korrnum NOT LIKE &apos;SAP%&apos;
        AND  korrnum NOT LIKE &apos;UPGRADE%&apos;.

  LOOP AT it_vrsd INTO wa_vrsd.
    APPEND wa_vrsd-objname TO it_such.
  ENDLOOP.

*Modi-Tabelle
  SELECT DISTINCT sub_name FROM smodilog INTO TABLE lcl_it_smodilog
            FOR ALL ENTRIES IN it_such
                  WHERE sub_name = it_such-sub_name.

  LOOP AT lcl_it_smodilog INTO lcl_wa_smodilog.
    APPEND lcl_wa_smodilog TO it_f4_modi.
  ENDLOOP.


  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;o_inc-low&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = it_f4_modi
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_inc-low = wa_rueck-fieldval.
  ENDIF.
  REFRESH it_f4_modi.

************************************************
*F4-Hilfe fuer einzelne Includes
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sireps-low.
  DATA: lcl_it_include TYPE STANDARD TABLE OF d010inc.

  IF NOT o_sireps IS INITIAL.

    SELECT * FROM d010inc INTO TABLE lcl_it_include
             WHERE include IN o_sireps.
  ENDIF.

  REFRESH it_rueck.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;D010INC&apos;
      retfield        = &apos;INCLUDE&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lcl_it_include
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_sireps-low = wa_rueck-fieldval.
  ENDIF.

************************************************
*F4-Hilfe fuer einzelnen Funktionsbaustein
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sifunc-low.
  DATA: lcl_it_tfdir TYPE STANDARD TABLE OF tfdir.

  IF NOT o_sifunc IS INITIAL.

    SELECT * FROM tfdir INTO TABLE lcl_it_tfdir
             WHERE funcname IN o_sifunc.
  ENDIF.

  REFRESH it_rueck.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;TFDIR&apos;
      retfield        = &apos;FUNCNAME&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lcl_it_tfdir
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_sifunc-low = wa_rueck-fieldval.
  ENDIF.

************************************************
*F4-Hilfe fuer einzelne Tabellen / Strukturen/ View
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sitabl-low.
  DATA: lcl_it_info_tabl TYPE STANDARD TABLE OF info_tabl.

  IF NOT o_sitabl IS INITIAL.

    SELECT * FROM info_tabl INTO TABLE lcl_it_info_tabl
             WHERE tabname IN o_sitabl
               AND tabclass IN (&apos;TRANSP&apos;, &apos;VIEW&apos;,
                                &apos;INTTAB&apos;, &apos;APPEND&apos;).
  ENDIF.

  REFRESH it_rueck.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;INFO_TABL&apos;
      retfield        = &apos;TABNAME&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lcl_it_info_tabl
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_sitabl-low = wa_rueck-fieldval.
  ENDIF.

************************************************
*F4-Hilfe fuer einzelne Tabellentypen
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sittyp-low.
  DATA: lcl_it_dd40vv TYPE STANDARD TABLE OF dd40vv.

  IF NOT o_sittyp IS INITIAL.

    SELECT * FROM dd40vv INTO TABLE lcl_it_dd40vv
             WHERE typename IN o_sittyp.
  ENDIF.

  REFRESH it_rueck.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;DD40VV&apos;
      retfield        = &apos;TYPENAME&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lcl_it_dd40vv
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_sittyp-low = wa_rueck-fieldval.
  ENDIF.


************************************************
*F4-Hilfe fuer einzelne Typepools
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sitypd-low.
  DATA: lcl_dynpfields TYPE STANDARD TABLE OF dynpread WITH HEADER LINE.
* Get entry from screen
  lcl_dynpfields-fieldname  = &apos;O_SITYPD-LOW&apos;.
  APPEND lcl_dynpfields.

  CALL FUNCTION &apos;DYNP_VALUES_READ&apos;
       EXPORTING
            dyname     = sy-repid
            dynumb     = sy-dynnr
       TABLES
            dynpfields = lcl_dynpfields
       EXCEPTIONS
            OTHERS.

  IF sy-subrc EQ 0.
    READ TABLE lcl_dynpfields INDEX 1.
    o_sitypd-low = lcl_dynpfields-fieldvalue.
  ENDIF.

  CALL FUNCTION &apos;F4_DD_TYPES&apos;
    EXPORTING
      object             = o_sitypd-low
      suppress_selection = space
      display_only       = space
    IMPORTING
      RESULT             = o_sitypd-low.

************************************************
*F4-Hilfe fuer einzelne Datenelemente
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sidtel-low.
  DATA: lcl_dynpfields TYPE STANDARD TABLE OF dynpread WITH HEADER LINE.
* Get entry from screen
  lcl_dynpfields-fieldname  = &apos;O_SIDTEL-LOW&apos;.
  APPEND lcl_dynpfields.

  CALL FUNCTION &apos;DYNP_VALUES_READ&apos;
       EXPORTING
            dyname     = sy-repid
            dynumb     = sy-dynnr
       TABLES
            dynpfields = lcl_dynpfields
       EXCEPTIONS
            OTHERS.

  IF sy-subrc EQ 0.
    READ TABLE lcl_dynpfields INDEX 1.
    o_sidtel-low = lcl_dynpfields-fieldvalue.
  ENDIF.

  CALL FUNCTION &apos;F4_DD_DATA_ELEMENT&apos;
    EXPORTING
      object             = o_sidtel-low
      suppress_selection = space
      display_only       = space
    IMPORTING
      RESULT             = o_sidtel-low.

************************************************
*F4-Hilfe fuer einzelne Domänen
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sidoma-low.
  DATA: lcl_dynpfields TYPE STANDARD TABLE OF dynpread WITH HEADER LINE.
* Get entry from screen
  lcl_dynpfields-fieldname  = &apos;O_SIDOMA-LOW&apos;.
  APPEND lcl_dynpfields.

  CALL FUNCTION &apos;DYNP_VALUES_READ&apos;
       EXPORTING
            dyname     = sy-repid
            dynumb     = sy-dynnr
       TABLES
            dynpfields = lcl_dynpfields
       EXCEPTIONS
            OTHERS.

  IF sy-subrc EQ 0.
    READ TABLE lcl_dynpfields INDEX 1.
    o_sidoma-low = lcl_dynpfields-fieldvalue.
  ENDIF.

  CALL FUNCTION &apos;F4_DD_DOMAIN&apos;
    EXPORTING
      object             = o_sidoma-low
      suppress_selection = space
      display_only       = space
    IMPORTING
      RESULT             = o_sidoma-low.

************************************************
*F4-Hilfe fuer einzelne Sperrobjekte
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sienqu-low.
  DATA: lcl_dynpfields TYPE STANDARD TABLE OF dynpread WITH HEADER LINE.
* Get entry from screen
  lcl_dynpfields-fieldname  = &apos;O_SIENQU-LOW&apos;.
  APPEND lcl_dynpfields.

  CALL FUNCTION &apos;DYNP_VALUES_READ&apos;
       EXPORTING
            dyname     = sy-repid
            dynumb     = sy-dynnr
       TABLES
            dynpfields = lcl_dynpfields
       EXCEPTIONS
            OTHERS.

  IF sy-subrc EQ 0.
    READ TABLE lcl_dynpfields INDEX 1.
    o_sienqu-low = lcl_dynpfields-fieldvalue.
  ENDIF.

  CALL FUNCTION &apos;F4_DD_LOCKOBJECT&apos;
    EXPORTING
      object             = o_sienqu-low
      suppress_selection = space
      display_only       = space
    IMPORTING
      RESULT             = o_sienqu-low.

************************************************
*F4-Hilfe fuer Berechtigungsobjekte
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sisuso-low.
  DATA: lcl_it_info_suso TYPE STANDARD TABLE OF info_suso.

  IF NOT o_sisuso IS INITIAL.

    SELECT * FROM info_suso INTO TABLE lcl_it_info_suso
             WHERE objct IN o_sisuso.
  ENDIF.

  REFRESH it_rueck.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;INFO_SUSO&apos;
      retfield        = &apos;OBJCT&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lcl_it_info_suso
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_sisuso-low = wa_rueck-fieldval.
  ENDIF.

************************************************
*F4-Hilfe fuer Transaktionscodes
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_sitran-low.
  DATA: lcl_it_tstc TYPE STANDARD TABLE OF tstc.

  IF NOT o_sitran IS INITIAL.

    SELECT * FROM tstc INTO TABLE lcl_it_tstc
             WHERE tcode IN o_sitran.

  ENDIF.

  REFRESH it_rueck.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;TSTC&apos;
      retfield        = &apos;TCODE&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lcl_it_tstc
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_sitran-low = wa_rueck-fieldval.
  ENDIF.

************************************************
*F4-Hilfe fuer Modifizierte Funktionsbaustein
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_func-low.
*Bereiche fuer Kundenenhancementtabelle
  DATA: lcl_it_smodilog  TYPE STANDARD TABLE OF smodilog-sub_name,
        lcl_wa_smodilog  LIKE LINE OF lcl_it_smodilog.

* Create search string for partner namespace
* Take customer name space if initial
  IF p_nspace IS INITIAL.
    p_nspace = &apos;Z&apos;.
  ENDIF.
  CONCATENATE p_nspace &apos;%&apos; INTO g_name.
  CONDENSE g_name NO-GAPS.

*Initialisieren der Tabellen
  REFRESH lcl_it_smodilog. CLEAR lcl_wa_smodilog.

  REFRESH it_such. REFRESH it_vrsd.
*Relevante Daten aus der Versionverwaltung lesen.
  SELECT * FROM vrsd INTO TABLE it_vrsd
      WHERE objtype = &apos;FUNC&apos;
        AND  versno = &apos;00000&apos;
        AND  objname NOT LIKE &apos;Z%&apos;
        AND  objname NOT LIKE &apos;Y%&apos;
        AND  objname NOT LIKE g_name
        AND  korrnum NOT LIKE &apos;SAP%&apos;
        AND  korrnum NOT LIKE &apos;UPGRADE%&apos;.

  LOOP AT it_vrsd INTO wa_vrsd.
    APPEND wa_vrsd-objname TO it_such.
  ENDLOOP.

*Modi-Tabelle
  SELECT DISTINCT sub_name FROM smodilog INTO TABLE lcl_it_smodilog
            FOR ALL ENTRIES IN it_such
                  WHERE sub_name = it_such-sub_name.


  LOOP AT lcl_it_smodilog INTO lcl_wa_smodilog.
    APPEND lcl_wa_smodilog TO it_f4_modi.
  ENDLOOP.


  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;o_func-low&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = it_f4_modi
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_func-low = wa_rueck-fieldval.
  ENDIF.
  REFRESH it_f4_modi.


************************************************
*F4-Hilfe fuer Modifizierte Dynpros
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_dynp-low.
*Bereiche fuer Kundenenhancementtabelle
  DATA: lcl_it_smodilog  TYPE STANDARD TABLE OF smodilog-sub_name,
        lcl_wa_smodilog  LIKE LINE OF lcl_it_smodilog.
  DATA: lcl_saplname(30) TYPE c.

* Create search string for partner namespace
* Take customer name space if initial
  IF p_nspace IS INITIAL.
    p_nspace = &apos;Z&apos;.
  ENDIF.
  CONCATENATE p_nspace &apos;%&apos; INTO g_name.
  CONDENSE g_name NO-GAPS.
* Create name with SAPL*
  IF p_nspace(1) = &apos;/&apos;.
    CONCATENATE p_nspace &apos;SAPL%&apos; INTO lcl_saplname.
  ELSE.
    lcl_saplname = &apos;SAPLZ%&apos;.
  ENDIF.


*Initialisieren der Tabellen
  REFRESH lcl_it_smodilog. CLEAR lcl_wa_smodilog.

  SELECT DISTINCT sub_name FROM smodilog INTO TABLE lcl_it_smodilog
                       WHERE   sub_name NOT LIKE &apos;Z%&apos;
                               AND sub_name NOT LIKE &apos;Y%&apos;
                               AND sub_name NOT LIKE g_name
                               AND sub_name NOT LIKE &apos;SAPLZ%&apos;
                               AND sub_name NOT LIKE &apos;SAPLY%&apos;
                               AND sub_name NOT LIKE lcl_saplname
                               AND  sub_type = &apos;DYNP&apos;.

  LOOP AT lcl_it_smodilog INTO lcl_wa_smodilog.
    APPEND lcl_wa_smodilog TO it_f4_modi.
  ENDLOOP.


  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;o_dynp-low&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = it_f4_modi
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_dynp-low = wa_rueck-fieldval.
  ENDIF.
  REFRESH it_f4_modi.



************************************************************
* F4-Hilfe fuer Reports und Modulpools
************************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_prog-low.
  DATA: lcl_dynpfields TYPE STANDARD TABLE OF dynpread WITH HEADER LINE.
* Get entry from screen
  lcl_dynpfields-fieldname  = &apos;O_PROG-LOW&apos;.
  APPEND lcl_dynpfields.

  CALL FUNCTION &apos;DYNP_VALUES_READ&apos;
       EXPORTING
            dyname     = sy-repid
            dynumb     = sy-dynnr
       TABLES
            dynpfields = lcl_dynpfields
       EXCEPTIONS
            OTHERS.

  IF sy-subrc EQ 0.
    READ TABLE lcl_dynpfields INDEX 1.
    o_prog-low = lcl_dynpfields-fieldvalue.
  ENDIF.

  CALL FUNCTION &apos;REPOSITORY_INFO_SYSTEM_F4&apos;
    EXPORTING
      object_type          = &apos;PROG&apos;
      object_name          = o_prog-low
      suppress_selection   = &apos;X&apos;
    IMPORTING
      object_name_selected = o_prog-low
    EXCEPTIONS
      cancel               = 01.


************************************************
*F4-Hilfe fuer Interface
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_class-low.
  DATA: lcl_dynpfields TYPE STANDARD TABLE OF dynpread WITH HEADER LINE.
* Get entry from screen
  lcl_dynpfields-fieldname  = &apos;O_CLASS-LOW&apos;.
  APPEND lcl_dynpfields.

  CALL FUNCTION &apos;DYNP_VALUES_READ&apos;
       EXPORTING
            dyname     = sy-repid
            dynumb     = sy-dynnr
       TABLES
            dynpfields = lcl_dynpfields
       EXCEPTIONS
            OTHERS.

  IF sy-subrc EQ 0.
    READ TABLE lcl_dynpfields INDEX 1.
    o_class-low = lcl_dynpfields-fieldvalue.
  ENDIF.

  CALL FUNCTION &apos;REPOSITORY_INFO_SYSTEM_F4&apos;
    EXPORTING
      object_type          = &apos;O&apos;
      object_name          = o_class-low
      suppress_selection   = &apos;X&apos;
    IMPORTING
      object_name_selected = o_class-low
    EXCEPTIONS
      cancel               = 01.

************************************************
*F4-Hilfe fuer Interface
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_intf-low.
*Bereiche fuer Kundenenhancementtabelle
  DATA: lcl_it_vseointerf TYPE STANDARD TABLE OF vseointerf-clsname,
        lcl_wa_vseointerf LIKE LINE OF lcl_it_vseointerf.

*Initialisieren der Tabellen
  REFRESH lcl_it_vseointerf. CLEAR lcl_wa_vseointerf.
* Create search string for partner namespace
* Take customer name space if initial
  IF p_nspace IS INITIAL.
    p_nspace = &apos;Z&apos;.
  ENDIF.
  CONCATENATE p_nspace &apos;%&apos; INTO g_name.
  CONDENSE g_name NO-GAPS.

  SELECT DISTINCT clsname FROM vseointerf INTO TABLE lcl_it_vseointerf
                       WHERE clsname LIKE &apos;Z%&apos;
                         OR  clsname LIKE &apos;Y%&apos;
                         OR  clsname LIKE g_name.

  LOOP AT lcl_it_vseointerf INTO lcl_wa_vseointerf .
    APPEND lcl_wa_vseointerf TO it_f4_intf.
  ENDLOOP.

  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;o_intf-low&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = it_f4_intf
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_intf-low = wa_rueck-fieldval.
  ENDIF.
  REFRESH it_f4_intf.
************************************************
***
*F4-Hilfe fuer Enhancementprojekt (Feld modact-name
*************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_cmod-low.
*Bereiche fuer Kundenenhancementtabelle
  DATA: lcl_it_modact TYPE STANDARD TABLE OF modact-name,
        lcl_wa_modact LIKE LINE OF lcl_it_modact.

*Initialisieren der Tabellen
  REFRESH lcl_it_modact. REFRESH it_rueck.

  SELECT DISTINCT name FROM modact INTO TABLE lcl_it_modact.
  LOOP AT lcl_it_modact INTO lcl_wa_modact.
    APPEND lcl_wa_modact TO it_f4_cmod.
  ENDLOOP.

  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;o_cmod-low&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = it_f4_cmod
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_cmod-low = wa_rueck-fieldval.
  ENDIF.
  REFRESH it_f4_cmod.

************************************************************
*Ausprogrammierte F4-Hilfe fuer Badi-Implementierungen
************************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_badis-low.
*Bereiche fuer Kundenenhancementtabelle
  DATA: lcl_it_badiimp TYPE STANDARD TABLE OF sxc_attr-imp_name,
        lcl_wa_badiimp LIKE LINE OF lcl_it_badiimp.

*Initialisieren der Tabellen
  REFRESH lcl_it_badiimp. REFRESH it_rueck.

  SELECT  imp_name FROM sxc_attr INTO TABLE lcl_it_badiimp
          WHERE active = &apos;X&apos;.
  LOOP AT lcl_it_badiimp INTO lcl_wa_badiimp.
    APPEND lcl_wa_badiimp TO it_f4_badiimp.
  ENDLOOP.

  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;o_badis-low&apos;
      value_org       = &apos;S&apos;
    TABLES
      value_tab       = it_f4_badiimp
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_badis-low = wa_rueck-fieldval.
  ENDIF.
  REFRESH it_f4_badiimp.



*Serch help F4 help addition.

************************************************************
*F4 help for Enhancement Project
************************************************************
*----Enhancement Spot.
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_enhspt-low.
  DATA: lcl_it_enh TYPE STANDARD TABLE OF enhspotobj,
        lcl_prog   TYPE sy-repid,
        lcl_nr     TYPE sy-dynnr.
  CONSTANTS: gc_enhspt   TYPE help_info-dynprofld VALUE &apos;O_ENHSPT&apos;,
             gc_enhspt_1   TYPE dfies-fieldname     VALUE &apos;ENHSPOT&apos;.

  SELECT enhspot FROM enhspotobj INTO TABLE lcl_it_enh.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;ENHSPOTOBJ&apos;
      retfield        = gc_enhspt_1
      dynpprog        = lcl_prog
      dynpnr          = lcl_nr
      dynprofield     = gc_enhspt
*      value_org       = &apos;S&apos;
    TABLES
      value_tab       = lcl_it_enh
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_enhspt-low = wa_rueck-fieldval.
  ENDIF.

************************************************************
*F4 help for Webdyn Pro
************************************************************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_webd-low.
  DATA: lcl_it_webd TYPE STANDARD TABLE OF wdy_component,
        lcl_prog   TYPE sy-repid,
        lcl_nr     TYPE sy-dynnr.

  CONSTANTS: gc_webd   TYPE help_info-dynprofld VALUE &apos;O_WEBD&apos;,
             gc_f_webd TYPE dfies-fieldname     VALUE &apos;COMPONENT_NAME&apos;.

  SELECT component_name FROM wdy_component INTO TABLE lcl_it_webd.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;WDY_COMPONENT&apos;
      retfield        = gc_f_webd
      dynpprog        = lcl_prog
      dynpnr          = lcl_nr
      dynprofield     = gc_webd
*      value_org       = &apos;S&apos;
    TABLES
      value_tab       = lcl_it_webd
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_webd-low = wa_rueck-fieldval.
  ENDIF.

*----New Core BADI
AT SELECTION-SCREEN ON VALUE-REQUEST FOR o_badi-low.
  DATA: lcl_it_badi TYPE STANDARD TABLE OF badi_impl,
        lcl_prog   TYPE sy-repid,
        lcl_nr     TYPE sy-dynnr.

  CONSTANTS: gc_badi   TYPE help_info-dynprofld VALUE &apos;O_BADI&apos;,
             gc_f_badi TYPE dfies-fieldname     VALUE &apos;BADI_NAME&apos;.

  SELECT * FROM badi_impl INTO TABLE lcl_it_badi.
*             WHERE badi_name IN o_badi.
  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      ddic_structure  = &apos;BADI_IMPL&apos;
      retfield        = gc_f_badi
      dynpprog        = lcl_prog
      dynpnr          = lcl_nr
      dynprofield     = gc_badi
    TABLES
      value_tab       = lcl_it_badi
      return_tab      = it_rueck
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
  IF sy-subrc = 0.
    READ TABLE it_rueck INDEX 1 INTO wa_rueck.
    o_badi-low = wa_rueck-fieldval.
  ENDIF.
***************************************************
*
********Beginn der Hauptroutine***********************
*
***************************************************
START-OF-SELECTION.

*Ueberpruefung, ob erster Programmstart
  IF tp_flag = &apos;X&apos;.
*    Information message wegen Popup-Verhalten
    MESSAGE i888(sabapdocu) WITH
     &apos;Restart of Report!&apos;
     &apos;Tis happens only at the first start&apos;.
*    Zur Aufrufstelle zurückspringen;  Neuer Programmstart
    SET  SCREEN 0.
    STOP.
  ENDIF.

*Eindeutigen Schlüssel für Installation + System
  PERFORM get_unique_identifier.


*Startverzeichnis herststellen
  dir = pfad.

* Übernahme des Parameters zur Steuerung, ob abhängige
* Hauptobjekte berücksichtigt werden sollen.
  g_nodep = p_nodep.

*Alle Tabellentypen im Kundennamensraum fuer Abgleich lesen
  SELECT typename FROM ddtypes INTO TABLE it_all_tabletypes
          WHERE typekind = &apos;TTYP&apos;.

*Aufruf des gewählten Selektionsbildschirms
  PERFORM get_selected_screen.

*Selektionsbirdschirm abfangen
  PERFORM selection.


*Protokolltabelle ausgeben
  PERFORM output_protocol.



***************************************************
*
********Ende der Hauptroutine***********************
*
***************************************************



****************************************************
****Unterprogramme; Formroutinen
****************************************************

*&amp;---------------------------------------------------------------------*
*&amp;      Form  reps_mods
*&amp;---------------------------------------------------------------------*
*  Aufruf aus dem Selektionsbildschirm für einzelne Objekte
*  Abfangen der Eingabe aus diesem Bildschirm
*  Aufruf der Verarbeitungsroutine fuer Reports/Modulpools
*----------------------------------------------------------------------*
FORM reps_mods.
*Bereiche fuer trdir
  DATA: lcl_it_trdir TYPE STANDARD TABLE OF trdir,
        lcl_wa_trdir LIKE LINE OF lcl_it_trdir.

*Selektion der relevanten Reports und Modulpoole
  SELECT * FROM trdir INTO TABLE lcl_it_trdir
     WHERE name IN o_prog
       AND ( ( subc = &apos;1&apos; ) OR ( subc =&apos;M&apos; )
             OR ( subc =&apos;S&apos; ) ). &quot;Report o. Modulpool

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_trdir IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for Reports or Modulpools! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.

**********Ausfuehren des Programmdownloads
*** Ausführung für jedes Rahmenprogramms
  LOOP AT lcl_it_trdir INTO lcl_wa_trdir.
*Liste mit Ober-Objekten bei Einzelselektion
    MOVE lcl_wa_trdir-name TO wa_obj_list-name.
    APPEND wa_obj_list TO it_obj_list.
*Aufruf der Verarbeitungsroutine fuer Reports / Modulpoole
    PERFORM handle_reps_mods USING lcl_wa_trdir-name.


*Stueckliste fuer logische Entwicklung schreiben
    IF NOT ( p_logic IS INITIAL ).
      PERFORM write_log_stueckliste USING   &apos;Report/Modulpool&apos;
                                            lcl_wa_trdir-name
                                            p_logic.

    ENDIF.

  ENDLOOP. &quot;Schleife ueber selektierte Rahmenprogramme



ENDFORM.   &quot;Reps_Mods



*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_UNIQUE_IDENTIFIER
*&amp;---------------------------------------------------------------------*
*       Liest die Lizenznummer des Systems und den Systemnamen.
*       Daraus wird eindeutiger Identifikationsstring für dieses System
*       zusammengebaut (globales Feld).
*----------------------------------------------------------------------*
FORM get_unique_identifier.
************************************************
***Lesen  der Installationsnummer des Systems
************************************************
*1. Installationsnummer des Kunden herauslesen
  CALL FUNCTION &apos;SLIC_GET_LICENCE_NUMBER&apos;
    IMPORTING
      license_number = instnr.

**2. Concatenieren der Inst-Nummer, Trennzeichen und Systemnamen
*  CONCATENATE instnr &apos;#%%#&apos; sy-sysid INTO instnr.
ENDFORM.                    &quot; GET_UNIQUE_IDENTIFIER

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_NORMAL_INCLUDES
*&amp;---------------------------------------------------------------------*
*       Rekursives Lesen und Sichern aller Includes fuer das
*       angegebene Rahmenprogramm
*----------------------------------------------------------------------*

FORM handle_normal_includes USING    p_name.

  DATA: lcl_it_includes TYPE STANDARD TABLE OF include,
        lcl_wa_includes LIKE LINE OF  lcl_it_includes.


*FB liefert nur die normalen Inlcudes des Programmes/Includes
  CALL FUNCTION &apos;GET_INCLUDETAB&apos;
    EXPORTING
      progname = p_name
    TABLES
      incltab  = lcl_it_includes.

  LOOP AT lcl_it_includes INTO lcl_wa_includes.
    PERFORM download_include USING lcl_wa_includes-name &apos;I&apos;
                              CHANGING ok.
    IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*Stueckliste herunterschreiben
      PERFORM write_stueckliste USING   &apos;IN&apos;
                                          lcl_wa_includes-name
                                          p_name.
    ENDIF. &quot;Dowhload erfolgreich
  ENDLOOP.
ENDFORM.                    &quot; READ_NORMAL_INCLUDES

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_INCLUDE
*&amp;---------------------------------------------------------------------*
*       Sichern des angegebenen Includes in das Filesystem.
*       Erstellung der Dateinamen je nach Aufrufparameter p_typus.
*       Rückgabe des Parameters OK zur Überprüfung, ob Sicherung
*       erfolgt ist.
*----------------------------------------------------------------------*

FORM download_include USING    p_include LIKE c_includename
                               p_typus TYPE c
                      CHANGING ok TYPE c.
*Variable fuer Laenge des Typgruppennamens (aussagefähiger Name)
  DATA: lcl_laeng TYPE i.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
* XML-Strukutur
  DATA: lcl_it_xml TYPE STANDARD TABLE OF tbl2048.

*Ausgabeparameter initialisieren
  REFRESH downtab.
  CLEAR str_output. CLEAR size. CLEAR filename.

*Fuer Typgruppen den Namen der Typgruppe aus dem Incldename
*herausnehemen --&gt; Offset von 3 bei p_include
*Nur downloaden wenn noch nicht gedownloaded, da in Stückliste.
  IF p_typus = &apos;T&apos;.
    READ TABLE it_prog_stueckliste WITH KEY name = p_include+3
            TRANSPORTING NO FIELDS.
  ELSE.
    READ TABLE it_prog_stueckliste WITH KEY name = p_include
            TRANSPORTING NO FIELDS.
  ENDIF.
  IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden

*Quelltext lesen
    READ REPORT p_include INTO downtab.

*Fallunterscheidung der einzelnen Typen von Includes
*fuer Downloadtabelle und Ausgabename
    CASE p_typus.
      WHEN &apos;I&apos;. &quot;normale Includes
        CONCATENATE ci  p_include INTO filename.
        str_output = text011.
      WHEN &apos;R&apos;. &quot;Rahmenprogramme
        CONCATENATE cr  p_include INTO filename.
        str_output = text010.
      WHEN &apos;T&apos;. &quot;Typgruppen
        lcl_laeng = STRLEN( p_include ).
        lcl_laeng = lcl_laeng - 3.
        CONCATENATE ctg  p_include+3(lcl_laeng) INTO filename.
        str_output = text025.
      WHEN &apos;C&apos;. &quot;Klaseeninclude
        CONCATENATE ccl p_include INTO filename.
        str_output = text037.
      WHEN &apos;J&apos;. &quot;Interface
        CONCATENATE cint p_include INTO filename.
        str_output = text038.
      WHEN &apos;E&apos;. &quot;Include eines Enhancements
        CONCATENATE  eint p_include INTO filename.
        str_output = text050.
      WHEN &apos;F&apos;. &quot;Einzelner Funktionsbaustein
        CONCATENATE cfunc p_include INTO filename.
        str_output = text058.
    ENDCASE.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace

*   Convert include to XML
    PERFORM convert_include_to_xml TABLES lcl_it_xml
                                   USING  p_include.

*Nur downloaden wenn include existiert (subrc von read report =0)
    IF sy-subrc = 0.
*   create complete filename
      CONCATENATE new_dir &apos;\&apos; filename &apos;.XML&apos; INTO filename.
*      replace g_nspace with g_savename into p_include.

*Unerlaubte Zeichen erstzen
      SEARCH filename FOR &apos;&lt;&apos;.
      IF sy-subrc EQ 0.
        REPLACE &apos;&lt;&apos; WITH &apos;_&apos; INTO  filename.
      ENDIF.
      SEARCH filename FOR &apos;&gt;&apos;.
      IF sy-subrc EQ 0.
        REPLACE &apos;&gt;&apos; WITH &apos;_&apos; INTO  filename.
      ENDIF.

*Durchführung des eigentlichen Downloads
      PERFORM call_ws_download USING    filename
                                        lcl_it_xml
                               CHANGING lcl_subrc.

      IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;E&apos;  str_output p_include filename.

      ELSE.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;N&apos;  str_output p_include filename.

*p_OK auf X setzen; Download hat funktioniert
        ok = &apos;X&apos;.
      ENDIF.  &quot;subrc-Abfrage Fktbstabfrage

    ELSE.
*   no success in reading the files
*   WE have to clear the ok flag
      CLEAR ok.

    ENDIF. &quot;Include vorhanden?
  ENDIF. &quot;schon in Stueckliste drin

*  replace g_savename with g_nspace into p_include.

ENDFORM.                    &quot; DOWNLOAD_INCLUDE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_TYPGROUPS
*&amp;---------------------------------------------------------------------*
*       Lesen und Sichern der Typgruppen des Rahmenprogramms,
*       das in Parameter P_NAME enthalten ist.
*       Schreiben der Stueckliste.
*----------------------------------------------------------------------*

FORM handle_typgroups USING  p_wa_cross_ref TYPE cross.
*Variable fuer Includenamen der Typgruppe
  DATA: lcl_inc LIKE c_includename.

  CONCATENATE &apos;%_C&apos; p_wa_cross_ref-name INTO lcl_inc.


*Uebergabe des Typ des Includes, um Dateinamen festlegen zu können
  CLEAR ok.
  PERFORM download_include USING lcl_inc &apos;T&apos;
                           CHANGING ok.
  IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Typgroup&apos;
                                    p_wa_cross_ref-name
                                    global_main_name.
  ENDIF.

ENDFORM.                    &quot; HANDLE_TYPGROUPS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_SCREENS
*&amp;---------------------------------------------------------------------*
*     Selektion der Dynpros des im Parameter P_NAME mitgegegbenen
*     Rahmenprogrammes.
*     Aufruf der Downloadroutine fuer Dynpros und Schreiben der
*     Uebersichtsliste.
*----------------------------------------------------------------------*

FORM handle_screens USING    p_name LIKE wa_trdir-name
                             p_typus TYPE c.
*Lokale Tabellen und Arbeitsbereiche zur Sicherung der
* Modularisierbareit
  DATA: lcl_it_d020s LIKE it_d020s,
        lcl_wa_d020s LIKE wa_d020s.



*Nur die Screens selektieren die nicht durch select-option/parameters
*im Coding festgelegt worden sind (d020s-type = S;J;W).
  SELECT prog dnum type fnum FROM d020s INTO TABLE lcl_it_d020s
              WHERE prog = p_name
                AND ( ( type NE &apos;S&apos; )
                      AND  ( type NE &apos;J&apos; )
                      AND ( type NE &apos;W&apos; ) ).

  LOOP AT lcl_it_d020s INTO lcl_wa_d020s.

*Unterscheidung zu welcher Ordnungsebene der  Screen gehoert:
*Rahmenprogramm oder Funktionsgruppe oder ... (wegen Stuecklisten)
    IF p_typus = &apos;R&apos;. &quot;Rahmenprogramm
*Ueberpuefen, ob schon Heruntergeladen (nur fuer Rahmenprogramme,
*da Screens von Funktionsgruppen ueber die Funktionsgruppen selbst
*abgesichert sind.
      READ TABLE it_prog_stueckliste WITH TABLE KEY
              name = lcl_wa_d020s-dnum
              obername =  p_name
              TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden
        PERFORM download_dynpro USING lcl_wa_d020s.
        PERFORM write_stueckliste USING &apos;SCR&apos;
                                        lcl_wa_d020s-dnum
                                        p_name.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    &quot; HANDLE_SCREENS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_DYNPRO
*&amp;---------------------------------------------------------------------*
*       Durchführung der Sicherung eines Dynpros in das lokale
*       Dateisystem.
*       Der Code ist angepasster Standardcode. Änderungen sind druch
*       eckige Klammern gekennzeichnet
*----------------------------------------------------------------------*

FORM download_dynpro USING    p_wa_d020s LIKE wa_d020s.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Lokaler Dynproname zum Download
  DATA: lcl_screenbez TYPE string.

*Lokale Strukturen zu Einlesen des Dynpros aus dem System
  DATA: lcl_wa_dynproheader TYPE d020s,     &quot;Header des Dynpros
       lcl_it_feldliste TYPE TABLE OF d021s,          &quot;Feldlistentabelle
    lcl_it_ablauflogik LIKE d022s OCCURS 0 WITH HEADER LINE, &quot;Ablauflogk
        lcl_it_matchcode LIKE d023s OCCURS 0 WITH HEADER LINE.

  DATA: BEGIN OF lcl_dynp,
              prog TYPE d020s-prog,
              dnum TYPE d020s-dnum,
        END OF lcl_dynp.

*filename initialisieren
  CLEAR filename.

*[zusätzliche Deklarationen für kopierten code(siehe Include)
  DATA: header TYPE d020s,
        descript TYPE d020t-dtxt,
*        file TYPE rlgrap-filename.
        file TYPE string.
  DATA: fields TYPE TABLE OF d021s,
        flowlogic LIKE d022s OCCURS 0 WITH HEADER LINE,
        params LIKE d023s OCCURS 0 WITH HEADER LINE.
  DATA  header_char LIKE scr_chhead.
  DATA  dynp_char LIKE scr_chfld OCCURS 0 WITH HEADER LINE.
  TABLES: d020t.
  DATA  prog_len     TYPE p.
  DATA  fields_char LIKE scr_chfld OCCURS 0 WITH HEADER LINE.


  CONSTANTS:           stars(64)          VALUE
  &apos;****************************************************************&apos;,
                                                            &quot;#EC NOTEXT
             comment1(64)       VALUE
  &apos;*   THIS FILE IS GENERATED BY THE SCREEN PAINTER.              *&apos;,
                                                            &quot;#EC NOTEXT
             comment2(64)       VALUE
  &apos;*   NEVER CHANGE IT MANUALLY, PLEASE !                         *&apos;,

             dynpro_text(8)     VALUE &apos;%_DYNPRO&apos;,
             header_text(8)     VALUE &apos;%_HEADER&apos;,
             params_text(8)     VALUE &apos;%_PARAMS&apos;,
             descript_text(13)  VALUE &apos;%_DESCRIPTION&apos;,
             fields_text(8)     VALUE &apos;%_FIELDS&apos;,
             flowlogic_text(11) VALUE &apos;%_FLOWLOGIC&apos;.

*]
*Dynpro zuordnen
  lcl_dynp-dnum = p_wa_d020s-dnum.
  lcl_dynp-prog = p_wa_d020s-prog.


*Dynpro importieren
  IMPORT DYNPRO lcl_wa_dynproheader lcl_it_feldliste lcl_it_ablauflogik
        lcl_it_matchcode ID lcl_dynp.


*** Dateiname und Pfad bilden
  CONCATENATE new_dir &apos;\&apos; cs  p_wa_d020s-prog p_wa_d020s-dnum &apos;.TXT&apos;
        INTO filename.

*In dieser Routine bis zum Ende des Formulars ist im wesentlichen der
*Code aus dem Funktionsbaustein RS_DYNPRO_DOWNLOAD enthalten. Die
*zusätzlichen
*Datendeklarationen sind am Anfang der Form enthalten. Änderungen des
*Codings sind mit [] gekennzeichnet. Der Funktionsbaustein &apos;Download&apos;
*wurde durch &apos;WS_Download&apos; ersetzt, um nicht den Pfad zur Speicherung
*manuell eingeben zu müssen.
*-----------------------------------------------------------------------

*[Erweiterung DNE
*Zuordnung der Parameter wie beim Aufruf des FB-Bausteins
  header              = lcl_wa_dynproheader.
  file                = filename.
  fields              = lcl_it_feldliste.
  flowlogic[]         = lcl_it_ablauflogik[].
  params[]            = lcl_it_matchcode[].


*Lesen der Kurztextbeschreibung des Dynpros
  SELECT SINGLE dtxt FROM d020t INTO descript
              WHERE prog = lcl_dynp-prog
                AND dynr = lcl_dynp-dnum .

*]

*kopierter Text aus Funktionsbaustein
  CALL FUNCTION &apos;RS_SCRP_HEADER_RAW_TO_CHAR&apos;
    EXPORTING
      header_int  = header
    IMPORTING
      header_char = header_char
    EXCEPTIONS
      OTHERS      = 1.

  REFRESH dynp_char.

* Comment
  dynp_char = stars.    APPEND dynp_char.
  dynp_char = comment1. APPEND dynp_char.
  dynp_char = comment2. APPEND dynp_char.
  dynp_char = stars.    APPEND dynp_char.

* Identification
  dynp_char = dynpro_text.      APPEND dynp_char.          &quot;  &apos;%_DYNPRO&apos;
  dynp_char = header_char-prog. APPEND dynp_char.
  dynp_char = header_char-dnum. APPEND dynp_char.
  dynp_char = sy-saprl.         APPEND dynp_char.
  DESCRIBE FIELD d020t-prog LENGTH prog_len IN CHARACTER MODE.
  dynp_char(16) = prog_len.      APPEND dynp_char.

* Header
  dynp_char = header_text.      APPEND dynp_char.     &quot;  &apos;%_HEADER&apos;
  APPEND header_char TO dynp_char.

* Description
  dynp_char = descript_text.    APPEND dynp_char.     &quot;  &apos;%_DESCRIPTION&apos;
  APPEND descript TO dynp_char.

* Fieldlist
  dynp_char = fields_text.          &quot;  &apos;%_FIELDS&apos;
  APPEND dynp_char.
  CALL FUNCTION &apos;RS_SCRP_FIELDS_RAW_TO_CHAR&apos;
    TABLES
      fields_int  = fields
      fields_char = fields_char
    EXCEPTIONS
      OTHERS      = 1.

  LOOP AT fields_char.
    APPEND fields_char TO dynp_char.
  ENDLOOP.

* Flowlogic
  dynp_char = flowlogic_text.         &quot;  &apos;%_FLOWLOGIC&apos;
  APPEND dynp_char.

  LOOP AT flowlogic.
    APPEND flowlogic TO dynp_char.
  ENDLOOP.
**  refresh flowlogic.                   &quot;vjb 25.06.98

*[Abänderung des Funktionsbausteins DNE
* Dynpro Parameters                      &quot;vjb ab 4.6A (01.07.98)
**  IF NOT ( PARAMS IS INITIAL ).
  dynp_char = params_text.
  APPEND dynp_char.

  LOOP AT params.
    APPEND params TO dynp_char.
  ENDLOOP.
*  ENDIF.
*]

* begin of changes for partner namespace
  TRANSLATE file USING &apos;/_&apos;.
* end of changes for partner namespace

* Download
  PERFORM call_ws_download  USING    file
                                     dynp_char[]
                            CHANGING lcl_subrc.
*[Eigene Fehlerprüfung/Wegschreiben Listen; Erweiterung DNE
  CONCATENATE p_wa_d020s-prog &apos;, &apos; p_wa_d020s-dnum INTO lcl_screenbez.
  IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;E&apos;  text017 lcl_screenbez filename.
  ELSE.
    PERFORM write_protocol USING &apos;N&apos;  text017 lcl_screenbez filename.

  ENDIF.
*]

ENDFORM.                    &quot; DOWNLOAD_DYNPRO

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_TEXTELEMENTS
*&amp;---------------------------------------------------------------------*
*       Lesen und Sichern der Textelemente des im Parameter
*       P_NAME uebergebenen Rahmenprogrammes
*----------------------------------------------------------------------*

FORM download_textelements USING    p_name LIKE wa_trdir-name
                                    p_typus TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Lokale Datendefinition fuer Textelementtabelle
*Interne Tabellle zum Aufnehmender Textelemente
  DATA: lcl_it_textelements LIKE textpool OCCURS 50 WITH HEADER LINE.
*Name des Textelements in der Stückliste (darf nicht heißen wie
*Rahmenprogramm.
  DATA: lcl_text_name TYPE snodetext-text1.

*Filename initialisieren
  CLEAR filename.

*Schleife ueber die selektierten Sprachen
  LOOP AT it_lan INTO wa_lan.
*Name für Prüfung zusammenbauen.
    CONCATENATE &apos;TE_&apos; p_name &apos;(&apos; wa_lan &apos;)&apos;  INTO filename.
*Namen fuer Stueckliste
    lcl_text_name = filename.
*Nur downloaden wenn noch nicht gedownloaded, da in Stückliste.
    READ TABLE it_prog_stueckliste WITH KEY name = filename
              TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.
** Dateiname und Pfad bilden
      CONCATENATE new_dir &apos;\&apos; filename &apos;.htm&apos; INTO filename.
*Textelemente in der Anmeldesprache herunterladen
      READ TEXTPOOL p_name
          INTO  lcl_it_textelements LANGUAGE wa_lan.

*Nur Download und Eintrag in Stueckliste durchfuehren, wenn
*Textelement vorhanden sind.
      IF sy-subrc = 0.

*HTML-Tabelle fuer Textelemente zusamenbauen
        PERFORM create_htmltab_for_textelement USING
        lcl_it_textelements[]
           .
*   begin of changes for partner namespace
        TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
        PERFORM call_ws_download  USING    filename
                                           it_html
                                  CHANGING lcl_subrc.

        IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
          PERFORM write_protocol USING &apos;E&apos;  text018 p_name filename.
        ELSE.
*Protokollliste schreiben.
          PERFORM write_protocol USING &apos;N&apos;  text018 p_name filename.

*Je nach Typ oder Hierarchiestufe wird das wegschreiben der
*Strukturinformationen verschieden gehandhabt.
          IF p_typus = &apos;G&apos;. &quot;Funktionsgruppe
            CLEAR wa_fkgrp_struktur.
            wa_fkgrp_struktur-objecttype = &apos;TE&apos;.
            wa_fkgrp_struktur-objectname = p_name.
            APPEND wa_fkgrp_struktur TO it_fkgrp_struktur.
          ELSEIF p_typus = &apos;R&apos;. &quot;Rahmenprogramm: Report/Modulpool
*Statisches wegschreiben der Stückliste für die Textelemente (Angaben
*stehen im vorhinein schon fest
            CLEAR wa_prog_stueckliste.
            wa_prog_stueckliste-type = &apos;TE&apos;.
            wa_prog_stueckliste-name = lcl_text_name.
            wa_prog_stueckliste-obername = p_name.
            wa_prog_stueckliste-instnr = instnr.
            APPEND wa_prog_stueckliste TO it_prog_stueckliste.

          ELSEIF p_typus = &apos;T&apos;. &quot;Selektion über Transportrequest
*Statisches wegschreiben der Stückliste für die Textelemente (Angaben
*stehen im vorhinein schon fest
            CLEAR wa_prog_stueckliste.
            wa_prog_stueckliste-type = &apos;TE&apos;.
            wa_prog_stueckliste-name = lcl_text_name.
            wa_prog_stueckliste-obername = global_main_name.
            wa_prog_stueckliste-instnr = instnr.
            APPEND wa_prog_stueckliste TO it_prog_stueckliste.

          ELSEIF p_typus = &apos;C&apos;. &quot;Klasse
            CLEAR wa_classlist.
            wa_classlist-typus = &apos;TE&apos;.
            wa_classlist-inc = lcl_text_name.
            APPEND wa_classlist TO it_classlist.
          ENDIF. &quot;Welcher Typ liegt vor vor????
        ENDIF. &quot;Waren Textelemente vorhanden
      ENDIF.
    ENDIF.
    &quot;Ende der Ueberpruefung, ob ueberhaupt Textelemente vorhanden

  ENDLOOP.  &quot;Sprachentabelle


ENDFORM.                    &quot; DOWNLOAD_TEXTELEMENTS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_STUECKLISTE
*&amp;---------------------------------------------------------------------*
*      Sicherung einer erzeugten Stueckliste in das lokale Dateisystem.
*      Generierung der Tabelle in HTML-Format
*----------------------------------------------------------------------*
FORM download_stueckliste.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Stücklistenname
  DATA: lcl_stueckliste_name TYPE string.
* Name for object name in parts list
  DATA: lcl_file_name LIKE wa_prog_stueckliste-file_name.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

* begin of changes for partner namespace
* Auffuellen der Felder fuer den verwendeten file_name
  LOOP AT it_prog_stueckliste INTO wa_prog_stueckliste.
    lcl_file_name = wa_prog_stueckliste-name.
    TRANSLATE lcl_file_name USING &apos;/_&apos;.
    CONDENSE lcl_file_name NO-GAPS.
    wa_prog_stueckliste-file_name = lcl_file_name.
    MODIFY it_prog_stueckliste FROM wa_prog_stueckliste
                                            INDEX sy-tabix.
  ENDLOOP.
* end of changes for partner namespace

*Ueberschrift zusammenbauen
  CONCATENATE &apos;List of Object&apos;  global_main_name
        INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
  APPEND &apos;Objecttype&apos; TO lcl_it_headerrow.
  APPEND &apos;Objectname&apos; TO lcl_it_headerrow.
  APPEND &apos;Super Object&apos; TO lcl_it_headerrow.
  APPEND &apos;System Identifier&apos; TO lcl_it_headerrow.
  APPEND &apos;Name in file system&apos; TO lcl_it_headerrow.


*Nur downloaden, wenn nicht leer
  IF NOT ( it_prog_stueckliste IS INITIAL ).
    CONCATENATE &apos;Stueckliste_&apos; global_main_name
              INTO lcl_stueckliste_name.
*Umwandlung in HTML-Tabelle
********************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_prog_stueckliste INTO wa_prog_stueckliste.
      PERFORM create_htmltab_body USING wa_prog_stueckliste.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_stueckliste_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download  USING    filename
                                       it_html
                              CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*     Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text019 lcl_stueckliste_name
          filename.
    ELSE.
*     Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text019 lcl_stueckliste_name
          filename.

    ENDIF.

*   Navigationsfiles zusammenbauen
    CONCATENATE lcl_stueckliste_name &apos;.htm&apos; INTO lcl_stueckliste_name.
    PERFORM create_nav_files USING lcl_stueckliste_name.

*   Aufbauen und Herunterladen der XSL-Files
    PERFORM create_xsl_files.

  ENDIF.
ENDFORM.                    &quot; DOWNLOAD_STUECKLISTE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  WRITE_STUECKLISTE
*&amp;---------------------------------------------------------------------*
*      Schreiben der Stueckliste mit den Aufrufparametern Typ (p_typus),
*      Name des Objektes (p_name) und Nam des übergeordneten Objektes
*      (p_obername).
*----------------------------------------------------------------------*
FORM write_stueckliste USING  p_type TYPE any
                              p_name TYPE any
                               p_obername TYPE any.

  wa_prog_stueckliste-type = p_type.
  wa_prog_stueckliste-name = p_name.
  wa_prog_stueckliste-obername = p_obername.
  wa_prog_stueckliste-instnr = instnr.

  APPEND wa_prog_stueckliste TO it_prog_stueckliste.

ENDFORM.                    &quot; WRITE_STUECKLISTE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_DDIC
*&amp;---------------------------------------------------------------------*
*       Lesen von Tabellentypen, Strukturen, Tabellen, Views und Appends
*       zu einem Rahmenprogramm (Parameter P_NAME).
*----------------------------------------------------------------------*
FORM handle_ddic USING    p_name LIKE wa_trdir-name
                          p_typus TYPE c.
*Breiche fuer Bearbeitung von Rahmenprogramm abhängigen Includes
  DATA: lcl_it_d010tab LIKE it_d010tab,
        lcl_wa_d010tab LIKE wa_d010tab.
  DATA: lcl_it_ddic TYPE STANDARD TABLE OF rddnm.
  DATA: lcl_wa_ddic LIKE LINE OF lcl_it_ddic.
*lokaler Puffer fuer dd02l
  DATA: lcl_it_puffer TYPE STANDARD TABLE OF dd02l,
        lcl_wa_puffer LIKE LINE OF lcl_it_puffer.
*lokale Variable fuer Stuecklisten
  DATA: lcl_ddictyp TYPE string.
*Arbeitsrbereiche fuer Bestimmung von Tabellenappends
  DATA: lcl_it_dd02l TYPE STANDARD TABLE OF dd02l,
        lcl_wa_dd02l LIKE LINE OF lcl_it_dd02l.


*Abgleich und Verarbeitung der Tabellentypen
  SELECT * FROM d010tab INTO TABLE lcl_it_d010tab
        WHERE master = p_name.
*  DELETE lcl_it_d010tab
*     WHERE NOT (   ( tabname(1) = &apos;Y&apos; )
*                  OR ( tabname(1) = &apos;Z&apos; )
*                  OR ( tabname(g_len_nspace) = p_nspace ) ).

  LOOP AT lcl_it_d010tab INTO lcl_wa_d010tab.

*   Only deal with elements in namespace
    IF ( ( lcl_wa_d010tab-tabname(1) NE &apos;Y&apos; )
         AND ( lcl_wa_d010tab-tabname(1) NE &apos;Z&apos; )
         AND ( lcl_wa_d010tab-tabname(g_len_nspace) NE p_nspace ) ).

      CONTINUE.

    ENDIF.

    READ TABLE it_all_tabletypes WITH KEY
      typename = lcl_wa_d010tab-tabname TRANSPORTING NO FIELDS.
    IF sy-subrc = 0. &quot;Tabellentyp liegt vor
      PERFORM handle_tabletype USING  lcl_wa_d010tab-tabname.
*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Tabletype&apos;
                                  lcl_wa_d010tab-tabname
                                  p_name.

    ENDIF.
  ENDLOOP.

  LOAD REPORT p_name PART &apos;DDNM&apos; INTO lcl_it_ddic.


*Zu den
*Verarbeitung der Informationen
  LOOP AT lcl_it_ddic INTO lcl_wa_ddic.
*Initialisieren des Puffers
    REFRESH  lcl_it_puffer.
    CLEAR lcl_wa_puffer.
*Feststellen des Typs des DDicobjektes
    SELECT SINGLE * FROM dd02l INTO wa_ddictypes
          WHERE tabname = lcl_wa_ddic-tabname.
*Objekte im Kundennamensraum herunterladen + Partnernamensraum
    IF ( ( lcl_wa_ddic-tabname(1) = &apos;Y&apos; )
      OR ( lcl_wa_ddic-tabname(1) = &apos;Z&apos; )
      OR ( lcl_wa_ddic-tabname(g_len_nspace) = p_nspace ) ).
*Behandlung der Faelle
      CASE wa_ddictypes-tabclass.
        WHEN &apos;TRANSP&apos;. &quot;normale Tabellen
          PERFORM download_table USING  wa_ddictypes &apos;T&apos;.
          lcl_ddictyp =  &apos;Table&apos;.
        WHEN &apos;VIEW&apos;. &quot;View
*          PERFORM download_table USING  wa_ddictypes &apos;V&apos;.
          PERFORM download_view USING wa_ddictypes.
          lcl_ddictyp =  &apos;View&apos;.
        WHEN &apos;INTTAB&apos;. &quot;Struktur
          PERFORM download_table USING  wa_ddictypes &apos;S&apos;.
          lcl_ddictyp =  &apos;Structure&apos;.
      ENDCASE.
    ELSE.
*Objekte im SAP-Namensraum auf eine Appendstruktur ueberpruefen
      REFRESH lcl_it_dd02l. CLEAR lcl_wa_dd02l.
      SELECT  * FROM dd02l INTO TABLE lcl_it_dd02l
          WHERE sqltab = lcl_wa_ddic-tabname
           AND  tabclass = &apos;APPEND&apos;.
      IF sy-subrc = 0. &quot;es existieren appends
        lcl_ddictyp =  &apos;APP&apos;.
        LOOP AT lcl_it_dd02l INTO lcl_wa_dd02l.
*Eigentlicher Download
          PERFORM download_table USING  lcl_wa_dd02l &apos;A&apos;.
*Schreiben der Stuecklisten
*Unterscheidung zu welcher Ordnungsebene diese Ddic-objektes gehoert:
*Rahmenprogramm oder Funktionsgruppe oder ...
          IF p_typus = &apos;R&apos;. &quot;Rahmenprogramm
*Ueberpruefen, ob Eintrag mit diesem Schluessel schon in Stueckliste
*steht
            READ TABLE it_prog_stueckliste WITH TABLE KEY
                 name = lcl_wa_dd02l-tabname
                 obername =  lcl_wa_ddic-tabname
                 TRANSPORTING NO FIELDS.
            IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden
              PERFORM write_stueckliste USING &apos;Append&apos;
                                        lcl_wa_dd02l-tabname
                                        lcl_wa_ddic-tabname.
            ENDIF.
          ENDIF.


        ENDLOOP. &quot;Loop ueber Appends
        CONTINUE.
      ELSE.  &quot;Sap-Tabellen nicht in Stueckliste schreiben
        CONTINUE.
      ENDIF. &quot;existiert ein Append
    ENDIF. &quot;Kundennamensraum


*Unterscheidung zu welcher Ordnungsebene diese Ddic-objektes gehoert:
*Rahmenprogramm oder Funktionsgruppe oder ...
    IF p_typus = &apos;R&apos;. &quot;Rahmenprogramm
*Ueberpruefen, ob Eintrag mit diesem Schluessel schon in Stueckliste
*steht
      READ TABLE it_prog_stueckliste WITH TABLE KEY
              name = lcl_wa_ddic-tabname
              obername =  global_main_name
              TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden
        PERFORM write_stueckliste USING lcl_ddictyp
                                    lcl_wa_ddic-tabname
                                    global_main_name.
      ENDIF.
    ENDIF.

  ENDLOOP.

ENDFORM.                    &quot; HANDLE_DDIC

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_DOMAINS
*&amp;---------------------------------------------------------------------*
*       Lesen und Sichern der Domaenenheaderinformationen und
*       wenn vorhanden der Wertehilfen. Als Grundlage dient dient die
*       Liste der Datenelemente.
*----------------------------------------------------------------------*
FORM download_domains.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Variablen fuer Download (Filename) festlegen
  DATA: lcl_domainheader_name TYPE string.
  DATA: lcl_domainvalues_name TYPE string.
*Lokaler  Datenbereich fuer temporaere Verarbeitung von dd07v(enthält
*evtl. Wertebereich der Domaene.
  DATA: lcl_it_dd07v TYPE STANDARD TABLE OF dd07v,
        lcl_wa_dd07v LIKE LINE OF lcl_it_dd07v.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.
*Arbeitsbereich nur fuer die sinnvolen Attrbute der Domaene
  DATA: lcl_wa_idd01v TYPE idd01v.
*Arbeitsbereich nur fuer die sinnvolen Festwerte der Domaene
  DATA: lcl_wa_idd07v TYPE idd07v.

*Schleife ueber die Kundeneigenen Datenelemente
*Es werden alle Domaenen (auch die SAP-Domaenen)
*betrachtet, da sie wegen der referentiellen Intgrität
*in der Datenbank notwendig sind
  LOOP AT it_dataelements INTO wa_dataelements.

    LOOP AT it_lan INTO wa_lan.
      REFRESH lcl_it_dd07v.
      CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
           EXPORTING
                name          = wa_dataelements-domname
               state         = &apos;A&apos;
               langu         = wa_lan
          IMPORTING
*                   GOTSTATE      =
               dd01v_wa      = wa_dd01v
          TABLES
               dd07v_tab     = lcl_it_dd07v
              EXCEPTIONS
                   illegal_input = 1
                   OTHERS        = 2.
      IF sy-subrc = 0.
*  Domaeneninfos in Gesamttabelle schreiben, wenn im Kundennamensraum.
        IF     wa_dd01v-domname(1) = &apos;Z&apos;
            OR wa_dd01v-domname(1) = &apos;Y&apos;
            OR wa_dd01v-domname(g_len_nspace) = p_nspace.
          APPEND wa_dd01v TO it_dd01v.
*  Wertelistetabelle (dd07v) in Gesamtwerteliste schreiben.
*  Nur ausführen wenn lcl_it_dd07v nicht leer ist. Nur aus-
*  fuehren wenn Domaenen im Kundennamensraum liegen.
          IF NOT ( lcl_it_dd07v IS INITIAL ).
            LOOP AT lcl_it_dd07v INTO lcl_wa_dd07v.
              IF ( lcl_wa_dd07v-domname(1) = &apos;Z&apos;
                    OR lcl_wa_dd07v-domname(1) = &apos;Y&apos;
                    OR lcl_wa_dd07v-domname(g_len_nspace) = p_nspace ).
                APPEND lcl_wa_dd07v TO it_dd07v.
              ENDIF. &quot;Kundennamensraum
            ENDLOOP.
          ENDIF. &quot;initialpruefung
        ENDIF. &quot;Kundnennamensraum
      ENDIF. &quot;sy-subrc

*  Loeschen der zeile, wenn kein Datenelementname vorhanden--&gt;Eintrag
*  aus Verarbeitung Tabellentyp
      IF wa_dataelements-rollname IS INITIAL.
        DELETE it_dataelements INDEX sy-tabix.
      ENDIF.
    ENDLOOP. &quot;Sprachtabelle
  ENDLOOP.

******************************************************************
*Download der allgemeinen Informationen
******************************************************************

*Nur Download wenn it_dd01v nicht leer ist
  IF NOT ( it_dd01v IS INITIAL ).
*Duplikate löschen
    SORT it_dd01v BY domname ddlanguage.
    DELETE ADJACENT DUPLICATES FROM it_dd01v COMPARING ALL FIELDS.

*    Ueberschrift zusammenbauen
    CONCATENATE &apos;Domain Attributes of &apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*    Headertabelle zusammenbauen
    APPEND &apos;Domain Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Language Key&apos; TO lcl_it_headerrow.
    APPEND &apos;Data Type&apos; TO lcl_it_headerrow.
    APPEND &apos;Length of Type&apos; TO lcl_it_headerrow.
    APPEND &apos;Output Length&apos; TO lcl_it_headerrow.
    APPEND &apos;Decimal places&apos; TO lcl_it_headerrow.
    APPEND &apos;Lowercase letters (flag)&apos; TO lcl_it_headerrow.
    APPEND &apos;Sign (flag)&apos; TO lcl_it_headerrow.
    APPEND &apos;Flag for fixed Values&apos; TO lcl_it_headerrow.
    APPEND &apos;Value Table&apos; TO lcl_it_headerrow.
    APPEND &apos;Conversion Routine&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Text&apos; TO lcl_it_headerrow.



*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_dd01v INTO wa_dd01v.
*nur sinnvolle Felder nutzen
      MOVE-CORRESPONDING wa_dd01v TO lcl_wa_idd01v.
      PERFORM create_htmltab_body USING lcl_wa_idd01v.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************

    CONCATENATE &apos;DomHeader_&apos; global_main_name
        INTO lcl_domainheader_name.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_domainheader_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html               &quot;it_dd01v
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text023 lcl_domainheader_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text023 lcl_domainheader_name
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Domainheader&apos;
                                      &apos;Domainheader&apos;
                                       global_main_name.

    ENDIF.
  ENDIF. &quot;Ist Tabelle it_dd01v gefüllt.

******************************************************
*Herunterladen der Wertehilfen
******************************************************

*Nur Download wenn it_dd07v nicht leer ist
  IF NOT ( it_dd07v IS INITIAL ).
*Duplikate löschen
    SORT it_dd07v BY domname valpos ddlanguage.
    DELETE ADJACENT DUPLICATES FROM it_dd07v COMPARING ALL FIELDS.
    SORT it_dd07v BY domname ddlanguage valpos.

    CLEAR lcl_header. REFRESH lcl_it_headerrow.
*    Ueberschrift zusammenbauen
    CONCATENATE &apos;Value Range and Short Text of Domains used in &apos;
        global_main_name INTO lcl_header SEPARATED BY space.

*    Headertabelle zusammenbauen
    APPEND &apos;Domain Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Position in Value List&apos; TO lcl_it_headerrow.
    APPEND &apos;Language&apos; TO lcl_it_headerrow.
    APPEND &apos;Single Value/lower Limit&apos; TO lcl_it_headerrow.
    APPEND &apos;Upper limit&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Text for fixed Values&apos; TO lcl_it_headerrow.

*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_dd07v INTO wa_dd07v.
*nur sinnvolle Felder nutzen
      MOVE-CORRESPONDING wa_dd07v TO lcl_wa_idd07v.
      PERFORM create_htmltab_body USING lcl_wa_idd07v.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************


    CONCATENATE &apos;DomValues_&apos; global_main_name INTO lcl_domainvalues_name
    .
    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_domainvalues_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html               &quot;it_dd07v
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text024 lcl_domainvalues_name
            filename.
    ELSE.
      PERFORM write_protocol USING &apos;N&apos;  text024 lcl_domainvalues_name
            filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Domainvalues&apos;
                                      &apos;Domainvalues&apos;
                                      global_main_name.

    ENDIF.
  ENDIF.

ENDFORM.                    &quot; DOWNLOAD_DOMAINS



*&amp;---------------------------------------------------------------------*
*&amp;      Form  WRITE_DATAELEMENTS
*&amp;---------------------------------------------------------------------*
*       Lesen der Informationen zu dem im Parameter P_ROLLNAME
*       angegebenen Datenelement. Information wird an Gesamtliste
*       der Dateneelemente zu späterem Download angehängt.
*----------------------------------------------------------------------*
FORM write_dataelements USING    p_rollname LIKE
                                    wa_dataelements-rollname.

*Initialisieren der Datenelemente
  CLEAR wa_dataelements.

*Sprachabhaengigkeit
  LOOP AT it_lan INTO wa_lan.
*Herauslesen der spezifischen Information fuer Datenelemente
    CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
         EXPORTING
              name          = p_rollname
             state         = &apos;A&apos;
             langu         = wa_lan
        IMPORTING
*         GOTSTATE      =
             dd04v_wa      = wa_dataelements
*         TPARA_WA      =
    EXCEPTIONS
         illegal_input = 1
         OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.
    APPEND wa_dataelements TO it_dataelements.
  ENDLOOP.  &quot;Sprachtabelle

ENDFORM.                    &quot; WRITE_DATAELEMENTS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_TABLE
*&amp;---------------------------------------------------------------------*
*       Lesen und Sichern der Feldinformationen zu Tabellen, Views,
*       Strukturen und Appends.
*----------------------------------------------------------------------*
FORM download_table USING    p_dd02l  TYPE dd02l
                             p_typus       TYPE c.

* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Arbeitsbereich fuer die sinnvolen Felder
  DATA: lcl_wa_idd03p TYPE idd03p.
*Variable fuer Kopfzeile der zu generierenden HTML-Tabelle
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

*Variable zur Modularisierung des Ausgabenamens
  DATA: str_output TYPE string.
*lokale Datendeklarationen fuer Zugriff auf DDIC-Objekte
  DATA: lcl_t_dd03p   LIKE dd03p OCCURS 0 WITH HEADER LINE,
        lcl_t_dd05m   LIKE dd05m OCCURS 0 WITH HEADER LINE,
        lcl_ddic_name LIKE  dcobjdef-name,
        lcl_w_dd02v   LIKE dd02v.
** Variable for shorttext of fieldname
  DATA: lcl_it_dfies TYPE STANDARD TABLE OF dfies,
        lcl_wa_dfies LIKE LINE OF lcl_it_dfies,
        lcl_txttab TYPE  dd08v-tabname.

  CLEAR filename.

  lcl_ddic_name = p_dd02l-tabname.

  CALL FUNCTION &apos;DDIF_TABL_GET&apos;
    EXPORTING
      name          = lcl_ddic_name
      langu         = o_lan-low
    IMPORTING
      dd02v_wa      = lcl_w_dd02v
    TABLES
      dd03p_tab     = lcl_t_dd03p
      dd05m_tab     = lcl_t_dd05m
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.

  IF sy-subrc = 0.

*   Weiter Verarbeitung wenn etwas gefunden worden ist
    IF NOT ( lcl_t_dd03p[] IS INITIAL ).

      IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.
************************************************************
*Addition of code for displaying text table of selected
*Structure/Table.
************************************************************
      CALL FUNCTION &apos;DDUT_TEXTTABLE_GET&apos;
        EXPORTING
          tabname   = lcl_ddic_name
        IMPORTING
          texttable = lcl_txttab.
*       CHECKFIELD       =.
      IF lcl_txttab = space.
        lcl_txttab = &apos;No Text Table Found&apos;.
      ELSE.
* DNE Begin
*     Downlad the structure of the text table....
        DATA: lcl_wa_dd02l TYPE dd02l.
        SELECT SINGLE * FROM dd02l INTO lcl_wa_dd02l
               WHERE tabname = lcl_txttab.
        IF sy-subrc EQ 0.
          PERFORM download_table USING lcl_wa_dd02l
                                          &apos;T&apos;.
*       Create parts list
          PERFORM write_stueckliste USING &apos;Table&apos;
                                        lcl_wa_dd02l-tabname
                                        global_main_name.
        ENDIF.
* DNE End
      ENDIF.
************************************************************

*     Verarbeitung der kundeneigenen Datenelemente in der Tabelle
      LOOP AT lcl_t_dd03p.
        IF (   ( lcl_t_dd03p-rollname(1) = &apos;Z&apos; )
            OR ( lcl_t_dd03p-rollname(1) = &apos;Y&apos; )
            OR ( lcl_t_dd03p-rollname(g_len_nspace) = p_nspace ) ).
          PERFORM write_dataelements USING lcl_t_dd03p-rollname.
        ENDIF.
      ENDLOOP.

*Vorbereitungen für Download

*Fallunterscheidung der einzelnen Typen von DDIC-Strukturen
*fuer Downloadtabelle und Ausgabename; und Ueberschrift HTML-Tabelle
      CASE p_typus.
        WHEN &apos;T&apos;. &quot;Tabelle
          CONCATENATE new_dir &apos;\&apos; ct  lcl_ddic_name &apos;.xml&apos; INTO filename
          .
          str_output = text009.

          CONCATENATE &apos;Table:&apos;lcl_ddic_name&apos;,Text Table:&apos;lcl_txttab
                       INTO lcl_header SEPARATED BY space.

        WHEN &apos;V&apos;. &quot;View
          CONCATENATE new_dir &apos;\&apos; cv  lcl_ddic_name &apos;.xml&apos; INTO filename
          .
          str_output = text060.
          CONCATENATE &apos;Fields of View &apos;  lcl_ddic_name
             INTO lcl_header SEPARATED BY space.

        WHEN &apos;S&apos;. &quot;Strukturen
          CONCATENATE new_dir &apos;\&apos; cst lcl_ddic_name &apos;.xml&apos; INTO filename
          .
          str_output = text026.
          CONCATENATE &apos;Fields of Structure &apos;  lcl_ddic_name
             INTO lcl_header SEPARATED BY space.
        WHEN &apos;A&apos;. &quot;Appends
          CONCATENATE new_dir &apos;\&apos; cap lcl_ddic_name &apos;.xml&apos; INTO filename
          .
          str_output = text027.
          CONCATENATE &apos;Fields of Append-Structure &apos; lcl_ddic_name
            &apos;of Table&apos; p_dd02l-sqltab
             INTO lcl_header SEPARATED BY space.
      ENDCASE.

*     begin of changes for partner namespace
      TRANSLATE filename USING &apos;/_&apos;.

*     Read shorttext for fieldname
*     To Do: Check whether this function module can replace the one
*          above
      CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
        EXPORTING
          tabname        = lcl_ddic_name
          langu          = sy-langu
        TABLES
          dfies_tab      = lcl_it_dfies
        EXCEPTIONS
          not_found      = 1
          internal_error = 2
          OTHERS         = 3.
      IF sy-subrc &lt;&gt; 0.
        REFRESH lcl_it_dfies.
      ENDIF.


*    Headertabelle zusammenbauen
      APPEND &apos;Table Name&apos; TO lcl_it_headerrow.
      APPEND &apos;Field Name&apos; TO lcl_it_headerrow.
      APPEND &apos;Short Text&apos; TO lcl_it_headerrow.
      APPEND &apos;Position in Table&apos; TO lcl_it_headerrow.
      APPEND &apos;Key Field (Flag)&apos; TO lcl_it_headerrow.
      APPEND &apos;Mandatory Field (Flag)&apos; TO lcl_it_headerrow.
      APPEND &apos;Data Element&apos; TO lcl_it_headerrow.
      APPEND &apos;Checktable&apos; TO lcl_it_headerrow.
      APPEND &apos;Nesting Depth for Includes&apos; TO lcl_it_headerrow.
      APPEND &apos;Table for Reference Field&apos; TO lcl_it_headerrow.
      APPEND &apos;Name of included Table&apos; TO lcl_it_headerrow.
      APPEND &apos;NOTNULL (flag)&apos; TO lcl_it_headerrow.
      APPEND &apos;Data Type&apos; TO lcl_it_headerrow.
      APPEND &apos;Length of Field&apos; TO lcl_it_headerrow.
      APPEND &apos;Number of decimals&apos; TO lcl_it_headerrow.


*    Umwandlung in HTML-Tabelle
*    *******************************************************
      PERFORM create_htmltab_header  USING lcl_it_headerrow
                                           lcl_header.

*     Kurztext mit ausgeben
      DATA: lv_short TYPE string.
      lv_short =  lcl_w_dd02v-ddtext.
*     Sonderzeichen ersetzen
      REPLACE &apos;&lt;&apos; WITH &apos;&amp;lt;&apos; INTO lv_short.
      REPLACE &apos;&gt;&apos; WITH &apos;&amp;gt;&apos; INTO lv_short.
      REPLACE &apos;&amp;&apos; WITH &apos;&amp;amp;&apos; INTO lv_short.
      REPLACE &apos;&quot;&apos; WITH &apos;&amp;quot;&apos; INTO lv_short.
      REPLACE &apos;&apos;&apos;&apos; WITH &apos;&amp;apos;&apos; INTO lv_short.
      CONCATENATE &apos;&lt;short&gt;&apos; lv_short
                  &apos;&lt;/short&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.

      LOOP AT lcl_t_dd03p.
        MOVE-CORRESPONDING lcl_t_dd03p TO lcl_wa_idd03p.

*        Get fieldtexts
        CLEAR lcl_wa_dfies.
        READ TABLE lcl_it_dfies
                   WITH KEY tabname    = lcl_t_dd03p-tabname
                            fieldname  = lcl_t_dd03p-fieldname
                    INTO lcl_wa_dfies.
        lcl_wa_idd03p-shorttext = lcl_wa_dfies-fieldtext.

        PERFORM create_htmltab_body USING lcl_wa_idd03p.
      ENDLOOP.

      PERFORM create_html_tab_foot.
*    ********************************************************

*** Tables/View downloaden

*     end of changes for partner namespace
      PERFORM call_ws_download USING    filename
                                        it_html  &quot;lcl_t_dd03p
                               CHANGING lcl_subrc.
*lcl_t_DD03P-ROLLNAME.

      IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;E&apos; str_output lcl_ddic_name
          filename.
      ELSE.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;N&apos; str_output lcl_ddic_name
          filename.

      ENDIF. &quot;subrc-Abfrage des Download
    ENDIF.  &quot;subrc des ddifget-Bausteine
*    ENDIF. &quot;Subrc der Stuecklistenueberpruefung
  ENDIF. &quot;Tabelle gefuellte???
ENDFORM.                    &quot; DOWNLOAD_TABLE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DATAELEMENTS_DOWNLOAD
*&amp;---------------------------------------------------------------------*
*      Sicherung der Gesamttabelle der Datenelemente.
*      Konvertierung in HTML-Format.
*----------------------------------------------------------------------*
FORM download_dataelements.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Datenelementname
  DATA: lcl_dataelements_name TYPE string.
  DATA: lcl_wa_idd03p TYPE idd03p.
*Variable fuer Kopfzeile der zu generierenden HTML-Tabelle
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.
*Komprimierter Bereich fuer Datenelemete
  DATA: lcl_wa_idataelements TYPE idd04v.

*Nur herunterladen, wenn Datenelementliste Inhalt hat.
  IF NOT ( it_dataelements IS INITIAL ).
    lcl_header = &apos;Dataelements&apos;.
*Duplikate löschen
    SORT it_dataelements BY rollname ddlanguage.
    DELETE ADJACENT DUPLICATES FROM it_dataelements COMPARING ALL FIELDS
    .

*    Headertabelle zusammenbauen
    APPEND &apos;Dataelement Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Language&apos; TO lcl_it_headerrow.
    APPEND &apos;Domainname&apos; TO lcl_it_headerrow.
    APPEND &apos;Parameter ID&apos; TO lcl_it_headerrow.
    APPEND &apos;Change Document (flag)&apos; TO lcl_it_headerrow.
    APPEND &apos;Length of Heading&apos; TO lcl_it_headerrow.
    APPEND &apos;Length of Short-Label&apos; TO lcl_it_headerrow.
    APPEND &apos;Length of Medium-Label&apos; TO lcl_it_headerrow.
    APPEND &apos;Length of Long-Label&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Text&apos; TO lcl_it_headerrow.
    APPEND &apos;Heading Text&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Label Text&apos; TO lcl_it_headerrow.
    APPEND &apos;Medium Label Text&apos; TO lcl_it_headerrow.
    APPEND &apos;Long Label Text&apos; TO lcl_it_headerrow.
    APPEND &apos;Active-Flag&apos; TO lcl_it_headerrow.
    APPEND &apos;Search Help Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Search Help Parameter&apos; TO lcl_it_headerrow.



*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_dataelements INTO wa_dataelements.
      MOVE-CORRESPONDING wa_dataelements TO lcl_wa_idataelements.
      PERFORM create_htmltab_body USING lcl_wa_idataelements.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************


    CONCATENATE &apos;Dataelements_&apos; global_main_name
        INTO lcl_dataelements_name.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_dataelements_name &apos;.xml&apos; INTO filename.
*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_dataelements
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text022 lcl_dataelements_name
            filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text022 lcl_dataelements_name
            filename.


*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Dataelements&apos;
                                      &apos;Dataelements&apos;
                                      global_main_name.

    ENDIF.
  ENDIF.  &quot;Tabelle it_dataelements gefuellt?????
ENDFORM.                    &quot; DATAELEMENTS_DOWNLOAD

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_DIRECTORY
*&amp;---------------------------------------------------------------------*
*      Anlegen eines Verzeichnis aus dem Uebergabeparameter P_NAME und
*      dem Basisverzeichnis (DIR). Je nach Typ des anzulegenden
*      Verzeichnisses (Parameter P_TYPUS) wird vor P_NAME ein
*      entsprechendes Praefix angehaengt.
*      Die Methode zur Verzeichnisanlage wird je nach Implementierung im
*      System unterschiedlich aufgerufen.
*----------------------------------------------------------------------*
FORM create_directory USING    p_name TYPE any
                               p_typus TYPE c.

*Sicherung des Verzeichniss bei Entwicklungsklasssenelementen
*  DATA: lcl_path TYPE rlgrap-filename.
  DATA: lcl_path TYPE string.

*Bereich fuer Lesen der Parameter
  DATA: lcl_wa_vseoparam TYPE vseoparam.
*Variablen je nach Typisierung de
  DATA: lcl_char(128) TYPE c.
  DATA: lcl_string TYPE string.

  DATA: l_name(40) TYPE c.

  l_name = p_name.

*** alle slashes im Filenamen entfernen
  TRANSLATE l_name USING &apos;/_&apos;.


*Initialisieren des Flags zur Ueberpruefung, ob Verzeichnis schon
*existiert.
  CLEAR direxists.

*initialsieren des Verzeichnisnamens
  CLEAR new_dir.

*Wenn Entwicklungsklassenselektion vorliegt Basisverzeichnis
*setzen (nicht wenn Beasisvereichnis angelegt wird
  IF p_devc = &apos;X&apos; AND p_typus &lt;&gt; &apos;Devc&apos;.
    lcl_path = dir.
    dir = dc_path.
  ENDIF.
*Wenn Transportauftrag vorliegt Basisverzeichnis
*setzen (nicht wenn Beasisvereichnis angelegt wird)
  IF p_trkorr = &apos;X&apos; AND p_typus &lt;&gt; &apos;T&apos;.
    lcl_path = dir.
    dir = tr_path.
  ENDIF.


*Pruefen wie der Parameter Directory der Methode  typisiert ist
  SELECT SINGLE * FROM vseoparam INTO lcl_wa_vseoparam
      WHERE clsname = &apos;CL_GUI_FRONTEND_SERVICES&apos;
       AND cmpname = &apos;DIRECTORY_CREATE&apos;.


  IF lcl_wa_vseoparam-type = &apos;C&apos;. &quot;Typisierung mit Char

*Zusammensetzen des Verzeichnisnamen aus root und Rahmenprogrammname
*je nach Typ des Rahmenprogramms
    IF p_typus = &apos;R&apos;.  &quot;Report/Modulpoole
      CONCATENATE dir &apos;\RM_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;F&apos;.  &quot;Funktionsgruppen
      CONCATENATE dir &apos;\FG_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;C&apos;.  &quot;Klassen OO
      CONCATENATE dir &apos;\OC_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;I&apos;.  &quot;Interface OO
      CONCATENATE dir &apos;\OI_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;ORG&apos;.  &quot;Basistype IDOC.
      CONCATENATE dir &apos;\IB_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;EXT&apos;.  &quot;IDOC-Enhancemenet
      CONCATENATE dir &apos;\IE_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;E&apos;.   &quot;CMOD-Erweiterung
      CONCATENATE dir &apos;\EP_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;S&apos;.  &quot;IAC_Service
      CONCATENATE dir &apos;\IAC_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;Devc&apos;.  &quot;Entwicklungsklasse
      CONCATENATE dir &apos;\DC_&apos; l_name INTO new_dir.
*Basisverzeichnis fuer Entwicklungsklasse schreiben
      dc_path = new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
      CLEAR dir.
      dir = new_dir.
    ELSEIF p_typus = &apos;B&apos;. &quot;Badiimplementierung
      CONCATENATE dir &apos;\BI_&apos; l_name INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;T&apos;.  &quot;Transportrequest
      CONCATENATE dir &apos;\TR_&apos; l_name INTO new_dir.
*Basisverzeichnis fuer Tranportauftraege schreiben
      tr_path = new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
      CLEAR dir.
      dir = new_dir.
    ELSEIF p_typus = &apos;M&apos;. &quot;Modifikationen
      CONCATENATE dir &apos;\Modifications&apos;  INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;L&apos;. &quot;Logische Entwicklung
      CONCATENATE dir &apos;\&apos; l_name  INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;TA&apos;. &quot;Transaktionscode
      CONCATENATE dir &apos;\TA_&apos; l_name  INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;SUB&apos;. &quot;Unterobjekte in Klassen
      CONCATENATE dir &apos;\S&apos;  INTO new_dir.
      ASSIGN new_dir TO &lt;new_dir&gt;.

    ENDIF. &quot;Art des Verzeichnisses


*Ueberpruefen, ob Verzeichnis bereits angelegt worden ist
    READ TABLE it_directory_list WITH KEY dir = &lt;new_dir&gt;
           TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.

      CALL METHOD cl_gui_frontend_services=&gt;directory_create
        EXPORTING
          directory               = &lt;new_dir&gt;
        CHANGING
          rc                      = rc
        EXCEPTIONS
          directory_create_failed = 1
          cntl_error              = 2
          OTHERS                  = 3.
      IF sy-subrc &lt;&gt; 0.
*    Im Feherfall; Verzeichnis existiert schon; Falscher root
*    Information message wegen Popup-Verhalten
        MESSAGE i888(sabapdocu) WITH
         &apos;Error on creating directory:&apos;
         new_dir
        &apos;! The chosen root path must exist!&apos;
         &apos;Please check your File System!&apos;.
*    Zur Aufrufstelle zurückspringen;  Neuer Programmstart
        SET  SCREEN 0.
        STOP.

      ENDIF. &quot;Ergebnis der Verzeichnisanlage

*    Absetzen der Verzeichnisanlage Queue
      CALL METHOD cl_gui_cfw=&gt;flush
        EXCEPTIONS
          cntl_system_error = 1
          cntl_error        = 2
          OTHERS            = 3.
      IF sy-subrc &lt;&gt; 0.
*    Im Feherfall; Verzeichnis existiert schon; Falscher root
*    Information message wegen Popup-Verhalten
        MESSAGE i888(sabapdocu) WITH
         &apos;Error on creating directory:&apos;
         new_dir
        &apos;! The chosen root path must exist!&apos;
         &apos;Please check your File System!&apos;.
*    Zur Aufrufstelle zurückspringen;  Neuer Programmstart
        SET SCREEN  0.
        STOP.

      ENDIF. &quot;Ergebnis der asynchronen Verarbeitung
*    Ueberpruefung des Returncodes der Methode
      IF rc &lt;&gt; 0.
*    Im Feherfall; Verzeichnis existiert schon; Falscher root
*    Information message wegen Popup-Verhalten
        MESSAGE i888(sabapdocu) WITH
         &apos;Error on creating directory:&apos;
         new_dir
        &apos;! The chosen root path must exist!&apos;
         &apos;Please check your File System!&apos;.
*    Zur Aufrufstelle zurückspringen;  Neuer Programmstart
        SET SCREEN  0.
        STOP.

      ENDIF. &quot;RC-Abfrage
*    Erstelltes Verzeichnis an Verzeichnistabelle anhaengen
      MOVE &lt;new_dir&gt; TO wa_directory_list-dir.
      APPEND wa_directory_list TO it_directory_list.

    ELSE.
      direxists = &apos;X&apos;.

    ENDIF. &quot;Verzeichnis bereits erstellt

  ELSEIF lcl_wa_vseoparam-type = &apos;STRING&apos;. &quot;Typisierung mit String

*Zusammensetzen des Verzeichnisnamen aus root und Rahmenprogrammname
*je nach Typ des Rahmenprogramms
    IF p_typus = &apos;R&apos;. &quot;Report/MOdulpoole
      CONCATENATE dir &apos;\RM_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;F&apos;. &quot;Funktionsgruppe
      CONCATENATE dir &apos;\FG_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;C&apos;.  &quot;OO Klassen
      CONCATENATE dir &apos;\OC_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;I&apos;.  &quot;OO Interface
      CONCATENATE dir &apos;\OI_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;ORG&apos;.  &quot;IDOC-Basis.
      CONCATENATE dir &apos;\IB_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;EXT&apos;.  &quot;IDOc-Erweiterung
      CONCATENATE dir &apos;\IE_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;E&apos;.  &quot;CMOD-Projekt
      CONCATENATE dir &apos;\EP_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;S&apos;.  &quot;IAC_Service
      CONCATENATE dir &apos;\IAC_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;..
    ELSEIF p_typus = &apos;Devc&apos;.  &quot;Entwicklungsklasse
      CONCATENATE dir &apos;\DC_&apos; l_name INTO new_dir.
*Basisverzeichnis fuer Entwicklungsklasse
      dc_path = new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
      CLEAR dir.
      dir = new_dir.
    ELSEIF p_typus = &apos;B&apos;.  &quot;Badiimplementierung
      CONCATENATE dir &apos;\BI_&apos; l_name INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;T&apos;.  &quot;Transportauftrag
      CONCATENATE dir &apos;\TR_&apos; l_name INTO new_dir.
*Basisverzeichnis fuer Tranportauftraege schreiben
      tr_path = new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
      CLEAR dir.
      dir = new_dir.
    ELSEIF p_typus = &apos;M&apos;. &quot;Modifikationen
      CONCATENATE dir &apos;\Modifications&apos;  INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;L&apos;. &quot;Logische Entwicklung
      CONCATENATE dir &apos;\&apos; l_name  INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;TA&apos;. &quot;Transaktionscode
      CONCATENATE dir &apos;\TA_&apos; l_name  INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.
    ELSEIF p_typus = &apos;SUB&apos;. &quot;Unterobjekte von Klassen
      CONCATENATE dir &apos;\S&apos; INTO new_dir.
      lcl_string = new_dir.
      ASSIGN lcl_string TO &lt;new_dir&gt;.

    ENDIF. &quot;Art des Verzeichnisse

*Ueberpruefen, ob Verzeichnis bereits angelegt worden ist
    READ TABLE it_directory_list WITH KEY dir = &lt;new_dir&gt;
           TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.

      CALL METHOD cl_gui_frontend_services=&gt;directory_create
        EXPORTING
          directory = &lt;new_dir&gt;
        CHANGING
          rc        = rc
       EXCEPTIONS
          directory_create_failed  = 1
          cntl_error               = 2
*           ERROR_NO_GUI             = 3
*           PATH_NOT_FOUND           = 4
*          DIRECTORY_ACCESS_DENIED  = 5
*           DIRECTORY_ALREADY_EXISTS = 6
*           UNKNOWN_ERROR            = 7
          OTHERS                   = 8
              .

      IF sy-subrc &lt;&gt; 0.
*    Information message wegen Popup-Verhalten
        MESSAGE i888(sabapdocu) WITH
         &apos;Error on creating directory:&apos;
         new_dir
        &apos;! The chosen root path must exist!&apos;
         &apos;Please check your File System!&apos;.
*    Zur Aufrufstelle zurückspringen;  Neuer Programmstart
        SET SCREEN  0.
        STOP.

      ENDIF.
*    Erstelltes Verzeichnis an Verzeichnistabelle anhaengen
      MOVE &lt;new_dir&gt; TO wa_directory_list-dir.
      APPEND wa_directory_list TO it_directory_list.

    ELSE.
      direxists = &apos;X&apos;.

    ENDIF. &quot;Verzeichnis bereits angelegt
  ENDIF. &quot;Art der Parametrisierung: Stirng oder Char

  UNASSIGN &lt;new_dir&gt;.


*Ruecksichern des Verzeichnisses bei Entwicklungsklassen
  IF p_devc = &apos;X&apos; AND p_typus &lt;&gt; &apos;Devc&apos;.
    dir = lcl_path.
  ENDIF.
*Ruecksichern des Verzeichnisses bei Transportauftraegen
  IF p_trkorr = &apos;X&apos; AND p_typus &lt;&gt; &apos;T&apos;.
    dir = lcl_path.
  ENDIF.


ENDFORM.                    &quot; CREATE_DIRECTORY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  INITIALIZE
*&amp;---------------------------------------------------------------------*
*      Initialisierung von globalen Tabellen.
*----------------------------------------------------------------------*
FORM initialize.
  REFRESH it_prog_stueckliste. &quot;Stueckliste
  REFRESH it_dataelements. &quot;Datenelemente
  REFRESH it_dd01v. &quot;Domaenenheader
  REFRESH it_dd07v. &quot;Festwertehilfen
  REFRESH it_tobj. &quot;Berechtigungsobjekte
  REFRESH it_tactz. &quot;Aktivitaeten von Berechtigungsobjekten
  REFRESH it_authx. &quot;Tabelle der Berechtigungsfelder
  REFRESH it_tstc. &quot;Tabelle mit zu einem Programm zugeordneten TA-Codes
  REFRESH it_collectmains. &quot;externe Aufrufe in externen Aufrufen
  REFRESH it_d347t. &quot;Titlebar
  REFRESH it_fkgrp_struktur. &quot;Funtionsgruppenstruktur
  REFRESH it_tstcp. &quot;TA-Codes einer Klasse.
  REFRESH it_tdct. &quot;Dialogbausteinuebersicht
  REFRESH it_diapar. &quot;Parameter fuer Dialogbaustein
  REFRESH it_tpara. &quot;Tabelle der set/get-Parameter
  REFRESH it_classlist. &quot;Klassenliste initialisieren

***********************************************************************
*Addition of code for search help.
***********************************************************************
  REFRESH it_serchlp.   &quot;Search Help.
***********************************************************************
ENDFORM.                    &quot; INITIALIZE


*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_EXTPROG
*&amp;---------------------------------------------------------------------*
*     Lesen von aufgerufenen Objekten des im Parameter P_NAME
*     angegebenen Rahmenprogrammes.
*     Funktionsbausteine, Sperrobjekte, Meldungen,  Programmaufrufen
*     Berechtigungsobjekten und Set/Get-Parametern
*----------------------------------------------------------------------*
FORM handle_extprog USING    p_name LIKE wa_trdir-name.
*Lokale Bereich zur Aufnahme der Fktbst-Rueckgabewerte
*1.) Name der definierten Variablen (wird nicht verwendet
  DATA: lcl_it_compo TYPE STANDARD TABLE OF scompo,
        lcl_wa_compo LIKE LINE OF lcl_it_compo.
*2.)aufgerufene Includes: bereits behandelt
  DATA: lcl_it_inc TYPE STANDARD TABLE OF d010inc,
        lcl_wa_inc LIKE LINE OF lcl_it_inc.

*-&gt;Nur se Tabelle wird auch wirklich verwendet
*3.)Referenzen: Funktionsbausteine, Messages, Externe Programme
  DATA: lcl_it_cross_ref TYPE STANDARD TABLE OF cross,
        lcl_wa_cross_ref LIKE LINE OF  lcl_it_cross_ref.

*4.)Sperrobjektname für Patnernamensraum aufbereiten
  DATA: lcl_enqueue TYPE string,
        lcl_dequeue TYPE string,
        lcl_len TYPE i.

*Hilfsarbeitsbereich um Festzustellen ob ein Funktionsbaustein
*zu dieser Funktionsgruppe gehoert (nur bei funtkionsgruppen)
  DATA: lcl_wa_tfdir TYPE tfdir.

*Namen für Sperrobjekte zusammenbauen
  IF p_nspace(1) = &apos;/&apos;.

    CONCATENATE  &apos;ENQUEUE_&apos; p_nspace &apos;E&apos; INTO lcl_enqueue.
    CONCATENATE  &apos;DEQUEUE_&apos; p_nspace &apos;E&apos; INTO lcl_dequeue.
    lcl_len = STRLEN( lcl_enqueue ).
  ELSE.
    lcl_len = 1.
  ENDIF.

*Lesen der vom Include aufgerufenen Objekte
*  CALL FUNCTION &apos;RS_PROGRAM_INDEX&apos;
*       EXPORTING
*            pg_name       = p_name
**         WITHOUT_TREE  = &apos; &apos;
**    IMPORTING
**         MESSAGE_CLASS =
*       TABLES
*            compo         = lcl_it_compo
*            cross_ref     = lcl_it_cross_ref
*            inc           = lcl_it_inc
**    EXCEPTIONS
**         SYNTAX_ERROR  = 1
**         OTHERS        = 2
*           .
  PERFORM rs_program_index USING p_name
                           CHANGING lcl_it_cross_ref.
*  IF sy-subrc = 0. &quot;Es sind keine Fehler aufgetreten

*Wenn vorhanden Verarbeitung der Objetkliste (Messages, Funktionen).
  IF NOT ( lcl_it_cross_ref IS INITIAL ).
*Nur betrachten wo externe Verweise in Programmen
*des Kundennamensraumes gemacht worden sind, bzw. Partnernamensraum.
    LOOP AT lcl_it_cross_ref INTO lcl_wa_cross_ref.

      IF NOT ( ( lcl_wa_cross_ref-include(1) = &apos;Z&apos; )  &quot;Includes
           OR ( lcl_wa_cross_ref-include(1) = &apos;Y&apos; )
           OR ( lcl_wa_cross_ref-include(2) = &apos;LZ&apos; )
           OR ( lcl_wa_cross_ref-include(2) = &apos;LY&apos; )
           OR ( lcl_wa_cross_ref-include(2) = &apos;MZ&apos; )
           OR ( lcl_wa_cross_ref-include(2) = &apos;MY&apos; )
         OR ( lcl_wa_cross_ref-include(g_len_nspace) = p_nspace ) ).

        CONTINUE.

      ENDIF.
*Behandlung je nach Typ
      CASE lcl_wa_cross_ref-type.
        WHEN &apos;N&apos;. &quot;Verarbeitung von messages
          PERFORM handle_message USING lcl_wa_cross_ref.
        WHEN &apos;F&apos;.  &quot;Verarbeitung Funktionsbaustein
*Behandlung von normalen Funktionsbausteinen in Kundennamensraum.
*Ueberpruefen, ob der aufgerufene Funktionsbaustein im aufrufenden
*Programm liegt (nur bei Funktionsgruppen der Fall )--&gt;Zirkelbezug.
          SELECT SINGLE * FROM tfdir INTO lcl_wa_tfdir
            WHERE funcname = lcl_wa_cross_ref-name
             AND  pname = p_name.
          IF sy-subrc &lt;&gt; 0. &quot;Dies trifft nicht zu
            &quot;Kundennamenraum ueberpruefen; auch Funktionsgruppe
            IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
              OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
              OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
              PERFORM handle_functionmodule USING lcl_wa_cross_ref.
            ENDIF. &quot;Kundennamensraum
          ENDIF. &quot;sy-subrc
*Behandlung von Sperrobjekten im Kundennamensraum
          IF ( ( lcl_wa_cross_ref-name(10) = &apos;ENQUEUE_EZ&apos; ) OR
             ( lcl_wa_cross_ref-name(10) = &apos;ENQUEUE_EY&apos; ) OR
             ( lcl_wa_cross_ref-name(lcl_len) = lcl_enqueue ) OR
             ( lcl_wa_cross_ref-name(10) = &apos;DEQUEUE_EZ&apos; ) OR
             ( lcl_wa_cross_ref-name(10) = &apos;DEQUEUE_EY&apos; ) OR
             ( lcl_wa_cross_ref-name(lcl_len) = lcl_dequeue ) ).
            PERFORM handle_lockobject USING lcl_wa_cross_ref
                                            &apos;F&apos;.
            &quot;Name ist ein Funktionsbausteinname
          ENDIF.
        WHEN &apos;R&apos;.  &quot;Aufruf eines anderen Reports (submit program)
          IF (   ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
              OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
              OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
            PERFORM handle_submits USING lcl_wa_cross_ref.
          ENDIF.
        WHEN &apos;U&apos;. &quot;Aufruf einer Form in einem anderen Programm
          IF ( ( lcl_wa_cross_ref-prog(1) = &apos;Z&apos; )
             OR ( lcl_wa_cross_ref-prog(1) = &apos;Y&apos; )
             OR  ( lcl_wa_cross_ref-prog(g_len_nspace) = p_nspace ) ).
            PERFORM handle_performextern USING lcl_wa_cross_ref.
          ENDIF.
        WHEN &apos;T&apos;. &quot;Behandlung von Transaktionen (call transaction)
          IF (   ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
              OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
              OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
            PERFORM handle_transaction USING lcl_wa_cross_ref.
          ENDIF.
        WHEN &apos;A&apos;. &quot;Behandlung von Berechtigungsobjekten
          IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
              OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
              OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
            PERFORM handle_authorityobject USING lcl_wa_cross_ref.
          ENDIF.
        WHEN &apos;D&apos;. &quot;Dialogbaustein
          IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
             OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
             OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
            PERFORM handle_dialogmodule USING lcl_wa_cross_ref.
          ENDIF.
        WHEN &apos;P&apos;. &quot;set/get Parameterpaar
          IF (  ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
             OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
             OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ) .
            PERFORM handle_setgetparamss USING lcl_wa_cross_ref.
          ENDIF.
        WHEN &apos;G&apos;.  &quot;Typgruppe
          IF (   ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
              OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
              OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
            PERFORM handle_typgroups USING lcl_wa_cross_ref.
          ENDIF.

      ENDCASE.
    ENDLOOP.
  ENDIF.
*  ENDIF.

ENDFORM.                    &quot; HANDLE_EXTPROG

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_MESSAGE
*&amp;---------------------------------------------------------------------*
*      Lesen der Meldungsinformationen, die in Uebergabestruktur
*      angegeben ist. Anhaengen an Gesmttabelle fuer Meldungen.
*----------------------------------------------------------------------*
FORM handle_message USING    p_wa_cross_ref TYPE cross.

*Lokale Variablen zum zerlegen der messagevariable in
*Klasse und Nummer.
  DATA: lcl_message_class TYPE t100-arbgb,
       lcl_message_nr TYPE t100-msgnr.

*Feld um den Namen der Message (Klasse/Name) in Stückliste aufnehmen zu
*können.
  DATA: lcl_message_name TYPE trdir-name.

*Db-Feld auseinandernehmen
  lcl_message_class =  p_wa_cross_ref-name(20).
  lcl_message_nr = p_wa_cross_ref-name+20(3).

*Nur Behandeln, wenn Messageclass/arbeitsbereich im Kundennamensraum
*liegt
  IF (  ( lcl_message_class(1) = &apos;Z&apos; ) OR ( lcl_message_class(1) = &apos;Y&apos; )
      OR ( lcl_message_class(g_len_nspace) = p_nspace ) ).

    LOOP AT it_lan INTO wa_lan.
*Name für Stückliste zusammensetzen
      CONCATENATE lcl_message_class &apos;/&apos; lcl_message_nr &apos;/&apos; wa_lan INTO
         lcl_message_name.

      CLEAR wa_messages.
*Messagetabelle lesen mit Schlüssel nur bei Fehler nichts tun
      SELECT SINGLE * FROM t100 INTO wa_messages
              WHERE arbgb = lcl_message_class
                AND msgnr = lcl_message_nr
                AND sprsl = wa_lan.
      IF sy-subrc = 0.
*Überprüfen ob diese Meldung schon in Messagetabelle enthalten ist.
*Wenn enthalten nur noch in Stückliste aufnehmen und nicht mehr in
*Messagetabelle.
        READ TABLE it_messages WITH TABLE KEY arbgb = lcl_message_class
                                          msgnr = lcl_message_nr
                                          sprsl = wa_lan
                               TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
*Schreiben der Gesamt-Messagetabellle
          APPEND wa_messages TO it_messages.
        ENDIF.
*Schreiben der Stückliste, nicht länderspezifisch nur einmal
        PERFORM write_stueckliste USING &apos;MSG&apos;
                                     lcl_message_name
                                     p_wa_cross_ref-include.
      ENDIF.

    ENDLOOP. &quot;Sprachentabelle.
  ENDIF. &quot;Ueberpruefung Kundennamensraum

ENDFORM.                    &quot; HANDLE_MESSAGE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_MESSAGES
*&amp;---------------------------------------------------------------------*
*      Sicherung der globalen Nachrichtentabelle ins lokale Dateisystem.
*      Generierung der Tabelle in HTML-Format.
*----------------------------------------------------------------------*
FORM download_messages.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Name fuer die Gesamtmessagetabelle des Rahmenprogramms
  DATA: lcl_messagetab_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.

*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

*Nur Download durchführen wenn Messgetabelle nicht leer ist.
  IF NOT ( it_messages IS INITIAL ).
    CONCATENATE &apos;Messagetable_&apos; global_main_name INTO
    lcl_messagetab_name.

*Umwandlung in HTML-Tabelle
********************************************************
*Ueberschrift zusammenbauen
    CONCATENATE &apos;Messages in Customer Name Space of Object&apos;
          global_main_name INTO lcl_header SEPARATED BY space.

*Headertabelle zusammenbauen
    APPEND &apos;Language&apos; TO lcl_it_headerrow.
    APPEND &apos;Working Area&apos; TO lcl_it_headerrow.
    APPEND &apos;Message Number&apos; TO lcl_it_headerrow.
    APPEND &apos;Message Text&apos; TO lcl_it_headerrow.


    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_messages INTO wa_messages.
      PERFORM create_htmltab_body USING wa_messages.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_messagetab_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_messages
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text020 lcl_messagetab_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text020 lcl_messagetab_name
          filename.
    ENDIF.
  ENDIF. &quot;Download nur wen Messagetabelle nicht leer ist

ENDFORM.                    &quot; DOWNLOAD_MESSAGES

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_FUNCTIONMODULE
*&amp;---------------------------------------------------------------------*
*       Verarbeitung des in der Uebergabestruktur angegebenen
*       Funktionsbausteins. Zugehoerig Funktionsgruppe wird an
*       Tabelle zur späteren Verarbeitung von Rahmenprogrammen
*       angehaengt.
*----------------------------------------------------------------------*
FORM handle_functionmodule USING    p_wa_cross_ref TYPE cross.
*Lokale Defintion des Funktionsgruppennamens
  DATA: lcl_fktgroup_name LIKE wa_trdir-name.
  DATA: lcl_devc_name LIKE wa_trdir-name.
*Sicherung  des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.
* Area for devclass.
  DATA: lcl_devc TYPE tadir-devclass.
* Variables for dividing in partner namespace
  DATA: lcl_include TYPE rs38l-include.
  DATA: lcl_namespace TYPE rs38l-namespace.
  DATA: lcl_without TYPE rs38l-include.

*Funktionsbaustein verarbeiten; Herunterladen der gesamten
*Funktionsgruppe wegen eventueller Beziehungen

*Suche der Funktionsgruppe über den Fktbausteinname in tfdir
  SELECT SINGLE pname FROM tfdir INTO lcl_fktgroup_name
                      WHERE funcname = p_wa_cross_ref-name.
  IF sy-subrc = 0. &quot;Der Funktionsbaustein existiert

*   Check whether this object belongs to the selected dev-class
    IF NOT p_devc IS INITIAL.
*   Get name without namespace
      IF lcl_fktgroup_name(1) = &apos;/&apos;.
        lcl_include = lcl_fktgroup_name.

        CALL FUNCTION &apos;RS_PROGNAME_SPLIT&apos;
          EXPORTING
            progname_with_namespace    = lcl_include
          IMPORTING
            namespace                  = lcl_namespace
            progname_without_namespace = lcl_without.
        IF sy-subrc &lt;&gt; 0.
          EXIT.
        ELSE.
          CONCATENATE lcl_namespace lcl_without+4 INTO
            lcl_devc_name .
        ENDIF.

      ELSE. &quot;normal name space
        lcl_devc_name = lcl_fktgroup_name+4.
      ENDIF.

      SELECT SINGLE devclass FROM tadir INTO lcl_devc
                             WHERE pgmid    = &apos;R3TR&apos;
                               AND object   = &apos;FUGR&apos;
                               AND obj_name =  lcl_devc_name.
      CHECK lcl_devc IN o_devcl.
    ENDIF.
*Überpruefen, ob Funktionsgruppe runtergeladen worden ist.
    READ TABLE it_prog_stueckliste WITH KEY
              name = lcl_fktgroup_name
              TRANSPORTING NO FIELDS.
*Nur downloaden wenn download noch nicht durchgefuehrt worden ist.
    IF sy-subrc &lt;&gt; 0.

*     Nur wenn abhängige Objekte berücksichtig werden sollen
      IF g_nodep IS INITIAL.

*       Eintrag fuer Funktionsgruppe zu dem den Fktbaustein aufrufenden
*       Include schreiben
        PERFORM write_stueckliste USING &apos;Functiongroup&apos;
                                   lcl_fktgroup_name
                                   p_wa_cross_ref-include.

*       Eintrag fuer Funktionsbaustein zu aufrufendem Include
        PERFORM write_stueckliste USING &apos;Functionmodule&apos;
                                        p_wa_cross_ref-name
                                        lcl_fktgroup_name.


*       Tabellen zur späteren Weierverarbeitung zwischenspeichern
        PERFORM write_global_save USING &apos;F&apos; lcl_fktgroup_name.
      ENDIF.

    ENDIF.  &quot;FKGRP bereits gesichert
  ENDIF. &quot;Funktionsbaustein existiert

ENDFORM.                    &quot; HANDLE_FUNCTIONMODULE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  Download_Functiongroup
*&amp;---------------------------------------------------------------------*
*       Sicherung der Elemente der im Uebergabeparmeter angegebenen
*       Funktionsgruppe.
*----------------------------------------------------------------------*
FORM download_functiongroup USING    p_fktgroup_name LIKE wa_trdir-name.
*Die Typiesierung mit &apos;G&apos; ist obsolet, da diese Elemente fast alle
*an die normale Strueckliste angehaengt werden


*Textelemente des Rahmenprogramms herunterladen
  PERFORM download_textelements USING p_fktgroup_name
                                      &apos;R&apos;. &quot;&apos;G&apos;.
*Stueckliste wird in &apos;download_textelements&apos; geschrieben

**Echter Screen des Rahmenprogramms herunterladen
  PERFORM handle_screens USING p_fktgroup_name
                               &apos;R&apos;.  &quot;&apos;G&apos;.
*Titlebars suchen
  PERFORM handle_titlebar USING p_fktgroup_name
                                &apos;R&apos;.  &quot;&apos;G&apos;.

*pf-Stati verarbeiten
  PERFORM handle_pf_status USING p_fktgroup_name
                                  &apos;R&apos;.  &quot;&apos;G&apos;.

*Eventuell zughöriger Transaktionscode suchen
  PERFORM handle_tacode USING p_fktgroup_name.



*Normale Includes des Rahmenprogramms herunterladen
  PERFORM handle_includes_fktgroup USING p_fktgroup_name.


*Klassen und Interface behandeln
  PERFORM handle_classinterface USING p_fktgroup_name
                                      &apos;R&apos;.  &quot;&apos;G&apos;.

*Tabellen/Strukturen herunterladen
  PERFORM handle_ddic USING p_fktgroup_name
                            &apos;R&apos;.  &quot;&apos;G&apos;.

*Gesamtfunktionsgruppenliste herunterladen
  PERFORM download_fktgrplist USING p_fktgroup_name.

ENDFORM.                    &quot; FUNCTIONGROUP_DOWNLOAD

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_INCLUDES_FKTGROUP
*&amp;---------------------------------------------------------------------*
*       Rekursives Lesen und Speichern der Inlcudes (normale Includes
*       und Funktionsbausteinincludes). Anhaengen an globale Liste der
*       Funtkionsgruppenstruktur.
*----------------------------------------------------------------------*
FORM handle_includes_fktgroup USING    p_fktgroup_name.
*Lokale Tabellen und Arbeitsbereiche zur Sicherung der
* Modularisierbareit
  DATA: lcl_it_includes TYPE STANDARD TABLE OF include,
        lcl_wa_includes LIKE LINE OF  lcl_it_includes.
*lokale Variable fuer Includesuffix (z.B. &apos;01&apos; oder &apos;XX&apos;
*notwendig fuer tfdir
  DATA: lcl_suffix(2) TYPE c.
*Variable zur Laengenbestimmung: Ermittlung der Doppelincludes
*von Funktionsbausteinen.
  DATA: lcl_laenge TYPE i.


  CALL FUNCTION &apos;GET_INCLUDETAB&apos;
    EXPORTING
      progname = p_fktgroup_name
    TABLES
      incltab  = lcl_it_includes.


* Wenn Transportauftrag: alles betrachten
* ansonsten nur Kundennamensraum....
  IF p_trkorr IS INITIAL.

*  Nur Betrachtung des Kundnenamensraumes
    LOOP AT lcl_it_includes INTO lcl_wa_includes.

*Nichtbeachtung der doppelt vorhandenen Includes der Funktionsbausteine
      lcl_laenge = STRLEN( lcl_wa_includes-name ).
      lcl_laenge = lcl_laenge - 3.
      IF lcl_wa_includes-name+lcl_laenge(1) = &apos;$&apos;.
        CONTINUE. &quot;aktuellen Schleifendurchlauf hier beenden
      ENDIF.
*     Wenn nötig Funktionsbauteinname bestimmen und in globale
*     Variable setzen
      IF lcl_wa_includes-name+lcl_laenge(1) = &apos;U&apos;.
        lcl_laenge  = lcl_laenge  + 1.
        lcl_suffix = lcl_wa_includes-name+lcl_laenge(2).
        SELECT SINGLE funcname FROM tfdir INTO gv_funcname
            WHERE pname = p_fktgroup_name
            AND   include = lcl_suffix.
      ENDIF.
*  Uebergabe des Type des Includes, um Dateinamen festlegen zu können
      CLEAR ok.
      PERFORM download_include USING lcl_wa_includes-name &apos;I&apos;
                                     CHANGING ok.
      CLEAR gv_funcname.
      IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*  Fktgruppenstruktur schreiben
        PERFORM write_fktgruppenstruktur USING &apos;IN&apos;
                                         lcl_wa_includes-name
                                         p_fktgroup_name.
      ENDIF.
    ENDLOOP.

  ELSE.

    LOOP AT lcl_it_includes INTO lcl_wa_includes
                              WHERE  name(1) &lt;&gt; &apos;&lt;&apos; .
*Nichtbeachtung der doppelt vorhandenen Includes der Funktionsbausteine
      lcl_laenge = STRLEN( lcl_wa_includes-name ).
      lcl_laenge = lcl_laenge - 3.
      IF lcl_wa_includes-name+lcl_laenge(1) = &apos;$&apos;.
        CONTINUE. &quot;aktuellen Schleifendurchlauf hier beenden
      ENDIF.
*     Wenn nötig Funktionsbauteinname bestimmen und in globale
*     Variable setzen
      IF lcl_wa_includes-name+lcl_laenge(1) = &apos;U&apos;.
        lcl_laenge  = lcl_laenge  + 1.
        lcl_suffix = lcl_wa_includes-name+lcl_laenge(2).
        SELECT SINGLE funcname FROM tfdir INTO gv_funcname
            WHERE pname = p_fktgroup_name
            AND   include = lcl_suffix.
      ENDIF.
*  Uebergabe des Type des Includes, um Dateinamen festlegen zu können
      CLEAR ok.
      PERFORM download_include USING lcl_wa_includes-name &apos;I&apos;
                                     CHANGING ok.
      CLEAR gv_funcname.

      IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*  Fktgruppenstruktur schreiben
        PERFORM write_fktgruppenstruktur USING &apos;IN&apos;
                                         lcl_wa_includes-name
                                         p_fktgroup_name.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    &quot; HANDLE_INCLUDES_FKTGROUP

*&amp;---------------------------------------------------------------------*
*&amp;      Form  WRITE_FKTGRUPPENSTRUKTUR
*&amp;---------------------------------------------------------------------*
*       Schreiben der globalen Liste der Funktionsgruppenstruktur.
*----------------------------------------------------------------------*
FORM write_fktgruppenstruktur USING
                        p_objecttype TYPE any
                        p_objectname TYPE any
                        p_fktbstname TYPE any.

*lokale Variable fuer Laenge des uebergebenen Includes
  DATA: lcl_inc_len TYPE i.
*lokale Variable fuer Includesuffix (z.B. &apos;01&apos; oder &apos;XX&apos;
*notwendig fuer tfdir
  DATA: lcl_suffix(2) TYPE c.
*lokale Variable fuer fktbstname
  DATA: lcl_fktbstname TYPE tfdir-funcname.
*lokale Variable um &apos;u-Bestandteil&apos; von Fktbausteinincludes
*herunterzuladen
  DATA: lcl_u(1) TYPE c.


*Ueberpruefen, ob das Objekt ein Include ist welches ein Fktbaustein
*ist.
  IF p_objecttype = &apos;IN&apos;.
    lcl_inc_len = STRLEN( p_objectname ).
    lcl_inc_len = lcl_inc_len - 3.
    lcl_u = p_objectname+lcl_inc_len(1).
*Nur wenn drittletzter Buchstabe ein &apos;u&apos; ist liegt ein Fktbaustein vor
    IF lcl_u = &apos;U&apos;.
      lcl_inc_len = lcl_inc_len + 1.
      lcl_suffix = p_objectname+lcl_inc_len(2).
      SELECT SINGLE funcname FROM tfdir INTO lcl_fktbstname
          WHERE pname = p_fktbstname
          AND   include = lcl_suffix.
    ENDIF.
  ENDIF.
*Schreiben der Infos in die interne Tabelle.
  CLEAR wa_fkgrp_struktur.
  wa_fkgrp_struktur-objecttype = p_objecttype.
  wa_fkgrp_struktur-objectname = p_objectname.
  wa_fkgrp_struktur-fktbstname = lcl_fktbstname.
  APPEND wa_fkgrp_struktur TO it_fkgrp_struktur.

ENDFORM.                    &quot; WRITE_FKTGRUPPENSTRUKTUR

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_FKTGRPLIST
*&amp;---------------------------------------------------------------------*
*       Liste der Funktionsgruppenstruktur ins Dateisystem laden.
*       Generierung der Tabelle im HTML-Format
*----------------------------------------------------------------------*
FORM download_fktgrplist USING p_name LIKE wa_trdir-name.
*Herunterladen der Strukturtabelle
**********************************************************
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Fktgruppenstrukturname
  DATA: lcl_fkgrp_file TYPE string.
  DATA: lcl_file_objectname LIKE wa_fkgrp_struktur-objectname.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

* begin of changes for partner namespace
* Auffuellen der Felder fuer den verwendeten file_name
  LOOP AT it_fkgrp_struktur INTO wa_fkgrp_struktur.
    lcl_file_objectname = wa_fkgrp_struktur-objectname.
    TRANSLATE lcl_file_objectname USING &apos;/_&apos;.
    wa_fkgrp_struktur-file_objectname = lcl_file_objectname.
    MODIFY it_fkgrp_struktur FROM wa_fkgrp_struktur
                                            INDEX sy-tabix.
  ENDLOOP.
* end of changes for partner namespace

*Nur Herunterladen, wenn die Tabelle nicht initial ist
  IF NOT ( it_fkgrp_struktur IS INITIAL ).
    CONCATENATE &apos;FKGroup_&apos; p_name INTO lcl_fkgrp_file.
*Umwandlung in HTML-Tabelle
********************************************************
*Ueberschrift zusammenbauen
    CONCATENATE &apos;Functiongrouplist of Functiongroup&apos;  p_name
          INTO lcl_header SEPARATED BY space.

*Headertabelle zusammenbauen
    APPEND &apos;Objecttype&apos; TO lcl_it_headerrow.
    APPEND &apos;Objectname&apos; TO lcl_it_headerrow.
    APPEND &apos;Functionmodule&apos; TO lcl_it_headerrow.
    APPEND &apos;Objectname in file system&apos; TO lcl_it_headerrow.

    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_fkgrp_struktur INTO wa_fkgrp_struktur.
      PERFORM create_htmltab_body USING wa_fkgrp_struktur.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_fkgrp_file &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_fkgrp_struktur
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text021 lcl_fkgrp_file
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text021 lcl_fkgrp_file
          filename.

    ENDIF.

  ENDIF.
ENDFORM.                    &quot; DOWNLOAD_FKTGRPLIST

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_SUBMITS
*&amp;---------------------------------------------------------------------*
*      Verarbeitung des in der Uebergabestruktur angegebenen Reports,
*      der in einem Rahmenprogram mit SUBMiT aufgerufen worden ist.
*      Anhaengen an Tabelle zur späteren Verarbeitung von Rahmen-
*      programmen.
*----------------------------------------------------------------------*
FORM handle_submits USING    p_wa_cross_ref TYPE cross.
*Hilfsvariable um den Namen des Programm Typkonform an
*Forms uebergeben zu können.
  DATA: lcl_inlcude LIKE c_includename.
* Area for devclass.
  DATA: lcl_devc TYPE tadir-devclass.

*Variable fuer globalen Namen
  DATA: lcl_name LIKE wa_trdir-name.

*   Nur wenn abhängige Objekte berücksichtig werden sollen
  IF NOT g_nodep IS INITIAL.
    EXIT.
  ENDIF.

*Überpruefen, ob Programm schon runtergeladen worden ist.
  READ TABLE it_prog_stueckliste WITH KEY
              name = p_wa_cross_ref-name
              TRANSPORTING NO FIELDS.
*Nur downloaden wenn download noch nicht durchgefuehrt worden ist.
  IF sy-subrc &lt;&gt; 0.

*   Hilfsfeld fuer Typenkonformitaet fuellen
    MOVE p_wa_cross_ref-name TO lcl_inlcude.
*   Check whether this object belongs to the selected dev-class
    IF NOT p_devc IS INITIAL.
      SELECT SINGLE devclass FROM tadir INTO lcl_devc
                              WHERE pgmid    = &apos;R3TR&apos;
                                AND object   = &apos;PROG&apos;
                                AND obj_name =  lcl_inlcude.
      CHECK lcl_devc IN o_devcl.
    ENDIF.


*   Hauptstuecklist schreiben.
    PERFORM write_stueckliste USING &apos;1&apos;
                                      p_wa_cross_ref-name
                                      p_wa_cross_ref-include.

*   Tabellen  zur späteren Weiterverarbeitung zwischenspeichern
    PERFORM write_global_save USING &apos;1&apos; lcl_inlcude.

  ELSE.


  ENDIF. &quot;Lesen der Stueckliste
ENDFORM.                    &quot; HANDLE_SUBMITS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_PERFORMEXTERN
*&amp;---------------------------------------------------------------------*
*      Verarbeitung des in der Uebergabestruktur angegebenen Reports,
*      der in einem Rahmenprogram mit PERFORM IN PROGRAM aufgerufen
*      worden ist.
*      Anhaengen an Tabelle zur späteren Verarbeitung von Rahmen-
*      programmen.
*----------------------------------------------------------------------*
FORM handle_performextern USING    p_wa_cross_ref TYPE cross.
*Variable zur Zwischenspeicherung eines globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.
* Area for devclass.
  DATA: lcl_devc TYPE tadir-devclass.

* Nur wenn abhängige Objekte berücksichtig werden sollen
  IF NOT g_nodep IS INITIAL.
    EXIT.
  ENDIF.

*Überpruefen, ob Programm runtergeladen worden ist.
  READ TABLE it_prog_stueckliste WITH KEY
                      name = p_wa_cross_ref-prog
                      TRANSPORTING NO FIELDS.
*Nur downloaden wenn download noch nicht durchgefuehrt worden ist.
  IF sy-subrc &lt;&gt; 0.

*   Check whether this object belongs to the selected dev-class
    IF NOT p_devc IS INITIAL.
      SELECT SINGLE devclass FROM tadir INTO lcl_devc
                             WHERE pgmid    = &apos;R3TR&apos;
                               AND object   = &apos;PROG&apos;
                               AND obj_name =  p_wa_cross_ref-prog.
      CHECK lcl_devc IN o_devcl.

    ENDIF.
*Hauptstückliste schreiben
    PERFORM write_stueckliste USING &apos;1&apos;
                                  p_wa_cross_ref-prog
                                  p_wa_cross_ref-include.

*Tabellen zur späteren Weiterverarbeitung zwischenspeichern
    PERFORM write_global_save USING &apos;1&apos; p_wa_cross_ref-prog.


  ELSE.
*  Do Nothing
  ENDIF. &quot;bereits heruntergeladen

ENDFORM.                    &quot; HANDLE_PERFORMEXTERN

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_TRANSACTION
*&amp;---------------------------------------------------------------------*
*     Verarbeitung der in der Uebergabestruktur angegebenen Transaktion,
*     dir in einem Rahmenprogram mit CALL TRANSACITON  aufgerufen worden
*     ist.
*     Anhaengen an Tabelle zur späteren Verarbeitung von Rahmen-
*     programmen.
*----------------------------------------------------------------------*
FORM handle_transaction USING    p_wa_cross_ref TYPE cross.
*Lokale Variable für den Programmnamen aus Tabelle TSTC
  DATA: lcl_progname LIKE  c_includename.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.
* Area for devclass.
  DATA: lcl_devc TYPE tadir-devclass.

*Lesen des Programmnamens zum Transaktionscode
  SELECT SINGLE pgmna  FROM tstc INTO lcl_progname
            WHERE tcode = p_wa_cross_ref-name.

*   Check whether this object belongs to the selected dev-class
  IF NOT p_devc IS INITIAL.
    SELECT SINGLE devclass FROM tadir INTO lcl_devc
                           WHERE pgmid    = &apos;R3TR&apos;
                             AND object   = &apos;PROG&apos;
                             AND obj_name =  lcl_progname.
    CHECK lcl_devc IN o_devcl.
  ENDIF.

*  Weiterbearbeitung wie ein mit submit aufgerufenes Programm
*  ************************************************************
*  Schreiben der Stueckliste fuer Transaktionscodes
*  1.Transaktionscode zu aufrufendem Programm (Hauptliste)
  PERFORM write_stueckliste USING &apos;Transcation Code&apos;
                               p_wa_cross_ref-name
                               p_wa_cross_ref-include.


*  Überpruefen, ob Programm runtergeladen worden ist.
  READ TABLE it_prog_stueckliste WITH KEY
                      name = lcl_progname
                      TRANSPORTING NO FIELDS.

*  Nur downloaden wenn download noch nicht durchgefuehrt worden ist.
  IF sy-subrc &lt;&gt; 0.

*    Nur wenn abhängige Objekte berücksichtig werden sollen
    IF g_nodep IS INITIAL.
*    2.)Stueckliste schreiben (Hauptliste)
      PERFORM write_stueckliste USING &apos;1&apos;
                                     lcl_progname
                                      p_wa_cross_ref-name.


*    Tabelle zur späteren Weiterverarbeitung
      PERFORM write_global_save USING &apos;1&apos; lcl_progname.

    ENDIF.

  ELSE. &quot;Schon in gesichert (nur zu Uebersicht
*  Schreiben der Stueckliste fuer Transaktionscodes
*  1.Transaktionscode zu aufrufendem Programm
    PERFORM write_stueckliste USING &apos;TAC&apos;
                                 p_wa_cross_ref-name
                                 p_wa_cross_ref-include.

  ENDIF. &quot;schon gesichert?

ENDFORM.                    &quot; HANDLE_TRANSACTION

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_AUTHORITYOBJECT
*&amp;---------------------------------------------------------------------*
*       Lesen der Infos des in der Uebergabestruktur angegebenen
*       Berechtigungsobjektes. Anhaengen an globale Tabelle der
*       Berechtigungsobjekte.
*----------------------------------------------------------------------*
FORM handle_authorityobject USING    p_wa_cross_ref TYPE cross.
*Bereich fuer Felder
  DATA: lcl_wa_authx TYPE authx.
*Tabelle fuer Felder des Berechtigungsobjektes
  TYPES: BEGIN OF fields,
            name TYPE xufield,
         END OF fields.
  DATA: lcl_it_fields TYPE STANDARD TABLE OF fields,
        lcl_wa_fields LIKE LINE OF lcl_it_fields.
*Lokale Variablen für Tabellenbehandlung
  DATA: lcl_wa_tobj LIKE wa_tobj,
        lcl_it_tactz LIKE it_tactz.

*Selektion der Berechtigungsobjekte
  SELECT SINGLE * FROM tobj INTO lcl_wa_tobj
            WHERE objct = p_wa_cross_ref-name.

*Anhaengen an Gesamtliste
  APPEND lcl_wa_tobj TO it_tobj.

*Identifzieren von Datenelementen im Kunennamensraum
  APPEND lcl_wa_tobj-fiel1 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel2 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel3 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel4 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel5 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel6 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel7 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel8 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel9 TO lcl_it_fields.
  APPEND lcl_wa_tobj-fiel0 TO lcl_it_fields.

  LOOP AT lcl_it_fields INTO lcl_wa_fields
        WHERE  name(1) = &apos;Z&apos;
        OR name(1) = &apos;Y&apos;.

    SELECT SINGLE * FROM authx INTO lcl_wa_authx
        WHERE fieldname = lcl_wa_fields-name.

    IF ( ( lcl_wa_authx-rollname(1) = &apos;Z&apos; )
          OR ( lcl_wa_authx-rollname(1) = &apos;Y&apos; ) ).
      PERFORM write_dataelements USING lcl_wa_authx-rollname.
    ENDIF.

  ENDLOOP.

*Selektion der zu den Berechtigungsobjekten gehörigen Aktivitäten
  SELECT * FROM tactz INTO TABLE lcl_it_tactz
          WHERE brobj = p_wa_cross_ref-name.

  APPEND LINES OF lcl_it_tactz TO it_tactz.
*Schreiben der STueckliste
  PERFORM write_stueckliste USING &apos;Authority Object&apos;
                                  p_wa_cross_ref-name
                                  p_wa_cross_ref-include.

ENDFORM.                    &quot; HANDLE_AUTHORITYOBJECT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_AUTHORITYOBJECTS
*&amp;---------------------------------------------------------------------*
*       Sicherung der Gesamttabelle der Berechtigunsobjekte
*       und der Aktivitaetentabell in das Dateisystem .
*       Generierung der Tabelle in HTML-Format.
*----------------------------------------------------------------------*
FORM download_authorityobjects.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Berechtigungsobjektname
  DATA: lcl_authobj_name TYPE string.
*Aktivitaeten zu Berechtigungsobjekt
  DATA: lcl_auth_act TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

*1.) Berechtigungsobjekttabelle
*Nur herunterladen, wenn Berechtigungsobjektabelle Inhalt hat.
  IF NOT ( it_tobj IS INITIAL ).

*Ueberschrift zusammenbauen
    CONCATENATE &apos;Structure of Authorityobjects in Mainprogram&apos;
      global_main_name INTO lcl_header SEPARATED BY space.

*Headertabelle zusammenbauen
    APPEND &apos;Name of Object&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 1&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 2&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 3&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 4&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 5&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 6&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 7&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 8&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 9&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 10&apos; TO lcl_it_headerrow.
    APPEND &apos;Class&apos; TO lcl_it_headerrow.
    APPEND &apos;Author&apos; TO lcl_it_headerrow.
    APPEND &apos;Function Block&apos; TO lcl_it_headerrow.
    APPEND &apos;Conversion of Field&apos; TO lcl_it_headerrow.



*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_tobj INTO wa_tobj.
      PERFORM create_htmltab_body USING wa_tobj.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************



    CONCATENATE &apos;Auhthorities&apos; global_main_name INTO lcl_authobj_name.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_authobj_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tobj
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text031 lcl_authobj_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text031 lcl_authobj_name
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Authority Objects&apos;
                                       &apos;Authority Objects&apos;
                                        global_main_name.
    ENDIF.
  ENDIF.  &quot;Tabelle it_tobj gefuellt?????

*2.) Aktivitaeten zur Berechtigungsobjekttabelle
*Nur herunterladen, wenn Aktivitaetstabelle Inhalt hat.
  IF NOT ( it_tactz IS INITIAL ).

    CLEAR lcl_header. REFRESH lcl_it_headerrow.
*    Ueberschrift zusammenbauen
    CONCATENATE &apos;Activities of Authorization Objects in Program&apos;
        global_main_name INTO lcl_header SEPARATED BY space.

*    Headertabelle zusammenbauen
    APPEND &apos;Authority Object&apos; TO lcl_it_headerrow.
    APPEND &apos;Assigned Activity&apos; TO lcl_it_headerrow.


*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_tactz INTO wa_tactz.
      PERFORM create_htmltab_body USING wa_tactz.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************


    CONCATENATE &apos;AuthActivities&apos; global_main_name INTO lcl_auth_act.

*Html-tabelle anlegen
    CLEAR lcl_header. REFRESH lcl_it_headerrow.


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_authobj_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tactz
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text032 lcl_auth_act filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text032 lcl_auth_act filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Activities of Authority Objects&apos;
                                       &apos;Activities of Authority Objects&apos;
                                        global_main_name.
    ENDIF.
  ENDIF.  &quot;Tabelle it_tactz gefuellt?????

ENDFORM.                    &quot; DOWNLOAD_AUTHORITYOBJECTS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_TITLEBAR
*&amp;---------------------------------------------------------------------*
*       Lesen der Gui-Titel des im Parameter P_NAME uebergebenen
*       Rahmenprogramms. Anhaengen an globale Gesamtliste der GUI-Titel.
*----------------------------------------------------------------------*
FORM handle_titlebar USING    p_name TYPE c
                              p_typus TYPE c.
*Lokale interne Tabelle fuer Titlebar aufzunehmen
  DATA: lcl_it_d347t LIKE it_d347t.

  CLEAR wa_d347t.
*Lesen der Titlebartabelle mit dem Schlüssel Ra
  SELECT * FROM d347t INTO TABLE lcl_it_d347t
      WHERE  ( ( progname = p_name )
              AND ( sprsl IN o_lan ) ).

  LOOP AT lcl_it_d347t INTO wa_d347t.
*Anhaengen der lokalen Tabelle an die Gesamttabelle
    APPEND wa_d347t TO it_d347t.
    IF p_typus = &apos;R&apos;. &quot;Rahmenprogramm
*Nur schreiben wenn zu diesem Schluessel noch kein Eintrag
*existiert
      READ TABLE it_prog_stueckliste WITH TABLE KEY
                 name = wa_d347t-obj_code
                 obername =  p_name
                 TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden
        PERFORM write_stueckliste USING &apos;Titelbar&apos;
                                       wa_d347t-obj_code
                                       p_name.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    &quot; HANDLE_TITLEBAR

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_TITLEBAR
*&amp;---------------------------------------------------------------------*
*       Sicherung der Gesamtliste der GUI-Titel in das Dateisystem.
*       Generierung der Tabelle in  HTML-Format.
*----------------------------------------------------------------------*
FORM download_titlebar.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Dateiname fuer Download
  DATA: lcl_titlebar_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_d347t IS INITIAL ).
*    Ueberschrift zusammenbauen
    CONCATENATE &apos;GUI-Titles of Object&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*    Headertabelle zusammenbauen
    APPEND &apos;Programname&apos; TO lcl_it_headerrow.
    APPEND &apos;Language&apos; TO lcl_it_headerrow.
    APPEND &apos;Code of Title&apos; TO lcl_it_headerrow.
    APPEND &apos;Text of Title&apos; TO lcl_it_headerrow.


*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_d347t INTO wa_d347t.
      PERFORM create_htmltab_body USING wa_d347t.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************


    CONCATENATE &apos;Titlebar_&apos; global_main_name INTO lcl_titlebar_name.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_titlebar_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html               &quot;it_d347t
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text033 lcl_titlebar_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text033 lcl_titlebar_name
          filename.

    ENDIF.
  ENDIF. &quot;ist it_d347t überhaupt gefüllt
ENDFORM.                    &quot; DOWNLOAD_TITLEBAR

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_TACODE
*&amp;---------------------------------------------------------------------*
*       Lesen aller Transaktionscodes zu dem im Parameter P_NAME
*       uebergebenen Rahmenprgramm. Anhaengen an die Gesamtliste
*       der Transaktionscodes.
*----------------------------------------------------------------------*
FORM handle_tacode USING    p_name LIKE wa_trdir-name.
*Lokaler Arbeitsbereich fuer Transaktionscodezuweisung
  DATA: lcl_it_tstc TYPE STANDARD TABLE OF itstc.
  SELECT tcode pgmna dypno FROM tstc INTO TABLE lcl_it_tstc
        WHERE pgmna = p_name.

*Selektionsergebnis an  Gesamttabelle anhaengen
  APPEND LINES OF lcl_it_tstc TO it_tstc.


ENDFORM.                    &quot; HANDLE_TACODE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_TACODELIST
*&amp;---------------------------------------------------------------------*
*        Speicherung der Gesamtliste der Tranaktionscodes
*        Generierung der Tabelle in HTML-Format.
*----------------------------------------------------------------------*
FORM download_tacodelist.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Dateiname fuer Download
  DATA: lcl_tacode_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_tstc IS INITIAL ).

*  Ueberschrift zusammenbauen
    CONCATENATE &apos;Transactioncodes&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*  Headertabelle zusammenbauen
    APPEND &apos;Transactionscode&apos; TO lcl_it_headerrow.
    APPEND &apos;Programname&apos; TO lcl_it_headerrow.
    APPEND &apos;Number Start Dynpro&apos; TO lcl_it_headerrow.


*  Umwandlung in HTML-Tabelle
*  *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_tstc INTO wa_tstc.
      PERFORM create_htmltab_body USING wa_tstc.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************

    CONCATENATE &apos;Tacodelist_&apos; global_main_name INTO lcl_tacode_name.


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_tacode_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tstc
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text034 lcl_tacode_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text034 lcl_tacode_name
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Tranactioncodelist&apos;
                                      &apos;Tacodelist&apos;
                                      global_main_name.
    ENDIF.
  ENDIF. &quot;ist it_d347t überhaupt gefüllt

ENDFORM.                    &quot; DOWNLOAD_TACODELIST

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_SEARCHELP
*&amp;---------------------------------------------------------------------*
* Store the complete list of Search helps.
* Generation of the table in HTML format.
*----------------------------------------------------------------------*
FORM download_searchelp .

* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Dateiname fuer Download
  DATA: lcl_srchelp_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_serchlp IS INITIAL ).

*  Ueberschrift zusammenbauen
    CONCATENATE &apos;Search Help&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*  Headertabelle zusammenbauen
    APPEND &apos;Searchelp&apos; TO lcl_it_headerrow.
    APPEND &apos;Activation Status&apos; TO lcl_it_headerrow.
    APPEND &apos;Flag Elementary Sh. help&apos; TO lcl_it_headerrow.
    APPEND &apos;Selection method&apos; TO lcl_it_headerrow.
    APPEND &apos;Search help exit&apos; TO lcl_it_headerrow.
    APPEND &apos;Name of a search help parameter&apos; TO lcl_it_headerrow.
    APPEND &apos;Position of field&apos; TO lcl_it_headerrow.
    APPEND &apos;Assigned data element&apos; TO lcl_it_headerrow.
    APPEND &apos;Flag for IMPORT&apos; TO lcl_it_headerrow.
    APPEND &apos;Flag for EXPORT&apos; TO lcl_it_headerrow.
    APPEND &apos;Position in dialog box&apos; TO lcl_it_headerrow.
    APPEND &apos;Position in the hit list&apos; TO lcl_it_headerrow.
    APPEND &apos;Language Key&apos; TO lcl_it_headerrow.
    APPEND &apos;Explanation&apos; TO lcl_it_headerrow.

*  Umwandlung in HTML-Tabelle
*  *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_serchlp INTO wa_serchlp.
      PERFORM create_htmltab_body USING wa_serchlp.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************

    CONCATENATE &apos;Searchhelp_&apos; global_main_name INTO lcl_srchelp_name.


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_srchelp_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tstc
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  &apos;Searchhelp List&apos; lcl_srchelp_name   &quot;DNE_KW11
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  &apos;Searchhelp List&apos; lcl_srchelp_name  &quot;DNE_KW11
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Searchhelplist&apos;
                                      &apos;srchelplist&apos;
                                      global_main_name.
    ENDIF.
  ENDIF.


ENDFORM.                    &quot; DOWNLOAD_SEARCHELP

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_PF_STATUS
*&amp;---------------------------------------------------------------------*
*      Lesen der Informationen zu den GUI-Stati des im Paramter P_NAME
*      uebergebenen Rahmenprogramms. Aufruf der Routinen zur Sicherung
*      der Menueliste und der Funktionstastenliste.
*----------------------------------------------------------------------*
FORM handle_pf_status USING    p_name TYPE c
                               p_typus TYPE c.
*Variable fuer Prog-Name wegen Typkonformitaet
  DATA: lcl_prog LIKE c_includename.

*Zuweisung
  lcl_prog = p_name.

*Lokale Datenbereich um Status für Rahmenprogramm zu ermitteln
  DATA: lcl_it_rlseu0_dok TYPE STANDARD TABLE OF rlseu0_dok,
        lcl_wa_rlseu0_dok LIKE LINE OF lcl_it_rlseu0_dok.

*Sprachtabelle
  LOOP AT it_lan INTO wa_lan.

*Alle Stati zu diesem Rahmenprogamm besorgen
    CALL FUNCTION &apos;RS_CUA_STATUS&apos;
      EXPORTING
        objectname           = lcl_prog
        language             = wa_lan
      TABLES
        status               = lcl_it_rlseu0_dok
      EXCEPTIONS
        object_not_found     = 1
        object_not_specified = 2
        program_not_found    = 3
        OTHERS               = 4.
*Wenn ungleich null; hat dieses Rahmenprogramm keine Stati
    IF sy-subrc = 0.
*Jeden einzelnen Status bearbeiten
      LOOP AT lcl_it_rlseu0_dok INTO lcl_wa_rlseu0_dok.
*Alle Infos fuer pf-Status abfragen
        CALL FUNCTION &apos;RS_CUA_GET_STATUS&apos;
            EXPORTING
                 language              = wa_lan
                 program               = lcl_prog
                 status                = lcl_wa_rlseu0_dok-status
*         SUPPRESS_CMOD_ENTRIES = &apos;X&apos;
            TABLES
*         STATUS_LIST           =
*         FKEYS                 =
*         TREE                  =
*         NOT_FOUND_LIST        =
                 menutree              = it_rsmpe_tree
                 functionkeys          = it_rsmpe_keys
            EXCEPTIONS
                 not_found_program     = 1
                 not_found_status      = 2
                 recursive_menues      = 3
                 empty_list            = 4
                 not_found_menu        = 5
                 OTHERS                = 6
                  .
*Nur Downloaden wenn Ausführung erfolgreich war
        IF sy-subrc = 0.
*Download der Menustruktur, nur wenn Tabelle nicht leer.
          IF NOT ( it_rsmpe_tree IS INITIAL ).
            PERFORM download_menuliste USING lcl_prog
                                             lcl_wa_rlseu0_dok-status
                                             p_typus.
          ENDIF.
*Download der Funktionsbausteininfos, nur wenn Tabelle nicht leer
          IF NOT ( it_rsmpe_keys IS INITIAL ).
            PERFORM download_functionkeys USING lcl_prog
                                               lcl_wa_rlseu0_dok-status
                                                p_typus.

          ENDIF.
        ENDIF.
*Initialisieren der globalen Standardtabellen
        REFRESH it_rsmpe_keys. REFRESH it_rsmpe_tree.
      ENDLOOP. &quot;Stati
    ENDIF.
  ENDLOOP. &quot;Sprachtabelle
ENDFORM.                    &quot; HANDLE_PF_STATUS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_MENULISTE
*&amp;---------------------------------------------------------------------*
*       Download der in der globalen Tabelle fuer die Menueliste
*       enthaltenen Menueliste füer den Status.
*       Generierung der Liste in HTML-Format.
*----------------------------------------------------------------------*
FORM download_menuliste USING    p_name LIKE wa_trdir-name
                                 p_status TYPE rlseu0_dok-status
                                 p_typus TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Name fuer die Menuliste
  DATA: lcl_menuliste_name TYPE string.

  CONCATENATE &apos;Menulist_&apos; p_name &apos;_&apos; p_status &apos;(&apos; wa_lan &apos;)&apos; INTO
        lcl_menuliste_name.


*Ueberpruefen, ob dieses Element schon heruntergeladen worden ist
  READ TABLE it_prog_stueckliste WITH TABLE KEY
            name = lcl_menuliste_name
            obername =  p_name
            TRANSPORTING NO FIELDS.
  IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden

    PERFORM create_html_for_menulist USING p_status
                                           p_name.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_menuliste_name  &apos;.htm&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html &quot;it_rsmpe_tree
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text035 lcl_menuliste_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text035 lcl_menuliste_name
          filename.

    ENDIF.

*Unterscheidung zu welcher Ordnungsebene die Menuliste gehoert:
*Rahmenprogramm oder Funktionsgruppe oder ...(Stueckliste!!!)
    IF p_typus = &apos;R&apos;. &quot;Rahmenprogramm
      PERFORM write_stueckliste USING &apos;PfMe&apos;
                                      lcl_menuliste_name
                                      p_name.
    ELSEIF p_typus = &apos;G&apos;. &quot;Funktionsgruppe
      PERFORM write_fktgruppenstruktur USING &apos;MeLi&apos;
                                             lcl_menuliste_name
                                             p_name.
    ENDIF.
  ENDIF. &quot;Stueckliste lesen

ENDFORM.                    &quot; DOWNLOAD_MENULISTE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_FUNCTIONKEYS
*&amp;---------------------------------------------------------------------*
*       Download der in der globalen Tabelle fuer die Funktionstasten-
*       liste enthaltenen Menueliste füer den Status.
*       Generierung der Liste in HTML-Format.
*----------------------------------------------------------------------*
FORM download_functionkeys USING    p_name LIKE wa_trdir-name
                                    p_status  TYPE rlseu0_dok-status
                                    p_typus TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Lokaler Downloadtabelle für Funktionskeys(Aussagefähiger Name für Icon)
  TYPES: BEGIN OF downtab,
           keys LIKE rsmpe_keys,
           icon_text TYPE icon-name,
         END OF downtab.
  DATA: lcl_it_downtab TYPE STANDARD TABLE OF downtab,
        lcl_wa_downtab LIKE LINE OF lcl_it_downtab.
  DATA: lcl_text TYPE icon-name.
*Ausgabestruktur fuer Html-Aufbereitung bestellen
  TYPES: BEGIN OF idowntab,
*          PFNO like downtab-keys-PFNO,
            code TYPE downtab-keys-code,
            text TYPE downtab-keys-text,
            quickinfo TYPE downtab-keys-quickinfo,
            icon_text TYPE downtab-icon_text,
         END OF idowntab.
*Arbeitsbereich fuer Ausgabebereich
  DATA: lcl_wa_idowntab TYPE idowntab.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.



*Doanloadtabelle aufbereiten: Es wird der Name des Icons noch eingefuegt
  LOOP AT it_rsmpe_keys INTO lcl_wa_downtab-keys.
    IF NOT ( lcl_wa_downtab-keys-icon_id IS INITIAL ).
      SELECT SINGLE name FROM icon INTO lcl_text
            WHERE id = lcl_wa_downtab-keys-icon_id.
      MOVE lcl_text TO lcl_wa_downtab-icon_text.
    ELSEIF NOT ( lcl_wa_downtab-keys-sys_icon IS INITIAL ).
      SELECT SINGLE name FROM icon INTO lcl_text
            WHERE id = lcl_wa_downtab-keys-sys_icon.
      MOVE lcl_text TO lcl_wa_downtab-icon_text.
    ENDIF.
    APPEND lcl_wa_downtab TO lcl_it_downtab.
  ENDLOOP.

*Name fuer die Functionkeyliste
  DATA: lcl_functionkeylist_name TYPE string.

  CONCATENATE &apos;Functionkey_&apos; p_name &apos;_&apos; p_status &apos;(&apos; wa_lan &apos;)&apos;
          INTO lcl_functionkeylist_name.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Functionkeylist of Status &apos; p_status  &apos;of Mainprogram&apos;
         p_name &apos;(Language:&apos; wa_lan &apos;)&apos;
         INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
  APPEND &apos;Functioncode&apos; TO lcl_it_headerrow.
  APPEND &apos;Text of Function&apos; TO lcl_it_headerrow.
  APPEND &apos;Quick-Info&apos; TO lcl_it_headerrow.
  APPEND &apos;Name of Icon&apos; TO lcl_it_headerrow.



*Umwandlung in HTML-Tabelle
********************************************************
  PERFORM create_htmltab_header  USING lcl_it_headerrow
                                       lcl_header.

  LOOP AT lcl_it_downtab INTO lcl_wa_downtab.
*Nur wichtige Felder uebernehmen
    MOVE-CORRESPONDING lcl_wa_downtab-keys TO lcl_wa_idowntab.
    MOVE lcl_wa_downtab-icon_text TO lcl_wa_idowntab-icon_text.
    PERFORM create_htmltab_body USING lcl_wa_idowntab.
  ENDLOOP.

  PERFORM create_html_tab_foot.
*********************************************************
*Ueberpruefen, ob dieses Element schon heruntergeladen worden ist
  READ TABLE it_prog_stueckliste WITH TABLE KEY
            name = lcl_functionkeylist_name
            obername =  p_name
            TRANSPORTING NO FIELDS.
  IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_functionkeylist_name &apos;.xml&apos; INTO
    filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;lcl_it_downtab
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text036
          lcl_functionkeylist_name filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text036
          lcl_functionkeylist_name filename.

    ENDIF.

*Unterscheidung zu welcher Ordnungsebene die Menuliste gehoert:
*Rahmenprogramm oder Funktionsgruppe oder ...(Stueckliste!!!)
    IF p_typus = &apos;R&apos;. &quot;Rahmenprogramm
      PERFORM write_stueckliste USING &apos;PfFu&apos;
                                      lcl_functionkeylist_name
                                      p_name.
    ELSEIF p_typus = &apos;G&apos;. &quot;Funktionsgruppe
      PERFORM write_fktgruppenstruktur USING &apos;MeLi&apos;
                                             lcl_functionkeylist_name
                                             p_name.
    ENDIF.
  ENDIF. &quot;Stuecklistenueberpruefung

ENDFORM.                    &quot; DOWNLOAD_FUNCTIONKEYS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_CLASSINTERFACE
*&amp;---------------------------------------------------------------------*
*       Ermittlung der Klassen des im Uebergabeparmater p_name
*       angegegbenen Rahmenprogramm. Ermittelte Klassen werden in
*       Tabelle zur späteren Verarbeitung von Rahmenprogrammen
*       geschrieben.
*       Über die Klassen werden auch die enthaltenen Interfaces
*       berücksichtigt.
*----------------------------------------------------------------------*
FORM handle_classinterface USING    p_name LIKE wa_trdir-name
                                    p_typus TYPE c.
*Bereiche um Programmlas zu verarbeiten
  DATA: lcl_it_rcref TYPE STANDARD TABLE OF rcref,
        lcl_wa_rcref LIKE LINE OF lcl_it_rcref.
* Area for devclass.
  DATA: lcl_devc TYPE tadir-devclass.

* Nur wenn abhängige Objekte berücksichtig werden sollen
  IF NOT g_nodep IS INITIAL.
    EXIT.
  ENDIF.

*Klassen des Programmes laden
  LOAD REPORT p_name PART &apos;CREF&apos; INTO lcl_it_rcref.

*Sicherung der Klassen im Kundennamensraum
  LOOP AT lcl_it_rcref INTO lcl_wa_rcref.
*      WHERE name(1) = &apos;Z&apos;
*        OR name(1) = &apos;Y&apos;
*        or name(g_len_nspace) = p_nspace.

    IF     lcl_wa_rcref-name(1) = &apos;Y&apos;
        OR lcl_wa_rcref-name(1) = &apos;Z&apos;
        OR lcl_wa_rcref-name(g_len_nspace) = p_nspace.

*   Check whether this object belongs to the selected dev-class
      IF NOT p_devc IS INITIAL.
        SELECT SINGLE devclass FROM tadir INTO lcl_devc
                               WHERE pgmid    = &apos;R3TR&apos;
                                 AND object   = &apos;CLAS&apos;
                                 AND obj_name =  lcl_wa_rcref-name.
        CHECK lcl_devc IN o_devcl.
      ENDIF.

      PERFORM write_global_save USING &apos;C&apos; lcl_wa_rcref-name.
      PERFORM write_stueckliste USING &apos;Class(OO)&apos;
                                        lcl_wa_rcref-name
                                        p_name.
    ENDIF.
  ENDLOOP.

ENDFORM.                    &quot;handle_classinterface

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_classLIST
*&amp;---------------------------------------------------------------------*
*     Generierung der Klassenliste fuer Methodenincludes und
*     normale Includes.
*     Sicherung der Klassenliste in Dateisystem
*----------------------------------------------------------------------*
FORM download_classlist USING p_name TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Variablen für den Suchstring
  DATA: lcl_such(40) TYPE c.
*Variable fuer Anzahl der Zeilen der internen Tabelle
  DATA: lcl_lines TYPE i.
*Variable fuer Zaehler der do-Schleife
  DATA: lcl_zaehler TYPE i.
*Arbeitsbereich fuer tmdir
  DATA: lcl_it_tmdir TYPE STANDARD TABLE OF tmdir,
        lcl_wa_tmdir LIKE LINE OF lcl_it_tmdir.
*Arbeitsbereich fuer trdir
  DATA: lcl_it_trdir TYPE STANDARD TABLE OF trdir,
        lcl_wa_trdir LIKE LINE OF lcl_it_trdir.
*Varible um Laenge des uebergeben Strings zu ermittlen
  DATA: lcl_laeng TYPE i.
*Name fuer die Methodenliste der Klasse--&gt;Download
  DATA: lcl_classlist_name TYPE string.
  DATA: lcl_file_inc LIKE wa_classlist-file_inc.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

**************************************************************
*1.) Methodenincludes verarbeiten
**************************************************************

*Suchstring zur Selektion der Trdir aufbauen

  lcl_laeng = STRLEN( p_name ).
  IF lcl_laeng = 30.
    CONCATENATE p_name &apos;%CM___&apos; INTO lcl_such.
  ELSE.
    CONCATENATE p_name &apos;=%CM___&apos; INTO lcl_such.
  ENDIF.


*Alle relevanten Includes aus Trdir lesen
  SELECT * FROM trdir INTO TABLE lcl_it_trdir
        WHERE name  LIKE lcl_such.

*Ueberpruefen, ob die Selektierten Includes den Namenkonventionen
*fuer Methodenincludes entsprechen.
  LOOP AT lcl_it_trdir INTO lcl_wa_trdir.
*Wenn Laenge ungleich 35 ist diese Zeile aus interner Tabelle loeschen
*(Methodenincludes haben Laenge 35; normale Includes dürfen nur Laenge
*30 haben).
    lcl_laeng = STRLEN( lcl_wa_trdir-name ).
    IF lcl_laeng &lt;&gt; 35.
      DELETE lcl_it_trdir FROM sy-tabix.
      CONTINUE.
    ENDIF.
  ENDLOOP.

*Tabelle mit forlaufenden Nummern der Methoden selektieren
  SELECT * FROM tmdir INTO TABLE lcl_it_tmdir
        WHERE classname = p_name.

*Sortierung der beiden Tabellen dass sie spaeter gemischt werden
*koennen.
  SORT lcl_it_trdir BY name ASCENDING.
  SORT lcl_it_tmdir BY methodindx ASCENDING .

*Nur Saetze die einen Index haben sind relevant
  DELETE lcl_it_tmdir WHERE methodindx IS INITIAL.

*Anzahl der Saetze ermittlen fuer Schleife zum Mischen.
  DESCRIBE TABLE lcl_it_trdir LINES lcl_lines.

*Abmischen der der beiden Tabellen in Gesamttabelle
  lcl_zaehler = 1.
  DO lcl_lines TIMES.
    READ TABLE lcl_it_trdir INDEX lcl_zaehler INTO lcl_wa_trdir.
    READ TABLE lcl_it_tmdir INDEX lcl_zaehler INTO lcl_wa_tmdir.
    MOVE  &apos;Meth&apos; TO wa_classlist-typus.
    MOVE  lcl_wa_trdir-name TO wa_classlist-inc.
    MOVE  lcl_wa_tmdir-methodname TO wa_classlist-meth.
    APPEND wa_classlist TO it_classlist.
    lcl_zaehler = lcl_zaehler + 1.
  ENDDO.

********************************************************
*2.)Alle anderen Klassenincludes außer Methodenincludes
********************************************************
*Suchstring zur Selektion der Trdir aufbauen
  lcl_laeng = STRLEN( p_name ).
  IF lcl_laeng = 30.
    CONCATENATE p_name &apos;%C_&apos; INTO lcl_such.
  ELSE.
    CONCATENATE p_name &apos;=%C_&apos; INTO lcl_such.
  ENDIF.

  REFRESH lcl_it_trdir. CLEAR lcl_wa_trdir.
  CLEAR wa_classlist.
*Alle relevanten Includes aus Trdir lesen
  SELECT * FROM trdir INTO TABLE lcl_it_trdir
        WHERE name  LIKE lcl_such.

  LOOP AT lcl_it_trdir INTO lcl_wa_trdir.
    lcl_laeng = STRLEN( lcl_wa_trdir-name ).
    IF lcl_laeng = 32. &quot;Es ist ein Klasseninclude
      MOVE &apos;CIN&apos; TO wa_classlist-typus.
      MOVE lcl_wa_trdir-name TO wa_classlist-inc.
      APPEND wa_classlist TO it_classlist.
    ENDIF.
  ENDLOOP.

* Get local type-pools, local macros, local classes
* Suchstring zur Selektion der Trdir aufbauen
  lcl_laeng = STRLEN( p_name ).
  IF lcl_laeng = 30.
    CONCATENATE p_name &apos;%CC%&apos; INTO lcl_such.
  ELSE.
    CONCATENATE p_name &apos;=%CC%&apos; INTO lcl_such.
  ENDIF.

  REFRESH lcl_it_trdir. CLEAR lcl_wa_trdir.
  CLEAR wa_classlist.
*Alle relevanten Includes aus Trdir lesen
  SELECT * FROM trdir INTO TABLE lcl_it_trdir
        WHERE name  LIKE lcl_such.

  LOOP AT lcl_it_trdir INTO lcl_wa_trdir.
    lcl_laeng = STRLEN( lcl_wa_trdir-name ).
    IF lcl_laeng = 35. &quot;Es ist ein INclude für lokale definitions
      MOVE &apos;CIN&apos; TO wa_classlist-typus.
      MOVE lcl_wa_trdir-name TO wa_classlist-inc.
      APPEND wa_classlist TO it_classlist.
    ENDIF.
  ENDLOOP.

********************************************************
*3.)Klassenliste herunterladen
********************************************************
* begin of changes for partner namespace
* Auffuellen der Felder fuer den verwendeten file_name
  LOOP AT it_classlist INTO wa_classlist.
    lcl_file_inc = wa_classlist-inc.
    TRANSLATE lcl_file_inc USING &apos;/_&apos;.
    wa_classlist-file_inc = lcl_file_inc.
    MODIFY it_classlist FROM wa_classlist INDEX sy-tabix.
  ENDLOOP.
* end of changes for partner namespace
*Nur Download durchführen wenn Klassenliste nicht leer ist.
  IF NOT ( it_classlist IS INITIAL ).
    CONCATENATE &apos;Classlist_&apos; p_name INTO lcl_classlist_name.

*Umwandlung in HTML-Tabelle
********************************************************
*Ueberschrift zusammenbauen
    CONCATENATE &apos;Components of OO-Class&apos;  p_name
          INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
    APPEND &apos;Include Type&apos; TO lcl_it_headerrow.
    APPEND &apos;Include Name &apos; TO lcl_it_headerrow.
    APPEND &apos;Method Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Include Name in file system&apos; TO lcl_it_headerrow.


    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_classlist INTO wa_classlist.
      PERFORM create_htmltab_body USING wa_classlist.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_classlist_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_classlist
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text039 lcl_classlist_name
        filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text039 lcl_classlist_name
        filename.

    ENDIF.
  ENDIF. &quot;Download nur wenn Klassenliste nicht leer ist

ENDFORM.                    &quot; DOWNLOAD_METHODLIST

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SELECTION
*&amp;---------------------------------------------------------------------*
*       Abfangen der Selektionen in den Selektionsbildschirmen.
*----------------------------------------------------------------------*

FORM selection.
* Variable zur Speicherung des Root-Verzeichnisses
  DATA: lcl_root TYPE string.

* Bereich fuer Sprachen
  DATA lcl_t002c_spras TYPE t002c-spras.
* Variable fuer Laenge eines Strings
  DATA: lcl_len TYPE i.

  g_nspace   = p_nspace.
  g_savename = p_nspace.
  TRANSLATE g_savename USING &apos;/_&apos;.
* Ueberpruefen, ob  letztes Zeichen ein Backslash ist
* --&gt;dann loeschen des  Backslashs
  lcl_len = STRLEN( dir ).
  lcl_len = lcl_len - 1.
  IF dir+lcl_len = &apos;\&apos;.
    dir = dir(lcl_len).
  ENDIF.
* Behandlung der Sprache, gueltiger Eintrag
  IF o_lan IS INITIAL.
    APPEND sy-langu TO it_lan.
  ELSE.
    SELECT spras FROM t002c INTO TABLE it_lan WHERE spras IN o_lan.
  ENDIF.


* Welche Programmgruppe soll heruntergeladen werden

  IF p_single = &apos;X&apos;.  &quot;Einzelne Objekte

*   Ist eine der Einzelselektion gefüllt
    IF NOT o_sireps IS INITIAL OR
       NOT o_sitabl IS INITIAL OR
       NOT o_sifunc IS INITIAL OR
       NOT o_sittyp IS INITIAL OR
       NOT o_sitypd IS INITIAL OR
       NOT o_sidtel IS INITIAL OR
       NOT o_sidoma IS INITIAL OR
       NOT o_sienqu IS INITIAL OR
       NOT o_sisuso IS INITIAL OR
       NOT o_sitran IS INITIAL OR
       NOT o_srchep IS INITIAL OR
       NOT o_enhspt IS INITIAL OR
       NOT o_webd   IS INITIAL OR
       NOT o_badi IS INITIAL.

      g_single_limu = &apos;X&apos;.

    ENDIF.

*   Ueberpruefen, ob ueberhaupt eine Selektion vorgenommen worden
    IF ( o_prog IS INITIAL AND o_fkgrp IS INITIAL AND o_class IS INITIAL
              AND o_intf IS INITIAL AND o_idoc IS INITIAL
              AND o_cmod IS INITIAL AND o_badis IS INITIAL
              AND o_inc IS INITIAL AND o_func IS INITIAL
              AND o_dynp IS INITIAL AND o_tcode IS INITIAL

              AND o_iacs IS INITIAL AND g_single_limu IS INITIAL ).
      IF ( p_logic IS INITIAL ).
        MESSAGE i888(sabapdocu) WITH
        &apos;Please make a Selection!&apos;.
      ELSE.
        MESSAGE i888(sabapdocu) WITH
         &apos;Please choose Objects&apos;
         &apos;to your logical Development&apos;.
      ENDIF. &quot;Logische Entwicklung
*   Selektionen durchfuehren
    ELSE.

*     Ueberpruefen, ob logische Entwicklungsselektion vorliegt
      IF NOT ( p_logic IS INITIAL ).
        PERFORM prepare_for_logical_dev.
      ENDIF.
*     Reports/Modulpoole
      IF  NOT ( o_prog IS INITIAL ).
        lcl_root = dir.
        PERFORM reps_mods.
        dir = lcl_root.
      ENDIF.

*     Transaktionscodes verarbeiten
      IF NOT ( o_tcode IS INITIAL ).
        lcl_root = dir.
        PERFORM tacode.
        dir = lcl_root.
      ENDIF.

*     Funktionsgruppen
      IF  NOT ( o_fkgrp IS INITIAL ).
        lcl_root = dir.
        PERFORM function_group.
        dir = lcl_root.
      ENDIF.

*     OO-Klasse
      IF  NOT ( o_class IS INITIAL ).
        lcl_root = dir.
        PERFORM classes.
        dir = lcl_root.
      ENDIF.

*     OO-Interfaces
      IF  NOT ( o_intf IS INITIAL ).
        lcl_root = dir.
        PERFORM interfaces.
        dir = lcl_root.
      ENDIF.


*     IDOC (Baistypen und Erweiterungen
      IF  NOT ( o_idoc IS INITIAL ).
        lcl_root = dir.
        PERFORM idocs.
        dir = lcl_root.
      ENDIF.

*     Kundenerweiterungen CMOD
      IF  NOT ( o_cmod IS INITIAL ).
        lcl_root = dir.
        PERFORM customerenhancements.
        dir = lcl_root.
      ENDIF.

*     Kundenerweiterungen BADI
      IF  NOT ( o_badis IS INITIAL ).
        lcl_root = dir.
        PERFORM badi_implementation.
        dir = lcl_root.
      ENDIF.

*     IAC-Service(ITS)
      IF  NOT ( o_iacs IS INITIAL ).
        lcl_root = dir.
        PERFORM iac_service.
        dir = lcl_root.
      ENDIF.

*     Auswahl der Modifikationen bearbeiten; pruefung auf initial der
*     Selektionsvariablen ist in Routine eingebaut
      lcl_root = dir.
      PERFORM handle_modis.
      dir = lcl_root.

*     Bearbeitung von Einzelobjketen
      IF NOT g_single_limu IS INITIAL.
        lcl_root = dir.
        PERFORM handle_single_limu.
        dir = lcl_root.
      ENDIF.

*Aufbereitung und Verarbeitung der Daten fuer Download der Stueckliste
*     der logischen Entwicklung
      REFRESH it_prog_stueckliste.
      APPEND LINES OF it_log_stueckliste TO it_prog_stueckliste.
*     globale Variablen entsprechend anpassen
      global_main_name = p_logic.
      new_dir = dir.

*     Nur Verarbeitung, wenn  etwas archiviert worden ist
      IF NOT ( it_protocol IS  INITIAL ).
*       Trennung von Einzeldateiobjekten
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM download_stueckliste.
*       Download System information
        IF NOT p_logic IS INITIAL.
          PERFORM download_hpstand.
        ENDIF.
*       Leerzeile nach Ende dieser Verarbeitung
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
      ENDIF. &quot;Etwas Archiviert?

    ENDIF.  &quot;Sind Selektionen Einzelvarbeitung vorgenommen worden

  ELSEIF p_devc =&apos;X&apos;.
    lcl_root = dir.
    IF o_devcl IS INITIAL.
      MESSAGE i888(sabapdocu) WITH
      &apos;Please make a Selection!&apos;
      &apos;You have to enter a Developmentclass!&apos;.
    ELSE.
      PERFORM developmentclass.
    ENDIF.
    dir = lcl_root.

  ELSEIF p_trkorr = &apos;X&apos;.
    lcl_root = dir.
    IF o_trkorr IS INITIAL.
      MESSAGE i888(sabapdocu) WITH
      &apos;Please make a Selection!&apos;
      &apos;You have to enter a Transport Request!&apos;.
    ELSE.
      PERFORM transportrequest.
    ENDIF.
    dir = lcl_root.

  ENDIF.

ENDFORM.                    &quot; SELECTION

*&amp;---------------------------------------------------------------------*
*&amp;      Form  FUNCTION_GROUP
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Funtkionsgruppen aus dem
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Fuer jede gefundene Funktionsgruppe wird die entsprechende
*      Aufrufroutine ausgeführt.
*----------------------------------------------------------------------*
FORM function_group.
*Variable zum  Zusammenbauen des trdir-Names der  Funktiongruppe
  DATA: lcl_fktgrp LIKE wa_trdir-name.
*Bereich fuer Tabelle mit Funktionsgruppennamen
  DATA: lcl_it_tlibg TYPE STANDARD TABLE OF tlibg,
        lcl_wa_tlibg LIKE LINE OF lcl_it_tlibg.

*Lesen der Selektion
  SELECT * FROM tlibg INTO TABLE  lcl_it_tlibg
          WHERE area IN o_fkgrp.

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_tlibg IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for Functiongroups! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.



**********Ausfuehren des Programmdownloads
*** Ausführung für jede Funktionsgruppe
  LOOP AT lcl_it_tlibg INTO lcl_wa_tlibg.


*SAPL-Name des Funktionsbausteins zusammenbauen
*Unterscheidung auf Partnernamensraum.
    IF lcl_wa_tlibg-area(1) = &apos;/&apos;.
      lcl_fktgrp = lcl_wa_tlibg-area.
      PERFORM convert_fugrname_for_partner
           CHANGING lcl_fktgrp.
    ELSE. &quot;normaler namensraum
      CONCATENATE &apos;SAPL&apos; lcl_wa_tlibg-area INTO  lcl_fktgrp.
    ENDIF.

*build global name
    global_main_name = lcl_wa_tlibg-area.

*Liste mit Ober-Objekten bei Einzelselektion fuellen
    MOVE lcl_fktgrp TO wa_obj_list-name.
    APPEND wa_obj_list TO it_obj_list.

*Verarbeitungsroutine aufrufen
    PERFORM handle_functiongroup USING lcl_fktgrp.

*Stueckliste fuer logische Entwicklung
    IF NOT ( p_logic IS INITIAL ).
      PERFORM write_log_stueckliste USING   &apos;Functiongroup&apos;
                                            lcl_wa_tlibg-area
                                            p_logic.

    ENDIF.

  ENDLOOP.
ENDFORM.                    &quot; FUNCTION_GROUP

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CLASSES
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Klassen aus dem
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Fuer jede gefundene Klasse wird die entsprechende
*      Aufrufroutine ausgeführt
*----------------------------------------------------------------------*
FORM classes.
*Bereiche fuer seoclass
  DATA: lcl_it_seoclass TYPE STANDARD TABLE OF seoclass,
        lcl_wa_seoclass LIKE LINE OF lcl_it_seoclass.

*Selektieren der Programme nach Selekt-Options
  SELECT * FROM seoclass INTO TABLE lcl_it_seoclass
          WHERE clsname IN o_class
          AND   clstype = 0.

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_seoclass IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for Classes! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.


*Schleife ueber select-options
  LOOP AT lcl_it_seoclass INTO lcl_wa_seoclass.

*Liste mit Ober-Objekten bei Einzelselektion fuellen
    MOVE lcl_wa_seoclass-clsname TO wa_obj_list-name.
    APPEND wa_obj_list TO it_obj_list.

*Intitialisieren der globalen Tabellen
    PERFORM initialize.
*    PERFORM handle_class USING lcl_wa_seoclass-clsname.
    PERFORM handle_class_extern  USING lcl_wa_seoclass-clsname.
*Stueckliste fuer logische Entwicklung
    IF NOT ( p_logic IS INITIAL ).
      PERFORM write_log_stueckliste USING   &apos;Class(OO)&apos;
                                            lcl_wa_seoclass-clsname
                                            p_logic.

    ENDIF.

  ENDLOOP. &quot;Klassenliste

ENDFORM.                    &quot; CLASSES

*&amp;---------------------------------------------------------------------*
*&amp;      Form  WRITE_COLLECTMAINS
*&amp;---------------------------------------------------------------------*
*       Schreiben der Liste der später zu behadlenden Rahmenprogramme.
*       Der Typ des Rahmenprogrammes und der Programmname werden
*       beruecksichtigt.
*----------------------------------------------------------------------*
FORM write_collectmains USING    p_typus TYPE collectmains-typus
                                 p_name TYPE collectmains-mainname.

  CLEAR wa_collectmains.
  wa_collectmains-typus = p_typus.
  wa_collectmains-mainname = p_name.
  APPEND wa_collectmains TO it_collectmains.
ENDFORM.                    &quot; WRITE_COLLECTMAINS


*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_DIALOGMODULE
*&amp;---------------------------------------------------------------------*
*      Lesen der Informationen fuer das in der Uebergabestruktur
*      angegebene Dialogmodul.
*      Das zugehörige Programm wird in Tabelle fuer spaeteren Aufruf
*      der Rahmenprogramme gestellt.
*----------------------------------------------------------------------*
FORM handle_dialogmodule USING    p_wa_cross_ref TYPE cross.
*Lokalen Arbeitsbereich fuer Dialogbausteinelement
*Zuordnung der Parameter zum Modulpool
  DATA: lcl_wa_tdct LIKE wa_tdct,
        lcl_it_diapar LIKE it_diapar,
        lcl_wa_diapar LIKE wa_diapar.

*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.


*Dialogbausteinverwaltung selektieren
  SELECT SINGLE dnam prog  dynr FROM tdct INTO lcl_wa_tdct
          WHERE dnam = p_wa_cross_ref-name.
*An Gesamttabelle anhaengen
  APPEND lcl_wa_tdct TO it_tdct.

*Parameter der Dialogbausteine selektieren
  SELECT * FROM diapar INTO TABLE lcl_it_diapar
        WHERE dnam = lcl_wa_tdct-dnam
          AND spras IN o_lan.
*An Gesamttabelle der Parameter anhaengen
  LOOP AT lcl_it_diapar INTO lcl_wa_diapar.
    APPEND lcl_wa_diapar TO it_diapar.
  ENDLOOP.

*Stueckliste fuer Dialogmodul bauen
  PERFORM write_stueckliste USING &apos;Dialogmodule&apos;
                               p_wa_cross_ref-name
                               p_wa_cross_ref-include.

*Zuordnung Modulpool zu Dialogmodul
  PERFORM write_stueckliste USING &apos;Dialog Program&apos;
                               lcl_wa_tdct-prog
                               p_wa_cross_ref-name.

**********************************
*Herunterladen des Modulpools, wenn er im
*Kundennamensraum liegt.
  IF ( ( lcl_wa_tdct-prog(1) = &apos;Z&apos; ) OR ( lcl_wa_tdct-prog(1) = &apos;Y&apos; ) ).

    IF g_nodep IS INITIAL.
*     Tabelle zur späteren Weiterverarbeitung
      PERFORM write_global_save USING &apos;1&apos; lcl_wa_tdct-prog.
    ENDIF.

  ENDIF. &quot;Liegt Modulpool im Kundennamensraum?
ENDFORM.                    &quot; HANDLE_DIALOGMODULE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_DIALOGMODULE_ELEMENTS
*&amp;---------------------------------------------------------------------*
*       Globale Gesamttabellen (Zuordnung und Parameter)  ins
*       Dateissystem speichern.
*       Generierung der Tabellen in HTML-Format
*----------------------------------------------------------------------*
FORM download_dialogmodule_elements.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Dialogbausteinzuordnung
  DATA: lcl_dialogmodule_name TYPE string.
*Parameterzuordnung zu Dialogbaustein
  DATA: lcl_dialogmudule_params TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

***************************************************
*1.)Dialogbausteinzuordnung: it_tdct
***************************************************
*Nur downloaden, wenn nicht leer
  IF NOT ( it_tdct IS INITIAL ).

*    Ueberschrift zusammenbauen
    CONCATENATE &apos;Dialog Modules called by Program&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*    Headertabelle zusammenbauen
    APPEND &apos;Name of Dialog Module&apos; TO lcl_it_headerrow.
    APPEND &apos;Program name&apos; TO lcl_it_headerrow.
    APPEND &apos;Screen number&apos; TO lcl_it_headerrow.


*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_tdct INTO wa_tdct.
      PERFORM create_htmltab_body USING wa_tdct.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************

    CONCATENATE &apos;Dlgmd_to_Modpool_&apos; global_main_name INTO
                    lcl_dialogmodule_name.
    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_dialogmodule_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tdct
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text043 lcl_dialogmodule_name
          filename.
    ELSE.
      PERFORM write_protocol USING &apos;N&apos;  text043 lcl_dialogmodule_name
          filename.

    ENDIF. &quot;sy-subrc
  ENDIF. &quot;Ueberpruefung auf initial


***************************************************
*2.)Parameter der Dialogbausteine: it_diapar
***************************************************
*Nur downloaden, wenn nicht leer
  IF NOT ( it_diapar IS INITIAL ).

    CLEAR lcl_header. REFRESH lcl_it_headerrow.
*    Ueberschrift zusammenbauen
    CONCATENATE &apos;Parameters of Dialog Modules&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*    Headertabelle zusammenbauen
    APPEND &apos;Name of Dialog Module&apos; TO lcl_it_headerrow.
    APPEND &apos;Name of Parameter&apos; TO lcl_it_headerrow.
    APPEND &apos;Language&apos; TO lcl_it_headerrow.
    APPEND &apos;Table or Structur (T=Table)&apos; TO lcl_it_headerrow.
    APPEND &apos;Type of Parameter&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Text Dialog Module&apos; TO lcl_it_headerrow.
    APPEND &apos;Import(=I)/Export(=E)&apos; TO lcl_it_headerrow.
    APPEND &apos;Default Value&apos; TO lcl_it_headerrow.

*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_diapar INTO wa_diapar.
      PERFORM create_htmltab_body USING wa_diapar.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************


    CONCATENATE &apos;Dlgmd_Params_&apos; global_main_name INTO
                    lcl_dialogmudule_params.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_dialogmudule_params &apos;.xml&apos; INTO filename
    .

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_diapar
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text044
        lcl_dialogmudule_params filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text044
        lcl_dialogmudule_params filename.

    ENDIF. &quot;sy-subrc
  ENDIF. &quot;Ueberpruefung auf initial

ENDFORM.                    &quot; DOWNLOAD_DIALOGMODULE_ELEMENTS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_HPSTAND
*&amp;---------------------------------------------------------------------*
*       Lesen des Hotpackagestandes des Systems und
*       Speicherung der Tabelle im Dateisystem.
*       Generierung der Tabelle in HTML-Format
*----------------------------------------------------------------------*
FORM download_hpstand.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Datenbereiche fuer Hotpackagetabelle
  DATA: lcl_it_pat03 TYPE STANDARD TABLE OF pat03,
        lcl_wa_pat03 LIKE LINE OF lcl_it_pat03,
        lv_old_patch LIKE pat03-patch.
*Bezeichnung der Downloaddatei
  DATA: lcl_downnname TYPE string.
*Typ der nur die wichtigen Infos ueber HP-Stand enthält
  TYPES: BEGIN OF ipat03,
            patch TYPE pat03-patch,
            short_text TYPE pat03-short_text,
            l_impl_rel TYPE pat03-l_impl_rel,
            os TYPE pat03-os,
            db TYPE pat03-db,
            ancestor TYPE pat03-ancestor,
         END OF ipat03.
*Filterbereich fuer HP-Informationen
  DATA: lcl_wa_ipat03 TYPE ipat03.

*Variable fuer Kopfzeile der zu generierenden HTML-Tabelle
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

*Selektieren der Hotpackagetabelle nach dem aktuellen System
*Funktionsbaustein liest standardmäßig alle Komponenten des aktuellen
*Releases.
  CALL FUNCTION &apos;SPAM_READ_PAT03&apos;
      EXPORTING
           iv_patch_name              = &apos;*&apos;
           iv_patch_type              = &apos;*&apos;
           iv_base_release            = &apos;CURR&apos;
           iv_component_id            = &apos;CURR&apos;
           iv_component_release       = &apos;CURR&apos;
           iv_addon_id                = &apos;CURR&apos;
           iv_addon_release           = &apos;CURR&apos;
           iv_activ                   = &apos;X&apos;
           iv_only_supp_packs         = &apos;X&apos;
*    IMPORTING
*         EV_PAT03_ENTRIES           =
      TABLES
           tt_pat03_selected          = lcl_it_pat03
      EXCEPTIONS
           wrong_release_string       = 1
           wrong_patch_type           = 2
           no_component_available     = 3
           wrong_component_id_release = 4
           wrong_addon_id_release     = 5
           OTHERS                     = 6
            .
  IF sy-subrc = 0.

*    sort the table
    SORT lcl_it_pat03 BY patch DESCENDING.

*    only keep the newest CRT from one type in mind
    LOOP AT lcl_it_pat03 INTO lcl_wa_pat03.

      IF lcl_wa_pat03(5) NE lv_old_patch(5).
*       remember the current patch
        lv_old_patch = lcl_wa_pat03-patch.
        CONTINUE.
      ENDIF.

      DELETE lcl_it_pat03 INDEX sy-tabix.

*    remember the current patch
      lv_old_patch = lcl_wa_pat03-patch.

    ENDLOOP.


*Download starten: in der Tabelle sind auf jeden Fall Eintraege.
    CONCATENATE &apos;Information about system&apos; sy-sysid
           INTO lcl_header SEPARATED BY space.
*    Headertabelle zusammenbauen
    APPEND &apos;Support Package Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Patch Description&apos; TO lcl_it_headerrow.
    APPEND &apos;Release&apos; TO lcl_it_headerrow.
    APPEND &apos;OS Application Server&apos; TO lcl_it_headerrow.
    APPEND &apos;Name of central Database&apos; TO lcl_it_headerrow.
    APPEND &apos;Patch Predecessor&apos; TO lcl_it_headerrow.

*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT lcl_it_pat03  INTO lcl_wa_pat03.
      MOVE-CORRESPONDING lcl_wa_pat03 TO lcl_wa_ipat03.
      PERFORM create_htmltab_body USING lcl_wa_ipat03.
    ENDLOOP.

    APPEND &apos;&lt;/Tabelle&gt;&apos; TO it_html.

    APPEND &apos;&lt;Tabelle&gt;&apos; TO it_html.

    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; &apos;Date of Download:&apos; &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; sy-datum &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.

    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; &apos;Time of Download:&apos; &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; sy-uzeit &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.

    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; &apos;Number of Installation:&apos; &apos;&lt;/value&gt;&apos; INTO
    wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; instnr &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.

    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; &apos;System ID:&apos; &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; sy-sysid &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.

    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; &apos;Download User:&apos; &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; sy-uname &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.


    PERFORM create_html_tab_foot.
*    ********************************************************

    CONCATENATE &apos;Systeminfo_&apos; instnr INTO lcl_downnname.
    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_downnname &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;lcl_it_pat03
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text045 lcl_downnname
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text045 lcl_downnname
          filename.

    ENDIF. &quot;sy-subrc

  ENDIF.

ENDFORM.                    &quot; DOWNLOAD_HPSTAND

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_LOCKOBJECT
*&amp;---------------------------------------------------------------------*
*    Lesen und Sichern des in der Struktur P_WA_CROSS_REF uebergebenen
*    Sperrobjektes bzw. Sperrfunktionsbausteins.
*    Durch den Parameter P_TYPUS wird unterschieden, ob
*    Funktionsbaustein uebergeben worden  ist oder der Name des
*    Lockobjektes.
*    Generierung der Tabelle in HTML-Format
*
*----------------------------------------------------------------------*
FORM handle_lockobject USING    p_wa_cross_ref TYPE cross
                                p_typus TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Datenbereiche zum Lesen der Tabelle mit den Eintraegen der Sperrobjekte
*(dd27s)
  DATA: lcl_it_dd27s TYPE STANDARD TABLE OF dd27s,
        lcl_wa_dd27s LIKE LINE OF lcl_it_dd27s.
  TYPES: BEGIN OF locktab,
            lock_obj TYPE dd27s-viewname,
            tab TYPE dd27s-tabname,
            field TYPE dd27s-fieldname,
            keyflag TYPE dd27s-keyflag,
            modname(30) TYPE c,
         END OF locktab.
  DATA: lcl_it_locktab TYPE STANDARD TABLE OF locktab,
        lcl_wa_locktab LIKE LINE OF lcl_it_locktab.
*Hilfsvariablen zur Laengenberechnung des Includenamens
  DATA: lcl_laenge TYPE i.
*Hilfsvariable fuer Namen des Lockobjektes
  DATA: lcl_lockobj TYPE dd27s-viewname.
*Lockobjektname fuer Download
  DATA: lcl_locktab_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.



*Bestimmung des Namens des Lockobjektes
  IF p_typus = &apos;F&apos;. &quot;Aufruf ueber Funktionsbausteinname
    lcl_laenge = STRLEN( p_wa_cross_ref-name ).
    lcl_lockobj = p_wa_cross_ref-name+8.
  ELSEIF p_typus = &apos;S&apos;. &quot;Aufruf ueber Sperrobjektname
    lcl_lockobj = p_wa_cross_ref-name.
  ENDIF.

*Nur downloaden wenn noch nicht gedownloaded, da in Stückliste.
  READ TABLE it_prog_stueckliste WITH KEY name = lcl_lockobj
            TRANSPORTING NO FIELDS.
  IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden

*Selektieren der Tabelle mit den Sperrobjekteintraegen
    SELECT * FROM dd27s INTO CORRESPONDING FIELDS OF TABLE lcl_it_dd27s
            WHERE viewname = lcl_lockobj.

*Die entsprechenden Eintraege in die herunterzuladende Tabelle schreiben
*und den Eintrag fuer die Lockart durch einen aussagefähigen Eintrag
*ersezten.
    LOOP AT lcl_it_dd27s INTO lcl_wa_dd27s.
      MOVE lcl_wa_dd27s-viewname TO lcl_wa_locktab-lock_obj.
      MOVE lcl_wa_dd27s-tabname TO lcl_wa_locktab-tab.
      MOVE lcl_wa_dd27s-fieldname TO lcl_wa_locktab-field.
      MOVE lcl_wa_dd27s-keyflag TO lcl_wa_locktab-keyflag.
      IF lcl_wa_dd27s-enqmode = &apos;E&apos;.
        lcl_wa_locktab-modname = &apos;Exclusive, cumulative&apos;.
      ELSEIF lcl_wa_dd27s-enqmode = &apos;S&apos;.
        lcl_wa_locktab-modname = &apos;Shared&apos;.
      ELSEIF lcl_wa_dd27s-enqmode = &apos;X&apos;.
        lcl_wa_locktab-modname = &apos;Exclusive, not  cumulative&apos;.
      ENDIF.
      APPEND lcl_wa_locktab TO lcl_it_locktab.
    ENDLOOP.


***********************************************************
*****Tabelle mit Lockobjektinformationen downloaden
***********************************************************
*Ueberpruefen, ob Tabelle nicht leer ist
    IF NOT ( lcl_it_locktab IS INITIAL ).

*Ueberschrift zusammenbauen
      CONCATENATE &apos;Lockobjectinformation&apos;  lcl_lockobj
            INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
      APPEND &apos;Name of View&apos; TO lcl_it_headerrow.
      APPEND &apos;Basistable of the View&apos; TO lcl_it_headerrow.
      APPEND &apos;Fieldname&apos; TO lcl_it_headerrow.
      APPEND &apos;Keyflag&apos; TO lcl_it_headerrow.
      APPEND &apos;Locktype&apos; TO lcl_it_headerrow.



*Umwandlung in HTML-Tabelle
********************************************************
      PERFORM create_htmltab_header  USING lcl_it_headerrow
                                           lcl_header.

      LOOP AT lcl_it_locktab INTO lcl_wa_locktab.
        PERFORM create_htmltab_body USING lcl_wa_locktab.
      ENDLOOP.

      PERFORM create_html_tab_foot.
*********************************************************


*Schreiben der Stueckliste
      IF p_typus = &apos;F&apos;. &quot;Funktionsbausteinname
        PERFORM write_stueckliste USING &apos;Lockobject&apos;
                                        lcl_lockobj
                                        p_wa_cross_ref-include.
      ELSEIF p_typus = &apos;S&apos;.  &quot;Sperrobjektname
        PERFORM write_stueckliste USING &apos;Lockobject&apos;
                                        lcl_lockobj
                                        global_main_name.
      ENDIF. &quot;Typabfrage


*Name fuer Download zusammenbauen
      CONCATENATE &apos;Lockobject_&apos; lcl_lockobj INTO lcl_locktab_name.

      CLEAR filename.
      CONCATENATE new_dir &apos;\&apos; lcl_locktab_name &apos;.xml&apos; INTO filename.

*     begin of changes for partner namespace
      TRANSLATE filename USING &apos;/_&apos;.
*     end of changes for partner namespace
      PERFORM call_ws_download USING    filename
                                        it_html  &quot;lcl_it_locktab
                               CHANGING lcl_subrc.
      IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;E&apos;  text046 lcl_locktab_name
          filename.
      ELSE.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;N&apos;  text046 lcl_locktab_name
          filename.

      ENDIF. &quot;sy-subrc
    ENDIF. &quot;ist Tabelle gefuellt

  ENDIF. &quot;Abpruefung der Stueckliste

ENDFORM.                    &quot; HANDLE_LOCKOBJECT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_SETGETPARAMSS
*&amp;---------------------------------------------------------------------*
*       Lesen der Set/Get-Paramter-Liste des in der Struktur
*       uebergebenen Parameters. Anhaengen an Gesamtliste der
*       Set/Get-Parameter.
*----------------------------------------------------------------------*
FORM handle_setgetparamss USING    p_wa_cross_ref TYPE cross.
  CLEAR wa_tpara.
*Nur Verarbeitung wenn noch nicht in interner Parametertabelle enthalten
  READ TABLE it_tpara WITH KEY paramid = p_wa_cross_ref-name
          TRANSPORTING NO FIELDS.
  IF sy-subrc &lt;&gt; 0. &quot;Kein Wert gefunden
*Selektion aus Parametertabelle
    SELECT SINGLE * FROM tpara INTO wa_tpara
      WHERE paramid = p_wa_cross_ref-name.
    APPEND wa_tpara TO it_tpara.
  ENDIF.

*Stueckliste aus Informationsgruenden auf jeden Fall schreiben
  PERFORM write_stueckliste USING &apos;SET/Get-Parameter&apos;
                                  p_wa_cross_ref-name
                                  p_wa_cross_ref-include.
ENDFORM.                    &quot; HANDLE_SETGETPARAMSS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_SETGETPARAMS
*&amp;---------------------------------------------------------------------*
*      Sicherung der Gesamtliste der Set/Get-Parameter in das lokale
*      Dateisystem.
*      Generierung der Tabelle in HTML-Format.
*----------------------------------------------------------------------*
FORM download_setgetparams.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Name set/get-Parameter
  DATA: lcl_sgparams_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur downloaden, wenn nicht leer
  IF NOT ( it_tpara IS INITIAL ).
*  Ueberschrift zusammenbauen
    CONCATENATE &apos;Set/Get-Parameterlist of &apos;  global_main_name
          INTO lcl_header SEPARATED BY space.

*  Headertabelle zusammenbauen
    APPEND &apos;Set-/Get-Paramter-ID&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Description&apos; TO lcl_it_headerrow.

*Umwandlung in HTML-Tabelle
********************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_tpara INTO wa_tpara.
      PERFORM create_htmltab_body USING wa_tpara.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************

    CONCATENATE &apos;Set_Get_Params_&apos; global_main_name INTO
    lcl_sgparams_name.
* begin of changes for partner namespace
    TRANSLATE lcl_sgparams_name USING &apos;/_&apos;.
* end of changes for partner namespace    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_sgparams_name &apos;.xml&apos; INTO filename.

*Tabelle nach Obernamen sortieren
*  sort it_prog_stueckliste by obername ascending.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tpara
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text047 lcl_sgparams_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text047 lcl_sgparams_name
          filename.

    ENDIF.

  ENDIF. &quot;Tabelle it_params leer ???

ENDFORM.                    &quot; DOWNLOAD_SETGETPARAMS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  IDOCS
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten IDocs aus dem
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Fuer jedes gefundene IDOC wird die entsprechende
*      Aufrufroutine ausgeführt. Je nach Typ des IDOCs (Basis oder
*      Erweiterng) wird ein die Verarbeitungsrroutine mit einem paramter
*      aufgerufen.
*----------------------------------------------------------------------*
FORM idocs.
*Bereiche fuer Basisidoc-Tabelle
  DATA: lcl_it_edbas TYPE STANDARD TABLE OF edbas,
        lcl_wa_edbas LIKE LINE OF lcl_it_edbas.

*Bereiche fuer IDOc-Erweiterungen
  DATA: lcl_it_edcim TYPE STANDARD TABLE OF edcim,
        lcl_wa_edcim LIKE LINE OF lcl_it_edcim.


*Selektion je nach Art der Selektion
  IF p_basis = &apos;X&apos;. &quot;Basisobjekt

    SELECT * FROM edbas INTO TABLE lcl_it_edbas
        WHERE idoctyp IN o_idoc.

*Verlassen,wenn keine Werte gefunden worden sind
    IF lcl_it_edbas IS INITIAL.
      MESSAGE i888(sabapdocu) WITH
     &apos;No suitable selection&apos; &apos;for IDoc Basistype! &apos;
     &apos;Please check your selection. &apos;
     &apos;The program will process your other selections.&apos;.

*      Form-Routine verlassen
      EXIT.
    ENDIF.



    LOOP AT lcl_it_edbas INTO lcl_wa_edbas.

      PERFORM handle_idoc USING lcl_wa_edbas-idoctyp
                                &apos;B&apos;.

*Stueckliste fuer logische Entwicklung
      IF NOT ( p_logic IS INITIAL ).
        PERFORM write_log_stueckliste USING   &apos;IDOC-Basistype&apos;
                                              lcl_wa_edbas-idoctyp
                                              p_logic.

      ENDIF.


    ENDLOOP.

  ELSEIF p_enh = &apos;X&apos;.

    SELECT * FROM edcim INTO TABLE lcl_it_edcim
          WHERE cimtyp IN o_idoc.

*Verlassen,wenn keine Werte gefunden worden sind
    IF lcl_it_edcim IS INITIAL.
      MESSAGE i888(sabapdocu) WITH
     &apos;No suitable selection&apos; &apos;for IDoc-Enhancement!  &apos;
     &apos;Please check your selection. &apos;
     &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
      EXIT.
    ENDIF.

    LOOP AT lcl_it_edcim INTO lcl_wa_edcim.

      PERFORM handle_idoc USING lcl_wa_edcim-cimtyp
                                 &apos;E&apos;.

*  Stueckliste fuer logische Entwicklung
      IF NOT  ( p_logic IS INITIAL ).
        PERFORM write_log_stueckliste USING   &apos;IDOC-Enhancement&apos;
                                              lcl_wa_edcim-cimtyp
                                              p_logic.

      ENDIF.
    ENDLOOP.

  ENDIF.

ENDFORM.                    &quot; IDOCS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_HTML_GENERATOR
*&amp;---------------------------------------------------------------------*
*     Formular zum Herunterladen der IDOCs
*     Diese Logik ist zum Teil aus der Transaktion WE60 uebernommen
*----------------------------------------------------------------------*
*                       STRUCT_TYPE type LEDID_STRUCT_TYPE
*                       IDOCTYPE type EDI_IAPI00-IDOCTYP
*                       RELEASE like sy-saprl
*                       VERSION type EDI_VERREC-VERSION
*----------------------------------------------------------------------*
FORM handle_html_generator USING    p_struct_type TYPE ledid_struct_type
                                    p_idoctype TYPE edi_iapi00-idoctyp
                                    p_release LIKE sy-saprl
                                    p_version TYPE edi_verrec-version.

****Kopiertes Coding aus Funktionsbaustein IDOC_TYPE_GENERATE_HTML
  DATA : idoc_struct       TYPE ledid_t_idoc_struct,
         idoc_type         TYPE ledid_idoc_type,
         segments          TYPE ledid_t_segment,
         segment_struct    TYPE ledid_t_segment_struct,
         l_returncode      LIKE sy-subrc,
*         l_path            LIKE rlgrap-filename,
         l_path            TYPE string,
*         l_file            LIKE rlgrap-filename,
         l_file            TYPE char70,
         l_url(1024)       TYPE c,
         l_browser_start   LIKE edi_htmfil-edi_start.

  DATA: frameset LIKE line OCCURS 0,
        index    LIKE line OCCURS 0,
        docu     LIKE line OCCURS 0.

*Lesen der IDOC-Struktur
  CALL FUNCTION &apos;IDOC_TYPE_COMPLETE_READ&apos;
    EXPORTING
      struct_type    = p_struct_type
      idoctype       = p_idoctype
      release        = p_release
      version        = p_version
    IMPORTING
      idoc_type      = idoc_type
    TABLES
      idoc_struct    = idoc_struct
      segments       = segments
      segment_struct = segment_struct
    EXCEPTIONS
      OTHERS         = 1.
  CASE sy-subrc.
    WHEN 0.

*Zusammensetzen des Pfadnamens
      CONCATENATE new_dir &apos;\&apos; INTO l_path.

*Grundtext fuer Filenamen
      l_file = p_idoctype.

*Generierung des HTML-Files
      CALL FUNCTION &apos;IDOC_TAB_GENERATE_HTML&apos;
        EXPORTING
          idoc_type         = idoc_type
          release           = p_release
          version           = p_version
        TABLES
          idoc_struct       = idoc_struct
          segments          = segments
          segment_structure = segment_struct
          text_frameset     = frameset
          text_index        = index
          text_docu         = docu
        CHANGING
          file              = l_file
        EXCEPTIONS
          internal_error    = 1
          OTHERS            = 2.
      IF sy-subrc EQ 0.
* download html-coding to the file system
        PERFORM html_download_files  TABLES frameset
                                            index
                                            docu
                                     USING  l_file
                                            l_path.

      ELSE.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;E&apos;  text048 l_file &apos;file&apos;.
      ENDIF.
    WHEN OTHERS.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text048 l_file &apos;file&apos;.
  ENDCASE.

ENDFORM.                    &quot; HANDLE_HTML_GENERATOR

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HTML_DOWNLOAD_FILES
*&amp;---------------------------------------------------------------------*
*      Abgeaenderte Form zum Herunterladen der IDOC Strukt7ur
*      (Ursprung Funktionsgruppe EDID)
*----------------------------------------------------------------------*
FORM html_download_files TABLES frameset STRUCTURE line
                                index    STRUCTURE line
                                docu     STRUCTURE line
                         USING
                             p_file TYPE char70
                             p_path TYPE string.  &quot;LIKE rlgrap-filename.

*  DATA: file_ext LIKE rlgrap-filename,
  DATA: file_ext TYPE string,
        l_rcode  LIKE sy-subrc.


  CLEAR file_ext.
  CONCATENATE p_file &apos;_d&apos; &apos;.htm&apos; INTO file_ext.
  PERFORM download_htmltable TABLES docu
                               USING   file_ext
                                       space
                                       p_path.

ENDFORM.                    &quot; HTML_DOWNLOAD_FILES

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_HTMLTABLE
*&amp;---------------------------------------------------------------------*
*      Abgeaenderte Form zum Herunterladen der IDOC-Struktur
*      (Ursprung Funktionsgruppe EDID)
*----------------------------------------------------------------------*
FORM download_htmltable  TABLES t_text STRUCTURE line
                         USING p_file TYPE string &quot;LIKE rlgrap-filename
                         p_with_check TYPE c
                         p_path TYPE string. &quot;LIKE rlgrap-filename.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Lokale Variable fuer Filename
*  DATA: lcl_complete_filename TYPE rlgrap-filename.
  DATA: lcl_complete_filename TYPE string.

*Zusammensetzen des Dateinamens
  CONCATENATE p_path p_file INTO lcl_complete_filename.

* begin of changes for partner namespace
  TRANSLATE lcl_complete_filename USING &apos;/_&apos;.
* end of changes for partner namespace
  PERFORM call_ws_download USING    lcl_complete_filename
                                    t_text[]
                           CHANGING lcl_subrc.

  IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;E&apos;  text048 p_file
      lcl_complete_filename.
  ELSE.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;N&apos;  text048 p_file
      lcl_complete_filename.

  ENDIF.

ENDFORM.                    &quot; DOWNLOAD_HTMLTABLE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_HTMLTAB
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      Generische Erstellung des Kopfes einer Seite mit HTML-Tabelle mit
*      Hilfe der Uebergabeparameter. P_HEADER enthaelt die Ueberschrift.
*      P_HEADERROW enthaelt die Uebeschriften der Tabelle.
*----------------------------------------------------------------------*
FORM create_htmltab_header USING  p_headerrow TYPE ANY TABLE
                                  p_header TYPE string.
*Arbeitsbereich fuer die uebergebene Tabellen
  DATA: lcl_wa_headerrow TYPE string.

*Initialsieren der Html-Tabelle, da sie von allen Downloadtabellen
*benutzt wird
  REFRESH it_html.

*Schreiben des Tabellenkopfes
*  APPEND &apos;&lt;HTML&gt;&apos; TO it_html.
*  APPEND &apos;&lt;head&gt;&apos; TO it_html.
*  APPEND &apos;&lt;/head&gt;&apos; TO it_html.
*  APPEND &apos;&lt;body&gt;&apos; TO it_html.
  APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;&apos; TO it_html.
  APPEND &apos;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;table.XSL&quot;?&gt;&apos;
      TO it_html.
*    Header-Tag
  APPEND &apos;&lt;Doc&gt;&apos; TO it_html.
  APPEND &apos;&lt;Tabelle&gt;&apos; TO it_html.
  CONCATENATE &apos;&lt;header&gt;&apos; p_header &apos;&lt;/header&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.

*    Überschriften der Tabelle
  APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.

  LOOP AT p_headerrow INTO lcl_wa_headerrow.
    CONCATENATE &apos;&lt;value&gt;&apos; lcl_wa_headerrow &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
  ENDLOOP.

  APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.
**Ueberschrift generieren
*  CONCATENATE &apos;&lt;header&gt;&apos; p_header &apos;&lt;/header&gt;&apos; INTO wa_html.
*  APPEND wa_html TO it_html.
**
**  APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.
*
*
**Tabelle mit Ueberschriften generieren
*  APPEND &apos;&lt;table border&gt;&apos;
*          TO it_html.
*  APPEND &apos;&lt;tr&gt;&apos; TO it_html.
*  LOOP AT p_headerrow INTO lcl_wa_headerrow.
*    CONCATENATE &apos;&lt;th&gt;&apos; lcl_wa_headerrow &apos;&lt;/th&gt;&apos; INTO wa_html.
*    APPEND wa_html TO it_html.
*  ENDLOOP.
*  APPEND &apos;&lt;/tr&gt;&apos; TO it_html.

ENDFORM.                    &quot; CREATE_HTMLTAB

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_HTMLTAB_BODY
*&amp;---------------------------------------------------------------------*
*      Generische Erstellung des Rumpfes einer  HTML-Tabelle mit
*      Hilfe des Uebergabeparameters. P_BASETABLE enthaelt die Daten
*      fuer eine Zele der Tabelle.
*----------------------------------------------------------------------*
FORM create_htmltab_body USING    p_basetable TYPE any.
  FIELD-SYMBOLS: &lt;data&gt; TYPE ANY.
*Schreiben der Datenzeilen
  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  DO.
    ASSIGN COMPONENT sy-index OF STRUCTURE p_basetable TO &lt;data&gt;.
*    IF &lt;data&gt; IS INITIAL.
*      ASSIGN &apos;_&apos; TO &lt;data&gt;.
*    ENDIF.
    IF sy-subrc = 0. &quot;Nur durchfuehren wenn nicht an Ende des Feldes
      CONCATENATE &apos;&lt;value&gt;&lt;![CDATA[&apos; &lt;data&gt; &apos;]]&gt;&lt;/value&gt;&apos; INTO wa_html.
      APPEND  wa_html TO it_html.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.
  APPEND &apos;&lt;/item&gt;&apos; TO it_html.

*  APPEND &apos;&lt;tr&gt;&apos; TO it_html.
*  DO.
*    ASSIGN COMPONENT sy-index OF STRUCTURE p_basetable TO &lt;data&gt;.
*    IF &lt;data&gt; IS INITIAL.
*      ASSIGN &apos;&amp;nbsp&apos; TO &lt;data&gt;.
*    ENDIF.
*    IF sy-subrc = 0. &quot;Nur durchfuehren wenn nicht an Ende des Feldes
*      CONCATENATE &apos;&lt;td&gt;&apos; &lt;data&gt; &apos;&lt;/td&gt;&apos; INTO wa_html.
*      APPEND  wa_html TO it_html.
*    ELSE.
*      EXIT.
*    ENDIF.
*  ENDDO.
*  APPEND &apos;&lt;/tr&gt;&apos; TO it_html.
ENDFORM.                    &quot; CREATE_HTMLTAB_BODY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_HTML_TAB_FOOT
*&amp;---------------------------------------------------------------------*
*      Generische Erstellung des Fußes einer Seite mit HTML-Tabelle.
*      P_HEADER enthaelt die Ueberschrift.
*      P_HEADERROW enthaelt die Uebeschriften der Tabelle.
*----------------------------------------------------------------------*
FORM create_html_tab_foot.

  APPEND &apos;&lt;/Tabelle&gt;&apos; TO it_html.
  APPEND &apos;&lt;/Doc&gt;&apos; TO it_html.

*  APPEND &apos;&lt;/table&gt;&apos; TO it_html.
*  APPEND &apos;&lt;/body&gt;&apos; TO it_html.
*  APPEND &apos;&lt;/Html&gt;&apos; TO it_html.
ENDFORM.                    &quot; CREATE_HTML_TAB_FOOT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CUSTOMERENHANCEMENTS
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Erweiterungsprojekte aus dem
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Fuer jedes gefundene Projekt wird die
*      Aufrufroutine fuer die Objekte ausgeführt
*----------------------------------------------------------------------*
FORM customerenhancements.

*Interne Tabelle fuer Kundenerweiterungsprojekte
  DATA: lcl_it_modname TYPE STANDARD TABLE OF modact-name,
        lcl_wa_modname LIKE LINE OF lcl_it_modname.

*Aktive Kundenerweiterungprojekte aus modattr waehlen
  SELECT name FROM modattr INTO TABLE lcl_it_modname
          WHERE name IN o_cmod
          AND   status = &apos;A&apos;.

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_modname IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for Enhancemetprojects! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.

  LOOP AT lcl_it_modname INTO lcl_wa_modname.

    PERFORM handle_customerenhancement USING lcl_wa_modname.

*Stueckliste fuer logische Entwicklung
    IF NOT ( p_logic IS INITIAL ).
      PERFORM write_log_stueckliste USING   &apos;CMOD-Enhancement&apos;
                                            lcl_wa_modname
                                            p_logic.

    ENDIF.

  ENDLOOP.
ENDFORM.                    &quot; CUSTOMERENHANCEMENTS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  WRITE_ENHANCEMENTLIST
*&amp;---------------------------------------------------------------------*
*      Schreiben der Uebersichtsliste zu einer Erweiterung.
*----------------------------------------------------------------------*
FORM write_enhancementlist USING    p_sapenhancement TYPE modsap-name
                                    p_comp TYPE modsap-member
                                    p_typus TYPE c
                                    p_intern TYPE any.
  wa_enhancecomp-sapenh = p_sapenhancement.
  wa_enhancecomp-comp = p_comp.
  wa_enhancecomp-typus = p_typus.
  wa_enhancecomp-internal = p_intern.
  APPEND wa_enhancecomp TO it_enhancecomp.
ENDFORM.                    &quot; WRITE_ENHANCEMENTLIST

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_ENHANCEMENTTAB
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      Sicherung der Uebersichtsliste eines Erweiterungsprojektes in
*      das lokale Dateisystem.
*      Generierung der Tabelle in HTML-Format.
*----------------------------------------------------------------------*
FORM download_enhancementtab USING p_name TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Dateiname fuer Download
  DATA: lcl_project_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.
  DATA: lcl_file_internal LIKE wa_enhancecomp-file_internal.

* begin of changes for partner namespace
* Auffuellen der Felder fuer den verwendeten file_name
  LOOP AT it_enhancecomp INTO wa_enhancecomp.
    lcl_file_internal = wa_enhancecomp-internal.
    TRANSLATE lcl_file_internal USING &apos;/_&apos;.
    wa_enhancecomp-file_internal = lcl_file_internal.
    MODIFY it_enhancecomp FROM wa_enhancecomp INDEX sy-tabix.
  ENDLOOP.
* end of changes for partner namespace


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_enhancecomp IS INITIAL ).
    CONCATENATE &apos;Enhproject_&apos; p_name INTO lcl_project_name.


*Umwandlung in HTML-Tabelle
********************************************************
*Ueberschrift zusammenbauen
    CONCATENATE &apos;Enhancement List  of CMOD-Enhancement&apos;  p_name
          INTO lcl_header SEPARATED BY space.

*Headertabelle zusammenbauen
    APPEND &apos;SAP Extension Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Enhancement&apos; TO lcl_it_headerrow.
    APPEND &apos;Component Type&apos; TO lcl_it_headerrow.
    APPEND &apos;Object Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Object Name in file system&apos; TO lcl_it_headerrow.

    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_enhancecomp INTO wa_enhancecomp.
      PERFORM create_htmltab_body USING wa_enhancecomp.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************
    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_project_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;&quot;it_enhancecomp
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text051 lcl_project_name
            filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text051 lcl_project_name
            filename.

    ENDIF.
  ENDIF. &quot;ist it_enhancecomp überhaupt gefüllt

ENDFORM.                    &quot; DOWNLOAD_ENHANCEMENTTAB

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DEVELOPMENTCLASS
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Entwicklungsklasse aus dem
*      Selektionsbildschirm fuer Entwicklungsklassen.
*      Fuer jede gefundene Entwicklungsklasse werden alle zu
*      verabeitenden Objekte behandelt.
*----------------------------------------------------------------------*
FORM developmentclass.
* Dummy für tdrir-name
  DATA: lcl_dummy TYPE trdir-name.
* Lokale Variable fuer Namen des Objektes in Tabelle trdir
  DATA: lcl_trdirname TYPE trdir-name.
* Lokaler Arbeitsbereich fuer trdir
  DATA: lcl_wa_trdir TYPE trdir.
* tabelle zur Speicherung der Stückliste
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste.
*Pfad
  DATA: path TYPE string.

* Arbeitsbereich fuer Gruppenwechsel ueber Enwicklungsklasse
  DATA: lcl_it_devclass TYPE STANDARD TABLE OF tadir-devclass,
        lcl_wa_devclass LIKE LINE OF lcl_it_devclass,
        lcl_root        LIKE root.

  DATA: lcl_wa_dd02l        TYPE dd02l,
        lcl_tmp_dir         TYPE string,
        lcl_tmp_new_dir     TYPE string,
        lcl_dataelement     LIKE wa_dataelements-rollname,
        lcl_it_dataelements TYPE STANDARD TABLE OF dd04v,
        lcl_it_domains      TYPE STANDARD TABLE OF dd04v-domname,
        lcl_wa_domains      LIKE LINE OF lcl_it_domains,
        lcl_wa_cross        TYPE cross,
        lcl_include         LIKE c_includename,
        lcl_it_tstc         LIKE it_tstc,
        lcl_wa_tstc         TYPE tstc,
        lcl_it_tstcp        LIKE it_tstcp,
        lcl_it_tpara        LIKE it_tpara.

* Initialisieren der Bereiche von tadir wegen evtl.Mehrfachaufruf
  REFRESH it_tadir. CLEAR wa_tadir.

  root = dir.
  lcl_root = root.
* Entwicklungklassen selektieren
  SELECT DISTINCT devclass FROM tadir INTO TABLE lcl_it_devclass
      WHERE     devclass IN o_devcl
        AND ( ( devclass LIKE &apos;Z%&apos; ) OR ( devclass LIKE &apos;Y%&apos; ) OR
              ( devclass LIKE g_name  ) ).

* Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_devclass IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for the Developmentclasses! &apos;
   &apos;Please check your selection.&apos;.
*   Form-Routine verlassen
    EXIT.
  ENDIF.

  LOOP AT lcl_it_devclass INTO lcl_wa_devclass.
    global_main_name =  lcl_wa_devclass.
*   Zuordnung des Rootverzeichnisses um, Verzeichnis darunter anlegen
*   zu koennen
    dir = lcl_root.
    root = lcl_root.
*    dir = root.

*   Intitialisieren der globalen Tabellen
    PERFORM initialize.

*   Sonderinitialisierungen
    REFRESH it_trdir.
    CLEAR lcl_wa_trdir.

*   Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Development Class&apos;
                                     lcl_wa_devclass
                                     &apos;&apos;.


*   Ueberschrift zusammenbauen
    CONCATENATE &apos;Developmentclass:&apos; lcl_wa_devclass INTO header
          SEPARATED BY space.
*   Protokollliste schreiben.
    PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.

*   Verzeichnis fuer diese Entwicklungsklasse
    PERFORM create_directory USING lcl_wa_devclass
                              &apos;Devc&apos;.

*   Abbrechen da es schon existiert
    IF direxists = &apos;X&apos;.
      CONTINUE.
    ENDIF.

    path = new_dir.

*   direkt an lokale Stueckliste anhaengen
    REFRESH lcl_it_prog_stueckliste.
    APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*   Selektion auf tadir
    SELECT * FROM tadir INTO TABLE it_tadir
       WHERE  devclass = lcl_wa_devclass
         AND  pgmid    = &apos;R3TR&apos;.

    SORT it_tadir BY pgmid object.

    LOOP AT it_tadir INTO wa_tadir.
      REFRESH it_prog_stueckliste.

*     Verarbeitung der einzelnen Typen
      IF  wa_tadir-object = &apos;FUGR&apos; &quot;Funktionsgruppe
       OR wa_tadir-object = &apos;FUGX&apos;
       OR wa_tadir-object = &apos;FUGS&apos;.

*       Um den globalen Gebrauch des Variable wa_trdir-name zu erhalten
*       wird das Feld mit dem aktuellen Namen gefuellt.
*       Unterscheidung auf Partnernamensraum.
        IF wa_tadir-obj_name(1) = &apos;/&apos;.
          lcl_trdirname = wa_tadir-obj_name.
          PERFORM convert_fugrname_for_partner
                CHANGING lcl_trdirname.
        ELSE. &quot;normaler namensraum
          CONCATENATE  &apos;SAPL&apos; wa_tadir-obj_name INTO lcl_trdirname.
        ENDIF.
*       Existiert die Funktionsgruppe überhaupt
        SELECT SINGLE name FROM trdir INTO lcl_dummy
          WHERE name = lcl_trdirname.
        IF sy-subrc NE 0.
          CONTINUE.
        ENDIF.

*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Funktionsgruppe&apos;
                                         lcl_trdirname
                                    wa_tadir-devclass.

        global_main_name = lcl_trdirname.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.


*       Ueberpruefen, ob Funktionsgruppe noch existiert
        SELECT SINGLE name FROM trdir INTO lcl_dummy
                WHERE name = lcl_trdirname.
        IF sy-subrc = 0.
*         Verarbeitungsroutine fuer Funktionsgruppen aufrufen
          PERFORM handle_functiongroup USING lcl_trdirname.
        ENDIF.

      ELSEIF wa_tadir-object = &apos;PROG&apos;
          OR wa_tadir-object = &apos;XPRA&apos;. &quot;Reports und Modulpoole
*       Enfaches Include wird wie Rahmenprogramm behandelt.
        SELECT SINGLE * FROM trdir INTO lcl_wa_trdir
              WHERE  name = wa_tadir-obj_name.
        IF sy-subrc = 0.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;Report/Modulpool&apos;
                                           wa_tadir-obj_name
                                        wa_tadir-devclass.

*         Stueckliste sichern
          APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste
          .


*         Globale Daten aufbereiten
          global_main_name = wa_tadir-obj_name.
*         Aufruf der Verarbeitungsroutine fuer Reports / Modulpoole
          PERFORM handle_reps_mods USING wa_tadir-obj_name.


        ENDIF. &quot;Ist das ein Report oder ein Modulpool

      ELSEIF wa_tadir-object = &apos;CLAS&apos;. &quot;Klasse
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Class(OO)&apos;
                                         wa_tadir-obj_name
                                      wa_tadir-devclass.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.


*       Globale Daten aufbereiten
        global_main_name = wa_tadir-obj_name.
*       Intitialisieren der globalen Tabellen
        PERFORM initialize.
        PERFORM  handle_class_extern USING wa_tadir-obj_name.

      ELSEIF wa_tadir-object = &apos;INTF&apos;.
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Interface(OO)&apos;
                                         wa_tadir-obj_name
                                      wa_tadir-devclass.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
*       Globale Daten aufbereiten
        global_main_name = wa_tadir-obj_name.
*       Intitialisieren der globalen Tabellen
        PERFORM initialize.
*       Herunterladen des Interface
        PERFORM handle_interface USING wa_tadir-obj_name.

      ELSEIF wa_tadir-object = &apos;CMOD&apos;. &quot;Customer Enhancementprojekt
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;CMOD-Enhancement&apos;
                                         wa_tadir-obj_name
                                      wa_tadir-devclass.
*       Stueckliste sichern

        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*       Globale Daten aufbereiten
        global_main_name = wa_tadir-obj_name.
        PERFORM handle_customerenhancement USING wa_tadir-obj_name.


      ELSEIF wa_tadir-object = &apos;SXCI&apos;.  &quot;Badiimplementierung
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Badi Implementation&apos;
                                         wa_tadir-obj_name
                                      wa_tadir-devclass.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.


*       Globale Daten aufbereiten
        global_main_name = wa_tadir-obj_name.
        PERFORM handle_badi_implementation USING wa_tadir-obj_name.


      ELSEIF wa_tadir-object = &apos;IDOC&apos;. &quot;IDOC Basistyp
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;IDOC-Basityp&apos;
                                         wa_tadir-obj_name
                                      wa_tadir-devclass.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*       Globale Daten aufbereiten
        global_main_name = wa_tadir-obj_name.
        PERFORM handle_idoc USING wa_tadir-obj_name
                                  &apos;B&apos;.


      ELSEIF wa_tadir-object = &apos;IEXT&apos;. &quot;IDOC Erweiterung
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;IDOC-Erweiterung&apos;
                                         wa_tadir-obj_name
                                      wa_tadir-devclass.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
        global_main_name = wa_tadir-obj_name.
        PERFORM handle_idoc USING wa_tadir-obj_name
                                   &apos;E&apos;.

      ELSEIF wa_tadir-object = &apos;IASP&apos;. &quot;IAC-Service
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;IACS&apos;
                                         wa_tadir-obj_name
                                      wa_tadir-devclass.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
        global_main_name = wa_tadir-obj_name.
        PERFORM handle_iac_service USING wa_tadir-obj_name.

*     Tabellen Berücksichtigen
      ELSEIF wa_tadir-object = &apos;TABL&apos;.
*       Feststellen ob Tabelle oder Struktur vorliegt
        CLEAR lcl_wa_dd02l.
        SELECT SINGLE * FROM dd02l INTO lcl_wa_dd02l
            WHERE tabname = wa_tadir-obj_name.
        IF sy-subrc NE 0.
          CONTINUE.
        ENDIF.
*       Verzeichnis sichern
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*       Zuweisen des Basisverzeichnis zum
        new_dir = dir.
*       Fuer Typ T feststellen ob Struktur, oder Taelle
        IF lcl_wa_dd02l-tabclass = &apos;TRANSP&apos;. &quot;normale Tabelle
*         Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
          READ TABLE it_prog_stueckliste WITH KEY name =
          wa_tadir-obj_name
                                      type = &apos;Tabelle&apos; TRANSPORTING NO
                                      FIELDS.
          IF sy-subrc &lt;&gt; 0.
*           Infos suchen und diese Downloaden
            PERFORM download_table USING lcl_wa_dd02l
                                         &apos;T&apos;.

*           Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Table&apos;
                                          wa_tadir-obj_name
                                          wa_tadir-devclass.

          ENDIF. &quot;Stuecklistenueberpruefung

        ELSEIF lcl_wa_dd02l-tabclass = &apos;INTTAB&apos;. &quot;Struktur

*         Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
          READ TABLE it_prog_stueckliste WITH KEY name =
          wa_tadir-obj_name
                                     type = &apos;Struktur&apos; TRANSPORTING NO
                                     FIELDS.
          IF sy-subrc &lt;&gt; 0.
*           Infos suchen und diese Downloaden
            PERFORM download_table USING lcl_wa_dd02l
                                         &apos;S&apos;.
*           Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Structure&apos;
                                          wa_tadir-obj_name
                                          wa_tadir-devclass.


          ENDIF. &quot;Stuecklistenueberpruefung

        ELSEIF lcl_wa_dd02l-tabclass = &apos;APPEND&apos;. &quot;Appendstruktur
*         Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
          READ TABLE it_prog_stueckliste WITH KEY name =
          wa_tadir-obj_name
                                       type = &apos;Append&apos; TRANSPORTING NO
                                       FIELDS.
          IF sy-subrc &lt;&gt; 0.
*           Infos suchen und diese Downloaden
            PERFORM download_table USING lcl_wa_dd02l
                                         &apos;A&apos;.
*           Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Append&apos;
                                          wa_tadir-obj_name
                                          wa_tadir-devclass.


          ENDIF. &quot;Stuecklistenueberpruefung

        ENDIF.
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      ELSEIF wa_tadir-object = &apos;TTYP&apos;.
*       Überüfung, ob Tabellentyp überhaupt noch existiert.
        SELECT SINGLE * FROM dd40vv INTO wa_tabletypes
          WHERE typename = wa_tadir-obj_name.
        IF sy-subrc NE 0.
          CONTINUE.
        ENDIF.

*       Verzeichnis sichern
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*       Zuweisen des Basisverzeichnis zum
        new_dir = dir.

        PERFORM handle_tabletype USING wa_tadir-obj_name.
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Tabletype&apos;
                                       wa_tadir-obj_name
                                       global_main_name.

*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*     Bearbeitung von Views
      ELSEIF wa_tadir-object = &apos;VIEW&apos;.

*       Tabelle lesen wegen Typkonformem Aufruf der Routine
        SELECT SINGLE * FROM dd02l INTO lcl_wa_dd02l
            WHERE tabname = wa_tadir-obj_name.
        IF sy-subrc NE 0.
          CONTINUE.
        ENDIF.
*       Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
        READ TABLE it_prog_stueckliste WITH KEY name = wa_tadir-obj_name
                                      type = &apos;View&apos; TRANSPORTING NO
                                      FIELDS.
        IF sy-subrc &lt;&gt; 0.

*         Verzeichnis sichern
          lcl_tmp_dir = dir.
          lcl_tmp_new_dir = new_dir.
*         Zuweisen des Basisverzeichnis zum
          new_dir = dir.

          CLEAR wa_ddictypes.
          wa_ddictypes-tabname = wa_tadir-obj_name.
          PERFORM download_view USING wa_ddictypes.

*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;View&apos;
                                         wa_tadir-obj_name
                                         global_main_name.

*         Stueckliste sichern
          APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste
          .

*         Wiederherstellung der Verzeichnisstruktur
          dir = lcl_tmp_dir.
          new_dir = lcl_tmp_new_dir.

*         Markierungen zur Trennung von naechstem Objekt
          PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
          PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

        ENDIF. &quot;Stuecklistenueberpruefung

*     Verarbeitung der Messageklasse
      ELSEIF wa_tadir-object = &apos;MSAG&apos;.

*       Verzeichnis sichern
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*       Zuweisen des Basisverzeichnis zum
        new_dir = dir.

        PERFORM trkorr_messageclass USING wa_tadir-obj_name
                                          wa_tadir-obj_name.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*       Wiederherstellung der Verzeichnisstruktur
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*     Verarbeitung von Datenelementen
      ELSEIF wa_tadir-object = &apos;DTEL&apos;.

*       Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
        READ TABLE it_prog_stueckliste WITH KEY name = wa_tadir-obj_name
                               type = &apos;Datenelement&apos; TRANSPORTING NO
                               FIELDS.
        IF sy-subrc &lt;&gt; 0.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;Datenelement&apos;
                                        wa_tadir-obj_name
                                        global_main_name.

*          Zuweisung des Datenelementnamens wegen Typkonformitaet
          lcl_dataelement = wa_tadir-obj_name.
*         Initialsierung der globalen Tabelle (Routine nutzt diese)
          REFRESH  it_dataelements.
          PERFORM write_dataelements USING lcl_dataelement.
*         Anhaengen der der Zeilen an lokale Tabelle
          APPEND LINES OF it_dataelements TO lcl_it_dataelements.
        ENDIF. &quot;Stücklistenprüfung

*     Verarbeitung von Domänen
      ELSEIF wa_tadir-object = &apos;DOMA&apos;.

        READ TABLE it_prog_stueckliste WITH KEY name = wa_tadir-obj_name
                                type = &apos;Domaene&apos; TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;Domaene&apos;
                                          wa_tadir-obj_name
                                          global_main_name.
          lcl_wa_domains = wa_tadir-obj_name.
          APPEND lcl_wa_domains TO lcl_it_domains.

        ENDIF. &quot;Stuecklistenueberpruefung

*     Verarbeitung Sperrobjekte
      ELSEIF wa_tadir-object = &apos;ENQU&apos;.

*       Verzeichnis sichern
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*       Zuweisen des Basisverzeichnis zum
        new_dir = dir.

*lcl_wa_cross fuellen um Sperrobjektroutine typkonform aufrufen zu
*       können
        CLEAR lcl_wa_cross-name.
        lcl_wa_cross-name = wa_tadir-obj_name.
*       Sperrobjekt-Routine aufrufen
        PERFORM handle_lockobject USING lcl_wa_cross
                                        &apos;S&apos;. &quot;Name ist Sperrobjektname

*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
*       Wiederherstellung der Verzeichnisstruktur
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.

*     Verarbeitung Berechtigungsobjekte
      ELSEIF wa_tadir-object = &apos;SUSO&apos;.

*       Verzeichnis sichern
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*       Zuweisen des Basisverzeichnis zum
        new_dir = dir.

        PERFORM trkorr_handleauthorityobject USING
                          wa_tadir-obj_name.

*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*       Wiederherstellung der Verzeichnisstruktur
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.

      ELSEIF wa_tadir-object = &apos;TYPE&apos;.

*       Verzeichnis sichern
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*       Zuweisen des Basisverzeichnis zum
        new_dir = dir.

*Zusammensetzen des Includenamens der Typgruppe: Praefix %_C vor Namen
        CONCATENATE &apos;%_C&apos; wa_tadir-obj_name INTO lcl_include.
*Uebergabe des Typ des Includes, um Dateinamen festlegen zu können
        CLEAR ok.
        PERFORM download_include USING lcl_include &apos;T&apos;
                                 CHANGING ok.
        IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*         Stueckliste schreiben, wenn download erfolgreich
          PERFORM write_stueckliste USING &apos;Typgroup&apos;
                                            wa_tadir-obj_name
                                            global_main_name.
*         Stueckliste sichern
          APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste
          .

*         Markierungen zur Trennung von naechstem Objekt
          PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
          PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

        ENDIF. &quot;downnload erfolgreich???

*       Wiederherstellung der Verzeichnisstruktur
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.

*     Verarbeitung Transaktionscodes
      ELSEIF wa_tadir-object = &apos;TRAN&apos;.

*       Tabelle der TA-Codes selektieren und an Gesamttabelle haengen
        SELECT SINGLE * FROM tstc INTO  lcl_wa_tstc
        WHERE tcode = wa_tadir-obj_name.

        IF NOT ( lcl_wa_tstc-pgmna IS INITIAL ). &quot;Report/Modulpool
          IF NOT lcl_wa_tstc IS INITIAL.
            APPEND lcl_wa_tstc TO   lcl_it_tstc.
          ENDIF.
        ELSE. &quot;Klassen
          SELECT SINGLE * FROM tstcp INTO wa_tstcp
              WHERE tcode = wa_tadir-obj_name.
          IF NOT wa_tstcp IS INITIAL.
            APPEND wa_tstcp TO lcl_it_tstcp.
          ENDIF.
        ENDIF.

      ELSEIF wa_tadir-object = &apos;PARA&apos;.
*       Globale Tabelle leeren
        REFRESH it_tpara.
*       lcl_wa_cross fuellen um Parameterroutine typkonform aufrufen zu
*       können
        CLEAR lcl_wa_cross-name.
        lcl_wa_cross-name = wa_tadir-obj_name.

        REFRESH it_prog_stueckliste.
*       Aufruf des Handlers fuer Set/Get-Parameter
        PERFORM handle_setgetparamss USING lcl_wa_cross.
*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
        APPEND LINES OF it_tpara TO lcl_it_tpara.

      ELSEIF wa_tadir-object = &apos;DIAL&apos;.

*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Dialogmodule&apos;
                                      wa_tadir-obj_name
                                      global_main_name.

*       Stueckliste sichern
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
        PERFORM trkorr_handle_dialogmodules USING wa_tadir-obj_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      ENDIF.

    ENDLOOP. &quot;Entwicklungsklasse

    global_main_name = lcl_wa_devclass.
    new_dir =  path.
    REFRESH it_prog_stueckliste.
*   globale Stueckliste wieder schreiben
    APPEND LINES OF lcl_it_prog_stueckliste TO
                                       it_prog_stueckliste.

*   Datenelemente herunterladen
    REFRESH it_dataelements.
    APPEND LINES OF lcl_it_dataelements TO it_dataelements.
    PERFORM download_dataelements.

*   Domaenen downloaden
    PERFORM handle_trkorr_domains USING lcl_it_domains.

*Gesamtliste der Transaktionscodes herunterladen (Reps/Modulpools/Fkgrp
    REFRESH it_tstc.
    APPEND LINES OF lcl_it_tstc TO it_tstc.
    PERFORM download_tacodelist.
*   Gesamtliste der Transaktionscodes fuer Klasse herunterladen
    REFRESH it_tstcp.
    APPEND LINES OF lcl_it_tstcp TO it_tstcp.
    PERFORM download_tacodelist_for_class.

*   Gesamtliste der Parameter herunterschreiben
    REFRESH it_tpara.
    APPEND LINES OF lcl_it_tpara TO it_tpara.
    PERFORM download_setgetparams.

*   Trennung von Einzeldateiobjekten
    PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
    PERFORM download_stueckliste.

*   Leerzeile nach Ende dieser Verarbeitung
    PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*   Supportpackagestand sichern
    PERFORM download_hpstand.

  ENDLOOP. &quot;Selektionsparameter abfangen

  dir = root.
ENDFORM.                    &quot; DEVELOPMENTCLASS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_extprog_singleinclude
*&amp;---------------------------------------------------------------------*
*     Lesen von aufgerufenen Objekten des im Parameter P_NAME
*     angegebenen Includes.
*     Funktionsbausteine, Sperrobjekte, Meldungen,  Programmaufrufen
*     Berechtigungsobjekten und Set/Get-Parametern
*----------------------------------------------------------------------*
FORM handle_extprog_singleinclude USING    p_include LIKE c_includename.
*Bereich fuer die Tabelle mit den externen Verweisen
  DATA: lcl_it_cross_ref TYPE STANDARD TABLE OF cross,
        lcl_wa_cross_ref LIKE LINE OF lcl_it_cross_ref.
*4.)Sperrobjektname für Patnernamensraum aufbereiten
  DATA: lcl_enqueue TYPE string,
        lcl_dequeue TYPE string,
        lcl_len TYPE i.

*Namen für Sperrobjekte zusammenbauen
  IF p_nspace(1) = &apos;/&apos;.

    CONCATENATE  &apos;ENQUEUE_&apos; p_nspace &apos;E&apos; INTO lcl_enqueue.
    CONCATENATE  &apos;DEQUEUE_&apos; p_nspace &apos;E&apos; INTO lcl_dequeue.
    lcl_len = STRLEN( lcl_enqueue ).
  ELSE.
    lcl_len = 1.
  ENDIF.


*Alle externen Verweise fuer dieses Include aus Tabelle cross lesen
  SELECT * FROM cross INTO TABLE lcl_it_cross_ref
        WHERE include = p_include.

*Verarabeitung der einzelnen Eintraege
  LOOP AT lcl_it_cross_ref INTO lcl_wa_cross_ref.
*Behandlung je nach Typ
    CASE lcl_wa_cross_ref-type.
      WHEN &apos;N&apos;. &quot;Verarbeitung von messages
        PERFORM handle_message USING lcl_wa_cross_ref.
      WHEN &apos;F&apos;.  &quot;Verarbeitung Funktionsbaustein
        &quot;Kundennamenraum ueberpruefen
        IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
            OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; ) )
            OR ( lcl_wa_cross_ref-include(g_len_nspace) = p_nspace ).
          PERFORM handle_functionmodule USING lcl_wa_cross_ref.
        ENDIF. &quot;Kundennamensraum
*Behandlung von Sperrobjekten im Kundennamensraum
        IF ( ( lcl_wa_cross_ref-name(10) = &apos;ENQUEUE_EZ&apos; ) OR
           ( lcl_wa_cross_ref-name(10) = &apos;ENQUEUE_EY&apos; ) OR
           ( lcl_wa_cross_ref-name(lcl_len) = lcl_enqueue ) OR
           ( lcl_wa_cross_ref-name(10) = &apos;DEQUEUE_EZ&apos; ) OR
           ( lcl_wa_cross_ref-name(10) = &apos;DEQUEUE_EY&apos; ) OR
           ( lcl_wa_cross_ref-name(lcl_len) = lcl_dequeue ) ).
          PERFORM handle_lockobject USING lcl_wa_cross_ref
                                          &apos;F&apos;.
          &quot;Name ist ein Funktionbausteinname

        ENDIF.
      WHEN &apos;R&apos;.  &quot;Aufruf eines anderen Reports (submit program)
        IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
            OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
            OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
          PERFORM handle_submits USING lcl_wa_cross_ref.
        ENDIF.
      WHEN &apos;U&apos;. &quot;Aufruf einer Form in einem anderen Programm
        IF ( ( lcl_wa_cross_ref-prog(1) = &apos;Z&apos; )
           OR ( lcl_wa_cross_ref-prog(1) = &apos;Y&apos; )
           OR ( lcl_wa_cross_ref-prog(g_len_nspace) = p_nspace ) ).
          PERFORM handle_performextern USING lcl_wa_cross_ref.
        ENDIF.
      WHEN &apos;T&apos;. &quot;Behandlung von Transaktionen (call transaction)
        IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
            OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
            OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
          PERFORM handle_transaction USING lcl_wa_cross_ref.
        ENDIF.
      WHEN &apos;A&apos;. &quot;Behandlung von Berechtigungsobjekten
        IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
            OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
            OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
          PERFORM handle_authorityobject USING lcl_wa_cross_ref.
        ENDIF.
      WHEN &apos;D&apos;. &quot;Dialogbaustein
        IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
           OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
           OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
          PERFORM handle_dialogmodule USING lcl_wa_cross_ref.
        ENDIF.
      WHEN &apos;P&apos;. &quot;set/get Parameterpaar
        IF ( ( lcl_wa_cross_ref-name(1) = &apos;Z&apos; )
             OR ( lcl_wa_cross_ref-name(1) = &apos;Y&apos; )
             OR ( lcl_wa_cross_ref-name(g_len_nspace) = p_nspace ) ).
          PERFORM handle_setgetparamss USING lcl_wa_cross_ref.
        ENDIF.
    ENDCASE.

  ENDLOOP.
ENDFORM.                    &quot; HANDLE_EXTPROG_CMODENH

*&amp;---------------------------------------------------------------------*
*&amp;      Form  BADI_IMPLEMENTATION
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Badiimplementierungen aus dem
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Fuer jede gefundene Implementierung wird die
*      Verarbeitungsroutine ausgeführt.
*----------------------------------------------------------------------*
FORM badi_implementation.
*Bereich fuer die selektierten aktiven Enhancements
  DATA: lcl_it_impsel TYPE STANDARD TABLE OF sxc_attr-imp_name,
        lcl_wa_impsel LIKE LINE OF lcl_it_impsel.




*Tabelle fuer Badiimplementierung initialisieren
  REFRESH it_ges_sxc_exit.
*Nur die aktiven Implementierungen der Selektion waehlen
  SELECT imp_name FROM sxc_attr INTO TABLE lcl_it_impsel
        WHERE imp_name IN o_badis
        AND active = &apos;X&apos;.

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_impsel IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable Selection&apos; &apos;for Badiimplementations! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.

  LOOP AT lcl_it_impsel INTO lcl_wa_impsel.

    PERFORM handle_badi_implementation USING lcl_wa_impsel.

  ENDLOOP.
ENDFORM.                    &quot; BADI_IMPLEMENTATION

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_BADI_FILTERPARAMS
*&amp;---------------------------------------------------------------------*
*       Sicherung der Liste der Filterparameter in das Dateisystem.
*       Generierung der TAbelle in HTML-Format.
*----------------------------------------------------------------------*
FORM download_badi_filterparams USING p_badiimpl TYPE c.
  &quot;sxc_attr-imp_name.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Arbeitsbereich fuer die TAbelle
  DATA: lcl_wa_ges_sxc_exit LIKE LINE OF it_ges_sxc_exit.
*Name fuer die Gesamtmessagetabelle des Rahmenprogramms
  DATA: lcl_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.



*Nur Download durchführen wenn Tabelle nicht leer ist.
  IF NOT ( it_ges_sxc_exit IS INITIAL ).

*Ueberschrift zusammenbauen
    CONCATENATE &apos;Filterparameters of Badi&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
    APPEND &apos;Badi Implementation&apos; TO lcl_it_headerrow.
    APPEND &apos;Badi Definition&apos; TO lcl_it_headerrow.
    APPEND &apos;Filter Value&apos; TO lcl_it_headerrow.

*Umwandlung in HTML-Tabelle
********************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_ges_sxc_exit INTO lcl_wa_ges_sxc_exit.
      PERFORM create_htmltab_body USING lcl_wa_ges_sxc_exit.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************

    CONCATENATE &apos;BadiImpFilter_&apos; global_main_name INTO lcl_name.
    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html &quot;it_ges_sxc_exit
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text055 lcl_name filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text055 lcl_name filename.
*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Filterparameter&apos;
                                      &apos;Filterparameter&apos;
                                      global_main_name.
    ENDIF.
  ENDIF. &quot;Download nur wenn Tabelle nicht leer ist

ENDFORM.                    &quot; DOWNLOAD_BADI_FILTERPARAMS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_MENUEXITCODELIST
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*       Sicherung der Liste der Menuexitcods in das Dateisystem.
*       Generierung der TAbelle in HTML-Format.
*----------------------------------------------------------------------*
FORM download_menuexitcodelist USING  p_name TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Arbeitsbereich nur fuer die wichtigen Felder der Liste
  DATA: lcl_wa_icuatexts TYPE icuatexts.
*Dateiname fuer Download
  DATA: lcl_project_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.
*Bereich fuer Verarbeitung der Exitcodeliste
  DATA: lcl_wa_cuatexts LIKE LINE OF it_cuatexts.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_cuatexts IS INITIAL ).

*Ueberschrift zusammenbauen
    CONCATENATE &apos;Menuexitcodelist of Customerenhancement&apos;
         global_main_name INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
    APPEND &apos;Programname&apos; TO lcl_it_headerrow.
    APPEND &apos;Code&apos; TO lcl_it_headerrow.
    APPEND &apos;Language&apos; TO lcl_it_headerrow.
    APPEND &apos;Longtext&apos; TO lcl_it_headerrow.
    APPEND &apos;Shottext&apos; TO lcl_it_headerrow.
    APPEND &apos;Infotext&apos; TO lcl_it_headerrow.
    APPEND &apos;Icon Name&apos; TO lcl_it_headerrow.

*Umwandlung in HTML-Tabelle
********************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_cuatexts INTO lcl_wa_cuatexts.
      MOVE-CORRESPONDING lcl_wa_cuatexts TO lcl_wa_icuatexts.
      PERFORM create_htmltab_body USING lcl_wa_icuatexts.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************
    CONCATENATE &apos;Menuexits_&apos; p_name INTO lcl_project_name.
    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_project_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_cuatexts
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text056 lcl_project_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text056 lcl_project_name
          filename.
    ENDIF.
  ENDIF. &quot;ist it_cuatexts ueberhaupt gefüllt

ENDFORM.                    &quot; DOWNLOAD_MENUEXITCODELIST

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TRANSPORTREQUEST
*&amp;---------------------------------------------------------------------*
*       Hier findet die Auswahl über die Tranportaufträge statt, die
*       im Selektionsbildschrim fuer Trasnportauftraege eingegeben
*       worden sind. Fuer jeden Transportauftrag werden alle
*       unterstuetzten Objekte verarbeitet.
*----------------------------------------------------------------------*
FORM transportrequest.

*Bereich fuer Uebberobjekte
  DATA: lcl_it_trkorr_ueber TYPE STANDARD TABLE OF e070-strkorr,
        lcl_wa_trkorr_ueber LIKE LINE OF lcl_it_trkorr_ueber.

*Bereiche fuer das Lesen der Selektionsbedingungen
  DATA: lcl_it_trkorr TYPE STANDARD TABLE OF e071-trkorr,
        lcl_wa_trkorr LIKE LINE OF lcl_it_trkorr.

  DATA: lcl_released TYPE e070-trstatus.


* Übernahme des Parameters zur Steuerung, ob abhängige
* Hauptobjekte berücksichtigt werden sollen.
  g_nodep = &apos;X&apos;.

*Alle Unterauftraege selektieren
  SELECT DISTINCT trkorr FROM e071 INTO TABLE lcl_it_trkorr
          WHERE trkorr IN o_trkorr.

*evtl. angegebene Oberauftraege angeben; Verarbeitung am Ende der
*Routine
  SELECT DISTINCT strkorr FROM e070 INTO TABLE lcl_it_trkorr_ueber
        WHERE strkorr IN o_trkorr.

*Verlassen,wenn keine Werte gefunden worden sind
  IF ( ( lcl_it_trkorr IS INITIAL )
             AND ( lcl_it_trkorr_ueber IS INITIAL ) ).

    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for the Transportrequests! &apos;
   &apos;Please check your selection.&apos;.
*Form-Routine verlassen
    EXIT.
  ENDIF.


*Verarbeitung Unterauftraege
  LOOP AT lcl_it_trkorr INTO lcl_wa_trkorr.
    PERFORM handle_transportrequest USING lcl_wa_trkorr.
  ENDLOOP.


*Verarbeitung Oberauftraege
  LOOP AT lcl_it_trkorr_ueber INTO lcl_wa_trkorr_ueber.

    CLEAR lcl_released.
*Ueberpruefen,ob auftrag schon released
    SELECT SINGLE trstatus FROM e070 INTO lcl_released
          WHERE trkorr = lcl_wa_trkorr_ueber.

    IF lcl_released = &apos;R&apos; OR lcl_released = &apos;N&apos;.
      PERFORM handle_transportrequest USING lcl_wa_trkorr_ueber.

    ELSE.

      REFRESH lcl_it_trkorr.
*  Alle Unterauftraege zu den Oberauftrag selektieren
      SELECT DISTINCT trkorr FROM e070 INTO TABLE lcl_it_trkorr
              WHERE strkorr = lcl_wa_trkorr_ueber.

*Ueberschrift zusammenbauen
      CONCATENATE &apos;Main Transport Request:&apos; lcl_wa_trkorr_ueber
        INTO header SEPARATED BY space.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
      FORMAT COLOR COL_BACKGROUND.
*  ***************

*  Verarbeitung Unterauftraege
      LOOP AT lcl_it_trkorr INTO lcl_wa_trkorr.
        PERFORM handle_transportrequest USING lcl_wa_trkorr.
      ENDLOOP.
    ENDIF. &quot;Oberauftrag bereits freigegeben
  ENDLOOP.

ENDFORM.                    &quot; TRANSPORTREQUEST

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_SELECTED_SCREEN
*&amp;---------------------------------------------------------------------*
*       Nach Selektionen im Startbildschirm wird hier entschieden,
*       welcher Folgescreen prozessiert wird.
*       Nach dem Abbrechen des Folgescreens wird durch Neustart der
*       Startselektionsbildschirm angezeigt.
*----------------------------------------------------------------------*
FORM get_selected_screen.

  IF p_single = &apos;X&apos;.
    CALL SELECTION-SCREEN &apos;102&apos;.  &quot;log.Entwicklung, einzelne Objekte
  ENDIF.
*Rueckkehr zu Startselektionsbilschirm zu Standardbedingungen
  IF sy-subrc = 4.
    SET SCREEN  0.
    STOP.
  ENDIF.

  IF p_trkorr = &apos;X&apos;.
    CALL SELECTION-SCREEN &apos;100&apos;.  &quot;Transportauftrag
  ENDIF.
*Rueckkehr zu Startselektionsbilschirm zu Standardbedingungen
  IF sy-subrc = 4.
    SET SCREEN  0.
    STOP.
  ENDIF.

  IF p_devc = &apos;X&apos;.
    CALL SELECTION-SCREEN &apos;101&apos;.  &quot;Entwicklungsklasse
  ENDIF.
*Rueckkehr zu Startselektionsbilschirm zu Standardbedingungen
  IF sy-subrc = 4.
    SET SCREEN  0.
    STOP.
  ENDIF.


*Rueckkehr zu Startselektionsbilschirm zu Standardbedingungen
  IF sy-subrc = 4.
    SET SCREEN  0.
    STOP.
  ENDIF.

*** Kundeneigener Namensraum beruecksichtigen
  IF p_nspace IS INITIAL.
    p_nspace = &apos;Z&apos;.
  ENDIF.
  CONCATENATE p_nspace &apos;%&apos; INTO g_name.
  CONDENSE g_name NO-GAPS.
*Länge des Partnernamensraumpräfixes bestimmen
  g_len_nspace = STRLEN( p_nspace ).

ENDFORM.                    &quot; GET_SELECTED_SCREEN
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_trkorr_domains
*&amp;---------------------------------------------------------------------*
*      Informationen zur Domaine in einem Transportauftrag
*      behandeln. Sonderbehandlung, da hier Domaene unabhaengig vom
*      Datenelement auftritt.
*      Download der Headertabelle und evtl. der Wertehilfe.
*      Generierung der Tabellen in HTML-Format.
*----------------------------------------------------------------------*
FORM handle_trkorr_domains USING
                   p_it_domains TYPE ANY TABLE.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Arbeitsbereich fuer uebergebene Tabelle
  DATA: lcl_wa_domains TYPE dd04v-domname.

*Variablen fuer Download (Filename) festlegen
  DATA: lcl_domainheader_name TYPE string.
  DATA: lcl_domainvalues_name TYPE string.
*Lokaler  Datenbereich fuer temporaere Verarbeitung von dd07v(enthält
*evtl. Wertebereich der Domaene.
  DATA: lcl_it_dd07v TYPE STANDARD TABLE OF dd07v,
        lcl_wa_dd07v LIKE LINE OF lcl_it_dd07v.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.
*Arbeitsbereich nur fuer die sinnvolen Attrbute der Domaene
  DATA: lcl_wa_idd01v TYPE idd01v.
*Arbeitsbereich nur fuer die sinnvolen Festwerte der Domaene
  DATA: lcl_wa_idd07v TYPE idd07v.

*Schleife ueber die Kundeneigenen Datenelemente
*Es werden alle Domaenen (auch die SAP-Domaenen)
*betrachtet, da sie wegen der referentiellen Intgrität
*in der Datenbank notwendig sind
  LOOP AT p_it_domains INTO lcl_wa_domains.

*Sprachtabelle
    LOOP AT it_lan INTO wa_lan.
      REFRESH lcl_it_dd07v.
      CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
        EXPORTING
          name          = lcl_wa_domains
          state         = &apos;A&apos;
          langu         = wa_lan
        IMPORTING
          dd01v_wa      = wa_dd01v
        TABLES
          dd07v_tab     = lcl_it_dd07v
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc = 0.
*   Domaeneninfos in Gesamttabelle schreiben
        APPEND wa_dd01v TO it_dd01v.
*    Wertelistetabelle (dd07v) in Gesamtwerteliste schreiben.
*    Nur ausführen wenn lcl_it_dd07v nicht leer ist. Nur aus-
*    fuehren wenn Domaenen im Kundennamensraum liegen.
        IF NOT ( lcl_it_dd07v IS INITIAL ).
          LOOP AT lcl_it_dd07v INTO lcl_wa_dd07v.
            IF ( lcl_wa_dd07v-domname(1) = &apos;Z&apos;
                  OR lcl_wa_dd07v-domname(1) = &apos;Y&apos; ).
              APPEND lcl_wa_dd07v TO it_dd07v.
            ENDIF. &quot;Kundennamensraum
          ENDLOOP.
        ENDIF. &quot;initialpruefung
      ENDIF. &quot;sy-subrc
    ENDLOOP.  &quot;Sprachtabelle
  ENDLOOP.

******************************************************************
*Download der allgemeinen Informationen
******************************************************************

*Nur Download wenn it_dd01v nicht leer ist
  IF NOT ( it_dd01v IS INITIAL ).

*    Ueberschrift zusammenbauen
    CONCATENATE &apos;Domain Attributes of &apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*    Headertabelle zusammenbauen
    APPEND &apos;Domain Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Language Key&apos; TO lcl_it_headerrow.
    APPEND &apos;Data Type&apos; TO lcl_it_headerrow.
    APPEND &apos;Length of Type&apos; TO lcl_it_headerrow.
    APPEND &apos;Output Length&apos; TO lcl_it_headerrow.
    APPEND &apos;Decimal places&apos; TO lcl_it_headerrow.
    APPEND &apos;Lowercase letters (flag)&apos; TO lcl_it_headerrow.
    APPEND &apos;Sign (flag)&apos; TO lcl_it_headerrow.
    APPEND &apos;Flag for fixed Values&apos; TO lcl_it_headerrow.
    APPEND &apos;Value Table&apos; TO lcl_it_headerrow.
    APPEND &apos;Conversion Routine&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Text&apos; TO lcl_it_headerrow.



*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_dd01v INTO wa_dd01v.
*nur sinnvolle Felder nutzen
      MOVE-CORRESPONDING wa_dd01v TO lcl_wa_idd01v.
      PERFORM create_htmltab_body USING lcl_wa_idd01v.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************

    CONCATENATE &apos;DomHeader_&apos; global_main_name
        INTO lcl_domainheader_name.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_domainheader_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html               &quot;it_dd01v
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text023 lcl_domainheader_name
        filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text023 lcl_domainheader_name
        filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Domainheader&apos;
                                      &apos;Domainheader&apos;
                                       global_main_name.

    ENDIF.
  ENDIF. &quot;Ist Tabelle it_dd01v gefüllt.

******************************************************
*Herunterladen der Wertehilfen
******************************************************

*Nur Download wenn it_dd07v nicht leer ist
  IF NOT ( it_dd07v IS INITIAL ).
    CLEAR lcl_header. REFRESH lcl_it_headerrow.
*    Ueberschrift zusammenbauen
    CONCATENATE &apos;Value Range and Short Text of Domains used in &apos;
        global_main_name INTO lcl_header SEPARATED BY space.

*    Headertabelle zusammenbauen
    APPEND &apos;Domain Name&apos; TO lcl_it_headerrow.
    APPEND &apos;Position in Value List&apos; TO lcl_it_headerrow.
    APPEND &apos;Language&apos; TO lcl_it_headerrow.
    APPEND &apos;Single Value/lower Limit&apos; TO lcl_it_headerrow.
    APPEND &apos;Upper limit&apos; TO lcl_it_headerrow.
    APPEND &apos;Short Text for fixed Values&apos; TO lcl_it_headerrow.




*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_dd07v INTO wa_dd07v.
*nur sinnvolle Felder nutzen
      MOVE-CORRESPONDING wa_dd07v TO lcl_wa_idd07v.
      PERFORM create_htmltab_body USING lcl_wa_idd07v.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************


    CONCATENATE &apos;DomValues_&apos; global_main_name INTO lcl_domainvalues_name
    .
    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_domainvalues_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html               &quot;&quot;it_dd07v
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text024 lcl_domainvalues_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text024 lcl_domainvalues_name
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Domainvalues&apos;
                                      &apos;Domainvalues&apos;
                                      global_main_name.

    ENDIF.
  ENDIF.
ENDFORM.                    &quot; handle_trkorr_domains

*&amp;---------------------------------------------------------------------*
*&amp;      Form  trkorr_handle_dialogmodules
*&amp;---------------------------------------------------------------------*
*       Behandlung von Dialogmodulen in
*       Transportauftraegen. Sonderbehandlung, da sie hier unabhaengig
*       von einem Rahmenprogramm verarbeitet werden.
*       Das zugehoerige Programm wird nicht beachtet, da Aufruf aus
*       einem Transportauftrag heraus erfolgt.
*----------------------------------------------------------------------*
FORM trkorr_handle_dialogmodules USING   p_name TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

  DATA: lcl_dialogmudule_params TYPE string.
*Tabelle und Arbeitsbereich fuer Joins
  DATA: lcl_it_dialogmodule TYPE STANDARD TABLE OF dialogmodule,
        lcl_wa_dialogmodule LIKE LINE OF lcl_it_dialogmodule.

  SELECT * FROM tdct
        INNER JOIN diapar ON diapar~dnam = tdct~dnam
        INTO TABLE lcl_it_dialogmodule
        WHERE tdct~dnam = p_name
          AND spras IN o_lan.



***************************************************
*Parameter des Dialogbausteine: lcl_it_diapar
***************************************************
*Nur downloaden, wenn nicht leer
  CONCATENATE &apos;Dlgmd_Params_&apos; p_name INTO
                  lcl_dialogmudule_params.

  CLEAR filename.
  CONCATENATE new_dir &apos;\&apos; lcl_dialogmudule_params &apos;.TXT&apos; INTO filename.

* begin of changes for partner namespace
  TRANSLATE filename USING &apos;/_&apos;.
* end of changes for partner namespace
  PERFORM call_ws_download USING    filename
                                    lcl_it_dialogmodule
                           CHANGING lcl_subrc.
  IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;E&apos;  text044
      lcl_dialogmudule_params filename.
  ELSE.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;N&apos;  text044
      lcl_dialogmudule_params filename.

  ENDIF. &quot;sy-subrc

ENDFORM.                    &quot; trkorr_handle_dialogmodules
*&amp;---------------------------------------------------------------------*
*&amp;      Form  trkorr_handleauthorityobject
*&amp;---------------------------------------------------------------------*
*       Behandlung von Berecchtigungsobjekten in
*       Transportauftraegen. Sonderbehandlung, da sie hier unabhaengig
*       von einem Rahmenprogramm verarbeitet werden.Der Parameter P_NAME
*       enthaelt den Namen der Bereichtigungsobhekte.
*----------------------------------------------------------------------*
FORM trkorr_handleauthorityobject USING p_name TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Lokale Variablen für Tabellenbehandlung; Objekte und Aktivitaeten
  DATA: lcl_it_tobj LIKE it_tobj,
        lcl_wa_tobj LIKE LINE OF lcl_it_tobj,
        lcl_it_tactz LIKE it_tactz,
        lcl_wa_tactz LIKE LINE OF lcl_it_tactz.
*Variablen fuer Download
*Berechtigungsobjektname
  DATA: lcl_authobj_name TYPE string.
*Aktivitaeten zu Berechtigungsobjekt
  DATA: lcl_auth_act TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Selektion der Berechtigungsobjekte
  SELECT * FROM tobj INTO TABLE lcl_it_tobj
            WHERE objct = p_name.

  IF lcl_it_tobj IS INITIAL.
    EXIT.
  ENDIF.

*Selektion der zu den Berechtigungsobjekten gehörigen Aktivitäten
  SELECT * FROM tactz INTO TABLE lcl_it_tactz
          WHERE brobj = p_name.


*Download dieser Tabellen
*1.) Berechtigungsobjekttabelle
*Nur herunterladen, wenn Berechtigungsobjektabelle Inhalt hat.
  IF NOT ( lcl_it_tobj IS INITIAL ).

*Ueberschrift zusammenbauen
    CONCATENATE &apos;Structure of Authorityobject&apos;
      p_name INTO lcl_header SEPARATED BY space.

*    Headertabelle zusammenbauen
    APPEND &apos;Name of Object&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 1&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 2&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 3&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 4&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 5&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 6&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 7&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 8&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 9&apos; TO lcl_it_headerrow.
    APPEND &apos;Field 10&apos; TO lcl_it_headerrow.
    APPEND &apos;Class&apos; TO lcl_it_headerrow.
    APPEND &apos;Name of Author&apos; TO lcl_it_headerrow.
    APPEND &apos;Function Block&apos; TO lcl_it_headerrow.
    APPEND &apos;Conversion of Field&apos; TO lcl_it_headerrow.



*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT lcl_it_tobj INTO lcl_wa_tobj.
      PERFORM create_htmltab_body USING lcl_wa_tobj.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*    ********************************************************


    CONCATENATE &apos;Auhthorityobject_&apos; p_name INTO lcl_authobj_name.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_authobj_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html &quot;lcl_it_tobj
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text031 lcl_authobj_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text031 lcl_authobj_name
          filename.

*Stueckliste aufbereiten
      PERFORM write_stueckliste USING &apos;Authority Object(TR)&apos;
                               p_name
                                global_main_name.

    ENDIF.
  ENDIF.  &quot;Tabelle it_tobj gefuellt?????

*2.) Aktivitaeten zur Berechtigungsobjekttabelle
*Nur herunterladen, wenn Aktivitaetstabelle Inhalt hat.
  IF NOT ( lcl_it_tactz IS INITIAL ).

    CLEAR lcl_header. REFRESH lcl_it_headerrow.
*Ueberschrift zusammenbauen
    CONCATENATE &apos;Activities of Authorization Object&apos;
        p_name INTO lcl_header SEPARATED BY space.

*    Headertabelle zusammenbauen
    APPEND &apos;Authority Object&apos; TO lcl_it_headerrow.
    APPEND &apos;Assigned Activity&apos; TO lcl_it_headerrow.


*    Umwandlung in HTML-Tabelle
*    *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT lcl_it_tactz INTO lcl_wa_tactz.
      PERFORM create_htmltab_body USING lcl_wa_tactz.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************


    CONCATENATE &apos;AuthActivities&apos; p_name INTO lcl_auth_act.

    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_auth_act &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html &quot;lcl_it_tactz
                             CHANGING lcl_subrc.


    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text032 lcl_auth_act filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text032 lcl_auth_act filename.

    ENDIF.
*Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Activities of Authority Object&apos;
                                     p_name
                                      global_main_name.

  ENDIF.  &quot;Tabelle it_tactz gefuellt?????


ENDFORM.                    &quot; trkorr_handleauthorityobject
*&amp;---------------------------------------------------------------------*
*&amp;      Form  trkorr_handle_authorityfield
*&amp;---------------------------------------------------------------------*
*       Behandlung der Berechtigungsfelder bei Tranportauftraegen.
*       Die Felder koennen einzeln in Transportauftraegen vorkommmen.
*       Sie selektierten Daten werden an die Gesamttabelle angehängt.
*----------------------------------------------------------------------*
FORM trkorr_handle_authorityfield USING    p_name.
*lokalen Arbeitsbereicht fuer Tabelle authx(Beschreibung
*Berechtigungsfelder
  DATA: lcl_wa_authx TYPE authx.

  SELECT SINGLE * FROM authx INTO lcl_wa_authx
          WHERE fieldname = p_name.

  APPEND lcl_wa_authx TO it_authx.
ENDFORM.                    &quot; trkorr_handle_authorityfield
*&amp;---------------------------------------------------------------------*
*&amp;      Form  TRKORR_DOWNLOAD_AUTHORITYFIELD
*&amp;---------------------------------------------------------------------*
*      Tabelle der Berechtigungsfelder in Dateisystem speichern.
*      Genierung der Tabelle in HTML-Format.
*----------------------------------------------------------------------*
FORM trkorr_download_authorityfield USING p_it_authx LIKE it_authx.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

  DATA: lcl_authorityfields TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Ueberschrift zusammenbauen
  CONCATENATE &apos;List of Authorityfield&apos;  global_main_name
        INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
  APPEND &apos;Fieldname&apos; TO lcl_it_headerrow.
  APPEND &apos;Dataelelment&apos; TO lcl_it_headerrow.
  APPEND &apos;Check Table&apos; TO lcl_it_headerrow.


  CONCATENATE &apos;Authortyfields_&apos; global_main_name INTO
                  lcl_authorityfields.



  CLEAR filename.
  CONCATENATE new_dir &apos;\&apos; lcl_authorityfields &apos;.xml&apos; INTO filename.
  IF NOT ( p_it_authx IS INITIAL ).

*Umwandlung in HTML-Tabelle
********************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT p_it_authx INTO wa_authx.
      PERFORM create_htmltab_body USING wa_authx.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*********************************************************


*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING  filename
                                    it_html  &quot;p_it_authx
                           CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text061 lcl_authorityfields
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text061 lcl_authorityfields
          filename.

    ENDIF. &quot;sy-subrc
  ENDIF.
ENDFORM.                    &quot; TRKORR_DOWNLOAD_AUTHORITYFIELD


*&amp;---------------------------------------------------------------------*
*&amp;      Form  interfaces
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Interfaces des
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Fuer jede gefundenes Interface wird die
*      Verarbeitungsroutine ausgeführt.
*----------------------------------------------------------------------*
FORM interfaces.
  DATA: lcl_it_seoclass TYPE STANDARD TABLE OF seoclass,
        lcl_wa_seoclass LIKE LINE OF lcl_it_seoclass.

*Arbeitsbereich fuer select-options:
*  data: lcl_wa_options like o_intf.

*Selektieren der Programme nach Selekt-Options
  SELECT * FROM seoclass INTO TABLE lcl_it_seoclass
          WHERE clsname IN o_intf
          AND   clstype = 1.

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_seoclass IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for Interfaces! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.


  LOOP AT lcl_it_seoclass INTO lcl_wa_seoclass.

*Liste mit Ober-Objekten bei Einzelselektion fuellen
    MOVE lcl_wa_seoclass-clsname TO wa_obj_list-name.
    APPEND wa_obj_list TO it_obj_list.

    PERFORM handle_interface USING lcl_wa_seoclass-clsname.

*Stueckliste fuer logische Entwicklung
    IF NOT ( p_logic IS INITIAL ).
      PERFORM write_log_stueckliste USING   &apos;Interface(OO)&apos;
                                            lcl_wa_seoclass-clsname
                                            p_logic.

    ENDIF.

  ENDLOOP. &quot;Klassenliste

ENDFORM.                    &quot; interfaces
*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_interface
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LCL_WA_OPTIONS_LOW  text
*----------------------------------------------------------------------*
FORM download_interface USING    p_name TYPE any.
*Variable fuer Laenge des Klassenname
  DATA: lcl_laeng TYPE i.
*Suchstringvariable
  DATA: lcl_such LIKE wa_trdir-name.
*Arbeitsbereich fuer trdir-name
  DATA: lcl_it_trdir_name TYPE STANDARD TABLE OF trdir-name,
        lcl_wa_trdir_name LIKE LINE OF lcl_it_trdir_name.

*Bereich fuer Typgruppentabelle
  DATA: lcl_it_vseotypep TYPE STANDARD TABLE OF vseotypep,
        lcl_wa_vseotypep LIKE LINE OF lcl_it_vseotypep.
*Variable fuer Includenamen einer Typgruppe
  DATA: lcl_typpconv LIKE wa_trdir-name.

*Bereiche fuer implementierte Interfaces
  DATA: lcl_it_seometarel TYPE STANDARD TABLE OF seometarel,
        lcl_wa_seometarel  LIKE LINE OF lcl_it_seometarel.

*Aufbau des Suchstrings

*Laenge des Interfacenamens
  lcl_laeng = STRLEN( p_name ).
*Zeichen &apos;=&apos; anfuegen (kann nicht bei Anlage verwendet werden)
  IF lcl_laeng &lt; 30.
    CONCATENATE p_name &apos;=%I%&apos; INTO lcl_such.
  ELSE.
    CONCATENATE p_name &apos;%I%&apos; INTO lcl_such.
  ENDIF.

  SELECT name FROM trdir INTO TABLE lcl_it_trdir_name
            WHERE name LIKE lcl_such.


*************************************************
*Download der dazugehoerigen Includes
*************************************************
  LOOP AT lcl_it_trdir_name INTO lcl_wa_trdir_name.

    CLEAR ok.
    PERFORM download_include USING   lcl_wa_trdir_name
                                           &apos;J&apos;
                              CHANGING ok .
    IF ok = &apos;X&apos;. &quot;Download war erfolgreich
*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Include&apos;
                                 lcl_wa_trdir_name
                                 p_name.
    ENDIF.

  ENDLOOP.

*2.)Typgruppe dieser Klasse behandeln
*Tabelle in der Zuordnung von Typgruppen zu Klassen stehen
  SELECT * FROM vseotypep INTO TABLE lcl_it_vseotypep
        WHERE clsname = p_name.
  IF NOT ( lcl_it_vseotypep IS INITIAL ).
    LOOP AT lcl_it_vseotypep  INTO lcl_wa_vseotypep.
*Nur herunterladenm, wenn Typegroup in Kundennamensraum
      IF ( ( lcl_wa_vseotypep-typegroup(1) = &apos;Z&apos; )
        OR ( lcl_wa_vseotypep-typegroup(1) = &apos;Y&apos; )
        OR ( lcl_wa_vseotypep-typegroup(g_len_nspace) = p_nspace ) ).
        CLEAR ok.
*Zusammensetzen des Includenamen fuer die Typgruppe
        CONCATENATE &apos;%_C&apos; lcl_wa_vseotypep-typegroup  INTO lcl_typpconv.
*Typgruppeninclude herunterladen
        PERFORM download_include USING   lcl_typpconv
                                         &apos;T&apos;
                                  CHANGING ok .
        IF ok = &apos;X&apos;.  &quot;Download war erfolgreich
*Klassenliste schreiben.
*Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;Typgroup&apos;
                                          lcl_wa_vseotypep-typegroup
                                          global_main_name.

        ENDIF.  &quot;Ok-abfrage
      ENDIF.
    ENDLOOP.
  ENDIF.

*3.)Implementierte Interfaces sichern
* Nur wenn abhängige Objekte berücksichtig werden sollen
  IF NOT g_nodep IS INITIAL.
    EXIT.
  ENDIF.

  SELECT DISTINCT clsname refclsname FROM seometarel
            INTO CORRESPONDING FIELDS OF TABLE lcl_it_seometarel
            WHERE clsname = p_name.

  LOOP AT lcl_it_seometarel INTO lcl_wa_seometarel.

    IF (    ( lcl_wa_seometarel-refclsname(1) = &apos;Z&apos; )
         OR ( lcl_wa_seometarel-refclsname(1) = &apos;Y&apos; )
         OR ( lcl_wa_seometarel-refclsname(g_len_nspace) = p_nspace ) ).


      PERFORM write_global_save USING &apos;I&apos; lcl_wa_seometarel-refclsname.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Interface&apos;
                                 lcl_wa_seometarel-refclsname
                                 global_main_name.
    ENDIF.
  ENDLOOP.
ENDFORM.                    &quot; download_interface
*&amp;---------------------------------------------------------------------*
*&amp;      Form  read_classes
*&amp;---------------------------------------------------------------------*
*       Lesen der Klassentabelle mit dem im Uebergabeparameter
*       P_NAME angegebenen Klassennamen
*----------------------------------------------------------------------*
FORM read_classes USING p_name TYPE c
                   CHANGING p_wa_vseoclass TYPE vseoclass.
  SELECT SINGLE * FROM vseoclass INTO p_wa_vseoclass
         WHERE clsname = p_name.
ENDFORM.                    &quot; read_programs_for_class
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_class
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*     Verarbeitungsroutine fuer Klassen. Fuer die im Parameter
*     P_NAME angegeben Klassen werden die Objekte gesichert.
*----------------------------------------------------------------------*
FORM handle_class USING    p_name TYPE c.
*Bereich fuer Klassenview
  DATA: lcl_it_vseoclass TYPE STANDARD TABLE OF vseoclass,
        lcl_wa_vseoclass LIKE LINE OF lcl_it_vseoclass.
*Bereich fuer Typgruppentabelle
  DATA: lcl_it_vseotypep TYPE STANDARD TABLE OF vseotypep,
        lcl_wa_vseotypep LIKE LINE OF lcl_it_vseotypep.
*Variable fuer Includenamen einer Typgruppe
  DATA: lcl_typpconv LIKE wa_trdir-name.
*Bereiche fuer Interface
  DATA: lcl_it_vseoimplem TYPE STANDARD TABLE OF vseoimplem,
        lcl_wa_vseoimplem  LIKE LINE OF lcl_it_vseoimplem.
*Variable zur Zwischenspeicherung der Stueckliste
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.
*Zwischenspeicherung Pfad
*  DATA: path TYPE rlgrap-filename.
  DATA: path TYPE string.
*Zwischenspeicherugng Pfad fuer Klassen OO
  DATA: it_path TYPE STANDARD TABLE OF string, &quot;rlgrap-filename,
        wa_path LIKE LINE OF it_path.
*Variable fuer Laengenbestimmung
  DATA: lcl_len TYPE i.
*Rootverzeichnis bei Einstieg
*  DATA: lcl_root TYPE rlgrap-filename.
  DATA: lcl_root TYPE string.

*aktuellen Eintrag aus Vererbungsliste löschen wenn Eintrag besteht
  DELETE it_inheritance INDEX 1.


*** Read relevant classes
  PERFORM read_classes USING p_name
                     CHANGING lcl_wa_vseoclass.

*select single  name from trdir into  lcl_wa_trdir_name
*          where name like lcl_such.

**********Ausfuehren des Programmdownloads

  IF NOT ( lcl_wa_vseoclass IS INITIAL ).

*Stueckliste fuer Klasse schreibvne
    PERFORM write_stueckliste USING &apos;Class&apos;
                                lcl_wa_vseoclass-clsname
                                &apos;&apos;.
    global_main_name = lcl_wa_vseoclass-clsname.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
    PERFORM create_directory USING lcl_wa_vseoclass-clsname
                               &apos;C&apos;.
*Abbrechen da es schon existiert
    IF direxists = &apos;X&apos;.
      EXIT.
    ENDIF.

*Ueberschrift zusammenbauen
    CONCATENATE &apos;Class:&apos; lcl_wa_vseoclass-clsname INTO header
          SEPARATED BY space.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.


*1.) Klassenincludes herunterladen
    PERFORM download_classincludes USING lcl_wa_vseoclass-clsname.

*2.)Typgruppe dieser Klasse behandeln
*Tabelle in der Zuordnung von Typgruppen zu Klassen stehen
    SELECT * FROM vseotypep INTO TABLE lcl_it_vseotypep
          WHERE clsname = lcl_wa_vseoclass-clsname.
    IF NOT ( lcl_it_vseotypep IS INITIAL ).
      LOOP AT lcl_it_vseotypep  INTO lcl_wa_vseotypep.
*Nur herunterladenm, wenn Typegroup in Kundennamensraum
        IF ( ( lcl_wa_vseotypep-typegroup(1) = &apos;Z&apos; )
          OR ( lcl_wa_vseotypep-typegroup(1) = &apos;Y&apos; ) ).
          CLEAR ok.
*Zusammensetzen des Includenamen fuer die Typgruppe
          CONCATENATE &apos;%_C&apos; lcl_wa_vseotypep-typegroup  INTO
          lcl_typpconv.
*Typgruppeninclude herunterladen
          PERFORM download_include USING   lcl_typpconv
                                           &apos;T&apos;
                                    CHANGING ok .
          IF ok = &apos;X&apos;.  &quot;Download war erfolgreich
*Klassenliste schreiben.
            CLEAR wa_classlist.
            MOVE  lcl_wa_vseotypep-typegroup TO  wa_classlist-inc.
            MOVE &apos;Typgroup&apos; TO wa_classlist-typus.
            APPEND wa_classlist TO it_classlist.

          ENDIF.  &quot;Ok-abfrage
        ENDIF.
      ENDLOOP.
    ENDIF.

*3.)Uebersichtsliste ueber diese Klasse
    PERFORM download_classlist USING lcl_wa_vseoclass-clsname.


*    Sicherung Pfad fuer Stueckliste in Tabelle um rekursiv darauf z
*    zugreifen zu können
    INSERT new_dir INTO it_path INDEX 1.

*Nur Pfad anlegen wenn nicht innerhalb von Entwicklungsklasse angelegt
    IF p_devc &lt;&gt; &apos;X&apos;.

      SEARCH new_dir FOR &apos;\S\&apos;.
      IF sy-subrc &lt;&gt; 0.
*    Neues Basisverzeichnis fuer alllen weiteren Verarbeitungen
        lcl_root = dir.
        dir = new_dir.
*    Erzeugen des Ausgabeverzeichnisses fuer untergeordnete Objekte
*    Interfaces und Klassen
        PERFORM create_directory USING lcl_wa_vseoclass-clsname
                                       &apos;SUB&apos;.

        dir = new_dir.
      ELSE. &quot;zurück zu bereits erstelltem subpfad
*    Verzeichnis auf Sub-Verzeichnis zurücksetzen
        sy-fdpos = sy-fdpos + 2.
        dir = new_dir(sy-fdpos).
      ENDIF.
    ENDIF.

*4.)Implementierte Interfaces sichern
    SELECT DISTINCT clsname refclsname FROM vseoimplem
              INTO CORRESPONDING FIELDS OF TABLE lcl_it_vseoimplem
              WHERE clsname = lcl_wa_vseoclass-clsname.


    LOOP AT lcl_it_vseoimplem INTO lcl_wa_vseoimplem
      WHERE refclsname(1) = &apos;Z&apos;
        OR  refclsname(1) = &apos;Y&apos;.

      global_main_name = lcl_wa_vseoimplem-refclsname.
*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Interface&apos;
                                 lcl_wa_vseoimplem-refclsname
                                 lcl_wa_vseoclass-clsname.

*Ueberschrift zusammenbauen
      CONCATENATE &apos;Interface:&apos; lcl_wa_vseoimplem-refclsname INTO header
            SEPARATED BY space.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.

*Verzeichnis sichern
*      path = new_dir.
      root = dir.
*      dir = new_dir.
*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
      PERFORM create_directory USING lcl_wa_vseoimplem-refclsname
                                     &apos;I&apos;.
*Stueckliste sichern
      REFRESH lcl_it_prog_stueckliste.
      APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*Eigentlicher Download durchfuehren
      PERFORM download_interface USING lcl_wa_vseoimplem-refclsname.

*Stückliste wiederherstellen und schreiben
      REFRESH it_prog_stueckliste.
      APPEND LINES OF lcl_it_prog_stueckliste TO
                                     it_prog_stueckliste.

*Verzeichnis wiederherstellen
      dir = root.
*      new_dir = path.
    ENDLOOP.


    global_main_name = lcl_wa_vseoclass-clsname.


*5.) Klassen der Vererbungshierarchie sichern
    PERFORM get_class_inheritance USING lcl_wa_vseoclass-clsname.

*6.)Vererbte Klassen herunterladen
    PERFORM download_class_inheritance.

    global_main_name = lcl_wa_vseoclass-clsname.



******abschließende Routinen fuer ganze Klassen
    PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Rekursives Lesen des Pfades
    READ TABLE it_path INDEX 1 INTO wa_path.
    new_dir =  wa_path.
    DELETE it_path INDEX 1.

*Domaenen downloaden
    PERFORM download_domains.
*Datenelementliste downloaden
    PERFORM download_dataelements.
*Berechtigungsobjekt Infos downloaden
    PERFORM download_authorityobjects.
*Titlebars herunterladen
    PERFORM download_titlebar.
*Meldungen herunterladen
    PERFORM download_messages.
*Gesamtliste der Transaktionscodes herunterladen
    PERFORM download_tacodelist.
*Gesamtliste mit Dialogbaustein-&gt;Funktionsbausteinzuordnung
*herunterladen und Gesamtliste mit Dialogpoolparametern herunterladen.
    PERFORM download_dialogmodule_elements.
*Gesamtliste der Parameter herunterschreiben
    PERFORM download_setgetparams.
*Gesamtstückliste
    PERFORM download_stueckliste.

*HotPackagestand sichern
    PERFORM download_hpstand.
*  SKIP.  &quot;Listausgabeformatierung
    PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


*7.)Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
*Globalen Namen setzen
    lcl_name = global_main_name.
*Sicherung und Initialisierung der globalen Tabellen
    PERFORM initialize.
*7Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
    PERFORM handle_externalprogs.

*Ruecksicherung des Verzeichnisses
    dir = lcl_root.


  ENDIF. &quot;Klasse gefunden??

ENDFORM.                    &quot; handle_class
*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_classincludes
*&amp;---------------------------------------------------------------------*
*       Verarbeitung der Objekte von Klassen die auf Includes
*       basieren. Insbesondere Objekte fuer deren Selektion das
*       Classpoolinclude notwendig ist.
*----------------------------------------------------------------------*
FORM download_classincludes USING    p_name TYPE c.
*Varible fuer Laenge einer Zeichenkette
  DATA: lcl_laeng TYPE i.
*Suchstringvariable
  DATA: lcl_such LIKE wa_trdir-name.
*Lokaler Bereich fuer trdir
  DATA: lcl_it_trdir TYPE STANDARD TABLE OF trdir,
        lcl_wa_trdir LIKE LINE OF lcl_it_trdir.
*Variabel fuer Maininclude
  DATA: mainname LIKE wa_trdir-name.
*Aufbau des Suchstrings
*Das evtl &apos;*&apos; Zeichen durch % ersetzen
  REPLACE &apos;*&apos; WITH &apos;%&apos; INTO  p_name.
  WHILE sy-subrc &lt;&gt; 4. &quot;Ein Vorkommen
    REPLACE &apos;*&apos; WITH &apos;%&apos; INTO  p_name.
  ENDWHILE.
*Laenge des Klassennamens
  lcl_laeng = STRLEN( p_name ).
*Zeichen &apos;=&apos; anfuegen (kann nicht bei Anlage verwendet werden)
  IF lcl_laeng &lt; 30.
    CONCATENATE p_name &apos;=%&apos; INTO lcl_such.
  ELSE.
    CONCATENATE p_name &apos;%&apos; INTO lcl_such.
  ENDIF.

*Alle Includes selektieren
  SELECT * FROM trdir INTO TABLE lcl_it_trdir
      WHERE name LIKE lcl_such.

  LOOP AT lcl_it_trdir INTO lcl_wa_trdir.
*Rahmenprogramm herunterladen
    CLEAR ok.
    PERFORM download_include USING lcl_wa_trdir-name
                                   &apos;C&apos;
                                    CHANGING ok.
*Ok wird nicht abgefragt da Klassenliste nicht geschrieben wird.

*wenn Rahmeninclude: Bezug auf alle Teile der Klasse
*Rahmeninclude zusammenbauen
*  concatenate lcl_such &apos;CP&apos; into lcl_such.
    IF lcl_wa_trdir-name+30(2) = &apos;CP&apos;.
*Externe Verweise herunterladen
      PERFORM handle_extprog USING lcl_wa_trdir-name.

*Textelemente
      PERFORM download_textelements USING lcl_wa_trdir-name
                                        &apos;R&apos;.

*Datadictionaryobjekte
      PERFORM handle_ddic USING lcl_wa_trdir-name
                              &apos;R&apos;.

*Benutzte Klassen und Interface behandeln
      PERFORM handle_classinterface USING lcl_wa_trdir-name
                                          &apos;R&apos;.


*Selbstaufrufe der Klasse loeschen.
      DELETE it_prog_stueckliste WHERE type = &apos;Class(OO)&apos;
                                    AND name = p_name
                                    AND obername = lcl_wa_trdir-name.

*Koennnen nicht fuer Klassen angelegt werden
**Echter Screen des Rahmenprogramms herunterladen
*      PERFORM handle_screens USING lcl_wa_trdir-name
*                                   &apos;R&apos;.
**pf-Stati verarbeiten
*      PERFORM handle_pf_status USING lcl_wa_trdir-name
*                                     &apos;R&apos;.
*
**Titlebars suchen
*      PERFORM handle_titlebar USING lcl_wa_trdir-name
*                                  &apos;R&apos;.


*eventueller Transaktionscode zu Rahmenprogramm
      PERFORM handle_tacode_for_class USING p_name.


    ENDIF.

  ENDLOOP.


ENDFORM.                    &quot; download_classincludes
*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_class_inheritance
*&amp;---------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
*      Vererbungshierarchie der im Parameter p_name uebergebenen
*      Klasse wird im Kundennamensraum ermittelt. Die ermittelten
*      Klassen werden in eine globale Tabelle zur spaeteren Verarbeitung
*      gespeichert.
*----------------------------------------------------------------------*
FORM get_class_inheritance USING   p_name TYPE c.
  DATA: lcl_wa_inheritance TYPE inheritance.

  SELECT SINGLE clsname refclsname FROM vseoextend
      INTO lcl_wa_inheritance
      WHERE  clsname = p_name
      AND   ( ( refclsname LIKE &apos;Z%&apos; )
                 OR ( refclsname LIKE &apos;Y%&apos; )
                 OR ( refclsname LIKE g_name )  ).
  IF sy-subrc = 0.
    APPEND lcl_wa_inheritance TO it_inheritance.
  ENDIF.
*Vererbungshierarchie aufwärts durcharbeiten wenn im
*Kundennamensraum
  WHILE ( sy-subrc = 0 ).
    SELECT SINGLE clsname refclsname FROM vseoextend
      INTO lcl_wa_inheritance
      WHERE clsname = lcl_wa_inheritance-super
      AND  ( ( refclsname LIKE &apos;Z%&apos; )
               OR   ( refclsname LIKE &apos;Y%&apos; )
               OR ( refclsname LIKE g_name ) ).
    IF sy-subrc = 0.
      APPEND lcl_wa_inheritance TO it_inheritance.
    ENDIF.
  ENDWHILE.


ENDFORM.                    &quot; get_class_inheritance
*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_class_inheritance
*&amp;---------------------------------------------------------------------*
*       Klassen der Vererbungshierarchie (globale Tabelle) werden
*       durch die Verarbeitungsroutine fuer Klassen.
*----------------------------------------------------------------------*
FORM download_class_inheritance.
*Sicherungsvariable
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste.
*  DATA: path TYPE rlgrap-filename.
  DATA: path TYPE string.


  LOOP AT it_inheritance INTO wa_inheritance.
*Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Class(OO)&apos;
                               wa_inheritance-super
                               wa_inheritance-sub.

*Verzeichnis sichern
    path = new_dir.
    root = dir.
    dir = new_dir.
*Stueckliste sichern
    REFRESH lcl_it_prog_stueckliste.
    APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.


*Klasse verarbeiten
    PERFORM initialize.
    PERFORM handle_class USING wa_inheritance-super.

*Stückliste wiederherstellen und schreiben
    REFRESH it_prog_stueckliste.
    APPEND LINES OF lcl_it_prog_stueckliste TO
                                   it_prog_stueckliste.

*Verzeichnis wiederherstellen
    dir = root.
    new_dir = path.

  ENDLOOP.


ENDFORM.                    &quot; download_class_inheritance
*&amp;---------------------------------------------------------------------*
*&amp;      Form  trkorr_handle_single_method
*&amp;---------------------------------------------------------------------*
*     Einzelne Methode aus einem Transportauftrag in
*     lokales Dateisystem sichern.
*----------------------------------------------------------------------*
FORM trkorr_handle_single_method USING    p_name TYPE c.
*Variablen für den Suchstring
  DATA: lcl_such LIKE wa_trdir-name.
*Variable fuer Anzahl der Zeilen der internen Tabelle
  DATA: lcl_lines TYPE i.
*Variable fuer Zaehler der do-Schleife
  DATA: lcl_zaehler TYPE i.
*Arbeitsbereich fuer tmdir
  DATA: lcl_it_tmdir TYPE STANDARD TABLE OF tmdir,
        lcl_wa_tmdir LIKE LINE OF lcl_it_tmdir.
*Arbeitsbereich fuer trdir
  DATA: lcl_it_trdir TYPE STANDARD TABLE OF trdir,
        lcl_wa_trdir LIKE LINE OF lcl_it_trdir.
*Varible um Laenge des uebergeben Strings zu ermittlen
  DATA: lcl_laeng TYPE i.
*Variable fuer Klassen- und Methodenname
  DATA: lcl_class LIKE lcl_wa_tmdir-classname,
        lcl_method LIKE lcl_wa_tmdir-methodname.
*Bereiche lokale Klassenliste
  DATA: lcl_it_classlist TYPE STANDARD TABLE OF classlist,
        lcl_wa_classlist LIKE LINE OF lcl_it_classlist.


  lcl_class = p_name(30).
  lcl_method = p_name+30.

*1.) Suchen des passenden Methodenincludes zu der Methode
**************************************************************

*Suchstring zur Selektion der Trdir aufbauen
  CONCATENATE lcl_class &apos;%CM___&apos; INTO lcl_such.

*Alle relevanten Includes aus Trdir lesen
  SELECT * FROM trdir INTO TABLE lcl_it_trdir
        WHERE name  LIKE lcl_such.

*Ueberpruefen, ob die Selektierten Includes den Namenkonventionen
*fuer Methodenincludes entsprechen.
  LOOP AT lcl_it_trdir INTO lcl_wa_trdir.
*Wenn Laenge ungleich 35 ist diese Zeile aus interner Tabelle loeschen
*(Methodenincludes haben Laenge 35; normale Includes dürfen nur Laenge
*30 haben).
    lcl_laeng = STRLEN( lcl_wa_trdir-name ).
    IF lcl_laeng &lt;&gt; 35.
      DELETE lcl_it_trdir FROM sy-tabix.
      CONTINUE.
    ENDIF.
  ENDLOOP.

*Tabelle mit forlaufenden Nummern der Methoden selektieren
  SELECT * FROM tmdir INTO TABLE lcl_it_tmdir
        WHERE classname = lcl_class.

*Sortierung der beiden Tabellen dass sie spaeter gemischt werden
*koennen.
  SORT lcl_it_trdir BY name ASCENDING.
  SORT lcl_it_tmdir BY methodindx ASCENDING .

*Nur Saetze die einen Index haben sind relevant
  DELETE lcl_it_tmdir WHERE methodindx IS INITIAL.

*Anzahl der Saetze ermittlen fuer Schleife zum Mischen.
  DESCRIBE TABLE lcl_it_trdir LINES lcl_lines.

*Abmischen der der beiden Tabellen in Gesamttabelle
  lcl_zaehler = 1.
  DO lcl_lines TIMES.
    READ TABLE lcl_it_trdir INDEX lcl_zaehler INTO lcl_wa_trdir.
    READ TABLE lcl_it_tmdir INDEX lcl_zaehler INTO lcl_wa_tmdir.
    MOVE  &apos;Meth&apos; TO lcl_wa_classlist-typus.
    MOVE  lcl_wa_trdir-name TO lcl_wa_classlist-inc.
    MOVE  lcl_wa_tmdir-methodname TO lcl_wa_classlist-meth.
    APPEND lcl_wa_classlist TO lcl_it_classlist.
    lcl_zaehler = lcl_zaehler + 1.
  ENDDO.

*Die Zeile mit der gesuchten Methode lesen
  READ TABLE lcl_it_classlist
      WITH KEY meth = lcl_method
      INTO lcl_wa_classlist.

*Include herunterladen
  CLEAR ok.
  PERFORM download_include USING lcl_wa_classlist-inc &apos;C&apos;
                           CHANGING ok.
*Download war erfolgreich
  IF ok = &apos;X&apos;.
*Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Method&apos;
                                  lcl_wa_classlist-meth
                                  global_main_name.

*Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Methodinclude&apos;
                                  lcl_wa_classlist-inc
                                  lcl_wa_classlist-meth.

  ENDIF.


ENDFORM.                    &quot; trkorr_handle_single_method
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_modis
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Modifikationen aus dem
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Jede selektierte Modifikation wird gesichert.
*      Es werden Includes, Funktionsbausteine und Screen unterstuetzt
*----------------------------------------------------------------------*
FORM handle_modis.
*Loakaler Bereich fuer trdir
  DATA: lcl_it_trdir LIKE it_trdir,
        lcl_wa_trdir LIKE LINE OF lcl_it_trdir.
*Bereich fuer tfdir
  DATA: lcl_it_tfdir TYPE STANDARD TABLE OF tfdir,
        lcl_wa_tfdir LIKE LINE OF lcl_it_tfdir.
*Includename fuer Funktionsbaustein
  DATA: lcl_funcinclude LIKE wa_trdir-name.
*Bereiche fuer smodilog:Modifikationstabelle
  DATA: lcl_it_smodilog TYPE STANDARD TABLE OF smodilog,
        lcl_wa_smodilog LIKE LINE OF lcl_it_smodilog.
*Bereich fuer d020s: Screeninformationen
  DATA: lcl_wa_d020s TYPE d020s.

*Flag, ob Ueberschrift schon geschrieben worden ist
  DATA: lcl_header TYPE c.

*Nur auswählen, wenn Modis selektiert sind.
  IF NOT ( o_inc IS INITIAL AND o_func IS INITIAL AND o_dynp IS INITIAL
  ).
    global_main_name = &apos;Modification&apos;.

*Initialisieren der Stueckliste
    REFRESH it_prog_stueckliste.

*Sicherung Verzeichnis
    IF ( new_dir  IS INITIAL ).
      root = dir.
    ELSE.
      root = new_dir.
    ENDIF.

*Verabeitung Selektion der modfizierten Includes
    IF NOT ( o_inc IS INITIAL ).
*Selektion abfangen
      SELECT * FROM trdir INTO TABLE lcl_it_trdir
           WHERE name IN o_inc
            AND  name NOT LIKE &apos;Z%&apos;
            AND  name NOT LIKE &apos;Y%&apos;
            AND  name NOT LIKE g_name.

*Wenn keine Werte gefunden Info-Melungen anzeigen
      IF lcl_it_trdir IS INITIAL.
        MESSAGE i888(sabapdocu) WITH
       &apos;No suitable Selection&apos; &apos;for modificated Includes! &apos;
       &apos;Please check your selelction. &apos;
       &apos;The program will process your other selections.&apos;.

      ELSE.
*Wenn noch nicht geschrieben Ueberschrift schreiben
        IF lcl_header IS INITIAL.
*Protokollliste schreiben.
          PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; &apos;Modifications:&apos;.

*      Flag setzen
          lcl_header = &apos;X&apos;.
        ENDIF.


*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
        PERFORM create_directory USING global_main_name
                                       &apos;M&apos;.

        LOOP AT lcl_it_trdir INTO lcl_wa_trdir.
*  Include herunterladen
          CLEAR ok.
          PERFORM download_include USING lcl_wa_trdir-name &apos;I&apos;
                                   CHANGING ok.
*  Download war erfolgreich
          IF ok = &apos;X&apos;.
*  Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Include(Modi)&apos;
                                          lcl_wa_trdir-name
                                          global_main_name.
          ENDIF.

*  Stueckliste fuer logische Entwicklung

          IF NOT ( p_logic IS INITIAL ).
            PERFORM write_log_stueckliste USING   &apos;Include(Modi)&apos;
                                                  lcl_wa_trdir-name
                                                  p_logic.

          ENDIF. &quot;logiche Entwicklung ???
        ENDLOOP. &quot;selektierte Einträge
      ENDIF. &quot;gueltige Selektion
    ENDIF. &quot;Includes


*Verarbeitung der modifizierten Funktionsbausteine
    IF NOT ( o_func IS INITIAL ) .

      SELECT * FROM tfdir INTO TABLE lcl_it_tfdir
        WHERE funcname IN o_func
       AND   funcname NOT LIKE &apos;Z%&apos;
       AND   funcname NOT LIKE &apos;Y%&apos;
       AND   funcname NOT LIKE g_name.

*Wenn keine Werte gefunden Info-Melungen anzeigen
      IF lcl_it_tfdir IS INITIAL.
        MESSAGE i888(sabapdocu) WITH
       &apos;No suitable selection&apos; &apos;for modificated &apos;
       &apos;Functiionmodules! Please check your selection. &apos;
       &apos;The program will process your other selections.&apos;.

      ELSE.

*Wenn noch nicht geschrieben Ueberschrift schreiben
        IF lcl_header IS INITIAL.
*Protokollliste schreiben.
          PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; &apos;Modifications:&apos;.

*      Flag setzen
          lcl_header = &apos;X&apos;.
        ENDIF.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
        PERFORM create_directory USING global_main_name
                                       &apos;M&apos;.


        LOOP AT lcl_it_tfdir INTO lcl_wa_tfdir.
          CONCATENATE lcl_wa_tfdir-pname+3 &apos;U&apos; lcl_wa_tfdir-include
                   INTO   lcl_funcinclude.
*    Include herunterladen
          CLEAR ok.
          PERFORM download_include USING lcl_funcinclude &apos;I&apos;
                                   CHANGING ok.
*    Download war erfolgreich
          IF ok = &apos;X&apos;.
*    Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Functionmodule(Modi)&apos;
                                          lcl_wa_tfdir-funcname
                                          global_main_name.

            PERFORM write_stueckliste USING &apos;Functioninclude(Modi)&apos;
                                          lcl_funcinclude
                                          lcl_wa_tfdir-funcname.


          ENDIF. &quot;Donwload erfolgreich

*    Stueckliste fuer logische Entwicklung
          IF NOT ( p_logic IS INITIAL ).
            PERFORM write_log_stueckliste USING   &apos;Functionmodule(Modi)&apos;
                                                   lcl_wa_tfdir-funcname
                                                     p_logic.

          ENDIF.

        ENDLOOP.
      ENDIF. &quot;gültige Selektion FB&apos;s
    ENDIF.  &quot;Funktionsbausteine

    IF NOT ( o_dynp IS INITIAL ).
      SELECT * FROM smodilog INTO TABLE lcl_it_smodilog
      WHERE sub_name IN o_dynp.

      SORT lcl_it_smodilog.
*    Duplikate loeschen
      DELETE ADJACENT DUPLICATES FROM lcl_it_smodilog
          COMPARING obj_name sub_name.

*Wenn keine Werte gefunden Info-Melungen anzeigen
      IF lcl_it_smodilog IS INITIAL.
        MESSAGE i888(sabapdocu) WITH
       &apos;No suitable selection&apos; &apos;for modificated &apos;
       &apos;Screens! Please check your selection. &apos;
       &apos;The program will process your other selections.&apos;.

      ELSE.

*Wenn noch nicht geschrieben Ueberschrift schreiben
        IF lcl_header IS INITIAL.
*Protokollliste schreiben.
          PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; &apos;Modifications:&apos;.

*      Flag setzen
          lcl_header = &apos;X&apos;.
        ENDIF.


*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
*Kein Handling wenn bereits angelegt wegen
        PERFORM create_directory USING global_main_name
                                       &apos;M&apos;.


        LOOP AT lcl_it_smodilog INTO lcl_wa_smodilog.

          SELECT SINGLE prog dnum FROM d020s INTO lcl_wa_d020s
                      WHERE prog = lcl_wa_smodilog-sub_name(40)
                AND dnum = lcl_wa_smodilog-sub_name+40.

          PERFORM download_dynpro USING lcl_wa_d020s.
*  Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;Dynpro(Modi)&apos;
                                        lcl_wa_smodilog-sub_name
                                        global_main_name.

*  Stueckliste fuer logische Entwicklung
          IF NOT ( p_logic IS INITIAL ).
            PERFORM write_log_stueckliste USING   &apos;Screen(Modi)&apos;
                                               lcl_wa_smodilog-sub_name
                                                  p_logic.

          ENDIF.
        ENDLOOP.
      ENDIF. &quot;gültige Selektion?
    ENDIF.&quot;Screeen ausgewählt?
*Stueckliste sichern
    IF NOT ( it_prog_stueckliste IS INITIAL ).
*Trennung von Einzeldateiobjekten
*    uline.
      PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
      PERFORM download_stueckliste.
*HP-Stand sichern
      PERFORM download_hpstand.
*Leerzeile nach Ende dieser Verarbeitung
*    skip.
      PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
    ENDIF.
*Ruecksicherung des Verzeichnisse
    new_dir = root.
  ENDIF.   &quot;Gesamtfleder
ENDFORM.                    &quot; handle_modis
*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_global_save
*&amp;---------------------------------------------------------------------*
*      Schreiben der globalen Tabelle fuer Rahmenprogramme, die
*      später verarbeitet werden.
*----------------------------------------------------------------------*
FORM write_global_save USING    p_typus TYPE c
                                p_name TYPE c.
  DATA: lcl_wa_global_save LIKE wa_global_save.

  MOVE p_typus TO lcl_wa_global_save-type.
  MOVE p_name TO lcl_wa_global_save-name.
  APPEND lcl_wa_global_save TO it_global_save.

ENDFORM.                    &quot; write_global_save
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_externalprogs
*&amp;---------------------------------------------------------------------*
*       Abarbeitung der Tabelle mit den Rahmenprogrammen, die
*       spaeter abgearbeitet werden. Je nach Typ des Rahmenprogramms
*       werden die entsprechenden Verarbeitungsroutinen abgearbeitet.
*----------------------------------------------------------------------*
FORM handle_externalprogs.
*Flag fuer extern Verarbeitung setzen
  extern = &apos;X&apos;.

*Duplikate loeschen
  SORT it_global_save.
  DELETE ADJACENT DUPLICATES FROM it_global_save COMPARING ALL FIELDS.

*solange ein eintrag drin ist diesen lesen; und danach loeschen
  WHILE NOT ( it_global_save IS INITIAL ).

    CLEAR wa_global_save.
    READ TABLE it_global_save INDEX 1 INTO wa_global_save.

*Ueberpruefen, ob schon gespeichert als Oberprogramm
    READ TABLE it_obj_list WITH KEY name = wa_global_save-name
                   TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.
*globale Tabellen Initialisieren
      PERFORM initialize.
**Globalen Namen fuellen
      global_main_name = wa_global_save-name.

*Verzeichnis sichern:
      root = dir.
      dir = new_dir.
      IF wa_global_save-type = &apos;1&apos;.
        PERFORM handle_extprog_report USING wa_global_save.
      ELSEIF wa_global_save-type = &apos;F&apos;.
        PERFORM handle_extprog_fkgrp USING wa_global_save.
      ELSEIF wa_global_save-type = &apos;C&apos;.
        PERFORM handle_class_extern USING wa_global_save-name.
      ELSEIF wa_global_save-type = &apos;I&apos;.
        PERFORM handle_interface_extern USING wa_global_save.
      ENDIF.
*Verzeichnis zurücksichern
      new_dir = dir.
      dir = root.
    ENDIF. &quot;Bereits gesichert

*Dieses Rahmenprogramm loeschen; Stack
    DELETE it_global_save INDEX 1.
  ENDWHILE.

*Flag fuer externe Verarbeitung ausschalten
  CLEAR extern.
ENDFORM.                    &quot; handle_externalprogs
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_extprog_report
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      Verarbeitung der Reports/Modulpools, die zu spaeteren Zeitpunkt
*      verarbeitet werden. (siehe auch Routine handle_reps_mods)
*----------------------------------------------------------------------*
FORM handle_extprog_report USING  p_wa_global_save LIKE wa_global_save.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.

*Existiert das Programm überhaupt?
  DATA: lcl_wa_trdir TYPE trdir.
  SELECT SINGLE * FROM trdir INTO lcl_wa_trdir
     WHERE name = p_wa_global_save-name
       AND ( ( subc = &apos;1&apos; ) OR ( subc =&apos;M&apos; )
             OR ( subc =&apos;S&apos; ) ). &quot;Report o. Modulpool
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.

*Globalen Namen setzen
  lcl_name = global_main_name.
  global_main_name = p_wa_global_save-name.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_wa_global_save-name
                                 &apos;R&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.


**********Ausfuehren des Programmdownloads
*Ueberschrift zusammenbauen
  CONCATENATE &apos;Report/Modulpool:&apos; p_wa_global_save-name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************


*Rahmenprogramm herunterladen
  CLEAR ok.
  PERFORM download_include USING p_wa_global_save-name &apos;R&apos;
                           CHANGING ok.
*Download war erfolgreich
  IF ok = &apos;X&apos;.
*Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Report/Modulpool&apos;
                                  p_wa_global_save-name
                                  &apos;&apos;.
  ENDIF.
*Textelemente des Rahmenprogramms herunterladen
  PERFORM download_textelements USING p_wa_global_save-name
                                      &apos;R&apos;.
*Stueckliste wird in &apos;download_textelements&apos; geschrieben

*Echter Screen des Rahmenprogramms herunterladen
  PERFORM handle_screens USING p_wa_global_save-name
                               &apos;R&apos;.
*pf-Stati verarbeiten
  PERFORM handle_pf_status USING p_wa_global_save-name
                                 &apos;R&apos;.

*Titlebars suchen
  PERFORM handle_titlebar USING p_wa_global_save-name
                                &apos;R&apos;.
*eventueller Transaktionscode zu Rahmenprogramm
  PERFORM handle_tacode USING p_wa_global_save-name.

*Normale Includes des Rahmenprogramms herunterladen
  PERFORM handle_normal_includes USING p_wa_global_save-name.


*Klassen und Interface behandeln
  PERFORM handle_classinterface USING p_wa_global_save-name
                                      &apos;R&apos;.
*Tabellen/Strukturen herunterladen
  PERFORM handle_ddic USING p_wa_global_save-name
                             &apos;R&apos; .


*Externe Programmaufrufe, Funktionsbausteine und Messages
*des Rahmenprogramms behandeln.

  PERFORM handle_extprog USING global_main_name.



*Aktivitäten die sich auf gesamtes Rahmenprogramm beziehen

*  ULINE.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Domaenen downloaden
  PERFORM download_domains.
*Datenelementliste downloaden
  PERFORM download_dataelements.
*Berechtigungsobjekt Infos downloaden
  PERFORM download_authorityobjects.
*Titlebars herunterladen
  PERFORM download_titlebar.
*Meldungen herunterladen
  PERFORM download_messages.
*Gesamtliste der Transaktionscodes herunterladen
  PERFORM download_tacodelist.
*Gesamtliste mit Dialogbaustein-&gt;Funktionsbausteinzuordnung
*herunterladen und Gesamtliste mit Dialogpoolparametern herunterladen.
  PERFORM download_dialogmodule_elements.
*Gesamtliste der Parameter herunterschreiben
  PERFORM download_setgetparams.
*Gesamtstückliste
  PERFORM download_stueckliste.

*HP-Stand sichern
  PERFORM download_hpstand.

*  SKIP.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*globalen Namen setzen
  global_main_name = lcl_name.
ENDFORM.                    &quot; handle_extprog_report
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_extprog_fkgrp
*&amp;---------------------------------------------------------------------*
*      Verarbeitung der Funktionsgruppen, die zu einem spaeteren
*      Zeitpunkt verarbeitet werden. (siehe auch Routine
*      handle_functiongroup)
*----------------------------------------------------------------------*

FORM handle_extprog_fkgrp USING    p_wa_global_save LIKE wa_global_save.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Functiongroup:&apos; p_wa_global_save-name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_wa_global_save-name
                                 &apos;F&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Stuecklisteneintrag fuer diese Funktionsgruppe.
  PERFORM write_stueckliste USING    &apos;Functiongroup&apos;
                                      p_wa_global_save-name
                                      &apos;&apos;.

*1.) Funktionsgruppe herunterladen
  PERFORM download_functiongroup USING p_wa_global_save-name.
*2) Externe Verweise herunterladen
  PERFORM handle_extprog USING p_wa_global_save-name.

*Aktivitäten die sich auf gesamtes Rahmenprogramm beziehen

*  ULINE.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Domaenen downloaden
  PERFORM download_domains.
*Datenelementliste downloaden
  PERFORM download_dataelements.
*Berechtigungsobjekt Infos downloaden
  PERFORM download_authorityobjects.
*Titlebars herunterladen
  PERFORM download_titlebar.
*Meldungen herunterladen
  PERFORM download_messages.
*Gesamtliste der Transaktionscodes herunterladen
  PERFORM download_tacodelist.
*Gesamtliste der Parameter herunterschreiben
  PERFORM download_setgetparams.
*Gesamtstückliste
  PERFORM download_stueckliste.

*HP-Stand sichern
  PERFORM download_hpstand.

  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


ENDFORM.                    &quot; handle_extprog_fkgrp
*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_performs_from_include
*&amp;---------------------------------------------------------------------*
*       Ermittelt die Aufgerufenen Formroutinen des im Parameter
*       P_INC übermittelten Includes. Die Tabelle der Formroutinen
*       wird an den Aufrufer zurueckgegeben (p_it_performs).
*----------------------------------------------------------------------*
FORM get_performs_from_include USING p_inc LIKE wa_trdir-name
                   CHANGING p_it_performs TYPE performtab.

*ABAP-Sourcentabelle
  DATA: lcl_abap TYPE STANDARD TABLE OF abaptxt255.  &quot;abapsource .
*Tabelle mit zu durschsuchende Schluesselwörtern
  DATA: BEGIN OF lcl_it_keys OCCURS 15,
           keywords(30),
        END OF lcl_it_keys.
*Token-Bereich fuer scan abap
  DATA: lcl_it_token TYPE STANDARD TABLE OF stoken.
  DATA: lcl_wa_token LIKE LINE OF lcl_it_token.
*Statement-Tabelle fuer abap scan
  DATA: lcl_it_statements TYPE STANDARD TABLE OF sstmnt.

  DATA: lcl_index TYPE i.

  APPEND &apos;PERFORM&apos; TO lcl_it_keys.


  READ REPORT p_inc INTO lcl_abap.

  SCAN ABAP-SOURCE downtab KEYWORDS FROM lcl_it_keys
                           TOKENS INTO lcl_it_token
                           STATEMENTS INTO lcl_it_statements.

  LOOP AT lcl_it_token INTO lcl_wa_token.
    IF lcl_wa_token-str = &apos;PERFORM&apos;.
      lcl_index = sy-tabix + 1.
      READ TABLE lcl_it_token INDEX lcl_index INTO lcl_wa_token.
      APPEND lcl_wa_token-str TO p_it_performs.
    ENDIF.
  ENDLOOP.

  SORT p_it_performs.
*Duplikate loeschen
  DELETE ADJACENT DUPLICATES FROM p_it_performs COMPARING ALL FIELDS.



ENDFORM.                    &quot; get_performs_from_include
*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_includes_of_forms
*&amp;---------------------------------------------------------------------*
*       Ermittelt aus der uebergebenen Tabelle der aufgerufenen
*      (Parameter P_IT_FORMS) Form-Routinen die
*       Includes in denen die Routinen stehen.
*----------------------------------------------------------------------*
FORM get_includes_of_forms
          USING p_it_forms TYPE performtab
                p_inc LIKE wa_trdir-name
          CHANGING p_it_includes TYPE includetab.

*Arbeitsbereich fuer Forms
  DATA: lcl_wa_forms TYPE string.
*Variable fuer Inclde in dem include steht
  DATA: lcl_wa_includes TYPE include.
*Dummytabellen zum Aufruf des Funktionsbausteins
  DATA: lcl_it_source TYPE STANDARD TABLE OF abaptxt255,  &quot;abapsource
        lcl_it_form TYPE STANDARD TABLE OF abaptxt255.  &quot;abapsource .
  DATA: lcl_objectname TYPE string,
        lcl_objecttype TYPE string,
        lcl_program TYPE string,
        lcl_operation TYPE string.
  LOOP AT p_it_forms INTO lcl_wa_forms.

    CLEAR lcl_wa_includes.


    CALL FUNCTION &apos;RS_SEARCH_FORM&apos;
      EXPORTING
        i_incl       = p_inc
        i_objectname = lcl_wa_forms
      IMPORTING
        o_incl       = lcl_wa_includes
        o_objectname = lcl_objectname
        o_objecttype = lcl_objecttype
        o_program    = lcl_program
        o_operation  = lcl_operation
      TABLES
        i_source     = lcl_it_source
        o_form_tab   = lcl_it_form.

    APPEND lcl_wa_includes TO p_it_includes.

  ENDLOOP.

  SORT p_it_includes.
*Duplikate loeschen

  DELETE ADJACENT DUPLICATES FROM p_it_includes COMPARING ALL FIELDS.

ENDFORM.                    &quot; get_includes_of_forms
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_reps_mods
*&amp;---------------------------------------------------------------------*
*       Verarbeitungsroutine fuer einen Report/Modulpool der im
*       Parameter P_NAME uebergebene wird. Die unterstuetzten
*       Objekte werden in das Filesystem gesichert.
*----------------------------------------------------------------------*
FORM handle_reps_mods USING    p_name TYPE trdir-name.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.


*Globales Namensfeld füllen
  global_main_name = p_name.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_name
                                 &apos;R&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Report/Modulpool:&apos; global_main_name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

*Intitialisieren der globalen Tabellen
  PERFORM initialize.


**Die folgenden Elemente nur behandeln wenn das Rahmengprogramm
**im Kundennamensraum liegt.
*  IF ( ( p_name(1) = &apos;Z&apos; ) OR ( p_name(1) = &apos;Y&apos; ) ).


*Rahmenprogramm herunterladen
  CLEAR ok.
  PERFORM download_include USING p_name &apos;R&apos;
                           CHANGING ok.
*Download war erfolgreich
  IF ok = &apos;X&apos;.
*Stueckliste schreiben
    PERFORM write_stueckliste USING &apos;Report/Modulpool&apos;
                                  p_name
                                  &apos;&apos;.
  ENDIF.
*Textelemente des Rahmenprogramms herunterladen
  PERFORM download_textelements USING p_name
                                      &apos;R&apos;.
*Stueckliste wird in &apos;download_textelements&apos; geschrieben

*Echter Screen des Rahmenprogramms herunterladen
  PERFORM handle_screens USING p_name
                               &apos;R&apos;.
*pf-Stati verarbeiten
  PERFORM handle_pf_status USING p_name
                                 &apos;R&apos;.

*Titlebars suchen
  PERFORM handle_titlebar USING p_name
                                &apos;R&apos;.
*eventueller Transaktionscode zu Rahmenprogramm
  PERFORM handle_tacode USING p_name.
*  ENDIF.
*Normale Includes des Rahmenprogramms herunterladen
  PERFORM handle_normal_includes USING p_name.


*Klassen und Interface behandeln
  PERFORM handle_classinterface USING p_name
                                      &apos;R&apos;.
*Tabellen/Strukturen herunterladen
  PERFORM handle_ddic USING p_name
                             &apos;R&apos; .

*Externe Programmaufrufe, Funktionsbausteine und Messages
*des Rahmenprogramms behandeln.
  PERFORM handle_extprog USING p_name.


*Aktivitäten die sich auf gesamtes Rahmenprogramm beziehen

*  ULINE.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Domaenen downloaden
  PERFORM download_domains.
*Datenelementliste downloaden
  PERFORM download_dataelements.
*Berechtigungsobjekt Infos downloaden
  PERFORM download_authorityobjects.
*Titlebars herunterladen
  PERFORM download_titlebar.
*Meldungen herunterladen
  PERFORM download_messages.
*Gesamtliste der Transaktionscodes herunterladen
  PERFORM download_tacodelist.
*Gesamtliste mit Dialogbaustein-&gt;Funktionsbausteinzuordnung
*herunterladen und Gesamtliste mit Dialogpoolparametern herunterladen.
  PERFORM download_dialogmodule_elements.
*Gesamtliste der Parameter herunterschreiben
  PERFORM download_setgetparams.
*Gesamtstückliste
  PERFORM download_stueckliste.

  PERFORM download_hpstand.

*  SKIP.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

* Verarbeitung der extern aufgerufenen Programme
* Globalen Namen setzen
  lcl_name = global_main_name.
  PERFORM initialize.
* Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
  PERFORM handle_externalprogs.
* globalen Namen setzen
  global_main_name = lcl_name.

ENDFORM.                    &quot; handle_reps_mods
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_functiongroup
*&amp;---------------------------------------------------------------------*
*       Verarbeitungsroutine fuer eine Funktionsgruppe die im
*       Parameter P_NAME uebergebene wird. Die unterstuetzten
*       Objekte werden in das Filesystem gesichert.
*----------------------------------------------------------------------*
FORM handle_functiongroup USING   p_name TYPE trdir-name.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_name
                                 &apos;F&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Functiongroup:&apos; global_main_name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

*Intitialisieren der globalen Tabellen
  PERFORM initialize.

*Stuecklisteneintrag fuer diese Funktionsgruppe.
  PERFORM write_stueckliste USING    &apos;Functiongroup&apos;
                                      global_main_name
                                      &apos;&apos;.

*1.) Funktionsgruppe herunterladen
  PERFORM download_functiongroup USING p_name .
*2) Externe Verweise herunterladen
  PERFORM handle_extprog USING p_name.

*Aktivitäten die sich auf gesamtes Rahmenprogramm beziehen

*  ULINE.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Domaenen downloaden
  PERFORM download_domains.
*Datenelementliste downloaden
  PERFORM download_dataelements.
*Berechtigungsobjekt Infos downloaden
  PERFORM download_authorityobjects.
*Titlebars herunterladen
  PERFORM download_titlebar.
*Meldungen herunterladen
  PERFORM download_messages.
*Gesamtliste der Transaktionscodes herunterladen
  PERFORM download_tacodelist.
*Gesamtliste der Parameter herunterschreiben
  PERFORM download_setgetparams.
*Gesamtstückliste
  PERFORM download_stueckliste.

*  Hotpackagestand sichern
*  if ( p_logic is initial ).
  PERFORM download_hpstand.
*  endif.

*  SKIP.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

* 3.)Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
* Globalen Namen setzen
  lcl_name = global_main_name.
  PERFORM initialize.
*   Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
  PERFORM handle_externalprogs.
*   globalen Namen setzen
  global_main_name = lcl_name.

ENDFORM.                    &quot; handle_functiongroup
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_interface
*&amp;---------------------------------------------------------------------*
*       Verarbeitungsroutine fuer ein Interface das im
*       Parameter P_NAME uebergeben wird. Die beiden Includes
*       des Interfaces werdengesichert.
*----------------------------------------------------------------------*
FORM handle_interface USING    p_name TYPE c.
*Variable fuer Sicherung des Verzeichnisnamens
*  DATA: lcl_name TYPE rlgrap-filename.
  DATA: lcl_name TYPE string.

*Intitialisieren der globalen Tabellen
  PERFORM initialize.
*  ULINE.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Globales Feld fuellen, da oft verwendet
  CLEAR wa_trdir.
  global_main_name = p_name.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_name
                                 &apos;I&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Interface:&apos; global_main_name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
*Rootverzeichnis sichern
  root = dir.

*Oberster Knoten der Stueckliste
  PERFORM write_stueckliste USING &apos;Interface(OO)&apos;
                             p_name
                             &apos;&apos;.

*Eigentlicher Download durchfuehren
  PERFORM download_interface USING p_name.

*Trennung von Einzeldateiobjekten
*    uline.
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Gesamtstückliste
  PERFORM download_stueckliste.
* HotPackagestand sichern
  PERFORM download_hpstand.

*  Verarbeitung der extern aufgerufenen Programme
*  Globalen Namen setzen
  lcl_name = global_main_name.
*Initialisierung der globalen Tabellen
  PERFORM initialize.
*  Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
  PERFORM handle_externalprogs.
*  globalen Namen setzen
  global_main_name = lcl_name.


*  SKIP.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Rootverzeichnis wiederherstellen
  dir = root.

ENDFORM.                    &quot; handle_interface
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_IDoc
*&amp;---------------------------------------------------------------------*
*      Verarbeitungsroutine fuer IDOC. Der Name des IDocs wird im
*      Parameter P_NAME. Der IDoc-Typ (BAsis oder Erweiterung) wird
*      im Parameter P_Typus  uebergeben.
*----------------------------------------------------------------------*
FORM handle_idoc USING   p_name TYPE c
                         p_typus TYPE c.

*Variable zur Bestimmung des Typs des IDocs (Basis oder Erweiterung)
*fuer Funktionsbaustein der ueberprueft, ob Eingabe richtig war
  DATA: lcl_typus(3) TYPE c.

*Variable fuer Objekttyp (benoetigt Html-Konverter, Funktionsbaustein)
  DATA: lcl_objtype TYPE ledid_struct_type.
*Variable wegen Typkonformitaet fuer Existenzpruefung Erweiterung
  DATA: lcl_exist_enh TYPE edi_iapi00-cimtyp.
*Variable fuer Typkonformitaet fuer Existenzpruefung IDOC
  DATA: lcl_exit_idoc TYPE edi_iapi00-idoctyp.
*Variable fuer Aufruf der HTML-Generierung
  DATA: lcl_htmlname TYPE edi_iapi00-idoctyp.

*Variable fuer Option zur Verzeichnisanlage (Name)
*Typ festlegen
  IF p_typus = &apos;B&apos;. &quot;Basisobjekt
    lcl_typus = &apos;ORG&apos;.
    lcl_objtype = &apos;B&apos;.
    lcl_exit_idoc = p_name.
    lcl_htmlname = p_name.
  ELSEIF p_typus = &apos;E&apos;.
    lcl_typus = &apos;EXT&apos;. &quot;Erweiterung
    lcl_objtype = &apos;E&apos;.
    lcl_exist_enh = p_name.
    lcl_htmlname = p_name.
  ENDIF.

****************

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_name
                                 lcl_typus.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

  IF p_typus = &apos;B&apos;. &quot;Basisidoc
*Ueberschrift zusammenbauen
    CONCATENATE &apos;BasisIDoc:&apos; p_name INTO header
          SEPARATED BY space.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.

*Ueberpruefung, ob eine Erweiterung ein Basisobjekt vorliegt
    CALL FUNCTION &apos;IDOCTYPE_EXISTENCE_CHECK&apos;
         EXPORTING
              pi_idoctyp       = lcl_exit_idoc
*               PI_READ_DEVC     = &apos;X&apos;
*          IMPORTING
*               PE_ATTRIBUTES    =
        EXCEPTIONS
             object_not_found = 1
             db_error         = 2
             OTHERS           = 3
              .
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ENDIF.
  ELSE.  &quot;Es liegt Erweiterung vor
*Ueberschrift zusammenbauen
    CONCATENATE &apos;IDocEnhancement:&apos; p_name INTO header
          SEPARATED BY space.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.

    CALL FUNCTION &apos;EXTTYPE_EXISTENCE_CHECK&apos;
         EXPORTING
              pi_cimtyp        = lcl_exist_enh
*               PI_READ_DEVC     = &apos;X&apos;
*          IMPORTING
*               PE_ATTRIBUTES    =
        EXCEPTIONS
             object_not_found = 1
             db_error         = 2
             OTHERS           = 3
              .
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ENDIF.
  ENDIF. &quot;Basisidoc oder Erweiterung
*Wenn Coding bishierher durchlaufen wurde existiert das IDoc/Erweiterung
*Der HTML-Download kann durchgeführt werden.

*Aufruf des abgeaenderten Codings des Funktionsbausteins
*&apos;IDOC_TYPE_GENERATE_HTML&apos;....
  PERFORM handle_html_generator USING lcl_objtype
                                      lcl_htmlname
                                      space
                                      &apos;3&apos;.

ENDFORM.                    &quot; handle_IDoc
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_customerenhancement
*&amp;---------------------------------------------------------------------*
*       Verarbeitungsroutine fuer ein Erweiterungsprojekt das im
*       Parameter P_NAME uebergeben wird. Die unterstuetzten
*       Objekte werden in das Filesystem gesichert.
*----------------------------------------------------------------------*
FORM handle_customerenhancement USING    p_name TYPE c.
*Lokaler Datenbereich fuer TAbelle modact (Zuordnung von
*SAP-Erweiterungen zu Kundenerweiterungsprojekten
  DATA: lcl_it_modact TYPE STANDARD TABLE OF modact,
        lcl_wa_modact LIKE LINE OF lcl_it_modact.
*Lokale Variabel fuer Includename
  DATA: lcl_zinc LIKE c_includename.
*Lokale Variable fuer Funktionsgruppennamen, Nummer des FB-Bausteins
  DATA: lcl_wa_tfdir TYPE tfdir.
*Lokaler Datenbereich fuer Tabelle modsap (Zuordnung der
*Komponenten zu SAP-Erweiterung.
  DATA: lcl_it_modsap TYPE STANDARD TABLE OF modsap,
        lcl_wa_modsap LIKE LINE OF lcl_it_modsap.
*Lokale Variablen fuer Funtkionsgruppenmemory
  DATA: lcl_it_memory TYPE STANDARD TABLE OF tfdir-pname,
        lcl_wa_memory LIKE LINE OF lcl_it_memory.
*Variable fuer die Laenge einer Zeichenkette
  DATA: lcl_len TYPE i.
*Selektionsvariablen fuer die Funktionsgruppenverarbeitung
  DATA: lcl_negativ LIKE c_includename.
*Lokaler Datenbereich fuer abhaengige Includes
  DATA: lcl_it_d010inc TYPE STANDARD TABLE OF d010inc,
        lcl_wa_d010inc LIKE LINE OF lcl_it_d010inc.
*Lokaler Datenbereich fuer Screens
  DATA: lcl_wa_d020s TYPE d020s.
*3 Lokale Variablen fuer split des Customer Subscreenstrings
  DATA: lcl_dummysplit1 TYPE string,
        lcl_dummysplit2 TYPE string,
        lcl_datasplit TYPE string.
*Variabel fuer Funktionsgruppe
  DATA: lcl_fktgroup TYPE tfdir-pname.
*Variable fuer Dynpronummer
  DATA: lcl_dynpnr(4) TYPE c.
*Variable fuer Sreenidentifizierer
  DATA: lcl_dynpname TYPE string.
*Dummyincludename fuer Typkonformitaet
  DATA: lcl_wa_dd02l TYPE dd02l.
*bereich fuer tadir-obj_name
  DATA: lcl_tadir_obj TYPE tadir-obj_name.
*Variable fuer Code eines Menueexits
  DATA: lcl_menuexitcode TYPE cuatexts-code.
*lokale Bereich fuer Infos zur Menuexits
  DATA: lcl_wa_cuatexts LIKE LINE OF it_cuatexts.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.

*Tabelle fuer Forms in einem Include
  DATA: lcl_it_performs TYPE STANDARD TABLE OF string.

*Tabelle, um temporaer Includename speichern zu koennen
  DATA: lcl_it_tempinclude TYPE STANDARD TABLE OF include.

*Tabelle, um fuer ganzes Enhancement Includename speichern zu koennen
  DATA: lcl_it_include TYPE STANDARD TABLE OF include,
        lcl_wa_include LIKE LINE OF lcl_it_include.


*SAP-Erweiterungen zu den entsprechenden Kundenprojekten waehlen
*und die Entsprechenden Elemente verarbeiten

*global_main_name fuer globalen Gebrauch aufbereiten
*--&gt;Parametrisierung umgangen
*Globalen Namen setzen
  global_main_name = p_name.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_name
                            &apos;E&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;CMOD-Enhnancment:&apos; global_main_name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

*Intitialisieren der globalen Tabellen
  PERFORM initialize. REFRESH it_enhancecomp. REFRESH it_cuatexts.


*Stueckliste fuer allgemeine Teile des Enhancements
  PERFORM write_stueckliste USING &apos;Enhancement Project&apos;
                                  p_name
                                  &apos;&apos;.


*Zum Erweiterungsprojekt das/die dazugehörige SAP-Projekte waehlen
  REFRESH lcl_it_modact.
  SELECT * FROM modact INTO TABLE lcl_it_modact
                WHERE ( ( name = p_name )
                AND ( member NE space ) ).
  LOOP AT lcl_it_modact INTO lcl_wa_modact.

*Fuer jedes SAP-Erweiterungsprojekt die dazugehörigen Komponenten
*waehlen.
    REFRESH lcl_it_modsap.
    SELECT * FROM modsap INTO TABLE lcl_it_modsap
        WHERE ( ( name = lcl_wa_modact-member )
         AND ( member NE space ) ).
*Bearbeitung der einzelnen Komponenten
    LOOP AT lcl_it_modsap INTO lcl_wa_modsap.
*Initialisierungen
      REFRESH lcl_it_performs. REFRESH lcl_it_tempinclude.
*Behandlung der Funktionsbausteinexits
      IF lcl_wa_modsap-typ = &apos;E&apos;. &quot;Funktionsbausteinexit
        SELECT SINGLE * FROM tfdir INTO lcl_wa_tfdir
               WHERE funcname = lcl_wa_modsap-member.
*Funktionsgruppenname in Memorytabelle schreiben, wenn
*dieser dort nicht schon steht.
        READ TABLE lcl_it_memory WITH KEY
              lcl_wa_tfdir-pname TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          APPEND lcl_wa_tfdir-pname TO lcl_it_memory.
        ENDIF.
*Zusammenbauen des Strings des ZIncludes
        CLEAR lcl_zinc.
        CONCATENATE &apos;Z&apos; lcl_wa_tfdir-pname+4 &apos;U&apos;
            lcl_wa_tfdir-include INTO lcl_zinc.
*Include herunterladen
        CLEAR ok.
        PERFORM download_include USING lcl_zinc
                                       &apos;E&apos;
                                CHANGING ok.
        IF ok = &apos;X&apos;. &quot;Download war erfolgreich
*Stueckliste dieser Kundenerweiterung schreiben

          PERFORM write_enhancementlist USING lcl_wa_modsap-name
                                             lcl_wa_modsap-member
                                             &apos;Function Exit&apos;
                                             lcl_zinc.
        ENDIF. &quot;War Download erfolgreich?

*Exterene Verweise diese Funktionsbausteines/Includes herunterladen
        PERFORM handle_extprog_singleinclude USING lcl_zinc.

*Form-Routinen in diesem Include ermitteln
        PERFORM get_performs_from_include USING lcl_zinc
                         CHANGING lcl_it_performs.

        IF NOT ( lcl_it_performs IS INITIAL ).
*Includes der Form-Routinen ermitteln
          PERFORM get_includes_of_forms
            USING lcl_it_performs
                  lcl_zinc
            CHANGING lcl_it_tempinclude.
*Inlcude löschen,wenn es das aufrufende ist
          DELETE lcl_it_tempinclude WHERE name = lcl_zinc.

*an Gesamtincludeliste anhängen
          APPEND LINES OF lcl_it_tempinclude TO lcl_it_include.

        ENDIF.


      ELSEIF lcl_wa_modsap-typ = &apos;S&apos;. &quot;Subscreen
*Zerlegen der Memberzeichenkette (nur der letzte Teil ist relevant)
        SPLIT lcl_wa_modsap-member AT &apos;_&apos;  INTO lcl_dummysplit1
            lcl_dummysplit2 lcl_datasplit.
*Funktionsgruppennamen (&apos;SAPL&apos;...) und Dynpronummer ermitteln
        lcl_len = STRLEN( lcl_datasplit ).
        lcl_len = lcl_len - 4.
        lcl_fktgroup = lcl_datasplit(lcl_len).
        lcl_dynpnr = lcl_datasplit+lcl_len.
*passenden Eintrag aus Dynprotabelle d020s ermitteln
        SELECT SINGLE * FROM d020s INTO lcl_wa_d020s
            WHERE prog = lcl_fktgroup
            AND   dnum = lcl_dynpnr.
*diesen Screen herunterladen
        PERFORM download_dynpro USING lcl_wa_d020s.
*An Memorytabelle fuer Funktionsgruppen anhaengen, wenn noch nicht drin.
        READ TABLE lcl_it_memory WITH KEY
          lcl_fktgroup TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          APPEND lcl_fktgroup TO lcl_it_memory.
        ENDIF.
*Identifikationstring fuer Screen zusammenbauen
        CONCATENATE lcl_fktgroup &apos;, screen: &apos; lcl_dynpnr INTO
        lcl_dynpname.
*Stueckliste der Kundenerweiterungen schreiben
        PERFORM write_enhancementlist USING lcl_wa_modsap-name
                                           lcl_wa_modsap-member
                                           &apos;Dynpro-Exit&apos;
                                           lcl_dynpname.

      ELSEIF lcl_wa_modsap-typ = &apos;C&apos;. &quot;Menueexit
*Zeichenkette aufsplitten
        SPLIT lcl_wa_modsap-member AT &apos;+&apos;  INTO lcl_dummysplit1
               lcl_dummysplit2 lcl_datasplit.
*Menuexit-Code zusammenbauen
        CONCATENATE &apos;+&apos; lcl_dummysplit2 INTO lcl_menuexitcode.
*Funktionsgruppennamen holen
        lcl_fktgroup = lcl_dummysplit1.

*An Memorytabelle fuer Funktionsgruppen anhaengen, wenn noch nicht drin.
        READ TABLE lcl_it_memory WITH KEY
         lcl_fktgroup TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          APPEND lcl_fktgroup TO lcl_it_memory.
        ENDIF.

*Infos zu diesem Menuexit lesen; nur ein Satz
        CLEAR lcl_wa_cuatexts.
        LOOP AT it_lan INTO wa_lan.
          SELECT SINGLE * FROM cuatexts INTO  lcl_wa_cuatexts
                  WHERE prog = lcl_fktgroup
                    AND code = lcl_menuexitcode
                    AND sprsl = wa_lan.
          IF sy-subrc = 0.
            APPEND lcl_wa_cuatexts TO it_cuatexts.
          ENDIF.
        ENDLOOP.
*Stueckliste der Kundenerweiterungen schreiben
        PERFORM write_enhancementlist USING lcl_wa_modsap-name
                                           lcl_wa_modsap-member
                                           &apos;Menu Exit&apos;
                                           lcl_menuexitcode.


      ELSEIF lcl_wa_modsap-typ = &apos;T&apos;. &quot;Includetabelle
*Ueberpruefen, ob verwendet
        SELECT SINGLE obj_name FROM tadir INTO lcl_tadir_obj
                        WHERE obj_name = lcl_wa_modsap-member.
        IF sy-subrc = 0.
*Umkopieren wegen Typkonformitaet
          lcl_wa_dd02l-tabname = lcl_wa_modsap-member.
          PERFORM download_table USING  lcl_wa_dd02l &apos;S&apos;.
*Stueckliste der Kundenerweiterungen schreiben
          PERFORM write_enhancementlist USING lcl_wa_modsap-name
                                            lcl_wa_modsap-member
                                               &apos;Customizing Include&apos;
                                             lcl_wa_modsap-member.
        ENDIF. &quot;Includetabelle aktiv
      ENDIF.  &quot;Typ des Customerextits
    ENDLOOP. &quot;Komponenten der SAP-Erweiterungen
  ENDLOOP. &quot;Sap-Erweiterungen in Kundenerweiterungen

*Sichern der Includes mit benutzten Formroutinen
  SORT lcl_it_include.
  DELETE ADJACENT DUPLICATES FROM lcl_it_include COMPARING ALL FIELDS.
  LOOP AT lcl_it_include INTO lcl_wa_include.
*Include herunterladen
    CLEAR ok.
    PERFORM download_include USING lcl_wa_include-name
                                   &apos;E&apos;
                            CHANGING ok.
    IF ok = &apos;X&apos;. &quot;Download war erfolgreich
*Stueckliste dieser Kundenerweiterung schreiben
      PERFORM write_enhancementlist USING lcl_wa_modsap-name
                                          &apos;&apos;
                                          &apos;Form Include&apos;
                                      lcl_wa_include-name.
    ENDIF. &quot;War Download erfolgreich?

  ENDLOOP.

*Herunterladen der kundeneigene DDic-Elemente, und Klassen,
*der im Projekt verwendeten Funktionsgruppen
*--&gt;geht zur Zeit nur auf Ebenen einer Funktionsgruppe
  LOOP AT lcl_it_memory INTO lcl_wa_memory.

*Tabellen und Strukturen herunterladen
    PERFORM handle_ddic USING lcl_wa_memory
                                 &apos;R&apos;.

*Klassen und Interface behandeln
    PERFORM handle_classinterface USING lcl_wa_memory
                                      &apos;R&apos;.

  ENDLOOP.

*Stueckliste dieser Kundenerweiterung schreiben
  IF NOT ( it_enh_d010tab IS INITIAL ).
    LOOP AT it_enh_d010tab INTO wa_enh_d010tab.
      PERFORM write_enhancementlist USING lcl_wa_modsap-name
                                                &apos;&apos;
                                            wa_enh_d010tab-typus
                                            wa_enh_d010tab-tabname.
    ENDLOOP.
  ENDIF.


*********************************************************
*Taetigkeiten die sich auf gesamtes Cmod-Projekt beziehen

*  ULINE.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Herunterladen der Menuexitcodeliste
  PERFORM download_menuexitcodelist USING p_name.
*Herunterladen der Gesamttabelle
  PERFORM download_enhancementtab USING p_name.

*Domaenen downloaden
  PERFORM download_domains.
**Datenelementliste downloaden
  PERFORM download_dataelements.
**Berechtigungsobjekt Infos downloaden
  PERFORM download_authorityobjects.
**Meldungen herunterladen
  PERFORM download_messages.
**Gesamtliste der Transaktionscodes herunterladen
  PERFORM download_tacodelist.
**Gesamtliste mit Dialogbaustein-&gt;Funktionsbausteinzuordnung
**herunterladen und Gesamtliste mit Dialogpoolparametern herunterladen.
  PERFORM download_dialogmodule_elements.
**Gesamtliste der Parameter herunterschreiben
  PERFORM download_setgetparams.
**Gesamtstückliste:
  PERFORM download_stueckliste.

*Hotpackagestand sichern
  PERFORM download_hpstand.

*Leerzeile nach Ende dieser Verarbeitung
*        skip.
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

* Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
  lcl_name = global_main_name.
  PERFORM initialize.
* Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
  PERFORM handle_externalprogs.
* globalen Namen setzen
  global_main_name = lcl_name.

ENDFORM.                    &quot; handle_customerenhancement
*&amp;---------------------------------------------------------------------*
*&amp;      Form  prepare_for_logical_dev
*&amp;---------------------------------------------------------------------*
*       Bei Angabe einer Bezeichnung fuer eine Logische Entwicklung
*       wird das Programm fuer dies Verarbeitung hier vorbereitet.
*----------------------------------------------------------------------*
FORM prepare_for_logical_dev.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Logical Development:&apos; p_logic INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

*Verzeichnis fuer die logische Entwicklung schaffen
  PERFORM create_directory USING p_logic
                                     &apos;L&apos;.

*Haupverzeichnis fuer die gesamte weitere Verarbeitung aender
  dir = new_dir.

*Stuecklistenanfang schreiben
  PERFORM write_log_stueckliste USING   &apos;Logical Development&apos;
                                        p_logic
                                        &apos;&apos;.

ENDFORM.                    &quot; prepare_for_logical_dev
*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_log_stueckliste
*&amp;---------------------------------------------------------------------*
*       Schreiben der Logischen Stueckliste
*----------------------------------------------------------------------*
FORM write_log_stueckliste USING   p_type TYPE any
                                   p_name TYPE any
                                   p_obername TYPE any.

  wa_log_stueckliste-type = p_type.
  wa_log_stueckliste-name = p_name.
  wa_log_stueckliste-obername = p_obername.
  wa_log_stueckliste-instnr = instnr.

  APPEND wa_log_stueckliste TO it_log_stueckliste.

ENDFORM.                    &quot; write_log_stueckliste
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_HTMLTAB_FOR_TEXTELEMENT
*&amp;---------------------------------------------------------------------*
*      Aufbereitung der im Parameter P_IT_TEXTELEMENTS uebergebenen
*      Textelemente in einer HTML-Datei.
*----------------------------------------------------------------------*
FORM create_htmltab_for_textelement
                        USING p_it_textelements LIKE it_textpool.
*Variable fuer Kopfzeilen
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabellen
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string,
        lcl_wa_headerrow LIKE LINE OF lcl_it_headerrow.
*Arbeitsbereich fuer Textelemente
  DATA: lcl_wa_textelements TYPE textpool.


*Headertabelle zusammenbauen
  APPEND &apos;Textelement Key&apos; TO lcl_it_headerrow.
  APPEND &apos;Text of Textelement&apos; TO lcl_it_headerrow.

*Gesamtuebershcrift zusammenbauen
  CONCATENATE &apos;&lt;h1&gt;&apos; &apos;Textelements of &apos;  global_main_name &apos;&lt;/h1&gt;&apos;
          INTO lcl_header SEPARATED BY space.

  REFRESH it_html.
*Anfang HTML-Dokument schreiben
  APPEND &apos;&lt;HTML&gt;&apos; TO it_html.
  APPEND &apos;&lt;head&gt;&apos; TO it_html.
  APPEND &apos;&lt;LINK REL=&quot;STYLESHEET&quot; TYPE=&quot;text/css&quot; HREF=&quot;formate.css&quot;/&gt;&apos;
    TO it_html.
  APPEND &apos;&lt;/head&gt;&apos; TO it_html.
  APPEND &apos;&lt;body&gt;&apos; TO it_html.
*Gesamtueberschrift schreiben
  APPEND lcl_header TO it_html.
  APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.

*Reporttitel schreiben
  READ TABLE p_it_textelements WITH KEY id = &apos;R&apos;
        INTO lcl_wa_textelements.
  IF sy-subrc = 0.
    CONCATENATE &apos;&lt;h2&gt;&apos; &apos;Report Title:&apos; lcl_wa_textelements-entry
              &apos;&lt;/h2&gt;&apos; INTO wa_html SEPARATED BY space.
    APPEND wa_html TO it_html.

  ENDIF.
  APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.

  CLEAR lcl_wa_textelements.
*1.) Tabelle fuer Selektionsparameter zusammenbauen
*ueberschrift
*Existieren Selektionstexte
  READ TABLE p_it_textelements WITH KEY id = &apos;S&apos;
      TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    CONCATENATE &apos;&lt;h2&gt;&apos; &apos;Selection Texts&apos; &apos;&lt;/h2&gt;&apos;
            INTO lcl_header SEPARATED BY space.

    APPEND lcl_header TO it_html.
*Tabelle mit Ueberschriften generieren
    APPEND &apos;&lt;table border&gt;&apos; TO it_html.
    APPEND &apos;&lt;tr&gt;&apos; TO it_html.
    LOOP AT lcl_it_headerrow INTO lcl_wa_headerrow.
      CONCATENATE &apos;&lt;th&gt;&apos; lcl_wa_headerrow &apos;&lt;/th&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDLOOP.
    APPEND &apos;&lt;/tr&gt;&apos; TO it_html.
*Datenzeilen generieren
    LOOP AT p_it_textelements INTO lcl_wa_textelements
          WHERE id = &apos;S&apos;.
      APPEND &apos;&lt;tr&gt;&apos; TO it_html.

      CONCATENATE &apos;&lt;td&gt;&apos; lcl_wa_textelements-key &apos;&lt;/td&gt;&apos; INTO wa_html.
      APPEND  wa_html TO it_html.
      CONCATENATE &apos;&lt;td&gt;&apos; lcl_wa_textelements-entry &apos;&lt;/td&gt;&apos; INTO wa_html.
      APPEND  wa_html TO it_html.
      APPEND &apos;&lt;/tr&gt;&apos; TO it_html.
    ENDLOOP.
    APPEND &apos;&lt;/table&gt;&apos; TO it_html.
    APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.
  ENDIF.


  CLEAR lcl_wa_textelements.
*2.) Tabelle fuer Textsymbole zusammenbauen

*Existieren Textsymbole
  READ TABLE p_it_textelements WITH KEY id = &apos;I&apos;
      TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
*ueberschrift
    CONCATENATE &apos;&lt;h2&gt;&apos; &apos;Text Symbols&apos; &apos;&lt;/h2&gt;&apos;
            INTO lcl_header SEPARATED BY space.

    APPEND lcl_header TO it_html.
*Tabelle mit Ueberschriften generieren
    APPEND &apos;&lt;table border&gt;&apos; TO it_html.
    APPEND &apos;&lt;tr&gt;&apos; TO it_html.
    LOOP AT lcl_it_headerrow INTO lcl_wa_headerrow.
      CONCATENATE &apos;&lt;th&gt;&apos; lcl_wa_headerrow &apos;&lt;/th&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDLOOP.
    APPEND &apos;&lt;/tr&gt;&apos; TO it_html.
*Datenzeilen generieren
    LOOP AT p_it_textelements INTO lcl_wa_textelements
          WHERE id = &apos;I&apos;.
      APPEND &apos;&lt;tr&gt;&apos; TO it_html.

      CONCATENATE &apos;&lt;td&gt;&apos; lcl_wa_textelements-key &apos;&lt;/td&gt;&apos; INTO wa_html.
      APPEND  wa_html TO it_html.
      CONCATENATE &apos;&lt;td&gt;&apos; lcl_wa_textelements-entry &apos;&lt;/td&gt;&apos; INTO wa_html.
      APPEND  wa_html TO it_html.
      APPEND &apos;&lt;/tr&gt;&apos; TO it_html.
    ENDLOOP.

    APPEND &apos;&lt;/table&gt;&apos; TO it_html.
    APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.

  ENDIF.

  CLEAR lcl_wa_textelements.
*3.) List Header schreiben
  READ TABLE p_it_textelements WITH KEY id = &apos;T&apos;
        INTO lcl_wa_textelements.
  IF sy-subrc = 0.
    CONCATENATE &apos;&lt;h2&gt;&apos; &apos;List Header:&apos; lcl_wa_textelements-entry
              &apos;&lt;/h2&gt;&apos; INTO wa_html SEPARATED BY space.
    APPEND wa_html TO it_html.
  ENDIF.

  APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.

  CLEAR lcl_wa_textelements.
*4.Spaltenueberschriften schreiben
*Existieren Textsymbole
  READ TABLE p_it_textelements WITH KEY id = &apos;H&apos;
      TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
*ueberschrift
    CONCATENATE &apos;&lt;h2&gt;&apos; &apos;Column Headings&apos; &apos;&lt;/h2&gt;&apos;
            INTO lcl_header SEPARATED BY space.

    APPEND lcl_header TO it_html.
*Tabelle mit Ueberschriften generieren
    APPEND &apos;&lt;table border&gt;&apos; TO it_html.
    APPEND &apos;&lt;tr&gt;&apos; TO it_html.
    LOOP AT lcl_it_headerrow INTO lcl_wa_headerrow.
      CONCATENATE &apos;&lt;th&gt;&apos; lcl_wa_headerrow &apos;&lt;/th&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDLOOP.
    APPEND &apos;&lt;/tr&gt;&apos; TO it_html.
*Datenzeilen generieren
    LOOP AT p_it_textelements INTO lcl_wa_textelements
          WHERE id = &apos;H&apos;.
      APPEND &apos;&lt;tr&gt;&apos; TO it_html.

      CONCATENATE &apos;&lt;td&gt;&apos; lcl_wa_textelements-key &apos;&lt;/td&gt;&apos; INTO wa_html.
      APPEND  wa_html TO it_html.
      CONCATENATE &apos;&lt;td&gt;&apos; lcl_wa_textelements-entry &apos;&lt;/td&gt;&apos; INTO wa_html.
      APPEND  wa_html TO it_html.
      APPEND &apos;&lt;/tr&gt;&apos; TO it_html.
    ENDLOOP.

    APPEND &apos;&lt;/table&gt;&apos; TO it_html.

    APPEND &apos;&lt;br&gt;&apos; TO it_html.
  ENDIF.

  CLEAR lcl_wa_textelements.

*Endbereich schreiben
  APPEND &apos;&lt;/body&gt;&apos; TO it_html.
  APPEND &apos;&lt;/Html&gt;&apos; TO it_html.
ENDFORM.                    &quot; CREATE_HTMLTAB_FOR_TEXTELEMENT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_menulist
*&amp;---------------------------------------------------------------------*
*      Aufbereitung der Menuliste (globale Tabelle) in eine HTML-Datei.
*----------------------------------------------------------------------*
FORM create_html_for_menulist USING p_status TYPE c
                                    p_name TYPE c.
*Feld fuer aktiv
  DATA: lcl_active(3) TYPE c.
*Flag,wo man in einem Menu ist; 1= Ebene1; 2=Ebene2; leer=Hauptmenu
  DATA: lcl_pos TYPE i.
*Ebene des Submenues
  DATA: lcl_level1 TYPE i.
  DATA: lcl_level2 TYPE i.
*Menuzaehler fuer Submenu 1. Ebene; 2. Ebene speichern
  DATA: lcl_zaehler TYPE i.

*Positionsvarialen fuer Menustruktur
  DATA: lcl_pos1 TYPE i,
        lcl_pos2 TYPE i,
        lcl_pos3 TYPE i,
        lcl_pos4 TYPE i.
*Initialsieren der Html-Tabelle, da sie von allen Downloadtabellen
*benutzt wird
  REFRESH it_html.

*Anfang der Seite
  APPEND &apos;&lt;HTML&gt;&apos; TO it_html.
  APPEND &apos;&lt;head&gt;&apos; TO it_html.
  APPEND &apos;&lt;/head&gt;&apos; TO it_html.
  APPEND &apos;&lt;body&gt;&apos; TO it_html.

*Ueberschrift generieren
  CONCATENATE &apos;&lt;h1&gt;&apos; &apos;Menustructure of Status&apos; p_status
    &apos;in Main-Program&apos; p_name &apos;(Language&apos; wa_lan &apos;)&lt;/h1&gt;&apos; INTO wa_html
          SEPARATED BY space.
  APPEND wa_html TO it_html.
  APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.

*Liste schreiben
  LOOP AT it_rsmpe_tree INTO wa_rsmpe_tree.

    lcl_pos1 = wa_rsmpe_tree-pos_1.
    lcl_pos2 = wa_rsmpe_tree-pos_2.
    lcl_pos3 = wa_rsmpe_tree-pos_3.
    lcl_pos4 = wa_rsmpe_tree-pos_4.

*neuer Menupunkt
    IF ( ( lcl_pos2 = 0 ) AND ( lcl_pos3 = 0 ) AND ( lcl_pos4 = 0 ) ).
      lcl_pos = 0.
      IF sy-tabix &lt;&gt; 1.
        APPEND &apos;&lt;/ul&gt;&apos; TO it_html.
      ENDIF.
      APPEND &apos;&lt;ul&gt;&apos; TO it_html.
    ENDIF.


    IF wa_rsmpe_tree-type = &apos;M&apos;.
      IF ( ( lcl_pos2 = 0 ) AND ( lcl_pos3 = 0 ) AND ( lcl_pos4 = 0 ) ).
        lcl_pos = 0.
        APPEND &apos;&lt;br&gt;&lt;br&gt;&apos; TO it_html.
        CONCATENATE  &apos;&lt;h3&gt; Menu: &lt;b&gt;&apos; wa_rsmpe_tree-text &apos;&lt;/b&gt; &lt;/h3&gt;&apos;
            INTO wa_html SEPARATED BY space.
        APPEND wa_html TO it_html.
      ELSE.  &quot;Submenu
        CONCATENATE &apos;&lt;li&gt;&apos; &apos;Submenu: &lt;b&gt;&apos; wa_rsmpe_tree-text &apos;&lt;/b&gt;&lt;/li&gt;&apos;
                INTO wa_html SEPARATED BY space.
        APPEND wa_html TO it_html.
*      append &apos;&lt;ul&gt;&apos; to it_html.
        IF lcl_pos = 0.
          lcl_pos = 1.
          lcl_level1 = wa_rsmpe_tree-pos_2.
        ELSEIF lcl_pos = 1.
          lcl_pos = 2.
          lcl_level2 = wa_rsmpe_tree-pos_3.
        ENDIF.


        APPEND &apos;&lt;ul&gt;&apos; TO it_html.

      ENDIF.
    ELSEIF wa_rsmpe_tree-type = &apos;S&apos;. &quot;horizontaler Strich
*evtl. Submenustruktur bearbeit
      IF (  lcl_pos = 1 AND wa_rsmpe_tree-pos_2 &lt;&gt; lcl_level1 ).
        APPEND &apos;&lt;/ul&gt;&apos; TO it_html.
        CLEAR lcl_level1.
        lcl_pos = 0.
      ELSEIF (  lcl_pos = 2 AND wa_rsmpe_tree-pos_3 &lt;&gt; lcl_level2 ).
        APPEND &apos;&lt;/ul&gt;&apos; TO it_html.
        CLEAR lcl_level2.
        lcl_pos = 1.
      ENDIF.

      CONCATENATE
       &apos;&lt;li&gt;&apos; &apos;&lt;hr noshade width=&quot;300&quot; size=&quot;3&quot; align=left&gt;&apos; &apos;&lt;/li&gt;&apos;
       INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.


    ELSEIF wa_rsmpe_tree-type = &apos;F&apos;.  &quot;normaler Funktionscode


*Aktiv-Flag setzen
      IF wa_rsmpe_tree-active = &apos;X&apos;.
        lcl_active = &apos;YES&apos;.
      ELSE.
        lcl_active = &apos;NO&apos;.
      ENDIF.

*evtl. Submenustruktur bearbeit
      IF (  lcl_pos = 1 AND wa_rsmpe_tree-pos_2 &lt;&gt; lcl_level1 ).
        APPEND &apos;&lt;/ul&gt;&apos; TO it_html.
        CLEAR lcl_level1.
        lcl_pos = 0.
      ELSEIF (  lcl_pos = 2 AND wa_rsmpe_tree-pos_3 &lt;&gt; lcl_level2 ).
        APPEND &apos;&lt;/ul&gt;&apos; TO it_html.
        CLEAR lcl_level2.
        lcl_pos = 1.
      ENDIF.

*Eintrag zusammenbauen
      CONCATENATE
      &apos;&lt;li&gt;Menufunction:&apos; wa_rsmpe_tree-text
       &apos;(Code:&quot;&apos; wa_rsmpe_tree-code &apos;&quot;; active=&quot;&apos; lcl_active
       &apos;&quot;)&apos; &apos;&lt;/li&gt;&apos; INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    ENDIF.

  ENDLOOP.

  APPEND &apos;&lt;/ul&gt;&apos; TO it_html.

*Ende der Seite
  APPEND &apos;&lt;/body&gt;&apos; TO it_html.
  APPEND &apos;&lt;/Html&gt;&apos; TO it_html.
ENDFORM.                    &quot; create_html_for_menulist
*&amp;---------------------------------------------------------------------*
*&amp;      Form  tacode
*&amp;---------------------------------------------------------------------*
*      Abfangen der selektierten Transaktionen aus dem
*      Selektionsbildschirm zur Auswahl einzelner Objekte.
*      Fuer jede gefundene Transaktion  werden
*      die Objekte gesichert.
*----------------------------------------------------------------------*
FORM tacode.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.
*Sicherungsvariable fuer Stueckliste
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste.
*Bereich fuer Parametertabelle
  DATA: lcl_wa_tstcp TYPE tstcp.

*Bereich fuer Transaktionscodetabelle
  DATA: lcl_it_tstc TYPE STANDARD TABLE OF tstc,
        lcl_wa_tstc LIKE LINE OF it_tstc.
*Klassennamenvarialble
  DATA: lcl_class TYPE seoclass-clsname.
*Variablen fuer Start-und Endposition
  DATA: lcl_start TYPE i,
        lcl_end TYPE i.


  SELECT * FROM tstc INTO TABLE lcl_it_tstc
        WHERE tcode IN o_tcode.

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_tstc IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for Transaction! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.


  LOOP AT lcl_it_tstc INTO lcl_wa_tstc.


*  Globales Namensfeld füllen
    global_main_name = lcl_wa_tstc-tcode.


*  Intitialisieren der globalen Tabellen
    PERFORM initialize.


*  Speziellle Verarbeitung bei Klassen
    IF lcl_wa_tstc-pgmna IS INITIAL.

      SELECT SINGLE * FROM tstcp INTO lcl_wa_tstcp
        WHERE tcode = lcl_wa_tstc-tcode.

*Suche nach dem Klassennamen
      SEARCH lcl_wa_tstcp-param FOR &apos;CLASS=&apos;.
      IF sy-subrc &lt;&gt; 0.  &quot;Nichts gefunden
        CONTINUE.
      ENDIF.
*Name der Klasse finden
      lcl_start = sy-fdpos.
*String &quot;CLASS=&quot; wegloeschen
      lcl_start = lcl_start + 6.
      SEARCH lcl_wa_tstcp-param FOR &apos;\&apos;  STARTING AT lcl_start.
      lcl_end = sy-fdpos - 1.
      IF lcl_end &lt; 0.
        lcl_end = 0.
      ENDIF.
      lcl_class =  lcl_wa_tstcp-param+lcl_start(lcl_end).
      IF lcl_class IS INITIAL.
        CONTINUE.
      ENDIF.

*Verarbeitung, da Klasse gefunden
*    Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
      PERFORM create_directory USING lcl_wa_tstc-tcode
                                     &apos;TA&apos;.
*Abbrechen da es schon existiert
      IF direxists = &apos;X&apos;.
        CONTINUE.
      ENDIF.

*Ueberschrift zusammenbauen
      CONCATENATE &apos;Transaction:&apos; global_main_name INTO header
            SEPARATED BY space.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
*    ***************

*Tacode schreiben
      PERFORM write_stueckliste USING &apos;Transaction&apos;
                                    lcl_wa_tstc-tcode
                                    &apos;&apos;.

*       Eintrag fuer Funktiosgruppe schreiben
      PERFORM write_stueckliste USING &apos;Class&apos;
                                    lcl_class
                                    lcl_wa_tstc-tcode.



      PERFORM write_global_save USING &apos;C&apos; lcl_class.

*Stueckliste sichern
      REFRESH lcl_it_prog_stueckliste.
      APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
*Verarbeitung fuer aufgerufene Programme anstarten
      PERFORM handle_externalprogs.

*Rücksichern der STückliste
      REFRESH it_prog_stueckliste.
      APPEND LINES OF lcl_it_prog_stueckliste TO it_prog_stueckliste.
*Namen wiederherstellen
      global_main_name = lcl_wa_tstc-tcode.

      PERFORM download_stueckliste.
*Hotpackagestand sichern
      PERFORM download_hpstand.

    ELSE. &quot;Normale Transaktionen

*    Die folgenden Elemente nur behandeln wenn das Rahmengprogramm
*    im Kundennamensraum liegt.
      IF ( ( lcl_wa_tstc-pgmna(1) = &apos;Z&apos; )
              OR ( lcl_wa_tstc-pgmna(1) = &apos;Y&apos; )
              OR ( lcl_wa_tstc-pgmna(2) = &apos;MZ&apos; )
              OR ( lcl_wa_tstc-pgmna(2) = &apos;MY&apos; )
              OR ( lcl_wa_tstc-pgmna(5) = &apos;SAPMZ&apos; )
              OR ( lcl_wa_tstc-pgmna(5) = &apos;SAPMY&apos; )
              OR (  lcl_wa_tstc-pgmna(g_len_nspace) = g_nspace
                    AND lcl_wa_tstc-pgmna+g_len_nspace(4) NE &apos;SAPL&apos; ) ).
*Liste mit Ober-Objekten bei Einzelselektion fuellen(keine rekursive
*Sicherung, da bereits gesichert.
        MOVE lcl_wa_tstc-pgmna TO wa_obj_list-name.
        APPEND wa_obj_list TO it_obj_list.

*    Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
        PERFORM create_directory USING lcl_wa_tstc-tcode
                                       &apos;TA&apos;.
*Abbrechen da es schon existiert
        IF direxists = &apos;X&apos;.
          CONTINUE.
        ENDIF.

*Ueberschrift zusammenbauen
        CONCATENATE &apos;Transaction:&apos; global_main_name INTO header
              SEPARATED BY space.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
*    ***************



*    Rahmenprogramm herunterladen
        CLEAR ok.
        PERFORM download_include USING lcl_wa_tstc-pgmna &apos;R&apos;
                                 CHANGING ok.
*    Download war erfolgreich
        IF ok = &apos;X&apos;.
*    Stueckliste schreiben
*Tacode
          PERFORM write_stueckliste USING &apos;Transaction&apos;
                                        lcl_wa_tstc-tcode
                                        &apos;&apos;.
*Program zu Transaktionscode
          PERFORM write_stueckliste USING &apos;Report/Modulpool&apos;
                                        lcl_wa_tstc-pgmna
                                        lcl_wa_tstc-tcode.
        ENDIF.
*    Textelemente des Rahmenprogramms herunterladen
        PERFORM download_textelements USING lcl_wa_tstc-pgmna
                                            &apos;R&apos;.
*    Stueckliste wird in &apos;download_textelements&apos; geschrieben

*    Echter Screen des Rahmenprogramms herunterladen
        PERFORM handle_screens USING lcl_wa_tstc-pgmna
                                     &apos;R&apos;.
*    pf-Stati verarbeiten
        PERFORM handle_pf_status USING lcl_wa_tstc-pgmna
                                       &apos;R&apos;.

*    Titlebars suchen
        PERFORM handle_titlebar USING lcl_wa_tstc-pgmna
                                      &apos;R&apos;.
*    eventueller Transaktionscode zu Rahmenprogramm
        PERFORM handle_tacode USING lcl_wa_tstc-pgmna.

*    Normale Includes des Rahmenprogramms herunterladen
        PERFORM handle_normal_includes USING lcl_wa_tstc-pgmna.

*    Klassen und Interface behandeln
        PERFORM handle_classinterface USING lcl_wa_tstc-pgmna
                                            &apos;R&apos;.
*    Tabellen/Strukturen herunterladen
        PERFORM handle_ddic USING lcl_wa_tstc-pgmna
                                   &apos;R&apos; .

*    Externe Programmaufrufe, Funktionsbausteine und Messages
*    des Rahmenprogramms behandeln.
        PERFORM handle_extprog USING lcl_wa_tstc-pgmna.



*    Aktivitäten die sich auf gesamtes Rahmenprogramm beziehen

*      ULINE.  &quot;Listausgabeformatierung
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*    Domaenen downloaden
        PERFORM download_domains.
*    Datenelementliste downloaden
        PERFORM download_dataelements.
*    Berechtigungsobjekt Infos downloaden
        PERFORM download_authorityobjects.
*    Titlebars herunterladen
        PERFORM download_titlebar.
*    Meldungen herunterladen
        PERFORM download_messages.
*    Gesamtliste der Transaktionscodes herunterladen
        PERFORM download_tacodelist.
*    Gesamtliste mit Dialogbaustein-&gt;Funktionsbausteinzuordnung
* herunterladen und Gesamtliste mit Dialogpoolparametern herunterladen.
        PERFORM download_dialogmodule_elements.
*    Gesamtliste der Parameter herunterschreiben
        PERFORM download_setgetparams.
*    Gesamtstückliste
        PERFORM download_stueckliste.
*Hotpackagestand sichern
        PERFORM download_hpstand.

*Leerzeile nach Ende dieser Verarbeitung
*        skip.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*    Globalen Namen setzen
        lcl_name = global_main_name.

        PERFORM initialize.
*        perform handle_collectmains.
*    Die Liste der extern aufgerufenen Rahmenprogramme abarbeieten
        PERFORM handle_externalprogs.
*    globalen Namen setzen
        global_main_name = lcl_name.


      ELSEIF ( ( lcl_wa_tstc-pgmna(5) = &apos;SAPLZ&apos; )
                  OR ( lcl_wa_tstc-pgmna(5) = &apos;SAPLY&apos; )
                  OR (  lcl_wa_tstc-pgmna(g_len_nspace) = g_nspace
                    AND lcl_wa_tstc-pgmna+g_len_nspace(4) = &apos;SAPL&apos; ) ).

*    Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
        PERFORM create_directory USING lcl_wa_tstc-tcode
                                       &apos;TA&apos;.
*Abbrechen da es schon existiert
        IF direxists = &apos;X&apos;.
          CONTINUE.
        ENDIF.

*Ueberschrift zusammenbauen
        CONCATENATE &apos;Transaction:&apos; global_main_name INTO header
              SEPARATED BY space.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
*    ***************

*Tacode schreiben
        PERFORM write_stueckliste USING &apos;Transaction&apos;
                                      lcl_wa_tstc-tcode
                                      &apos;&apos;.
*Nur wenn abhängige Objekte berücksichtig werden sollen
        IF g_nodep IS INITIAL.

*         Eintrag fuer Funktiosgruppe schreiben
          PERFORM write_stueckliste USING &apos;Functiongroup&apos;
                                        lcl_wa_tstc-pgmna
                                        lcl_wa_tstc-tcode.

          PERFORM write_global_save USING &apos;F&apos; lcl_wa_tstc-pgmna.
        ENDIF.

*Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
*Verarbeitung fuer aufgerufene Programme anstarten
        PERFORM handle_externalprogs.

*Rücksichern der STückliste
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO it_prog_stueckliste.
*Namen wiederherstellen
        global_main_name = lcl_wa_tstc-tcode.

        PERFORM download_stueckliste.


      ENDIF. &quot;Namensraum

    ENDIF. &quot;Klasse oder normales verbundenes Objekt

*Stueckliste fuer logische Entwicklung schreiben
    IF NOT ( p_logic IS INITIAL ).

      PERFORM write_log_stueckliste USING   &apos;Transaction&apos;
                                             lcl_wa_tstc-tcode
                                             p_logic.


      PERFORM write_log_stueckliste USING   &apos;Report/Modulpool(TA)&apos;
                                            lcl_wa_tstc-pgmna
                                           lcl_wa_tstc-tcode.

    ENDIF.

  ENDLOOP.

ENDFORM.                    &quot; tacode
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_nav_files
*&amp;---------------------------------------------------------------------*
*       Erstellung der Framset Datei und der Navigationsdatei der
*       HTML-Navigation.
*----------------------------------------------------------------------*
FORM create_nav_files USING file TYPE string.
*Variable fuer Art des Objektes
  DATA: lcl_typus TYPE string.
*Arbeitsbereich fuer Stueckliste
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste,
        lcl_wa_prog_stueckliste LIKE LINE OF lcl_it_prog_stueckliste.
*Anzahl Zeilen in tabellen
  DATA: lcl_line  TYPE i.
*Sicherung des Tabix der aktuellen Tabelle
  DATA: lcl_savetabix TYPE i.
*Bereich fuer Textelementname
  DATA: lcl_text(30) TYPE c.
*variable to replace special characters
  DATA: lcl_global_main_name LIKE global_main_name.
* variables for subitem-generation
  DATA: lcl_name LIKE wa_html,
        lcl_url  LIKE wa_html.

* begin of changes for partner namespace
  lcl_global_main_name = global_main_name.
  TRANSLATE lcl_global_main_name USING &apos;/_&apos;.
* end of changes for partner namespace

*Typ des Rahmenobjektes lesen
  READ TABLE it_prog_stueckliste INDEX 1 INTO lcl_wa_prog_stueckliste.
  lcl_typus = lcl_wa_prog_stueckliste-type.


  REFRESH it_html.
*Framset zusammenbauen
  APPEND &apos;&lt;HTML&gt;&apos; TO it_html.
  APPEND &apos;&lt;HEAD&gt;&apos; TO it_html.
  APPEND &apos;&lt;TITLE&gt;&apos; TO it_html.
  APPEND global_main_name TO it_html.
  APPEND &apos;&lt;/TITLE&gt;&apos; TO it_html.
  APPEND &apos;&lt;/HEAD&gt;&apos; TO it_html.
  APPEND &apos;&lt;FRAMESET COLS=&quot;30%,*&quot;&gt;&apos; TO it_html.

  APPEND &apos;&lt;FRAME SRC=&quot;nav.xml&quot; NAME=&quot;nav&quot;&gt;&apos; TO it_html.
  CONCATENATE &apos;Systeminfo_&apos; lcl_wa_prog_stueckliste-instnr &apos;.xml&apos;
    INTO lcl_url.
  CONCATENATE &apos;&lt;FRAME SRC=&quot;&apos; lcl_url &apos;&quot;NAME=&quot;main&quot;&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.
  APPEND &apos;&lt;/FRAMESET&gt;&apos; TO it_html.
  APPEND &apos;&lt;/HTML&gt;&apos; TO it_html.

*Frameset herunterladen
  PERFORM download_html_file USING &apos;F&apos;.


*Navigationsfile zusammenbauen
  REFRESH it_html.

  APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;&apos; TO it_html.
  APPEND &apos;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;nav.xsl&quot;?&gt;&apos;
      TO it_html.
  APPEND &apos;&lt;Nav&gt;&apos; TO it_html.

*Ueberschrift generieren je nach Typus
  CASE lcl_typus.
    WHEN &apos;Logical Development&apos;.
      CONCATENATE &apos;&lt;header&gt;Logical Development&apos;
          global_main_name &apos;&lt;/header&gt;&apos; INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Report/Modulpool&apos;.
      CONCATENATE &apos;&lt;header&gt;Report or Modulpool&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Transaction&apos;.
      CONCATENATE &apos;&lt;header&gt;Transaction&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.


    WHEN &apos;Functiongroup&apos;.
      CONCATENATE &apos;&lt;header&gt;Functiongroup&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Class&apos;.
      CONCATENATE &apos;&lt;header&gt;Class (ABAP OO)&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Interface(OO)&apos;.
      CONCATENATE &apos;&lt;header&gt;Interface (ABAP OO)&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Enhancement Project&apos;.
      CONCATENATE &apos;&lt;header&gt;Enhancement Project&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Badiimp&apos;.
      CONCATENATE &apos;&lt;header&gt;Badi Implementation&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Development Class&apos;.
      CONCATENATE &apos;&lt;header&gt;Development Class&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;Transportrequest&apos;.
      CONCATENATE &apos;&lt;header&gt;Transportrequest&apos;
        global_main_name &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN &apos;IACS&apos;.
      CONCATENATE &apos;&lt;header&gt;IAC-Service(ITS)&apos;
        &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.
    WHEN &apos;SINGLE_LIMU&apos;.
      CONCATENATE &apos;&lt;header&gt;Single Selected Objects&apos;
      &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.

    WHEN OTHERS.
      CONCATENATE &apos;&lt;header&gt;Modifications&apos;
        &apos;&lt;/header&gt;&apos;  INTO wa_html SEPARATED BY space.
      APPEND wa_html TO it_html.


  ENDCASE.

*gesonderte Verarbeitung fuer einzelene Typen
  IF  lcl_typus = &apos;Report/Modulpool&apos; OR lcl_typus = &apos;Transaction&apos;.
    PERFORM create_inc_for_rm USING lcl_typus.
  ELSEIF lcl_typus = &apos;Functiongroup&apos;.
    PERFORM create_inc_for_fk.
  ELSEIF  lcl_typus = &apos;Class&apos;.
    PERFORM create_inc_for_class.
  ELSEIF lcl_typus = &apos;Interface(OO)&apos;.
    PERFORM create_html_for_intf.
  ELSEIF lcl_typus = &apos;Logical Development&apos;.
    PERFORM create_html_for_logdev.
*Navigationsfile herunterladen
    PERFORM download_html_file USING &apos;N&apos;.
*Routine verlassen
    EXIT.
  ELSEIF lcl_typus = &apos;Enhancement Project&apos;.
    PERFORM create_html_for_enh.
  ELSEIF lcl_typus = &apos;Development Class&apos;.
    PERFORM create_html_for_devclass.
  ELSEIF lcl_typus = &apos;Transportrequest&apos;
      OR lcl_typus = &apos;SINGLE_LIMU&apos;.
    PERFORM create_html_for_trkorr.
  ELSEIF lcl_typus =  &apos;Badiimp&apos;.
    PERFORM create_html_for_badiimps.
  ELSEIF lcl_typus =  &apos;IACS&apos;.
    PERFORM create_html_for_iacs.
  ELSE.
    PERFORM create_html_for_modis.
  ENDIF.


*Textelemente wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;TE&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Textelements:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_rept &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;TE&apos;.
      IF p_trkorr IS INITIAL.
        CONCATENATE lcl_wa_prog_stueckliste-file_name
           &apos;.htm&apos; INTO lcl_url.
        lcl_name = lcl_wa_prog_stueckliste-name+3.

        PERFORM nav_xml_add_subitem USING lcl_url
                                          lcl_name
                                          &apos;main&apos;.
      ELSE.
*Workaround fuer Klassenincludes
        SEARCH lcl_wa_prog_stueckliste-name FOR &apos;=&apos;.
        IF sy-subrc = 4.
          lcl_text = lcl_wa_prog_stueckliste-name+3.
        ELSE.
          sy-fdpos = sy-fdpos - 3.
          lcl_text =
              lcl_wa_prog_stueckliste-name+3(sy-fdpos).
        ENDIF.
        CONCATENATE lcl_wa_prog_stueckliste-file_name
          &apos;.htm&apos; INTO lcl_url.
        lcl_name = lcl_text.

        PERFORM nav_xml_add_subitem USING lcl_url
                                          lcl_name
                                          &apos;main&apos;.

      ENDIF.
      APPEND wa_html TO it_html.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  ENDIF.


*exerne Funktionsbausteine wenn vorhanden
*Keine Beachtung, wenn abhängige Objkete nicht selektiert
*werden
  IF g_nodep IS INITIAL.
    READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Functionmodule&apos;
       TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Called Functionmodules:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_func_call &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
*    Verarbeitung der Funktionsbausteine--&gt; Verweis auf Funktionsgruppe
      LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
              WHERE type = &apos;Functionmodule&apos;.
*       begin of changes for partner namespace
        TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*       end of changes for partner namespace

*Je nach wird der Verweis unterschiedlich aufgebaut
        IF  extern = &apos;X&apos; OR p_devc = &apos;X&apos; OR p_trkorr = &apos;X&apos;.
*Ueberpruefen, ob Verweis da Oberprogramm ist
          READ TABLE it_obj_list WITH KEY
              name = lcl_wa_prog_stueckliste-obername
              TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            CONCATENATE
               &apos;../../FG_&apos; lcl_wa_prog_stueckliste-obername
               &apos;/index.htm&apos; INTO lcl_url.
            lcl_name = lcl_wa_prog_stueckliste-name.

            PERFORM nav_xml_add_subitem USING lcl_url
                                              lcl_name
                                              c_target_new.
          ELSE.
            CONCATENATE
              &apos;../FG_&apos; lcl_wa_prog_stueckliste-obername
              &apos;/index.htm&apos; INTO lcl_url.
            lcl_name = lcl_wa_prog_stueckliste-name.

            PERFORM nav_xml_add_subitem USING lcl_url
                                              lcl_name
                                              c_target_new.

          ENDIF. &quot;Lste Oberobjekte
        ELSE.
          CONCATENATE &apos;./FG_&apos; lcl_wa_prog_stueckliste-obername
                     &apos;/index.htm&apos; INTO lcl_url.
          lcl_name = lcl_wa_prog_stueckliste-name.

          PERFORM nav_xml_add_subitem USING lcl_url
                                            lcl_name
                                            c_target_new .
        ENDIF. &quot;Externe Programme


      ENDLOOP.

      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF. &quot;Funktionsbausteine
  ENDIF. &quot;Transportauftraege

*Screens verarbeiten, wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;SCR&apos;
     TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Screens:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_dynp &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*    Verarbeitung der Screens
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;SCR&apos;.

      IF    p_trkorr = &apos;X&apos;  &quot;fuer tranportauftrag Namen anders bauen
         AND lcl_wa_prog_stueckliste-file_name+5(1) NE space.

        CONCATENATE &apos;SC_&apos; lcl_wa_prog_stueckliste-file_name &apos;.txt&apos;
            INTO lcl_url.
        lcl_name = lcl_wa_prog_stueckliste-name.

      ELSE.
*       begin of changes for partner namespace
        TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*       end of changes for partner namespace
        CONCATENATE &apos;SC_&apos; lcl_wa_prog_stueckliste-obername
         lcl_wa_prog_stueckliste-file_name &apos;.txt&apos; INTO lcl_url.

        lcl_name = lcl_wa_prog_stueckliste-name.
      ENDIF.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF. &quot;Screens


*Functionkeys verarbeiten, wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;PfFu&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Funcktionkeys of Status:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cuad_key &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*    Verarbeitung der Functionkeys
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;PfFu&apos;.

      CONCATENATE lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
         INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name+12.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF. &quot;Functionkeys

*Menuelisten verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;PfMe&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Menuelist of Status:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cuad_menu &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*    Menuliste
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;PfMe&apos;.

      CONCATENATE lcl_wa_prog_stueckliste-file_name &apos;.htm&apos;
          INTO lcl_url.
      lcl_name = lcl_wa_prog_stueckliste-name+9.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        &apos;main&apos;.


    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF. &quot;Menuelisten

*Tiltbarliste wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Titelbar&apos;
      TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Titlebar:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cuad_pf &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Titlebar_&apos; lcl_global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = global_main_name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.


    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Messages wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;MSG&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Messages:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_mess &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Messagetable_&apos; lcl_global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = global_main_name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*DATA-Dictionary Objekte verarbeiten
  PERFORM create_ddic_for_nav.

*Typgruppen verarbeiten, wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Typgroup&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Typgroups:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_typd &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
*    Verarbeitung der Functionkeys
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Typgroup&apos;.

      CONCATENATE &apos;TGR_&apos; lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
          INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        &apos;main&apos;.


    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF. &quot;Functionkeys

*Transaktionscodeliste wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Tranactioncodelist&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Transactioncodes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_tran_main &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Tacodelist_&apos; lcl_global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = lcl_wa_prog_stueckliste-obername.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*DNE_KW11 Begin
* Enhancement Spot List
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Enhancement Spot List&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Enhancement Spot List:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_enh_spot &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Enhancement Spot&apos; global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Enhancement Spot List&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Core Badi List
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;New BADI List&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Core Badi List:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_core_badi &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;New BADI&apos; global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Core Badi List&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Web Dynpro List
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Web-Dyn Pro List&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Web Dynpro List:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_webd &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Web-Dyn Pro&apos; global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Web Dynpro List&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.


*DNE_KW11 End


*Lockobject verarbeiten wenn vorhanden
  REFRESH lcl_it_prog_stueckliste.
*Lockobjekte in lokale Tabellen kopieren
  LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type = &apos;Lockobject&apos;.
    APPEND lcl_wa_prog_stueckliste TO lcl_it_prog_stueckliste.
  ENDLOOP.
  DESCRIBE TABLE lcl_it_prog_stueckliste LINES lcl_line.
*Lockobject verarbeiten
  LOOP AT lcl_it_prog_stueckliste INTO lcl_wa_prog_stueckliste.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Lockobjects:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_enqu &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDIF.

    CONCATENATE &apos;Lockobject_&apos; lcl_wa_prog_stueckliste-file_name
      &apos;.xml&apos; INTO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.

*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.
  ENDLOOP.


* Dialogmodule in lokale Tabellen kopieren
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Dialogmodule&apos;
            INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
*   begin of changes for partner namespace
    TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*   end of changes for partner namespace
*verarbeiten
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Dialogmodules:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_dial &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*   Dialogmodulparameter
    CONCATENATE &apos;Dlgmd_Params_&apos; lcl_wa_prog_stueckliste-name
     &apos;.txt&apos; INTO lcl_url.

    lcl_name = &apos;Dialogmodul Parameter&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      &apos;main&apos;.


*Den Dialogmodulen zugeordnetes Program
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Assigned Programs:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_prog_dial &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
      WHERE type = &apos;Dialog Program&apos;.

      IF extern = &apos;X&apos; OR p_devc = &apos;X&apos; OR p_trkorr = &apos;X&apos;.
*Ueberpruefen, ob Verweis da Oberprogramm ist
        READ TABLE it_obj_list WITH KEY
            name = lcl_wa_prog_stueckliste-obername
            TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          CONCATENATE
            &apos;../../RM_&apos; lcl_wa_prog_stueckliste-file_name
             &apos;/index.htm&apos; INTO lcl_url.

          lcl_name = lcl_wa_prog_stueckliste-name.

        ELSE.
          CONCATENATE
            &apos;../RM_&apos; lcl_wa_prog_stueckliste-file_name
             &apos;/index.htm&apos; INTO lcl_url.

          lcl_name = lcl_wa_prog_stueckliste-name.
        ENDIF. &quot;Lste Oberobjekte

      ELSE.
        CONCATENATE &apos;./RM_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

        lcl_name = lcl_wa_prog_stueckliste-name.
      ENDIF. &quot;extern, DC, Tr

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  ENDIF.


*Berechtigungsobjektlisten, wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Authority Object&apos;
      TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Authority Objects:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_suso &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
*Authority-Objectliste
    CONCATENATE &apos;Auhthorities&apos; lcl_global_main_name &apos;.xml&apos;
       INTO lcl_url.
    lcl_name = &apos;Authority Object List&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.
*Aktivitaetenliste, wenn vorhanden
    READ TABLE it_prog_stueckliste  WITH KEY
      type = &apos;Activities of Authority Objects&apos; TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      CONCATENATE &apos;AuthActivities&apos; lcl_global_main_name &apos;.xml&apos;
          INTO lcl_url.
      lcl_name = &apos;Activities of Authority Objects&apos;.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDIF.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Felder der Berechtigungsobjekte (nur bei Tranportautrag moeglich)
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Authorityfield&apos;
      TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Authorityfields:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_auth &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;Authortyfields_&apos; lcl_global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Authorityfields&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                        &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.


*Set/GetParameterlisteliste wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;SET/Get-Parameter&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Set/Get-Parameter:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_para &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Set_Get_Params_&apos; lcl_global_main_name &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Set/Get-Parameterlist&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                        &apos;main&apos;.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Externe Programmaufrufe, wenn nicht ausgeschaltet
  IF g_nodep IS INITIAL.
    PERFORM create_html_extern.
  ENDIF.

*Verwendete Klassen verarbeiten Transportauftrag und
*Entwicklungsklasse werden extra gehandhabt
  IF lcl_typus &lt;&gt; &apos;Transportrequest&apos; AND lcl_typus &lt;&gt;
  &apos;Development Class&apos;.
    READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Class(OO)&apos;
       TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Used Classes:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_class_used &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.

*      Verarbeitung der Klassen--&gt; Verweis auf Verzeichnis der Klassen
      LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
              WHERE type = &apos;Class(OO)&apos;.

*  Je nach wird der Verweis unterschiedlich aufgebaut
        IF extern = &apos;X&apos;  OR p_devc = &apos;X&apos;.
          READ TABLE it_obj_list WITH KEY
            name = lcl_wa_prog_stueckliste-obername
            TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            CONCATENATE
              &apos;../../OC_&apos; lcl_wa_prog_stueckliste-file_name
               &apos;/index.htm&apos; INTO lcl_url.
            lcl_name = lcl_wa_prog_stueckliste-name.
          ELSE.
            CONCATENATE
              &apos;../OC_&apos; lcl_wa_prog_stueckliste-file_name
              &apos;/index.htm&apos; INTO lcl_url.
            lcl_name = lcl_wa_prog_stueckliste-name.
          ENDIF. &quot;Oberobjekt
        ELSEIF p_trkorr = &apos;X&apos;.

          CONCATENATE lcl_wa_prog_stueckliste-name
           &apos;(not linked)&apos; INTO lcl_name.
          CLEAR lcl_url.

        ELSE.
          CONCATENATE &apos;./OC_&apos; lcl_wa_prog_stueckliste-file_name
                &apos;/index.htm&apos; INTO lcl_url.
          lcl_name = lcl_wa_prog_stueckliste-name.
        ENDIF.

        PERFORM nav_xml_add_subitem USING lcl_url
                                          lcl_name
                                          c_target_new.

      ENDLOOP.

      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.
  ENDIF. &quot;Lieg Tr or DC vor

*Hotpackagestand anzeigen
  READ TABLE it_prog_stueckliste INDEX 1 INTO lcl_wa_prog_stueckliste.
* Listeneintrag schreiben
  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  APPEND &apos;&lt;value&gt;General Information:&lt;/value&gt;&apos; TO it_html.
  CONCATENATE &apos;&lt;order&gt;&apos; g_order_sys_info &apos;&lt;/order&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.

  CONCATENATE &apos;Systeminfo_&apos; lcl_wa_prog_stueckliste-instnr &apos;.xml&apos;
      INTO lcl_url.
  lcl_name = &apos;System Information&apos;.

  PERFORM nav_xml_add_subitem USING lcl_url
                                    lcl_name
                      &apos;main&apos;.
  APPEND &apos;&lt;/item&gt;&apos; TO it_html.

*Ende der Navigationsseite
  APPEND &apos;&lt;/Nav&gt;&apos; TO it_html.

*Navigationsfile herunterladen
  PERFORM download_html_file USING &apos;N&apos;.

ENDFORM.                    &quot; create_nav_files
*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_html_file
*&amp;---------------------------------------------------------------------*
*       Download der Framesetdatei und der Navigationsdatei
*       je nach Wert im Uebergabeparameter P_TYPUS.
*----------------------------------------------------------------------*
FORM download_html_file USING p_typus TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
  CLEAR filename.
*Feststellen, welche Dateiart vorhandnen ist.
  IF p_typus = &apos;F&apos;.  &quot;Framsetdatei
    CONCATENATE new_dir &apos;\index.htm&apos; INTO filename.
  ELSEIF p_typus = &apos;N&apos;.
    CONCATENATE new_dir &apos;\nav.xml&apos; INTO filename.
  ELSEIF p_typus = &apos;1&apos;. &quot;ABAP.xsl
    CONCATENATE new_dir &apos;\ABAP.xsl&apos; INTO filename.
  ELSEIF p_typus = &apos;2&apos;. &quot;nav.xsl
    CONCATENATE new_dir &apos;\nav.xsl&apos; INTO filename.
  ELSEIF p_typus = &apos;3&apos;. &quot;table.xsl
    CONCATENATE new_dir &apos;\table.xsl&apos; INTO filename.
  ELSEIF p_typus = &apos;4&apos;. &quot;formate.css
    CONCATENATE new_dir &apos;\formate.css&apos; INTO filename.
  ELSEIF p_typus = &apos;5&apos;. &quot;blank.xsl
    CONCATENATE new_dir &apos;\blank.xsl&apos; INTO filename.
  ENDIF.

* begin of changes for partner namespace
  TRANSLATE filename USING &apos;/_&apos;.
* end of changes for partner namespace
* download
  IF p_typus = &apos;1&apos;.
    PERFORM call_ws_download USING   filename
                                     it_abap_xsl
                             CHANGING lcl_subrc.
  ELSEIF p_typus = &apos;2&apos;.
    PERFORM call_ws_download USING   filename
                                     it_nav_xsl
                             CHANGING lcl_subrc.
  ELSEIF p_typus = &apos;3&apos;.
    PERFORM call_ws_download USING   filename
                                     it_table_xsl
                             CHANGING lcl_subrc.
  ELSEIF p_typus = &apos;4&apos;.
    PERFORM call_ws_download USING   filename
                                     it_formate_css
                             CHANGING lcl_subrc.
  ELSEIF p_typus = &apos;5&apos;.
    PERFORM call_ws_download USING   filename
                                     it_blank_xsl
                             CHANGING lcl_subrc.



  ELSE.
    PERFORM call_ws_download USING    filename
                                      it_html
                             CHANGING lcl_subrc.
  ENDIF.

ENDFORM.                    &quot; download_html_file
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_ddic_for_nav
*&amp;---------------------------------------------------------------------*
*       Erstellung der Eintraege in der Navigationsdatei
*       fuer die DATA-Dictionnary Objekte.
*----------------------------------------------------------------------*
FORM create_ddic_for_nav.
*Lokale Stueckliste fuer Verarbeitung
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste,
        lcl_wa_prog_stueckliste LIKE LINE OF lcl_it_prog_stueckliste.
*Zwischenspeicherung der Zeilenanzahl
  DATA: lcl_tmp TYPE i.
*Anzahl Zeilen in tabellen
  DATA: lcl_line  TYPE i.
*Sicherung des Tabix der aktuellen Tabelle
  DATA: lcl_savetabix TYPE i.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.


  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  MOVE &apos;&lt;value&gt;Data-Dictionnary Objekte:&lt;/value&gt;&apos; TO wa_html.
  APPEND wa_html TO it_html.
  CONCATENATE &apos;&lt;order&gt;&apos; g_order_ddic_main &apos;&lt;/order&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.

  APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  REFRESH lcl_it_prog_stueckliste.
*Tabellen in lokale Tabellen kopierenverarbeiten
  LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type = &apos;Table&apos;.
    APPEND lcl_wa_prog_stueckliste TO lcl_it_prog_stueckliste.
  ENDLOOP.

  DESCRIBE TABLE lcl_it_prog_stueckliste LINES lcl_line.
*Tabellen verarbeiten
  LOOP AT lcl_it_prog_stueckliste INTO lcl_wa_prog_stueckliste.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Tables:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_tabl_tab &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDIF.

    CONCATENATE &apos;TAB_&apos; lcl_wa_prog_stueckliste-file_name
      &apos;.xml&apos; INTO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                       &apos;main&apos;.
*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.

  ENDLOOP.

  REFRESH lcl_it_prog_stueckliste.
*Strukturen in lokale Tabellen kopieren
  LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type = &apos;Structure&apos;.
    APPEND lcl_wa_prog_stueckliste TO lcl_it_prog_stueckliste.
  ENDLOOP.

  DESCRIBE TABLE lcl_it_prog_stueckliste LINES lcl_line.
*Strukturen verarbeiten
  LOOP AT lcl_it_prog_stueckliste INTO lcl_wa_prog_stueckliste.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Structures:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_tabl_struc &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.

    ENDIF.

    CONCATENATE &apos;STR_&apos; lcl_wa_prog_stueckliste-file_name
      &apos;.xml&apos; INTO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                       &apos;main&apos;.
*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.

  ENDLOOP.

  REFRESH lcl_it_prog_stueckliste.
*Tabellentypen in lokale Tabellen kopieren
  LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type = &apos;Tabletype&apos;.
    APPEND lcl_wa_prog_stueckliste TO lcl_it_prog_stueckliste.
  ENDLOOP.

  DESCRIBE TABLE lcl_it_prog_stueckliste LINES lcl_line.
*Tabellentypen verarbeiten
  LOOP AT lcl_it_prog_stueckliste INTO lcl_wa_prog_stueckliste.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Tabletypes:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_ttyp &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDIF.

    CONCATENATE &apos;Tabletype_&apos; lcl_wa_prog_stueckliste-file_name
           &apos;.xml&apos; INTO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                       &apos;main&apos;.
*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.

  ENDLOOP.

  REFRESH lcl_it_prog_stueckliste.
*Appends in lokale Tabellen kopieren
  LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type = &apos;Append&apos;.
    APPEND lcl_wa_prog_stueckliste TO lcl_it_prog_stueckliste.
  ENDLOOP.
  DESCRIBE TABLE lcl_it_prog_stueckliste LINES lcl_line.
*Appends verarbeiten
  LOOP AT lcl_it_prog_stueckliste INTO lcl_wa_prog_stueckliste.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Appends:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_tabl_app &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDIF.

    CONCATENATE &apos;App_&apos; lcl_wa_prog_stueckliste-file_name
      &apos;.xml&apos; INTO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                       &apos;main&apos;.
*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.

  ENDLOOP.

  REFRESH lcl_it_prog_stueckliste.
*Views in lokale Tabellen kopieren
  LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type = &apos;View&apos;.
    APPEND lcl_wa_prog_stueckliste TO lcl_it_prog_stueckliste.
  ENDLOOP.
  DESCRIBE TABLE lcl_it_prog_stueckliste LINES lcl_line.
*Views verarbeiten
  LOOP AT lcl_it_prog_stueckliste INTO lcl_wa_prog_stueckliste.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Views:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_view &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDIF.

    CONCATENATE &apos;View_&apos; lcl_wa_prog_stueckliste-file_name
      &apos;.xml&apos; INTO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                       &apos;main&apos;.

*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.

  ENDLOOP.

*Datenelemente
  READ TABLE it_prog_stueckliste INTO lcl_wa_prog_stueckliste
      WITH KEY type = &apos;Dataelements&apos;.
  IF sy-subrc = 0.
*   begin of changes for partner namespace
    TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*   end of changes for partner namespace
*    APPEND &apos;&lt;item_linked&gt;&apos; TO it_html.
*
*    APPEND &apos;&lt;value&gt;Dataelements&lt;/value&gt;&apos; to it_html.
*
*     concatenate &apos;&lt;url&gt;Dataelements_&apos;
*       lcl_wa_prog_stueckliste-obername &apos;.xml&lt;/url&gt;&apos; into wa_html.
*      append wa_html to it_html.
*
*    APPEND &apos;&lt;target&gt;main&lt;/target&gt;&apos; to it_html.
*
*    APPEND &apos;&lt;/item_linked&gt;&apos; TO it_html.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Dataelements:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_dtel &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;Dataelements_&apos;
       lcl_wa_prog_stueckliste-obername &apos;.xml&apos; INTO lcl_url.
    lcl_name = &apos;Dataelements&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                     &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Domainen
  READ TABLE it_prog_stueckliste INTO lcl_wa_prog_stueckliste
      WITH KEY type = &apos;Domainheader&apos;.
  IF sy-subrc = 0.
*   begin of changes for partner namespace
    TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*   end of changes for partner namespace
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Domains:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_doma &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;DomHeader_&apos;
     lcl_wa_prog_stueckliste-obername &apos;.xml&apos; INTO lcl_url.

    lcl_name = &apos;Domainheader&apos;.
    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                        &apos;main&apos;.


    READ TABLE it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WITH KEY type = &apos;Domainvalues&apos;.
    IF sy-subrc = 0.
*     begin of changes for partner namespace
      TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*     end of changes for partner namespace
      CONCATENATE &apos;DomValues_&apos;
       lcl_wa_prog_stueckliste-obername &apos;.xml&apos; INTO lcl_url.

      lcl_name = &apos;Domain Values&apos;.
      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDIF.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.


*DNE_KW11 Begin
  READ TABLE it_prog_stueckliste INTO lcl_wa_prog_stueckliste
      WITH KEY type = &apos;Searchhelplist&apos;.
  IF sy-subrc = 0.
    TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Searchhelp List:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_shlp &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;Searchhelp_&apos; global_main_name &apos;.xml&apos; INTO lcl_url.
    lcl_name = &apos;Searchhelp List&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                     &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.
*DNE_KW11 End

*Ueberpruefen, ob Entraege geschriegben worden sind
*außer Rahmen
  DESCRIBE TABLE it_html LINES lcl_line.
  lcl_tmp = lcl_line - 2.
  READ TABLE it_html INDEX lcl_tmp INTO wa_html.
*Loeschen der bisher generierten Daten
  IF wa_html = &apos;&lt;value&gt;Data-Dictionnary Objekte:&lt;/value&gt;&apos;.
    lcl_tmp = lcl_tmp - 1.
    DELETE it_html FROM lcl_tmp TO lcl_line.
  ENDIF.

ENDFORM.                    &quot; create_ddic_for_nav
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_exetern
*&amp;---------------------------------------------------------------------*
*      Erstellung der Eintraege in die Navigationsdatei
*      fuer aufgerufene Reports/Modulpools.
*----------------------------------------------------------------------*
FORM create_html_extern.
*Lokale Stueckliste fuer Verarbeitung
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste,
        lcl_wa_prog_stueckliste LIKE LINE OF lcl_it_prog_stueckliste.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

*Anzahl Zeilen in tabellen
  DATA: lcl_line  TYPE i.
*Sicherung des Tabix der aktuellen Tabelle
  DATA: lcl_savetabix TYPE i.


  REFRESH lcl_it_prog_stueckliste.
*Externe Programmaufrufe in lokale Tabellen kopieren
  LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type = &apos;1&apos;.
    APPEND lcl_wa_prog_stueckliste TO lcl_it_prog_stueckliste.
  ENDLOOP.
  DESCRIBE TABLE lcl_it_prog_stueckliste LINES lcl_line.
*Externe Programmaufrufe verarbeiten
  LOOP AT lcl_it_prog_stueckliste INTO lcl_wa_prog_stueckliste.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Externe Programmaufrufe:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_prog_ext &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
    ENDIF.

*Je Ebenenach wird der Verweis unterschiedlich aufgebaut
    IF extern = &apos;X&apos;  OR p_devc = &apos;X&apos;.
      READ TABLE it_obj_list WITH KEY
           name = lcl_wa_prog_stueckliste-name
           TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        CONCATENATE &apos;../../RM_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

        lcl_name = lcl_wa_prog_stueckliste-name.

      ELSE.
        CONCATENATE &apos;../RM_&apos; lcl_wa_prog_stueckliste-file_name
            &apos;/index.htm&apos; INTO lcl_url.

        lcl_name = lcl_wa_prog_stueckliste-name.

      ENDIF.
    ELSE.
      READ TABLE it_obj_list WITH KEY
         name = lcl_wa_prog_stueckliste-name
         TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        lcl_url = &apos;index.htm&apos;.

        lcl_name = lcl_wa_prog_stueckliste-name.

      ELSE.
        CONCATENATE &apos;./RM_&apos; lcl_wa_prog_stueckliste-file_name
             &apos;/index.htm&apos; INTO lcl_url.

        lcl_name = lcl_wa_prog_stueckliste-name.
      ENDIF.
    ENDIF. &quot;Extern?

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      c_target_new.
*   Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.

  ENDLOOP.

ENDFORM.                    &quot; create_html_exetern
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_inc_for_rm
*&amp;---------------------------------------------------------------------*
*      Erstellung der Eintraege in der Navigationsdatei
*      fuer die Includes in Reports/Modulpools.
*----------------------------------------------------------------------*
FORM create_inc_for_rm USING p_typus TYPE string.
*Arbeitsbereich fuer Stueckliste
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste,
        lcl_wa_prog_stueckliste LIKE LINE OF lcl_it_prog_stueckliste.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.
*Transaktionen zu Funktionsgruppen und Klassen abfangen
  READ TABLE it_prog_stueckliste INDEX 1
      INTO lcl_wa_prog_stueckliste.
  IF lcl_wa_prog_stueckliste-type =&apos;Transaction&apos;.
    READ TABLE it_prog_stueckliste INDEX 2
         INTO lcl_wa_prog_stueckliste.
    IF lcl_wa_prog_stueckliste-type =&apos;Functiongroup&apos;.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Related Functiongroup:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_fugr_rel &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.

      CONCATENATE &apos;./FG_&apos; lcl_wa_prog_stueckliste-file_name
         &apos;/index.htm&apos; INTO lcl_url.
      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.

    ELSEIF lcl_wa_prog_stueckliste-type = &apos;Class&apos;.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Related Class:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_class_rel &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.
      CONCATENATE &apos;./OC_&apos; lcl_wa_prog_stueckliste-file_name &apos;/index.htm&apos;
         INTO lcl_url.
      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

      APPEND &apos;&lt;/item&gt;&apos; TO it_html.

    ENDIF.
*     APPEND &apos;&lt;/item&gt;&apos; to it_html.
  ENDIF.

*Incudes schreiben wenn vorhanden
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IN&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
*  Includes schreiben
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Includes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_reps &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  Schreiben der Includes je nach Typ des Programmes
    IF p_typus = &apos;Report/Modulpool&apos; OR p_typus = &apos;Transaction&apos;.
      LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
          WHERE type = &apos;Report/Modulpool&apos;
             OR type = &apos;IN&apos;.

        IF lcl_wa_prog_stueckliste-type = &apos;Report/Modulpool&apos;.
          CONCATENATE &apos;R_&apos; lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
              INTO lcl_url.
          lcl_name = lcl_wa_prog_stueckliste-name.

        ELSE.
          CONCATENATE &apos;IN_&apos; lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
            INTO lcl_url.
          lcl_name = lcl_wa_prog_stueckliste-name.

        ENDIF.
        PERFORM nav_xml_add_subitem USING lcl_url
                                          lcl_name
                                &apos;main&apos;.
      ENDLOOP.

      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF. &quot;Typus
  ELSE.
    READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Report/Modulpool&apos;
        INTO lcl_wa_prog_stueckliste.
    IF sy-subrc = 0.
*      Includes schreiben
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Includes:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_reps &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.

*      Schreiben der Includes je nach Typ des Programmes
      IF p_typus = &apos;Report/Modulpool&apos; OR p_typus = &apos;Transaction&apos;.
        LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Report/Modulpool&apos;
               OR type = &apos;IN&apos;.

          IF lcl_wa_prog_stueckliste-type = &apos;Report/Modulpool&apos;.
            CONCATENATE &apos;R_&apos; lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
                INTO lcl_url.
            lcl_name = lcl_wa_prog_stueckliste-name.

          ELSE.
            CONCATENATE &apos;IN_&apos; lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
                INTO lcl_url.
            lcl_name = lcl_wa_prog_stueckliste-name.

          ENDIF.
          PERFORM nav_xml_add_subitem USING lcl_url
                                            lcl_name
                                   &apos;main&apos;.
        ENDLOOP.

        APPEND &apos;&lt;/item&gt;&apos; TO it_html.
      ENDIF. &quot;Typus
    ENDIF. &quot;Report/Modulpoole

  ENDIF. &quot;INclude

ENDFORM.                    &quot; create_inc_for_rm
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_inc_for_fk
*&amp;---------------------------------------------------------------------*
*      Erstellung der Eintraege in der Navigationsdatei
*      fuer die Includes und Funktionsbausteine in Funktionsgruppen.
*----------------------------------------------------------------------*
FORM create_inc_for_fk.
*Lokale Bereiche fuer Funktionsgruppenstruktur
  DATA: lcl_it_fkgrp_struktur LIKE it_fkgrp_struktur,
        lcl_wa_fkgrp_struktur LIKE LINE OF lcl_it_fkgrp_struktur.
*Anzahl Zeilen in tabellen
  DATA: lcl_line  TYPE i.
*Sicherung des Tabix der aktuellen Tabelle
  DATA: lcl_savetabix TYPE i.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.



*Funktionsbausteinincludes bearbeiten
  REFRESH lcl_it_fkgrp_struktur.
*Externe Programmaufrufe in lokale Tabellen kopieren
  LOOP AT it_fkgrp_struktur INTO lcl_wa_fkgrp_struktur
        WHERE NOT ( fktbstname IS  INITIAL ).
    APPEND lcl_wa_fkgrp_struktur TO lcl_it_fkgrp_struktur.
  ENDLOOP.
  DESCRIBE TABLE lcl_it_fkgrp_struktur LINES lcl_line.
*Funktionsbausteinincludes bearbeiten
  LOOP AT lcl_it_fkgrp_struktur INTO lcl_wa_fkgrp_struktur.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Functionmodules:&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_func &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.

    ENDIF.

    CONCATENATE &apos;IN_&apos; lcl_wa_fkgrp_struktur-file_objectname &apos;.xml&apos;
        INTO lcl_url.

    lcl_name = lcl_wa_fkgrp_struktur-fktbstname.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.
*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.
  ENDLOOP. &quot;Funktionsbausteine


*Andere Includes bearbeiten
  REFRESH lcl_it_fkgrp_struktur.
*Includes in lokale Tabellen kopieren
  LOOP AT it_fkgrp_struktur INTO lcl_wa_fkgrp_struktur
        WHERE  fktbstname IS  INITIAL.
    APPEND lcl_wa_fkgrp_struktur TO lcl_it_fkgrp_struktur.
  ENDLOOP.
  DESCRIBE TABLE lcl_it_fkgrp_struktur LINES lcl_line.
*Funktionsbausteinincludes bearbeiten
  LOOP AT lcl_it_fkgrp_struktur INTO lcl_wa_fkgrp_struktur.
    lcl_savetabix = sy-tabix.

*Erster Eintrag
    IF sy-tabix = 1.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Includes&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_reps &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.


    ENDIF.

    CONCATENATE &apos;IN_&apos; lcl_wa_fkgrp_struktur-file_objectname &apos;.xml&apos;
        INTO lcl_url.

    lcl_name = lcl_wa_fkgrp_struktur-objectname.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.
*Letzter Eintrag
    IF lcl_savetabix = lcl_line.
      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ENDIF.
  ENDLOOP. &quot;Funktionsbausteine

ENDFORM.                    &quot; create_inc_for_fk
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_inc_for_class
*&amp;---------------------------------------------------------------------*
*      Erstellung der Eintraege in der Navigationsdatei
*      fuer die Includes und Methoden in Klassen.
*----------------------------------------------------------------------*
FORM create_inc_for_class.
*Lokale Bereiche fuer Klassenstruktur
  DATA: lcl_it_classlist TYPE STANDARD TABLE OF classlist,
        lcl_wa_classlist LIKE LINE OF lcl_it_classlist.
*Stuecklisenbereich
  DATA: lcl_wa_prog_stueckliste LIKE LINE OF it_prog_stueckliste.
*Hilfvariable Laenge
  DATA: lcl_len TYPE i.
*global_main_name
  DATA: lcl_global_main_name LIKE global_main_name.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

* begin of changes for partner namespace
  lcl_global_main_name = global_main_name.
  TRANSLATE lcl_global_main_name USING &apos;/_&apos;.
* end of changes for partner namespace


  READ TABLE it_classlist  WITH KEY typus = &apos;Meth&apos;
     TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Methods&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_meth &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  Verarbeitung der Methodenincludes
    LOOP AT it_classlist INTO lcl_wa_classlist
          WHERE  typus = &apos;Meth&apos;.

      CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
          INTO lcl_url.

      lcl_name = lcl_wa_classlist-meth.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                           &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  ENDIF.

*Hauptincludes
  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  APPEND &apos;&lt;value&gt;Mainincludes&lt;/value&gt;&apos; TO it_html.
  CONCATENATE &apos;&lt;order&gt;&apos; g_order_class_main &apos;&lt;/order&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.
*Traegerinclude
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CP&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
        INTO lcl_url.

    lcl_name = &apos;Classpoolinclude&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.

  ENDIF.

*Public Section
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CU&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Public Section&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.
  ENDIF.

*Private Section
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CI&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Private Section&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.
  ENDIF.

*Protected Section
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CO&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Protected Section&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.
  ENDIF.

*Local Types
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CCDEF&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Locale Types&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.

  ENDIF.

* Local Macros
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CCMAC&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Local Macros&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.

  ENDIF.

* Local Class Implementations
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CCIMP&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
        INTO lcl_url.
    lcl_name = &apos;Local Class Implementations&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.

  ENDIF.

*Dummy Include
  READ TABLE it_classlist INTO lcl_wa_classlist
    WITH KEY typus = &apos;CIN&apos; inc+30 = &apos;CT&apos;.
  IF sy-subrc = 0.
    CONCATENATE &apos;CLIN_&apos; lcl_wa_classlist-file_inc &apos;.xml&apos;
      INTO lcl_url.
    lcl_name = &apos;Dummy Include&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.
  ENDIF.

  APPEND &apos;&lt;/item&gt;&apos; TO it_html.

*Interfaces wenn vorhandnen
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Interface&apos;
     TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Interfaces:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_intf &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*    Verarbeitung der Interfaces
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Interface&apos;.
**Unterscheidung, ob bei extern in DC&apos;S oder TR&apos;s
      IF  extern = &apos;X&apos; OR p_devc = &apos;X&apos;.

        CONCATENATE &apos;../OI_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.
        lcl_name = lcl_wa_prog_stueckliste-name.
*
      ELSEIF  p_trkorr = &apos;X&apos;. &quot;Transportrequest

        lcl_name = lcl_wa_prog_stueckliste-name.
      ELSE.
        CONCATENATE &apos;./OI_&apos; lcl_wa_prog_stueckliste-file_name
            &apos;/index.htm&apos; INTO lcl_url.
        lcl_name = lcl_wa_prog_stueckliste-name.

      ENDIF.
      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Spezielle Transaktionscodeliste fuer Klassen
  READ TABLE it_prog_stueckliste  WITH KEY
      type = &apos;Transactioncodelist(Class)&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Transactioncodes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_tran_main &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Tacodeclass_&apos; lcl_global_main_name &apos;.xml&apos;
        INTO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-obername.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                      &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

ENDFORM.                    &quot; create_inc_for_class
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_logdev
*&amp;---------------------------------------------------------------------*
*       Aufbau der Navigationsliste fuer eine Logische Entwicklung.
*----------------------------------------------------------------------*
FORM create_html_for_logdev.
*lokale Bereiche fuer STuecklistenverarbeitung
  DATA: lcl_it_prog_stueckliste TYPE STANDARD TABLE OF prog_stueckliste,
        lcl_wa_prog_stueckliste LIKE LINE OF lcl_it_prog_stueckliste.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

*Reports/Modulpools verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Report/Modulpool&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Reports/Modulpoole:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_prog &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*    Menuliste
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Report/Modulpool&apos;.

      CONCATENATE &apos;./RM_&apos; lcl_wa_prog_stueckliste-file_name &apos;/index.htm&apos;
         INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.


*Transaktionen verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Transaction&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Transactions:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_tran &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*    Transaktionen
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Report/Modulpool(TA)&apos;.
*     begin of changes for partner namespace
      TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*     end of changes for partner namespace
      CONCATENATE &apos;./TA_&apos; lcl_wa_prog_stueckliste-obername &apos;/index.htm&apos;
          INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-obername.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.


*Functiongroup verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Functiongroup&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Functiongroups:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_fugr &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*   Functiongroup
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Functiongroup&apos;.

      CONCATENATE &apos;./FG_SAPL&apos; lcl_wa_prog_stueckliste-file_name
         &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Class(OO) verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Class(OO)&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Classes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_class &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  Class(OO)
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Class(OO)&apos;.

      CONCATENATE &apos;./OC_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Interface(OO)) verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Interface(OO)&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Interfaces:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_intf &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  Interface(OO)
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Interface(OO)&apos;.

      CONCATENATE &apos;./OI_&apos; lcl_wa_prog_stueckliste-file_name
        &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IDOC-Basistype verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IDOC-Basistype&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IDOC-Basistypes:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_idoc &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  IDOC-Basistype
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;IDOC-Basistype&apos;.

      CONCATENATE &apos;./IB_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/&apos; lcl_wa_prog_stueckliste-file_name &apos;_d.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                         &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IDOC-Enhancement verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IDOC-Enhancement&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IDoc-Enhancement:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_idoc &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  IDOC-Enhancement
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;IDOC-Enhancement&apos;.

      CONCATENATE &apos;./IB_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/&apos; lcl_wa_prog_stueckliste-file_name &apos;_d.htm&apos;
          INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                         &apos;main&apos;.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IAC-Service
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IACS&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IAC-Service(ITS):&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_iasp &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
*    Menuliste
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;IACS&apos;.

      CONCATENATE &apos;./IAC_&apos; lcl_wa_prog_stueckliste-file_name
         INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.



*CMOD-Enhancement verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;CMOD-Enhancement&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Enhancement-Project:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cmod &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  CMOD-Enhancement
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;CMOD-Enhancement&apos;.

      CONCATENATE &apos;./EP_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*BADI-Imlementation verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;BADI-Imlementation&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;BADI-Imlementations:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_sxci &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*  BADI-Imlementation
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;BADI-Imlementation&apos;.

      CONCATENATE &apos;./BI_&apos; lcl_wa_prog_stueckliste-file_name
        &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Modifikationen
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Include(Modi)&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Modifications&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_modis &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    CONCATENATE &apos;./Modifications&apos; &apos;/index.htm&apos; INTO lcl_url.

    lcl_name = &apos;Modificationoverview&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                                      c_target_new.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ELSE.
    READ TABLE it_prog_stueckliste  WITH KEY type =
    &apos;Functionmodule(Modi)&apos;
               TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND &apos;&lt;item&gt;&apos; TO it_html.
      APPEND &apos;&lt;value&gt;Modifications&lt;/value&gt;&apos; TO it_html.
      CONCATENATE &apos;&lt;order&gt;&apos; g_order_modis &apos;&lt;/order&gt;&apos; INTO wa_html.
      APPEND wa_html TO it_html.

      CONCATENATE &apos;./Modifications&apos; &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = &apos;Modificationoverview&apos;.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

      APPEND &apos;&lt;/item&gt;&apos; TO it_html.
    ELSE.
      READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Screen(Modi)&apos;
        TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
        APPEND &apos;&lt;item&gt;&apos; TO it_html.
        APPEND &apos;&lt;value&gt;Modifications&lt;/value&gt;&apos; TO it_html.
        CONCATENATE &apos;&lt;order&gt;&apos; g_order_modis &apos;&lt;/order&gt;&apos; INTO wa_html.
        APPEND wa_html TO it_html.
        CONCATENATE &apos;./Modifications&apos; &apos;/index.htm&apos; INTO lcl_url.

        lcl_name = &apos;Modificationoverview&apos;.

        PERFORM nav_xml_add_subitem USING lcl_url
                                          lcl_name
                                          c_target_new.

        APPEND &apos;&lt;/item&gt;&apos; TO it_html.
      ENDIF. &quot;Sreens
    ENDIF. &quot;Functionmodules
  ENDIF. &quot;Includes

* Einzeln selektierte Objekte
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;SINGLE_LIMU&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Single Selected Objects:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_modis &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*    Menuliste
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;SINGLE_LIMU&apos;.

      CONCATENATE &apos;Single_Selected_Objects&apos; &apos;/index.htm&apos;
         INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Listeneintrag schreiben für Systeminformationen
  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  APPEND &apos;&lt;value&gt;General Information:&lt;/value&gt;&apos; TO it_html.

  CONCATENATE &apos;&lt;order&gt;&apos; g_order_sys_info &apos;&lt;/order&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.

  CONCATENATE &apos;Systeminfo_&apos; lcl_wa_prog_stueckliste-instnr &apos;.xml&apos;
      INTO lcl_url.
  lcl_name = &apos;System Information&apos;.

  PERFORM nav_xml_add_subitem USING lcl_url
                                    lcl_name
                                      &apos;main&apos;.
  APPEND &apos;&lt;/item&gt;&apos; TO it_html.

*Ende der Navigationsseite
  APPEND &apos;&lt;/Nav&gt;&apos; TO it_html.
ENDFORM.                    &quot; create_html_for_logdev
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_enh
*&amp;---------------------------------------------------------------------*
*      Navigationsdatei fuer Erweiterungsprojekt generieren.
*----------------------------------------------------------------------*
FORM create_html_for_enh.
*Bereiche fuer Ehnancementkomponenten
  DATA: lcl_wa_enhancecomp TYPE enhancecomp.
*Rahmenprogrammname für Screenn
  DATA: lcl_screenprog TYPE string.
*Variable fuer Screennummer
  DATA: lcl_dynp(5) TYPE c.
*global_main_name
  DATA: lcl_global_main_name LIKE global_main_name.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

* begin of changes for partner namespace
  lcl_global_main_name = global_main_name.
  TRANSLATE lcl_global_main_name USING &apos;/_&apos;.
* end of changes for partner namespace


*Funktionsbausteinexits
  READ TABLE it_enhancecomp  WITH KEY typus = &apos;Function Exit&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Function Exits:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_exit_func &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*Funktionsbausteinexits
    LOOP AT it_enhancecomp INTO lcl_wa_enhancecomp
            WHERE typus = &apos;Function Exit&apos;.

      CONCATENATE &apos;Enh_&apos; lcl_wa_enhancecomp-file_internal
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_enhancecomp-comp.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                           &apos;main&apos;.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Dynproexits
  READ TABLE it_enhancecomp  WITH KEY typus = &apos;Dynpro-Exit&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Dynpro Exits:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_exit_dynp &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*Dynproexits
    LOOP AT it_enhancecomp INTO lcl_wa_enhancecomp
            WHERE typus = &apos;Dynpro-Exit&apos;.
*Dateinamen des Dynproexits zusammenbauen.
      SEARCH lcl_wa_enhancecomp-file_internal FOR &apos;,&apos;.
      lcl_screenprog = lcl_wa_enhancecomp-file_internal(sy-fdpos).
      SEARCH lcl_wa_enhancecomp-file_internal FOR &apos;:&apos;.
      sy-fdpos = sy-fdpos + 1.
      lcl_dynp = lcl_wa_enhancecomp-file_internal+sy-fdpos(4).
      CONCATENATE lcl_screenprog lcl_dynp INTO lcl_screenprog.
*Listeneintrag schreiben
      CONCATENATE &apos;SC_&apos; lcl_screenprog &apos;.txt&apos; INTO lcl_url.

      lcl_name = lcl_wa_enhancecomp-internal.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                           &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Customizing Include
  READ TABLE it_enhancecomp  WITH KEY typus = &apos;Customizing Include&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Customizing Includes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_exit_reps &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
    LOOP AT it_enhancecomp INTO lcl_wa_enhancecomp
            WHERE typus = &apos;Customizing Include&apos;.
*Listeneintrag schreiben
      CONCATENATE &apos;STR_&apos; lcl_wa_enhancecomp-file_internal &apos;.xml&apos;
          INTO lcl_url.

      lcl_name = lcl_wa_enhancecomp-comp.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                           &apos;main&apos;.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Menuexitcodelist
  READ TABLE it_enhancecomp  WITH KEY typus = &apos;Menu Exit&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Menu Exits:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_exit_cuad &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*Listeneintrag schreiben
    CONCATENATE &apos;Menulist_&apos; lcl_global_main_name &apos;.xml&apos;
      INTO lcl_url.

    lcl_name = &apos;Menuexitcodelist&apos;.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                         &apos;main&apos;.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Form Includes wenn vorhanden
  READ TABLE it_enhancecomp  WITH KEY typus = &apos;Form Include&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Used Form Includes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_exit_reps_used &apos;&lt;/order&gt;&apos; INTO wa_html
    .
    APPEND wa_html TO it_html.


*Form-Includes
    LOOP AT it_enhancecomp INTO lcl_wa_enhancecomp
            WHERE typus = &apos;Form Include&apos;.
*Listeneintrag schreiben
      CONCATENATE &apos;Enh_&apos; lcl_wa_enhancecomp-file_internal &apos;.xml&apos;
          INTO lcl_url.

      lcl_name = lcl_wa_enhancecomp-internal.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                           &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

ENDFORM.                    &quot; create_html_for_enh
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_modis
*&amp;---------------------------------------------------------------------*
*       Generieren der Navigationsliste fuer Modifikationen.
*----------------------------------------------------------------------*
FORM create_html_for_modis.
*Variable fuer STringbezeichnung
  DATA: lcl_dynp TYPE string.
*Bereich fuer Stueckliste
  DATA: lcl_wa_prog_stueckliste TYPE prog_stueckliste.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

*Modidfizierte Includes verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Include(Modi)&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.

    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Modificated Includes&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_modi_reps &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*Modidfizierte Includes
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Include(Modi)&apos;.

      CONCATENATE &apos;IN_&apos; lcl_wa_prog_stueckliste-file_name
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.
      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Modidfizierte Funktionsbausteine verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Functionmodule(Modi)&apos;
       TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Modificated Function Modules&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_modi_func &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*Modidfizierte Includes
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Functioninclude(Modi)&apos;.


      CONCATENATE &apos;IN_&apos; lcl_wa_prog_stueckliste-file_name
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-obername.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Modidfizierte Dynpros verarbeiten
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Dynpro(Modi)&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Modificated Dynpros&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_modi_dynp &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

*Modidfizierte Dynpros
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Dynpro(Modi)&apos;.
*Dynproname zusammenbauen
      lcl_dynp = lcl_wa_prog_stueckliste-file_name.
      CONDENSE  lcl_dynp NO-GAPS.

      CONCATENATE &apos;SC_&apos; lcl_dynp
         &apos;.txt&apos; INTO lcl_url.

      lcl_name =  lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;..

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

ENDFORM.                    &quot; create_html_for_modis
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_class_extern
*&amp;---------------------------------------------------------------------*
*       Verabeitungsroutine fuer Klassen die bei späterer Verarbeitung
*       aufgerufen werden. Die  unterstuetzten Objekte der im Parameter
*       P_NAME angegebenen Klasse werden gespeichert.
*----------------------------------------------------------------------*
FORM handle_class_extern USING    p_name TYPE c.
  DATA: lcl_it_inheritance TYPE STANDARD TABLE OF inheritance,
        lcl_wa_inheritance LIKE LINE OF lcl_it_inheritance.

*Variable fuer Includenamen einer Typgruppe
  DATA: lcl_typpconv LIKE wa_trdir-name.

*Bereiche fuer Interface
  DATA: lcl_it_vseoimplem TYPE STANDARD TABLE OF vseoimplem,
        lcl_wa_vseoimplem  LIKE LINE OF lcl_it_vseoimplem.

*Bereich fuer Typgruppentabelle
  DATA: lcl_it_vseotypep TYPE STANDARD TABLE OF vseotypep,
        lcl_wa_vseotypep LIKE LINE OF lcl_it_vseotypep.

*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.
*Variable fuer Klassenname
  DATA: lcl_classname TYPE vseoclass-clsname.

*Existiert die Klasse überhaupt?
  DATA: lcl_wa_seoclass TYPE seoclass.
  SELECT SINGLE * FROM seoclass INTO lcl_wa_seoclass
                  WHERE clsname = p_name
                  AND   clstype = 0.
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.

*Klassenname setzen
  lcl_classname = p_name.

*Globalen Namen setzen
  lcl_name = global_main_name.
  global_main_name = p_name.

*Stueckliste fuer Klasse schreibvne
  PERFORM write_stueckliste USING &apos;Class&apos;
                              lcl_classname
                              &apos;&apos;.
*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING lcl_classname
                                 &apos;C&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Class:&apos; lcl_classname INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

*1.) Klassenincludes herunterladen
  PERFORM download_classincludes USING lcl_classname.

*2.)Typgruppe dieser Klasse behandeln
*Tabelle in der Zuordnung von Typgruppen zu Klassen stehen
  SELECT * FROM vseotypep INTO TABLE lcl_it_vseotypep
        WHERE clsname = lcl_classname.
  IF NOT ( lcl_it_vseotypep IS INITIAL ).
    LOOP AT lcl_it_vseotypep  INTO lcl_wa_vseotypep.
*Nur herunterladenm, wenn Typegroup in Kundennamensraum
      IF ( ( lcl_wa_vseotypep-typegroup(1) = &apos;Z&apos; )
        OR ( lcl_wa_vseotypep-typegroup(1) = &apos;Y&apos; ) ).
        CLEAR ok.
*Zusammensetzen des Includenamen fuer die Typgruppe
        CONCATENATE &apos;%_C&apos; lcl_wa_vseotypep-typegroup  INTO lcl_typpconv.
*Typgruppeninclude herunterladen
        PERFORM download_include USING   lcl_typpconv
                                         &apos;T&apos;
                                  CHANGING ok .
        IF ok = &apos;X&apos;.  &quot;Download war erfolgreich
*Klassenliste schreiben.
          CLEAR wa_classlist.
          MOVE  lcl_wa_vseotypep-typegroup TO  wa_classlist-inc.
          MOVE &apos;Typgroup&apos; TO wa_classlist-typus.
          APPEND wa_classlist TO it_classlist.

        ENDIF.  &quot;Ok-abfrage
      ENDIF.
    ENDLOOP.
  ENDIF.

*3.)Uebersichtsliste ueber diese Klasse
  PERFORM download_classlist USING lcl_classname.

*4.)Implementierte Interfaces sichern
*Nur wenn abhängige Objekte berücksichtig werden sollen
  IF g_nodep IS INITIAL.
    SELECT DISTINCT clsname refclsname FROM vseoimplem
              INTO CORRESPONDING FIELDS OF TABLE lcl_it_vseoimplem
              WHERE clsname = lcl_classname.

    LOOP AT lcl_it_vseoimplem INTO lcl_wa_vseoimplem.

      IF  ( lcl_wa_vseoimplem-refclsname(1) = &apos;Z&apos;
            OR lcl_wa_vseoimplem-refclsname(1) = &apos;Y&apos; ).


        PERFORM write_global_save USING &apos;I&apos; lcl_wa_vseoimplem-refclsname
        .

*  Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Interface&apos;
                                   lcl_wa_vseoimplem-refclsname
                                   lcl_classname.
      ENDIF.
    ENDLOOP.
  ENDIF.

*5.) Klassen der Vererbungshierarchie sichern
*Nur wenn abhängige Objekte berücksichtig werden sollen
  IF g_nodep IS INITIAL.
    SELECT SINGLE clsname refclsname FROM vseoextend
        INTO lcl_wa_inheritance
        WHERE  clsname = lcl_classname
        AND   ( ( refclsname LIKE &apos;Z%&apos; )
                   OR ( refclsname LIKE &apos;Y%&apos; )
                   OR ( refclsname LIKE g_name ) ).
    IF sy-subrc = 0.
      APPEND lcl_wa_inheritance TO lcl_it_inheritance.
    ENDIF.
*   Vererbungshierarchie aufwärts durcharbeiten wenn im
*   Kundennamensraum
    WHILE ( sy-subrc = 0 ).
      SELECT SINGLE clsname refclsname FROM vseoextend
        INTO lcl_wa_inheritance
        WHERE clsname = lcl_wa_inheritance-super
        AND  ( ( refclsname LIKE &apos;Z%&apos; )
                 OR   ( refclsname LIKE &apos;Y%&apos; )
                 OR   ( refclsname LIKE g_name ) ).
      IF sy-subrc = 0.
        APPEND lcl_wa_inheritance TO lcl_it_inheritance.
      ENDIF.
    ENDWHILE.

*   In Liste fuer exterene Programmaufrufe schreiben
    LOOP AT lcl_it_inheritance INTO lcl_wa_inheritance.
      PERFORM write_global_save USING &apos;C&apos;
                                      lcl_wa_inheritance-super.

*     Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Class(OO)&apos;
                                 lcl_wa_inheritance-super
                                 lcl_classname.

    ENDLOOP.
  ENDIF.

*Trennung von Einzeldateiobjekten
*    uline.
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*6.)Vererbte Klassen herunterladen
  PERFORM download_class_inheritance.
*Domaenen downloaden
  PERFORM download_domains.
*Datenelementliste downloaden
  PERFORM download_dataelements.
*Berechtigungsobjekt Infos downloaden
  PERFORM download_authorityobjects.
*Titlebars herunterladen
  PERFORM download_titlebar.
*Meldungen herunterladen
  PERFORM download_messages.
*Gesamtliste der Transaktionscodes fuer Klasse herunterladen
  PERFORM download_tacodelist_for_class.
*Gesamtliste mit Dialogbaustein-&gt;Funktionsbausteinzuordnung
*herunterladen und Gesamtliste mit Dialogpoolparametern herunterladen.
  PERFORM download_dialogmodule_elements.
*Gesamtliste der Parameter herunterschreiben
  PERFORM download_setgetparams.
*Gesamtstückliste
  PERFORM download_stueckliste.

*HP-Stand sichern
  PERFORM download_hpstand.

*    SKIP.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Wenn nicht bei externer Verarbeitung aufgerufen Aufruf der
*externen Verarbeitung
  IF extern IS INITIAL.
    PERFORM handle_externalprogs.
  ENDIF. &quot;in externer Verarbeitung

*globalen Namen setzen
  global_main_name = lcl_name.
ENDFORM.                    &quot; handle_class_extern
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_interface_extern
*&amp;---------------------------------------------------------------------*
*      Verabeitungsroutine fuer Interfaces die bei späterer Verarbeitung
*      aufgerufen werden.
*----------------------------------------------------------------------*
FORM handle_interface_extern USING p_wa_global_save LIKE wa_global_save.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.

*Existiert die Klasse überhaupt?
  DATA: lcl_wa_seoclass TYPE seoclass.
  SELECT SINGLE * FROM seoclass INTO lcl_wa_seoclass
                  WHERE clsname = p_wa_global_save-name
                  AND   clstype = 1.
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.

*Globalen Namen setzen
  lcl_name = global_main_name.
  global_main_name = p_wa_global_save-name.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_wa_global_save-name
                                 &apos;I&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Ausgabeformatierungen: Ueberschrift
*  FORMAT COLOR COL_HEADING.
*  WRITE: / &apos;Interface: &apos;, p_wa_global_save-name.
*  FORMAT COLOR COL_BACKGROUND.
*  ULINE.
*Ueberschrift zusammenbauen
  CONCATENATE &apos;Interface:&apos; p_wa_global_save-name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

*Oberster Knoten der Stueckliste
  PERFORM write_stueckliste USING &apos;Interface(OO)&apos;
                             p_wa_global_save-name
                             &apos;&apos;.

*Eigentlicher Download durchfuehren
  PERFORM download_interface USING p_wa_global_save-name.

*Trennung von Einzelobjekten
*  uline.
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Gesamtstückliste
  PERFORM download_stueckliste.
* HotPackagestand sichern
  PERFORM download_hpstand.

*globalen Namen setzen
  global_main_name = lcl_name.
ENDFORM.                    &quot; handle_interface_extern
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_badi_implementation
*&amp;---------------------------------------------------------------------*
*       Verarbeitungsroutine fuer Badiimplementierungen. Der Name der
*        Implementierung wird im Parameter P_NAME uebermittelt.
*----------------------------------------------------------------------*
FORM handle_badi_implementation USING p_name TYPE c.
*Bereich fuer Implementierungsklasse
  DATA: lcl_it_impclass TYPE STANDARD TABLE OF sxc_class-imp_class,
        lcl_wa_impclass LIKE LINE OF lcl_it_impclass.
*Bereich fuer trdir-Namen fuer Klassenverarbeitung
  DATA: lcl_wa_trdirname TYPE trdir-name.
*Variable fuer Laengenbestimmung eines Includes
  DATA: lcl_len  TYPE i.
*Variable fuer Suchstring trdir-name
  DATA: lcl_such TYPE trdir-name.
*Bereiche fuer Uebersicht Badi zu Implementierung und Filterparameter
  DATA: lcl_it_sxc_exit TYPE STANDARD TABLE OF sxc_exit.
*Bereich fuer Badisubscreens
  DATA: lcl_it_sxc_scrn TYPE STANDARD TABLE OF sxc_scrn,
        lcl_wa_sxc_scrn LIKE LINE OF lcl_it_sxc_scrn.
*Bereich fuer Subscreen
  DATA: lcl_wa_d020s TYPE d020s.
*Variable zur Speicherung des globalen Namens
  DATA: lcl_name LIKE wa_trdir-name.
*Variablen zur Speicherung der Verzeichnisnamem.
  DATA: lcl_new_dir LIKE new_dir,
        lcl_dir LIKE dir.
*Stueckliste scihern
  DATA: lcl_it_prog_stueckliste LIKE it_prog_stueckliste.


*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_name
                            &apos;B&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*global_main_name fuer globalen Gebrauch aufbereiten
*--&gt;Parametrisierung umgangen
  global_main_name = p_name.
*Ueberschrift zusammenbauen
  CONCATENATE &apos;Badiimplementation:&apos; global_main_name INTO header
        SEPARATED BY space.
*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.

****************

*Intitialisieren der globalen Tabellen
  PERFORM initialize.


*Schreiben der Stueckliste fuer diese Badi-Implementierung
  PERFORM write_stueckliste USING &apos;Badiimp&apos;
                                  p_name
                                  &apos;&apos;.
*1.)evtl. Subscreens der Implementierung herunterladen
  SELECT * FROM sxc_scrn INTO TABLE lcl_it_sxc_scrn
      WHERE imp_name = p_name.
  IF sy-subrc = 0.
    LOOP AT lcl_it_sxc_scrn INTO lcl_wa_sxc_scrn.
      lcl_wa_d020s-prog = lcl_wa_sxc_scrn-scr_a_prog.
      lcl_wa_d020s-dnum = lcl_wa_sxc_scrn-scr_a_num.
      PERFORM download_dynpro USING lcl_wa_d020s.
    ENDLOOP.
  ENDIF.
*Implementierungsklassen fuer diese Badiimplementierung wählen
  SELECT imp_class FROM sxc_class INTO TABLE  lcl_it_impclass
      WHERE imp_name = p_name.

*Verarbeitung der Implementierungsklassen dieser Badiimplementierung
  LOOP AT lcl_it_impclass INTO lcl_wa_impclass.
*Schreiben der Stueckliste fuer diese Klass
    PERFORM write_stueckliste USING &apos;Class&apos;
                                    lcl_wa_impclass
                                    p_name.


*2.)Uebersicht von Filter,Badi zu Implementierung schreiben
    REFRESH lcl_it_sxc_exit.
    SELECT * FROM sxc_exit INTO TABLE lcl_it_sxc_exit
        WHERE imp_name = p_name.
    APPEND LINES OF lcl_it_sxc_exit TO it_ges_sxc_exit.

*Ubersicht der Filterparameter der Implementierung schreiben
    PERFORM download_badi_filterparams USING p_name.

*3.)Klasse herunterladen
*      PERFORM handle_classinterface USING lcl_wa_trdirname
*                                        &apos;K&apos;.
*Name sicern
    lcl_name = global_main_name.
*Stueckliste sichern
    lcl_it_prog_stueckliste = it_prog_stueckliste.
*Verzeichnisse sichern
    lcl_dir = dir.
    lcl_new_dir = new_dir.
    dir = new_dir.
    PERFORM initialize.
*Klasse sichern
*  PERFORM handle_class USING lcl_wa_impclass.
    PERFORM handle_class_extern USING lcl_wa_impclass .
*Verzeichnisse zurücksichern
    dir = lcl_dir.
    new_dir = lcl_new_dir.
*Ruecksicherung Stueckliste
    it_prog_stueckliste = lcl_it_prog_stueckliste  .
*Ruecksicherung Name
    global_main_name = lcl_name.
  ENDLOOP. &quot;Implementierungsklassen


*    ULINE.  &quot;Listausgabeformatierung
  PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
*Gesamtstückliste
  PERFORM download_stueckliste.


*Hp-Stand sichern
  PERFORM download_hpstand.

*Leerzeile nach Ende dieser Verarbeitung
*        skip.
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Stueckliste fuer logische Entwicklung
  IF NOT ( p_logic IS INITIAL ).
    PERFORM write_log_stueckliste USING   &apos;BADI-Imlementation&apos;
                                          global_main_name
                                          p_logic.

  ENDIF.

ENDFORM.                    &quot; handle_badi_implementation
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_devclass
*&amp;---------------------------------------------------------------------*
*       Generieren der Eintraege in der Navigationsdatei fuer
*       Entwicklungsklassen.
*----------------------------------------------------------------------*
FORM create_html_for_devclass.
*Lokaler Arbeitsbereich fuer Stueckliste
  DATA: lcl_wa_prog_stueckliste TYPE prog_stueckliste.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

*Funktionsgruppen
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Funktionsgruppe&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Functiongroups:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_fugr &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Funktionsgruppe&apos;.

      CONCATENATE &apos;./FG_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Reports/Modulpoole
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Report/Modulpool&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Reports/Modulpools :&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_prog &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Report/Modulpool&apos;.

      CONCATENATE &apos;./RM_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Klassen
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Class(OO)&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Classes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_class &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Class(OO)&apos;.

      CONCATENATE &apos;./OC_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Interfaces
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Interface(OO)&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Used Interfaces&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_intf_used &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Interface(OO)&apos;.


      CONCATENATE &apos;./OI_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Enhancement Projects
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;CMOD-Enhancement&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Enhancement Projects:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cmod &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;CMOD-Enhancement&apos;.

      CONCATENATE &apos;./EP_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Badi Implementation
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Badi Implementation&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Badiimplementation:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_sxci &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Badi Implementation&apos;.

      CONCATENATE &apos;./BI_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IAC-Services
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IACS&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IAC-Services:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_iasp &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;IACS&apos;.

      CONCATENATE &apos;./IAC_&apos; lcl_wa_prog_stueckliste-file_name
            INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IDoc-Erweiterung
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IDOC-Basistyp&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IDoc Basistype:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_idoc &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;IDOC-Basityp&apos;.

      CONCATENATE &apos;./IB_&apos; lcl_wa_prog_stueckliste-file_name
            &apos;/&apos; lcl_wa_prog_stueckliste-file_name &apos;_d.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                         &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IDOC-Erweiterung
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IDOC-Erweiterung&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IDoc Enhancement:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_iext &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.


    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;IDOC-Erweiterung&apos;.

      CONCATENATE &apos;./IE_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/&apos; lcl_wa_prog_stueckliste-file_name &apos;_d.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                         &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Messageklassen
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;MSAG&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Messageclasses&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_msag &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;MSAG&apos;.

      CONCATENATE lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
        INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Berechtigungsobjekte
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Authority Object(TR)&apos;
         TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Authority Objects:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_suso &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type =&apos;Authority Object(TR)&apos;.

*    Authority-Objectliste
      CONCATENATE &apos;Auhthorityobject_&apos;
          lcl_wa_prog_stueckliste-file_name
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                   &apos;main&apos;.
    ENDLOOP.

*    Aktivitaetenliste, wenn vorhanden
    READ TABLE it_prog_stueckliste  WITH KEY
      type = &apos;Activities of Authority Object&apos;
      name = lcl_wa_prog_stueckliste-name
      INTO lcl_wa_prog_stueckliste.
    IF sy-subrc = 0.
      CONCATENATE &apos;AuthActivities&apos;
        lcl_wa_prog_stueckliste-file_name
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = &apos;Activities of Authority Objects&apos;.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                         &apos;main&apos;.
    ENDIF.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Spezielle Transaktionscodeliste fuer Klassen
  READ TABLE it_prog_stueckliste  WITH KEY
      type = &apos;Transactioncodelist(Class)&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Transactioncodes:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_tran_main &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Tacodeclass_&apos;
          lcl_wa_prog_stueckliste-obername &apos;.xml&apos; INTO lcl_url.

    CONCATENATE lcl_wa_prog_stueckliste-obername
    &apos;(Parameterttransaction)&apos;
        INTO lcl_name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                               &apos;main&apos;.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

ENDFORM.                    &quot; create_html_for_devclass
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_trkorr
*&amp;---------------------------------------------------------------------*
*       Generieren der speziellen Eintraege in der Navigationsdatei fuer
*       Transportauftraege.
*----------------------------------------------------------------------*
FORM create_html_for_trkorr.
*lokaler Arbeitsbereich fuer Stueckliste.
  DATA: lcl_wa_prog_stueckliste TYPE prog_stueckliste.
*Bereich fuer Ermittlung des Klassennamens
  DATA: lcl_text(30) TYPE c.
*global_main_name
  DATA: lcl_global_main_name LIKE global_main_name.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

*   begin of changes for partner namespace
  lcl_global_main_name = global_main_name.
  TRANSLATE lcl_global_main_name USING &apos;/_&apos;.
*   end of changes for partner namespace


*Report oder Modulpoole
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;PROG&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Reports / Modulpools:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_prog &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;PROG&apos;.

      CONCATENATE &apos;RM_&apos; lcl_wa_prog_stueckliste-file_name
         &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Einzelne Inlcudes
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;REPS&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Includes:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_reps &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;REPS&apos;.

      CONCATENATE &apos;IN_&apos; lcl_wa_prog_stueckliste-file_name
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Funktionsbausteine
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IN&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Functionmodule:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_func &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;IN&apos;.

      CONCATENATE &apos;./Func_&apos; lcl_wa_prog_stueckliste-file_name
               &apos;.xml&apos; INTO lcl_url.

      CONCATENATE lcl_wa_prog_stueckliste-obername &apos;(&apos;
                  lcl_wa_prog_stueckliste-name &apos;)&apos;
          INTO lcl_name SEPARATED BY space.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.


*Funktionsgruppe
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Functiongroup&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Functiongroup:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_fugr &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Functiongroup&apos;.

      CONCATENATE &apos;./FG_&apos; lcl_wa_prog_stueckliste-file_name
               &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IAC-Service
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IACS&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IAC-Service:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_iasp &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;IACS&apos;.

      CONCATENATE &apos;IAC_&apos; lcl_wa_prog_stueckliste-file_name
         &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IAC-Template
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IACT&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IAC-Templates&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_iact &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;IACT&apos;.

      IF lcl_wa_prog_stueckliste-name+16(4) IS INITIAL.

        MOVE lcl_wa_prog_stueckliste-name+20
                    TO lcl_name.

        REPLACE &apos;/&apos; WITH &apos;-&apos; INTO lcl_wa_prog_stueckliste-name.

        CONCATENATE &apos;./TEMPLATES&apos;
                   &apos;/&apos; lcl_wa_prog_stueckliste-name(14)
                   &apos;/&apos; lcl_wa_prog_stueckliste-name+14(2)
                   &apos;/&apos; lcl_wa_prog_stueckliste-name+20
           &apos;.txt&apos; INTO lcl_url.

      ELSE.

        CONCATENATE lcl_wa_prog_stueckliste-name+20
                    &apos;_&apos; lcl_wa_prog_stueckliste-name+16(4)
                    INTO lcl_name.

        REPLACE &apos;/&apos; WITH &apos;-&apos; INTO lcl_wa_prog_stueckliste-name.

        CONCATENATE &apos;./TEMPLATES&apos;
                   &apos;/&apos; lcl_wa_prog_stueckliste-name(14)
                   &apos;/&apos; lcl_wa_prog_stueckliste-name+14(2)
                   &apos;/&apos; lcl_wa_prog_stueckliste-name+20
                   &apos;_&apos; lcl_wa_prog_stueckliste-name+16(4)
           &apos;.txt&apos; INTO lcl_url.

      ENDIF.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IDoc-Erweiterung
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;BasisIDoc&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IDoc Basistype:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_idoc &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;BasisIDoc&apos;.

      CONCATENATE &apos;./IB_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/&apos; lcl_wa_prog_stueckliste-file_name &apos;_d.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                         &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*IDOC-Erweiterung
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;IDOC-Erweiterung&apos;
  TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;IDoc Enhancement:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_iext &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;IDOC-Erweiterung&apos;.

      CONCATENATE &apos;./IE_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/&apos; lcl_wa_prog_stueckliste-file_name &apos;_d.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                         &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Enhancement Projects
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Enhancement Project&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Enhancement Projects:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cmod &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Enhancement Project&apos;.

      CONCATENATE &apos;./EP_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  ENDIF.

*Badi Implementation
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Badi Implementation&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Badi Implementation:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_sxci &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Badi Implementation&apos;.

      CONCATENATE &apos;./BI_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Private Header Include
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;PrivateHeaderInclude&apos;
       TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Private Header of:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cpri &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;PrivateHeaderInclude&apos;.
*Workaround fuer Klassennamen
      SEARCH lcl_wa_prog_stueckliste-name FOR &apos;=&apos;.
      IF sy-subrc = 4.
        lcl_text = lcl_wa_prog_stueckliste-name.
      ELSE.
        lcl_text =
            lcl_wa_prog_stueckliste-name(sy-fdpos).
      ENDIF.


      CONCATENATE &apos;CLIN_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_text.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.


* Protected Header Include
  READ TABLE it_prog_stueckliste  WITH KEY type =
  &apos;ProtectedHeaderInclude&apos;
          TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Protected Header of:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cpro &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;ProtectedHeaderInclude&apos;.
*     Workaround fuer Klassennamen
      SEARCH lcl_wa_prog_stueckliste-name FOR &apos;=&apos;.
      IF sy-subrc = 4.
        lcl_text = lcl_wa_prog_stueckliste-name.
      ELSE.
        lcl_text =
            lcl_wa_prog_stueckliste-name(sy-fdpos).
      ENDIF.

      CONCATENATE &apos;CLIN_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_text.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  ENDIF.


* Public Header Include
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;PublicHeaderInclude&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Public Header of&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_cpub &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;PublicHeaderInclude&apos;.

*     Workaround fuer Klassennamen
      SEARCH lcl_wa_prog_stueckliste-name FOR &apos;=&apos;.
      IF sy-subrc = 4.
        lcl_text = lcl_wa_prog_stueckliste-name.
      ELSE.
        lcl_text =
            lcl_wa_prog_stueckliste-name(sy-fdpos).
      ENDIF.

      CONCATENATE &apos;CLIN_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_text.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Mehtoden Include
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Methodinclude&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Methods&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_meth &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Methodinclude&apos;.

      CONCATENATE &apos;CLIN_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-obername.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Klasseninclude
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;CINC&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Classincludes&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_class_main &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;CINC&apos;.

      CONCATENATE &apos;CLIN_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Klassen, nur Hinweis  darauf(nicht verlinken)
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Class&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Used Classes&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_class_used &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Class&apos;.

      CONCATENATE &apos;./OC_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Interfaces
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Interface&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Used Interfaces&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_intf_used &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Interface&apos;.


      CONCATENATE &apos;./OI_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  ENDIF.

* Messageklassen
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;MSAG&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Messageclasses&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_msag &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;MSAG&apos;.

      CONCATENATE lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
        INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                          &apos;main&apos;.

    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Berechtigungsobjekte
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Authority Object(TR)&apos;
         TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Authority Objects:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_suso &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
        WHERE type =&apos;Authority Object(TR)&apos;.

*    Authority-Objectliste
      CONCATENATE &apos;Auhthorityobject_&apos;
          lcl_wa_prog_stueckliste-file_name
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                   &apos;main&apos;.
    ENDLOOP.

*   Aktivitaetenliste, wenn vorhanden
    READ TABLE it_prog_stueckliste  WITH KEY
      type = &apos;Activities of Authority Object&apos;
      name = lcl_wa_prog_stueckliste-name
      INTO lcl_wa_prog_stueckliste.
    IF sy-subrc = 0.
      CONCATENATE &apos;AuthActivities&apos;
        lcl_wa_prog_stueckliste-file_name
         &apos;.xml&apos; INTO lcl_url.

      lcl_name = &apos;Activities of Authority Objects&apos;.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                         &apos;main&apos;.
    ENDIF.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

* Spezielle Transaktionscodeliste fuer Klassen
  READ TABLE it_prog_stueckliste  WITH KEY
      type = &apos;Transactioncodelist(Class)&apos;
      INTO lcl_wa_prog_stueckliste.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Transactioncodes:&lt;/value&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;order&gt;&apos; g_order_tran_main &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;Tacodeclass_&apos;
        lcl_global_main_name &apos;.xml&apos; INTO lcl_url.

    CONCATENATE lcl_wa_prog_stueckliste-obername
    &apos;(Parameterttransaction)&apos;
        INTO lcl_name.

    PERFORM nav_xml_add_subitem USING lcl_url
                                      lcl_name
                               &apos;main&apos;.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

ENDFORM.                    &quot; create_html_for_trkorr

*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_badiimps
*&amp;---------------------------------------------------------------------*
*      Generieren der Eintraege der Navigationsdatei fuer
*      Badiimplementierungen.
*----------------------------------------------------------------------*
FORM create_html_for_badiimps.
*Arbeitsbereich fuer Stuecklisten
  DATA: lcl_wa_prog_stueckliste TYPE prog_stueckliste.
*Bereiche fuer die Ermittlung des Badi zur Implementiuerung
  DATA: lcl_badi TYPE sxc_exit-exit_name.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

*Ermittlung des namens des implementierten Badis
  READ TABLE it_prog_stueckliste INDEX 1 INTO
    lcl_wa_prog_stueckliste.
  SELECT SINGLE exit_name FROM sxc_exit INTO lcl_badi
      WHERE imp_name = lcl_wa_prog_stueckliste-name.

  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  CONCATENATE &apos;&lt;value&gt;Implemented Badi:&apos; lcl_badi &apos;&lt;/value&gt;&apos;
      INTO wa_html SEPARATED BY space.
  APPEND wa_html TO it_html.

  CONCATENATE &apos;&lt;order&gt;&apos; g_order_sxci &apos;&lt;/order&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.

*Implementierungsklassen
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Class&apos;
     TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.


*    Verarbeitung der Klassen--&gt; Verweis auf Verzeichnis der Klassen
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Class&apos;.

      IF p_trkorr IS INITIAL AND p_devc IS INITIAL.
        CONCATENATE &apos;./OC_&apos; lcl_wa_prog_stueckliste-file_name
                &apos;/index.htm&apos; INTO lcl_url.

        lcl_name = lcl_wa_prog_stueckliste-name.
      ELSE.
        CONCATENATE &apos;../OC_&apos; lcl_wa_prog_stueckliste-file_name
              &apos;/index.htm&apos; INTO lcl_url.

        lcl_name = lcl_wa_prog_stueckliste-name.
      ENDIF.



      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.

    ENDLOOP.

  ENDIF. &quot;Klassen vorhanden
  APPEND &apos;&lt;/item&gt;&apos; TO it_html.


*Filterparameter
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Filterparameter&apos;
     TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Filterparameter:&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_iext_filter &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
            WHERE type = &apos;Filterparameter&apos;.
*   begin of changes for partner namespace
      TRANSLATE lcl_wa_prog_stueckliste-obername USING &apos;/_&apos;.
*   end of changes for partner namespace
      CONCATENATE &apos;BadiImpFilter_&apos;
      lcl_wa_prog_stueckliste-obername &apos;.xml&apos; INTO lcl_url.

      lcl_name = lcl_wa_prog_stueckliste-name.

      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                           &apos;main&apos;.
    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.

  ENDIF.

ENDFORM.                    &quot; create_html_for_badiimps
*&amp;---------------------------------------------------------------------*
*&amp;      Form  trkorr_messageclass
*&amp;---------------------------------------------------------------------*
*       Verarbetungsroutine fuer komplette Nachrichtenklassen, die in
*       Transportauftraegen enthalten sind. Der Name der
*       Nachrichtenklasse wird im Parameter P_NAME uebermittelt.
*----------------------------------------------------------------------*
FORM trkorr_messageclass USING    p_name TYPE any
                                  p_trkorr TYPE c.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Bereich der Nachrichtentabellle
  DATA: lcl_it_messages TYPE STANDARD TABLE OF t100,
        lcl_wa_messages LIKE LINE OF lcl_it_messages.

*Name fuer die Gesamtmessagetabelle des Rahmenprogramms
  DATA: lcl_messagetab_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.

*Schleife ueber Sprachtabelle
  LOOP AT it_lan INTO wa_lan.
    REFRESH it_html.
    CLEAR wa_html.
    REFRESH lcl_it_headerrow.
*Messagetabelle fuer Klasse lesen
    SELECT * FROM t100 INTO TABLE lcl_it_messages
            WHERE arbgb = p_name
              AND sprsl = wa_lan.
    IF sy-subrc = 0. &quot;Saetze gelesen

      CONCATENATE &apos;Messageclass_&apos; p_name &apos;(&apos; wa_lan &apos;)&apos; INTO
          lcl_messagetab_name.

*Umwandlung in HTML-Tabelle
********************************************************
*Ueberschrift zusammenbauen
      CONCATENATE &apos;Messageclass&apos;
            p_name &apos;(Language:&apos; wa_lan &apos;)&apos; INTO lcl_header
                SEPARATED BY space.

*Headertabelle zusammenbauen
      APPEND &apos;Language&apos; TO lcl_it_headerrow.
      APPEND &apos;Working Area&apos; TO lcl_it_headerrow.
      APPEND &apos;Message Number&apos; TO lcl_it_headerrow.
      APPEND &apos;Message Text&apos; TO lcl_it_headerrow.


      PERFORM create_htmltab_header  USING lcl_it_headerrow
                                           lcl_header.

      LOOP AT lcl_it_messages INTO lcl_wa_messages.
        PERFORM create_htmltab_body USING lcl_wa_messages.
      ENDLOOP.

      PERFORM create_html_tab_foot.
*********************************************************


      CLEAR filename.
      CONCATENATE new_dir &apos;\&apos; lcl_messagetab_name &apos;.xml&apos; INTO filename.

*     begin of changes for partner namespace
      TRANSLATE filename USING &apos;/_&apos;.
*     end of changes for partner namespace
      PERFORM call_ws_download USING    filename
                                        it_html  &quot;it_messages
                               CHANGING lcl_subrc.
      IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;E&apos;  text071 lcl_messagetab_name
          filename.
      ELSE.
*Protokollliste schreiben.
        PERFORM write_protocol USING &apos;N&apos;  text071 lcl_messagetab_name
          filename.
*Stueckliste schreiben fuer dieses Objekt
        PERFORM write_stueckliste USING &apos;MSAG&apos;
                                        lcl_messagetab_name
                                        p_trkorr.


      ENDIF.
    ENDIF. &quot;Download nur wenn Messagetabelle nicht leer ist
  ENDLOOP.
ENDFORM.                    &quot; trkorr_messageclass
*&amp;---------------------------------------------------------------------*
*&amp;      Form handle_tabletype
*&amp;---------------------------------------------------------------------*
*       Verarbeitung des im Parameter p_name uebergebenen
*       Tabellentyps.
*----------------------------------------------------------------------*
FORM handle_tabletype USING    p_name TYPE c.
*Bereich zur Feststellung des Tabellentyps
  DATA: lcl_wa_dd02l TYPE dd02l.
*Bereich zum Feststellen des Referenztyps
  DATA: lcl_reftype TYPE seoclass-clstype.

  REFRESH it_tabletypes.

  SELECT SINGLE * FROM dd40vv INTO wa_tabletypes
          WHERE typename = p_name.

  APPEND wa_tabletypes TO it_tabletypes.

  CASE wa_tabletypes-rowkind.
    WHEN &apos;S&apos;.   &quot;Strukturierter Typ: Struktur oder Tabelle
*Liegt Bezugstype im Kundennamensraum
      IF   wa_tabletypes-rowtype(1) = &apos;Z&apos;
        OR wa_tabletypes-rowtype(1) = &apos;Y&apos;
        OR wa_tabletypes-rowtype(g_len_nspace) = p_nspace.

*    Feststellen des Typs des DDicobjektes
        SELECT SINGLE * FROM dd02l INTO lcl_wa_dd02l
              WHERE tabname = wa_tabletypes-rowtype.

*    Behandlung der Faelle
        CASE lcl_wa_dd02l-tabclass.
          WHEN &apos;TRANSP&apos;. &quot;normale Tabellen
            PERFORM download_table USING  lcl_wa_dd02l &apos;T&apos;.
*Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Table&apos;
                                        wa_tabletypes-rowtype
                                        global_main_name.
          WHEN &apos;VIEW&apos;. &quot;View
            PERFORM download_table USING  lcl_wa_dd02l &apos;V&apos;.
*Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;View&apos;
                                        wa_tabletypes-rowtype
                                        global_main_name.
          WHEN &apos;INTTAB&apos;. &quot;Struktur
            PERFORM download_table USING  lcl_wa_dd02l &apos;S&apos;.
*Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Structure&apos;
                                        wa_tabletypes-rowtype
                                        global_main_name.

        ENDCASE.
      ENDIF.

    WHEN &apos;L&apos;.   &quot;Tabellentyp
      PERFORM handle_tabletype USING wa_tabletypes-rowtype.
    WHEN &apos;R&apos;.  &quot;Referenztyp Interface oder Klasse
*Nur wenn abhängige Objekte berücksichtig werden sollen
      IF g_nodep IS INITIAL.
        SELECT SINGLE clstype FROM seoclass INTO lcl_reftype
              WHERE clsname = wa_tabletypes-rowtype.
        IF lcl_reftype = 0.
          PERFORM write_global_save USING &apos;C&apos; wa_tabletypes-rowtype.
        ELSE.
          PERFORM write_global_save USING &apos;I&apos; wa_tabletypes-rowtype.
        ENDIF.
      ENDIF.

    WHEN &apos;E&apos;.  &quot;Datenelement
*Liegt Bezugstype im Kundennamensraum
      IF    wa_tabletypes-rowtype(1) = &apos;Z&apos;
         OR wa_tabletypes-rowtype(1) = &apos;Y&apos;
         OR wa_tabletypes-rowtype(g_len_nspace) = p_nspace.

        PERFORM write_dataelements USING wa_tabletypes-rowtype.
      ENDIF.
    WHEN &apos;D&apos;.  &quot;Domaene
*Liegt Bezugstype im Kundennamensraum
      IF    wa_tabletypes-rowtype(1) = &apos;Z&apos;
         OR wa_tabletypes-rowtype(1) = &apos;Y&apos;
         OR wa_tabletypes-rowtype(g_len_nspace) = p_nspace.

        wa_dataelements-domname = wa_tabletypes-rowtype.
        APPEND wa_dataelements TO it_dataelements.

      ENDIF.

  ENDCASE.


*Herunterladen des Tabellentyps
  PERFORM download_tabletypes USING p_name.
ENDFORM.                    &quot; get_tabletype
*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_tabletypes
*&amp;---------------------------------------------------------------------*
*       Sicherung des im Parmeter P_NAME uebermittelten Tabellentyps
*       in das Dateisystem.
*----------------------------------------------------------------------*
FORM download_tabletypes USING p_name.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Stücklistenname
  DATA: lcl_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string,
        lcl_wa_headerrow LIKE LINE OF lcl_it_headerrow.
*interner Bereich fuer Infos zu Tabellentypen
  DATA: lcl_wa_itabletypes TYPE itabletypes.
*Bereiche fuer Verarbeitung der Schlüsselfelder
  DATA: lcl_it_idd42s TYPE STANDARD TABLE OF idd42s,
        lcl_wa_idd42s LIKE LINE OF lcl_it_idd42s.

*Lesen evtl. Schlüsselfelder
  SELECT keyfdpos keyfield FROM dd42s INTO TABLE lcl_it_idd42s
            WHERE typename = p_name.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;Tabletypes&apos;  p_name
        INTO lcl_header SEPARATED BY space.
*Headertabelle zusammenbauen
  APPEND &apos;Typename&apos; TO lcl_it_headerrow.
  APPEND &apos;Name of row type &apos; TO lcl_it_headerrow.
  APPEND &apos;Dictionary type&apos; TO lcl_it_headerrow.
  APPEND &apos;Data Type&apos; TO lcl_it_headerrow.
  APPEND &apos;Length of Datatype&apos; TO lcl_it_headerrow.
  APPEND &apos;Number of decimal places&apos; TO lcl_it_headerrow.
  APPEND &apos;Access modes&apos; TO lcl_it_headerrow.
  APPEND &apos;Key definition&apos; TO lcl_it_headerrow.
  APPEND &apos;Key category&apos; TO lcl_it_headerrow.
  APPEND &apos;Generic (flag)&apos; TO lcl_it_headerrow.





*Umwandlung in HTML-Tabelle
********************************************************
  PERFORM create_htmltab_header  USING lcl_it_headerrow
                                       lcl_header.

* Kurztext mit ausgeben
  DATA: lv_short TYPE string.
  SELECT SINGLE ddtext FROM dd40vv INTO lv_short
        WHERE typename = p_name
        AND ddlanguage = o_lan-low.
  IF sy-subrc EQ 0.
*  Sonderzeichen ersetzen
    REPLACE &apos;&lt;&apos; WITH &apos;&amp;lt;&apos; INTO lv_short.
    REPLACE &apos;&gt;&apos; WITH &apos;&amp;gt;&apos; INTO lv_short.
    REPLACE &apos;&amp;&apos; WITH &apos;&amp;amp;&apos; INTO lv_short.
    REPLACE &apos;&quot;&apos; WITH &apos;&amp;quot;&apos; INTO lv_short.
    REPLACE &apos;&apos;&apos;&apos; WITH &apos;&amp;apos;&apos; INTO lv_short.
    CONCATENATE &apos;&lt;short&gt;&apos; lv_short
                &apos;&lt;/short&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.
  ENDIF.


  LOOP AT it_tabletypes INTO wa_tabletypes.
    MOVE-CORRESPONDING wa_tabletypes TO lcl_wa_itabletypes.
*Ersetzen der aussagelosen Flags
    PERFORM substitute_flags_for_tabletype CHANGING lcl_wa_itabletypes.
    PERFORM create_htmltab_body USING lcl_wa_itabletypes.
  ENDLOOP.

*Build detailed Table manually
*Anzeige der Schluesselfelder
  IF NOT ( lcl_it_idd42s IS INITIAL ).
    APPEND &apos;&lt;/Tabelle&gt;&apos; TO it_html.
    APPEND &apos;&lt;Tabelle&gt;&apos; TO it_html.
    APPEND &apos;&lt;header&gt;Keyfields&lt;/header&gt;&apos; TO it_html.

    REFRESH lcl_it_headerrow.
    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Position of key component in key&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Key component&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.

    LOOP AT lcl_it_idd42s INTO lcl_wa_idd42s.
      PERFORM create_htmltab_body USING lcl_wa_idd42s.
    ENDLOOP.

  ENDIF.


  PERFORM create_html_tab_foot.
*********************************************************

  CONCATENATE &apos;Tabletype_&apos; p_name INTO lcl_name.

  CLEAR filename.
  CONCATENATE new_dir &apos;\&apos; lcl_name &apos;.xml&apos; INTO filename.

* begin of changes for partner namespace
  TRANSLATE filename USING &apos;/_&apos;.
* end of changes for partner namespace
  PERFORM call_ws_download USING    filename
                                    it_html
                           CHANGING lcl_subrc.
  IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;E&apos;  text072 lcl_name filename.
  ELSE.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;N&apos;  text072 lcl_name filename.
  ENDIF.


ENDFORM.                    &quot; download_tabletypes
*&amp;---------------------------------------------------------------------*
*&amp;      Form  substitute_flags_for_tabletype
*&amp;---------------------------------------------------------------------*
*       Ersetzen bestimmmter Flags in der uebergebenen Struktur
*       p_wa_itabletype durch aussagefähige Eintraege.
*----------------------------------------------------------------------*
FORM substitute_flags_for_tabletype
                  CHANGING p_wa_itabletype TYPE itabletypes.


*Aenderung des Feldes accessmode
  CASE p_wa_itabletype-accessmode.
    WHEN &apos;A&apos;.
      p_wa_itabletype-accessmode = &apos;not specified&apos;.
    WHEN &apos;I&apos;.
      p_wa_itabletype-accessmode = &apos;Indextable&apos;.
    WHEN &apos;T&apos;.
      p_wa_itabletype-accessmode = &apos;Standard Table&apos;.
    WHEN &apos;S&apos;.
      p_wa_itabletype-accessmode = &apos;Sorted Table&apos;.
    WHEN &apos;H&apos;.
      p_wa_itabletype-accessmode = &apos;Hash Table&apos;.
  ENDCASE.

*Aenderung des Feldes keydef
  CASE p_wa_itabletype-keydef.
    WHEN &apos;D&apos;.
      p_wa_itabletype-keydef = &apos;Standardkey&apos;.
    WHEN &apos;T&apos;.
      p_wa_itabletype-keydef = &apos;Rowtype&apos;.
    WHEN &apos;G&apos;.
      p_wa_itabletype-keydef = &apos;Not specified&apos;.
    WHEN &apos;K&apos;.
      p_wa_itabletype-keydef = &apos;Key Components&apos;.
  ENDCASE.

*Aenderung des Feldes keykind
  CASE p_wa_itabletype-keykind.
    WHEN &apos;U&apos;.
      p_wa_itabletype-keykind = &apos;Unique&apos;.
    WHEN &apos;N&apos;.
      p_wa_itabletype-keykind = &apos;Non-unique&apos;.
    WHEN &apos;G&apos;.
      p_wa_itabletype-keykind = &apos;Not specified&apos;.
  ENDCASE.

*Aenderung des Feldes ROWKIND
  CASE p_wa_itabletype-rowkind.
    WHEN &apos;E&apos;.
      p_wa_itabletype-rowkind = &apos;Elementary Type&apos;.
    WHEN &apos;S&apos;.
      p_wa_itabletype-rowkind = &apos;Structured type&apos;.
    WHEN &apos;L&apos;.
      p_wa_itabletype-rowkind = &apos;Table Type&apos;.
    WHEN &apos;&apos;.
      p_wa_itabletype-rowkind = &apos;Direct type entry&apos;.
    WHEN &apos;R&apos;.
      p_wa_itabletype-rowkind = &apos;Reference Type&apos;.
    WHEN &apos;D&apos;.
      p_wa_itabletype-rowkind = &apos;Domain&apos;.
  ENDCASE.
ENDFORM.                    &quot; substitute_flags_for_tabletype


*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_view
*&amp;---------------------------------------------------------------------*
*      Verarbeitungsrouttine fuer Views
*      Lesen und Speicherun der Joinbedingungen
*----------------------------------------------------------------------*
FORM download_view USING p_wa_dd02l  TYPE dd02l.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Ausgabename
  DATA: lcl_name TYPE string.
*Bereiche zur Aufnahme der Selektionsbedingungen
  DATA: lcl_it_idd28s TYPE STANDARD TABLE OF idd28s,
        lcl_wa_idd28s LIKE LINE OF lcl_it_idd28s.
*Bereiche zur Aufnnahme der Join-Bedingungen
  DATA: lcl_it_idd28j TYPE STANDARD TABLE OF idd28j,
        lcl_wa_idd28j LIKE LINE OF lcl_it_idd28j.
*Verich fuer Viewfelder
  DATA: lcl_it_idd27s TYPE STANDARD TABLE OF idd27s,
        lcl_wa_idd27s LIKE LINE OF lcl_it_idd27s.

*Tabelle fuer Viewtabellen
  DATA: lcl_it_dd02l TYPE STANDARD TABLE OF dd02l,
        lcl_wa_dd02l LIKE LINE OF lcl_it_dd02l.

*Ueberschrift fuer HTML-Tablle
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string,
        lcl_wa_headerrow LIKE LINE OF lcl_it_headerrow.

*  Data defintion for function module
*  Basistabellen
  DATA: lcl_it_dd26v TYPE STANDARD TABLE OF dd26v,
        lcl_wa_dd26v LIKE LINE OF lcl_it_dd26v.
*  Fields of the view
  DATA: lcl_it_dd27p TYPE STANDARD TABLE OF dd27p,
        lcl_wa_dd27p LIKE LINE OF lcl_it_dd27p.
*  Join-Conditions
  DATA: lcl_it_dd28j TYPE STANDARD TABLE OF dd28j,
        lcl_wa_dd28j LIKE LINE OF lcl_it_dd28j.
*  Selection Conditions
  DATA: lcl_it_dd28v TYPE STANDARD TABLE OF dd28v,
        lcl_wa_dd28v LIKE LINE OF lcl_it_dd28v.


  CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
    EXPORTING
      name                = p_wa_dd02l-tabname
      state               = &apos;A&apos;
*       LANGU               =
*    IMPORTING
*      GOTSTATE            =
*      DD25V_WA            =
*      DD09L_WA            =
    TABLES
      dd26v_tab           = lcl_it_dd26v
      dd27p_tab           = lcl_it_dd27p
      dd28j_tab           = lcl_it_dd28j
      dd28v_tab           = lcl_it_dd28v
    EXCEPTIONS
      illegal_input       = 1
      OTHERS              = 2
            .
  IF sy-subrc &lt;&gt; 0.
    EXIT.
  ENDIF.

* Convert data from format of function  module to internal format

* Fields of view
  LOOP AT lcl_it_dd27p INTO lcl_wa_dd27p.

    MOVE-CORRESPONDING lcl_wa_dd27p TO lcl_wa_idd27s.
    APPEND lcl_wa_idd27s TO lcl_it_idd27s.

  ENDLOOP.

* Selection conditions
  LOOP AT lcl_it_dd28j INTO lcl_wa_dd28j.

    MOVE-CORRESPONDING lcl_wa_dd28j TO lcl_wa_idd28j.
    APPEND lcl_wa_idd28j TO lcl_it_idd28j.

  ENDLOOP.

*Joinbedingungen

  LOOP AT lcl_it_dd28v INTO lcl_wa_dd28v.

    MOVE-CORRESPONDING lcl_wa_dd28v TO lcl_wa_idd28s.
    APPEND lcl_wa_idd28s TO lcl_it_idd28s.

  ENDLOOP.


**Joinbedingungen selektieren
*  SELECT tabname fieldname operator constants FROM dd28s
*        INTO TABLE lcl_it_idd28s
*        WHERE condname = p_wa_dd02l-tabname.
*
**Tabellenfelder selektieren
* SELECT viewfield tabname fieldname FROM dd27s INTO TABLE lcl_it_idd27s
*          WHERE viewname = p_wa_dd02l-tabname.

*Tabelle des Joins an Tabellen-Tabelle anhaengen
  LOOP AT lcl_it_idd28s INTO lcl_wa_idd28s.
*  lcl_wa_idd28s-operator = &apos;equal&apos;.
    MOVE lcl_wa_idd28s-tabname  TO lcl_wa_dd02l-tabname.
    APPEND lcl_wa_dd02l TO lcl_it_dd02l.
  ENDLOOP.

*Duplikate in Tabellen-Tabelle loeschen
  SORT lcl_it_dd02l BY tabname.
  DELETE ADJACENT DUPLICATES FROM lcl_it_dd02l COMPARING tabname.

*Tabellen im Kundennamensraum sichern
  LOOP AT lcl_it_dd02l INTO lcl_wa_dd02l.

    READ TABLE it_prog_stueckliste WITH TABLE KEY
                  name = lcl_wa_dd02l-tabname
                  obername =  global_main_name
                  TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0. &quot;nichts gefunden

      IF lcl_wa_dd02l-tabname(1) = &apos;Z&apos; OR lcl_wa_dd02l-tabname(1) = &apos;Y&apos;.
        PERFORM download_table USING  lcl_wa_dd02l &apos;T&apos;.
      ENDIF. &quot;

    ENDIF. &quot;Stuecklistenueberpruefung

  ENDLOOP.

*****************
*1. Allgemeiner Teil
*Initialsieren der Html-Tabelle, da sie von allen Downloadtabellen
*benutzt wird
  REFRESH it_html.

  APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;&apos; TO it_html.
  APPEND &apos;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;table.XSL&quot;?&gt;&apos;
         TO it_html.
* Header-Tag
  APPEND &apos;&lt;Doc&gt;&apos; TO it_html.

* 2. Selektionsbedingen
  IF NOT ( lcl_it_idd28s IS INITIAL ).

    APPEND &apos;&lt;Tabelle&gt;&apos; TO it_html.
*Ueberschrift zusammenbauen
    CONCATENATE &apos;&lt;header&gt;&apos; &apos;Selection Conditions of View&apos;
          p_wa_dd02l-tabname &apos;&lt;/header&gt;&apos;
          INTO wa_html SEPARATED BY space.
    APPEND wa_html TO it_html.

*  Headertabelle zusammenbauen
    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.

    APPEND &apos;&lt;value&gt;Tablename&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Fieldname&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Operator&lt;/value&gt;&apos;  TO it_html.
    APPEND &apos;&lt;value&gt;Constant Value&lt;/value&gt;&apos; TO it_html.

    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.



    LOOP AT lcl_it_idd28s INTO lcl_wa_idd28s.
      PERFORM create_htmltab_body USING lcl_wa_idd28s.
    ENDLOOP.

    APPEND &apos;&lt;/Tabelle&gt;&apos; TO it_html.
  ENDIF.

* 3. Joinbedingungen
  IF NOT ( lcl_it_idd28j IS INITIAL ).

    APPEND &apos;&lt;Tabelle&gt;&apos; TO it_html.
*Ueberschrift zusammenbauen
    CONCATENATE &apos;&lt;header&gt;&apos; &apos;Join Conditions of View&apos;
          p_wa_dd02l-tabname &apos;&lt;/header&gt;&apos;
          INTO wa_html SEPARATED BY space.
    APPEND wa_html TO it_html.

*  Headertabelle zusammenbauen
    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.

    APPEND &apos;&lt;value&gt;Tablename1&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Fieldname1&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Operator&lt;/value&gt;&apos;  TO it_html.
    APPEND &apos;&lt;value&gt;Tablename2&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Fieldname2&lt;/value&gt;&apos; TO it_html.

    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.



    LOOP AT lcl_it_idd28j INTO lcl_wa_idd28j.
      PERFORM create_htmltab_body USING lcl_wa_idd28j.
    ENDLOOP.

    APPEND &apos;&lt;/Tabelle&gt;&apos; TO it_html.
  ENDIF.

* 4. Felder
  IF NOT ( lcl_it_idd27s IS INITIAL ).

*Headertabelle zusammenbauen
    APPEND &apos;&lt;Tabelle&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;header&gt;&apos; &apos;Fields of View&apos;
          p_wa_dd02l-tabname &apos;&lt;/header&gt;&apos;
          INTO wa_html SEPARATED BY space.
    APPEND wa_html TO it_html.

    REFRESH lcl_it_headerrow.
    APPEND &apos;&lt;tab_header&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Name of Viewfield&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Table&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Name of Tablefield&lt;/value&gt;&apos; TO it_html.
    APPEND &apos;&lt;/tab_header&gt;&apos; TO it_html.



    LOOP AT lcl_it_idd27s INTO lcl_wa_idd27s.
      PERFORM create_htmltab_body USING lcl_wa_idd27s.
    ENDLOOP.

  ENDIF.

  PERFORM create_html_tab_foot.
*********************************************************

*Pfadname generieren
  CLEAR filename.
  CONCATENATE new_dir &apos;\&apos; cv  p_wa_dd02l-tabname
   &apos;.xml&apos; INTO filename.


*** Tables/View downloaden
*   begin of changes for partner namespace
  TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
  PERFORM call_ws_download USING    filename
                                    it_html
                           CHANGING lcl_subrc.
*lcl_t_DD03P-ROLLNAME.

  IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;E&apos;  text060 p_wa_dd02l-tabname
      filename.
  ELSE.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;N&apos;  text060 p_wa_dd02l-tabname
      filename.

  ENDIF. &quot;subrc-Abfrage des Download




ENDFORM.                    &quot; download_view
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_transportrequest
*&amp;---------------------------------------------------------------------*
*      Feststellung welche Objekte in einem Transportauftrag sind und
*      Anstoßen der Archivierung der Objekte.
*----------------------------------------------------------------------*
FORM handle_transportrequest USING    p_name TYPE e071-trkorr.
* Bereiche fuer die allgemeine Tabelle e071
  DATA: lcl_it_e071 TYPE STANDARD TABLE OF e071,
        lcl_wa_e071 LIKE LINE OF lcl_it_e071.
* Variable um den Trdir-Objektnamen eines Includes aufzunehmen
  DATA: lcl_include LIKE c_includename.
* Suchvariable fuer Klassenincludes
  DATA: lcl_such LIKE wa_trdir-name.
* Bereiche um die Rahmenprogramme zu einem Include zu finden
* Wird benötigt um die Reporttext-Eintraege aufzuloesen
  DATA: lcl_it_mastername TYPE STANDARD TABLE OF d010inc-master,
        lcl_wa_mastername LIKE LINE OF lcl_it_mastername.
* Variable fuer Laengeberechnung von Zeichenketten
  DATA: lcl_len TYPE i.
* Bereich konform zu d020s wegen Aufruf der Formroutine fuer Screens
  DATA:  lcl_wa_d020s LIKE wa_d020s.
* Lokale Variablen zum zerlegen der messagevariable in
* Klasse und Nummer.
  DATA: lcl_message_class TYPE t100-arbgb,
       lcl_message_nr TYPE t100-msgnr.
* Feld um den Namen der Message (Klasse/Name) in Stückliste aufnehmen zu
* können.
  DATA: lcl_message_name TYPE trdir-name.
* Arbeitsbereich tfdir um zu eine Funktionsbaustein seinen Incldename
* zu finden.
  DATA: lcl_wa_tfdir TYPE tfdir.
*Temporaere Variablen zur Sicherung der Verzeichnisstruktur
  DATA: lcl_tmp_dir  TYPE string,
        lcl_tmp_new_dir TYPE string.


* Temporaere Variable zur Sicherung der Messagetabelle
  DATA: lcl_tmp_it_messages TYPE STANDARD TABLE OF t100.
* Arbeitsbereich um Sperrobjekt-Routine typkonform aufrufen zu können
  DATA: lcl_wa_cross TYPE cross.
* Lokaler Arbeitsbereich fuer Transaktionscodezuweisung
  DATA: lcl_wa_tstc TYPE tstc.
* Wegen typkonformitaet mit Datenelement-Routine
  DATA: lcl_dataelement LIKE wa_dataelements-rollname.
* Lokale Tabelle fuer alle Datenelemente
  DATA: lcl_it_dataelements TYPE STANDARD TABLE OF dd04v.
* Variable zum feststellen des Tabellentyps
  DATA: lcl_wa_dd02l TYPE dd02l.
* Sicherungstabelle fuer Stuecklisten
  DATA: lcl_it_prog_stueckliste  TYPE STANDARD TABLE OF prog_stueckliste
  .
* Dummyvariable fuer trdir-name
  DATA: lcl_dummy TYPE trdir-name.
* Sicherung des Anfangsverzeichnisses
  DATA: lcl_root TYPE string.
* lokale Tabelle der Domaenen
  DATA: lcl_it_domains TYPE STANDARD TABLE OF dd04v-domname,
        lcl_wa_domains LIKE LINE OF lcl_it_domains.
* Lokale Tabelle fuer Berechtigungsfelder
  DATA: lcl_it_authx LIKE it_authx.
* Tabelle fuer Tranaktionscodeliste von Report/Modulpoole
  DATA: lcl_it_tstc LIKE it_tstc.
* Lokale Tabelle fuer Transaktionscodeliste von Klassen
  DATA: lcl_it_tstcp LIKE it_tstcp.
* Lokale interne Tabelle fuer Titlebar aufzunehmen
  DATA: lcl_it_d347t LIKE it_d347t.
* Lokale Tabelle für Parameter
  DATA: lcl_it_tpara LIKE it_tpara.
* Dummyvariable für Zugriff auf Programmtyp in trdir
  DATA: lcl_subc TYPE trdir-subc.

  lcl_root = dir.


* Intitialisieren der globalen Tabellen
  PERFORM initialize.

* Um Datenformat einzuhalen globales Feld wa_trdir-name fuellen.
* und wegen globaler Verwendung des Arbeitsbereiches wa_trdir
  global_main_name = p_name.

* Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_name
                                 &apos;T&apos;.
* Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

* Ueberschrift zusammenbauen
  CONCATENATE &apos;Transport Request:&apos; p_name INTO header
        SEPARATED BY space.
* Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************


* Basisverzeichnis herstellen
  dir = lcl_root.

* Stueckliste schreiben fuer diesen Transportauftrag
  PERFORM write_stueckliste USING &apos;Transportrequest&apos;
                                   p_name
                                   &apos;&apos;.


* Alle Objekte des Transportauftrages selektieren
  SELECT * FROM e071 INTO TABLE lcl_it_e071
      WHERE trkorr = p_name.

* Schleife ueber die Objekte des Transportrequests
  LOOP AT lcl_it_e071 INTO lcl_wa_e071.

*   Verarbeitung der einzelnen Objekte
    CASE lcl_wa_e071-object.
      WHEN &apos;REPS&apos; OR &apos;REPO&apos; OR &apos;PROG&apos; OR &apos;XPRA&apos;. &quot;Includes od.
        &quot;Rahmenprogram
*       Überprüfen was denn nun wirklich vorliegt
        SELECT SINGLE subc FROM trdir INTO lcl_subc
            WHERE name = lcl_wa_e071-obj_name.
        IF lcl_subc = &apos;I&apos;
          OR lcl_wa_e071-object = &apos;REPS&apos;. &quot;Include


*         Wegen Typkonformitaet Objektname umkopieren; hier entspricht
*         der Objektname der Typ-Vereinbarung.
          lcl_include = lcl_wa_e071-obj_name.
          CLEAR ok.
          PERFORM download_include USING lcl_include &apos;I&apos;
                                   CHANGING ok.
*         Download war erfolgreich
          IF ok = &apos;X&apos;.
*         Stueckliste schreiben fuer dieses Objekt
            PERFORM write_stueckliste USING &apos;REPS&apos;
                                            lcl_wa_e071-obj_name
                                            p_name.
          ENDIF.
        ELSEIF lcl_subc = &apos;1&apos; OR lcl_subc = &apos;M&apos;. &quot;Rahmenprogramm

*         Wegen Typkonformitaet Objektname umkopieren; hier entspricht
*         der Objektname der Typ-Vereinbarung.
          lcl_include = lcl_wa_e071-obj_name.


*         Stueckliste sichern
          REFRESH lcl_it_prog_stueckliste.
          APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste
          .
*         Sicherung der Messagetabelle, wegen Initialisierung in Routine
          lcl_tmp_it_messages = it_messages.
*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
          lcl_tmp_dir = dir.
          lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*         liegen.
          dir = new_dir.
*         Globalen Namen setzen
          global_main_name = lcl_wa_e071-obj_name.
          PERFORM handle_reps_mods USING lcl_include.

*         Wiederherstellen der Verzeichnisstruktur,
          dir = lcl_tmp_dir.
          new_dir = lcl_tmp_new_dir.
*         Ruecksicherung der Stueckliste
          it_prog_stueckliste = lcl_it_prog_stueckliste.
*         Ruecksicherung der Messagetabe0lle
          it_messages = lcl_tmp_it_messages.

*         Wiederherstellen des globalen Feldes global_main_name
          CLEAR wa_trdir.
          global_main_name = lcl_wa_e071-trkorr.
*         Stückliste wiederherstellen und schreiben
          REFRESH it_prog_stueckliste.
          APPEND LINES OF lcl_it_prog_stueckliste TO
                                       it_prog_stueckliste.

*         Stueckliste schreiben fuer dieses Objekt
          PERFORM write_stueckliste USING &apos;PROG&apos;
                                          lcl_wa_e071-obj_name
                                          p_name.


*       no include found ---&gt;next entry
        ELSE.

          CONTINUE.


        ENDIF. &quot;welcher Programmtyp liegt nun wirklich vor
*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


      WHEN &apos;REPT&apos;.  &quot; OR &apos;REPO&apos;.  &quot;Textelemente zu Reports
*       Wegen Typkonformitaet Objektname umkopieren; hier entspricht
*       der Objektname der Typ-Vereinbarung.
        lcl_include = lcl_wa_e071-obj_name.
*       Auloesen der Eintraege --&gt;Finden des Masterincludes, da Name des
*Masterincludes dem Namen des Textpools entspricht (es koennen auch
*       mehrere masterincludes sein
        SELECT master FROM d010inc INTO TABLE lcl_it_mastername
              WHERE include = lcl_include.
        global_main_name = lcl_wa_e071-obj_name.
        IF sy-subrc = 0. &quot;Master gefunden
          LOOP AT lcl_it_mastername INTO lcl_wa_mastername.
*           Textelemente des Rahmenprogramms herunterladen
            PERFORM download_textelements USING lcl_wa_mastername
                                          &apos;T&apos;.

*Stueckliste wird in &apos;download_textelements&apos; geschrieben --&gt; Typ &apos;T&apos;
          ENDLOOP.
        ELSE. &quot;Eintrag in Transportauftrag ist Master
*         Textelemente des Rahmenprogramms herunterladen
          PERFORM download_textelements USING lcl_include
                                       &apos;T&apos;.

        ENDIF.
        global_main_name = lcl_wa_e071-trkorr.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;TYPD&apos; OR &apos;TYPE&apos;. &quot;Typgruppe
*Zusammensetzen des Includenamens der Typgruppe: Praefix %_C vor Namen
        CONCATENATE &apos;%_C&apos; lcl_wa_e071-obj_name INTO lcl_include.
*Uebergabe des Typ des Includes, um Dateinamen festlegen zu können
        CLEAR ok.
        PERFORM download_include USING lcl_include &apos;T&apos;
                                 CHANGING ok.
        IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*         Stueckliste schreiben, wenn download erfolgreich
          PERFORM write_stueckliste USING &apos;Typgroup&apos;
                                            lcl_wa_e071-obj_name
                                            p_name.
        ENDIF. &quot;downnload erfolgreich???

*      Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;DYNP&apos;.  &quot;Dynpro
*Programmname und Dynpronummer aus Objektnamen des Transportrequests
*       ermitteln
        lcl_len = STRLEN( lcl_wa_e071-obj_name ).
        lcl_len = lcl_len - 4.
        lcl_wa_d020s-prog = lcl_wa_e071-obj_name(lcl_len).
        lcl_wa_d020s-dnum = lcl_wa_e071-obj_name+lcl_len.
*Dynpro herunterladen; Keine Ueberpruefung ob schon heruntergeladen,
*da ein Screen nur einmal in einem Transportauftrag vorkommen kann.
        PERFORM download_dynpro USING lcl_wa_d020s.
        PERFORM write_stueckliste USING &apos;SCR&apos;
                                         lcl_wa_e071-obj_name
                                         lcl_wa_d020s-prog.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;MESS&apos;. &quot;einzelne Message
*     Keine Ueberpruefung, ob schon heruntergeladen, da Message
*     nur einmal im Transportauftrag vorhanden sein kann.

*       Laengenbestimmung um Feld auseinanderzunehmen.
        lcl_len = STRLEN( lcl_wa_e071-obj_name ).
        lcl_len = lcl_len - 3.

*       Db-Feld auseinandernehmen fuer Messageklasse und Nummer
        lcl_message_class =  lcl_wa_e071-obj_name(lcl_len).
        lcl_message_nr = lcl_wa_e071-obj_name+lcl_len.

*       Schleife ueber Sprachtabelle
        LOOP AT it_lan INTO wa_lan.
*         Name für Stückliste zusammensetzen
          CONCATENATE lcl_message_class &apos;/&apos; lcl_message_nr &apos;/&apos; wa_lan
            INTO lcl_message_name.
          CLEAR wa_messages.
*         Messagetabelle lesen mit Schlüssel nur bei Fehler nichts tun
          SELECT SINGLE * FROM t100 INTO wa_messages
                  WHERE arbgb = lcl_message_class
                    AND msgnr = lcl_message_nr
                    AND sprsl = wa_lan.
          IF sy-subrc = 0.
*           Schreiben der Gesamt-Messagetabellle
            APPEND wa_messages TO it_messages.

*           Schreiben der Stückliste, nicht länderspezifisch nur einmal
            PERFORM write_stueckliste USING &apos;MSG&apos;
                                         lcl_message_name
                                         p_name.
          ENDIF.
        ENDLOOP. &quot;Sprachtabelle

      WHEN &apos;MSAG&apos;.

*       Verarbeitung der Messageklasse
        PERFORM trkorr_messageclass USING lcl_wa_e071-obj_name
                                          p_name.

      WHEN &apos;FUNC&apos;. &quot;Funktionsbaustein
*       Lesen, um zu dem Funktionsnamen den Includename zu finden
        SELECT SINGLE * FROM tfdir INTO lcl_wa_tfdir
              WHERE funcname =  lcl_wa_e071-obj_name.

*       Verarbeitung abhängig von Namensraum
        IF lcl_wa_tfdir-pname(1) = &apos;/&apos;.
*         Partnernamensraum
          PERFORM convert_funcname_for_partner USING lcl_wa_tfdir
                                               CHANGING lcl_include.
        ELSE.
*Zusammensetzen des Includenamens; Beim Funktionsgruupennamen Praefix
*         &apos;SAP&apos; abschneiden: --&gt;Offset
          CONCATENATE lcl_wa_tfdir-pname+3 &apos;U&apos; lcl_wa_tfdir-include
              INTO lcl_include.
        ENDIF.

*       Download des Includes
        CLEAR ok.
        gv_funcname = lcl_wa_tfdir-funcname.
        PERFORM download_include USING lcl_include &apos;F&apos;
                                 CHANGING ok.
        CLEAR gv_funcname.
        IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*         Stueckliste schreiben, wenn download erfolgreich
*         Funktionsbauseinname:
          PERFORM write_stueckliste USING &apos;FUNC&apos;
                                            lcl_wa_e071-obj_name
                                            p_name.
*         Includename des Funktionsbaustein
          PERFORM write_stueckliste USING &apos;IN&apos;
                                  lcl_include
                                  lcl_wa_e071-obj_name.

        ENDIF. &quot;downnload erfolgreich???

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;FUGT&apos;. &quot;Funktionsgruppentext
*       SAPL-Name des Funktionsbausteins zusammenbauen
*       Unterscheidung auf Partnernamensraum.
        IF lcl_wa_e071-obj_name(1) = &apos;/&apos;.
          PERFORM convert_fugrname_for_partner
               CHANGING lcl_wa_e071-obj_name.
          lcl_include = lcl_wa_e071-obj_name.
        ELSE. &quot;normaler namensraum
          CONCATENATE &apos;SAPL&apos; lcl_wa_e071-obj_name INTO lcl_include.
        ENDIF.
*       Textelemente des Rahmenprogramms herunterladen
        PERFORM download_textelements USING lcl_include
                                          &apos;T&apos;.
*     Stueckliste wird in &apos;download_textelements&apos; geschrieben --&gt; Typ &apos;T
      WHEN &apos;IASP&apos;. &quot;IAC-Service
*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
*       Sicherung der Messagetabelle, wegen Initialisierung in Routine
        lcl_tmp_it_messages = it_messages.
*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.

*       Globalen Namen setzen
        global_main_name = lcl_wa_e071-obj_name.

*       Ueberpruefen, ob Service noch existiert
        SELECT SINGLE service FROM iacservice INTO lcl_dummy
                  WHERE service = lcl_wa_e071-obj_name.
        IF sy-subrc = 0.
*         Verarbeitungsroutine fuer Funktionsgruppen aufrufen
          PERFORM handle_iac_service USING lcl_wa_e071-obj_name.
        ELSE.
          CONTINUE.
        ENDIF.
*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Ruecksicherung der Stueckliste
        it_prog_stueckliste = lcl_it_prog_stueckliste.
*       Ruecksicherung der Messagetabe0lle
        it_messages = lcl_tmp_it_messages.

*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = lcl_wa_e071-trkorr.
*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                     it_prog_stueckliste.

        PERFORM write_stueckliste USING &apos;IACS&apos;
                                  lcl_wa_e071-obj_name
                                  p_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;IATU&apos; OR &apos;IATL&apos;.

*       Globalen Namen setzen
        global_main_name = lcl_wa_e071-obj_name.

        PERFORM download_iac_template USING lcl_wa_e071-obj_name
                                            new_dir.

        PERFORM write_stueckliste USING &apos;IACT&apos;
                                  lcl_wa_e071-obj_name
                                  p_name.

*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = lcl_wa_e071-trkorr.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


      WHEN &apos;FUGR&apos; OR &apos;FUGX&apos; OR &apos;FUGS&apos; . &quot;Gesamte Funktionsgruppe
        &quot;(normal oder Erweiterungsgruppe

*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
*       Sicherung der Messagetabelle, wegen Initialisierung in Routine
        lcl_tmp_it_messages = it_messages.
*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.

*       Globalen Namen setzen
        global_main_name = lcl_wa_e071-obj_name.

*       SAPL-Name des Funktionsbausteins zusammenbauen
*       Unterscheidung auf Partnernamensraum.
        IF lcl_wa_e071-obj_name(1) = &apos;/&apos;.
          PERFORM convert_fugrname_for_partner
               CHANGING lcl_wa_e071-obj_name.
          lcl_include = lcl_wa_e071-obj_name.
        ELSE. &quot;normaler namensraum
          CONCATENATE &apos;SAPL&apos; lcl_wa_e071-obj_name INTO lcl_include.

        ENDIF.

*       Ueberpruefen, ob Funktionsgruppe noch existiert
        SELECT SINGLE name FROM trdir INTO lcl_dummy
                WHERE name = lcl_include.
        IF sy-subrc = 0.
*       Verarbeitungsroutine fuer Funktionsgruppen aufrufen
          PERFORM handle_functiongroup USING lcl_include.
        ELSE.
          CONTINUE.
        ENDIF.
*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Ruecksicherung der Stueckliste
        it_prog_stueckliste = lcl_it_prog_stueckliste.
*       Ruecksicherung der Messagetabe0lle
        it_messages = lcl_tmp_it_messages.

*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = lcl_wa_e071-trkorr.
*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                     it_prog_stueckliste.

        PERFORM write_stueckliste USING &apos;Functiongroup&apos;
                                  lcl_include
                                  p_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;ENQU&apos; OR &apos;ENQD&apos;. &quot;Sperrobjekt
*       lcl_wa_cross fuellen um Sperrobjektroutin typkonform aufrufen zu
*       können
        CLEAR lcl_wa_cross-name.
        lcl_wa_cross-name = lcl_wa_e071-obj_name.
*       Sperrobjekt-Routine aufrufen
        PERFORM handle_lockobject USING lcl_wa_cross
                                        &apos;S&apos;. &quot;Name ist Sperrobjektname

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;IDOC&apos;.  &quot;IDOC-Basistyp
*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.

*       Globale Daten aufbereiten, um IDOC-Routine aufrufen zu koennen
        global_main_name = lcl_wa_e071-obj_name.
*       IDOC-Routine ausfuehren
        PERFORM handle_idoc USING lcl_wa_e071-obj_name
                                  &apos;B&apos;.
*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.
*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Wiederherstellen des globalen Feldes wa_trdir-name
        CLEAR wa_trdir.
        global_main_name = p_name.

*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                     it_prog_stueckliste.

        PERFORM write_stueckliste USING &apos;BasisIDoc&apos;
                                  lcl_wa_e071-obj_name
                                  global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;IEXT&apos;.  &quot;IDOC-Erweiterung
*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.

*       Globale Daten aufbereiten, um IDOC-Routine aufrufen zu koennen
        global_main_name = lcl_wa_e071-obj_name.
*       IDOC-Routine ausfuehren
        PERFORM handle_idoc USING lcl_wa_e071-obj_name
                                   &apos;E&apos;.
*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = p_name.
*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                     it_prog_stueckliste.

        PERFORM write_stueckliste USING &apos;IDocEnhancement&apos;
                                  lcl_wa_e071-obj_name
                                  global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;PARA&apos;. &quot;Set/GetParameter
*       Globale Tabelle leeren
        REFRESH it_tpara.
*       lcl_wa_cross fuellen um Parameterroutine typkonform aufrufen zu
*       können
        CLEAR lcl_wa_cross-name.
        lcl_wa_cross-name = lcl_wa_e071-obj_name.

*       Aufruf des Handlers fuer Set/Get-Parameter
        PERFORM handle_setgetparamss USING lcl_wa_cross.

        APPEND LINES OF it_tpara TO lcl_it_tpara.

      WHEN &apos;TRAN&apos;. &quot;Transaktionscode
*       Tabelle der TA-Codes selektieren und an Gesamttabelle haengen
        SELECT SINGLE * FROM tstc INTO  lcl_wa_tstc
        WHERE tcode = lcl_wa_e071-obj_name.

        IF NOT ( lcl_wa_tstc-pgmna IS INITIAL ). &quot;Report/Modulpool
          IF NOT lcl_wa_tstc IS INITIAL.
            APPEND lcl_wa_tstc TO   lcl_it_tstc.
          ENDIF.
        ELSE. &quot;Klassen
          SELECT SINGLE * FROM tstcp INTO wa_tstcp
              WHERE tcode = lcl_wa_e071-obj_name.
          IF NOT wa_tstcp IS INITIAL.
            APPEND wa_tstcp TO lcl_it_tstcp.
          ENDIF.
        ENDIF.

      WHEN &apos;DOMD&apos; OR &apos;DOMA&apos;. &quot;Domaene
*   Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
        READ TABLE it_prog_stueckliste WITH KEY name =
        lcl_wa_e071-obj_name
                                    type = &apos;Domaene&apos; TRANSPORTING NO
                                    FIELDS.
        IF sy-subrc &lt;&gt; 0.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;Domaene&apos;
                                        lcl_wa_e071-obj_name
                                       global_main_name.
          lcl_wa_domains = lcl_wa_e071-obj_name.
          APPEND lcl_wa_domains TO lcl_it_domains.

        ENDIF. &quot;Stuecklistenueberpruefung



      WHEN &apos;DTED&apos; OR &apos;DTEL&apos;.  &quot;Datenelemente
*       Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
        READ TABLE it_prog_stueckliste WITH KEY name =
        lcl_wa_e071-obj_name
                               type = &apos;Datenelement&apos; TRANSPORTING NO
                               FIELDS.
        IF sy-subrc &lt;&gt; 0.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;Datenelement&apos;
                                        lcl_wa_e071-obj_name
                                        global_main_name.

*          Zuweisung des Datenelementnamens wegen Typkonformitaet
          lcl_dataelement = lcl_wa_e071-obj_name.
*         Initialsierung der globalen Tabelle (Routine nutzt diese)
          REFRESH  it_dataelements.
          PERFORM write_dataelements USING lcl_dataelement.
*         Anhaengen der der Zeilen an lokale Tabelle
          APPEND LINES OF it_dataelements TO lcl_it_dataelements.
        ENDIF. &quot;Stuecklistenueberpruefung


      WHEN &apos;TABD&apos; OR &apos;TABT&apos; OR &apos;TABL&apos;.
        &quot;Tabelle/Strukturen/Views

*       Feststellen ob Tabelle oder Struktur vorliegt
        SELECT SINGLE * FROM dd02l INTO lcl_wa_dd02l
            WHERE tabname = lcl_wa_e071-obj_name.

*       Fuer Typ T feststellen ob Struktur, oder Taelle
        IF lcl_wa_dd02l-tabclass = &apos;TRANSP&apos;. &quot;normale Tabelle
*         Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
          READ TABLE it_prog_stueckliste WITH KEY name =
          lcl_wa_e071-obj_name
                                      type = &apos;Tabelle&apos; TRANSPORTING NO
                                      FIELDS.
          IF sy-subrc &lt;&gt; 0.
*           Infos suchen und diese Downloaden
            PERFORM download_table USING lcl_wa_dd02l
                                         &apos;T&apos;.

*           Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Table&apos;
                                          lcl_wa_e071-obj_name
                                          global_main_name.

          ENDIF. &quot;Stuecklistenueberpruefung

        ELSEIF lcl_wa_dd02l-tabclass = &apos;INTTAB&apos;. &quot;Struktur

*   Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
          READ TABLE it_prog_stueckliste WITH KEY name =
          lcl_wa_e071-obj_name
                                     type = &apos;Struktur&apos; TRANSPORTING NO
                                     FIELDS.
          IF sy-subrc &lt;&gt; 0.
*           Infos suchen und diese Downloaden
            PERFORM download_table USING lcl_wa_dd02l
                                         &apos;S&apos;.
*           Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Structure&apos;
                                          lcl_wa_e071-obj_name
                                          global_main_name.


          ENDIF. &quot;Stuecklistenueberpruefung


        ELSEIF lcl_wa_dd02l-tabclass = &apos;APPEND&apos;. &quot;Appendstruktur
*         Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
          READ TABLE it_prog_stueckliste WITH KEY name =
          lcl_wa_e071-obj_name
                                       type = &apos;Append&apos; TRANSPORTING NO
                                       FIELDS.
          IF sy-subrc &lt;&gt; 0.
*            Infos suchen und diese Downloaden
            PERFORM download_table USING lcl_wa_dd02l
                                         &apos;A&apos;.
*           Stueckliste schreiben
            PERFORM write_stueckliste USING &apos;Append&apos;
                                          lcl_wa_e071-obj_name
                                          global_main_name.


          ENDIF. &quot;Stuecklistenueberpruefung
        ENDIF.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;TTYP&apos; OR &apos;TTYX&apos; OR &apos;TTYD&apos;.  &quot;Tabellentyp

*       Überüfung, ob Tabellentyp überhaupt noch existiert.
        SELECT SINGLE * FROM dd40vv INTO wa_tabletypes
          WHERE typename = lcl_wa_e071-obj_name.
        IF sy-subrc NE 0.
          CONTINUE.
        ENDIF.

        PERFORM handle_tabletype USING lcl_wa_e071-obj_name.
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Tabletype&apos;
                                       lcl_wa_e071-obj_name
                                       global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;VIEW&apos; OR &apos;VIED&apos; OR &apos;VIET&apos;.
*       Tabelle lesen wegen Typkonformem Aufruf der Routine
        SELECT SINGLE * FROM dd02l INTO lcl_wa_dd02l
            WHERE tabname = lcl_wa_e071-obj_name.
        IF sy-subrc NE 0.
          CONTINUE.
        ENDIF.
*   Ueberpruefen ob schon heruntergeladen (wegen or-Bedingung)
        READ TABLE it_prog_stueckliste WITH KEY name =
        lcl_wa_e071-obj_name
                                      type = &apos;View&apos; TRANSPORTING NO
                                      FIELDS.
        IF sy-subrc &lt;&gt; 0.

          CLEAR wa_ddictypes.
          wa_ddictypes-tabname = lcl_wa_e071-obj_name.
          PERFORM download_view USING wa_ddictypes.

*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;View&apos;
                                         lcl_wa_e071-obj_name
                                         global_main_name.

        ENDIF. &quot;Stuecklistenueberpruefung

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;DIAL&apos;. &quot;Dialogbaustein
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Dialogmodule&apos;
                                      lcl_wa_e071-obj_name
                                      global_main_name.

        PERFORM trkorr_handle_dialogmodules USING lcl_wa_e071-obj_name.
*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;SUSO&apos;. &quot;Authorityobject
*       Stueckliste schreiben

        PERFORM trkorr_handleauthorityobject USING
                                  lcl_wa_e071-obj_name.


      WHEN &apos;AUTH&apos;. &quot;Feld eines Berechtigungsobjektes

        PERFORM write_stueckliste USING &apos;Authorityfield&apos;
                                    lcl_wa_e071-obj_name
                                    global_main_name.

        REFRESH it_authx.
        PERFORM trkorr_handle_authorityfield
                                    USING lcl_wa_e071-obj_name.

*       Sicherung de Berechtigungsobjektfelder
        APPEND LINES OF it_authx TO lcl_it_authx.

      WHEN &apos;CMOD&apos;. &quot;CMOD-Erweiterungsprojekt
*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.

*       Globale Daten aufbereiten, um IDOC-Routine aufrufen zu koennen
        global_main_name = lcl_wa_e071-obj_name.
        APPEND o_cmod.
*       CMOD-Routine ausfuehren
        PERFORM handle_customerenhancement USING lcl_wa_e071-obj_name.
*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = p_name.
*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                     it_prog_stueckliste.

        PERFORM write_stueckliste USING &apos;Enhancement Project&apos;
                                  lcl_wa_e071-obj_name
                                  global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


      WHEN &apos;SXCI&apos;. &quot;Badiimplementierung
*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.

*       Globale Daten aufbereiten, um IDOC-Routine aufrufen zu koennen
        global_main_name = lcl_wa_e071-obj_name.

*       CMOD-Routine ausfuehren
        PERFORM handle_badi_implementation USING lcl_wa_e071-obj_name.
*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = p_name.
*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                     it_prog_stueckliste.

        PERFORM write_stueckliste USING &apos;Badi Implementation&apos;
                                  lcl_wa_e071-obj_name
                                  global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;CPRI&apos;. &quot;Private Header-Include einer Klasse
*       Laenge des Klassennamens
        lcl_len = STRLEN( lcl_wa_e071-obj_name ).
*       Zeichen &apos;=&apos; anfuegen (kann nicht bei Anlage verwendet werden)
        IF lcl_len &lt; 30.
          CONCATENATE lcl_wa_e071-obj_name &apos;=%CI&apos; INTO lcl_such.
        ELSE.
          CONCATENATE lcl_wa_e071-obj_name &apos;%CI&apos; INTO lcl_such.
        ENDIF.
*       das Include suchen
        CLEAR lcl_include.
        SELECT SINGLE name FROM trdir INTO lcl_include
                  WHERE name LIKE lcl_such.
*       Include herunterladen
        CLEAR ok.
        PERFORM download_include USING lcl_include &apos;C&apos;
                                 CHANGING ok.
*       Download war erfolgreich
        IF ok = &apos;X&apos;.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;PrivateHeaderInclude&apos;
                                        lcl_include
                                        global_main_name.
        ENDIF.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;CPRO&apos;. &quot;Protected Header-Include einer Klasse
*       Laenge des Klassennamens
        lcl_len = STRLEN( lcl_wa_e071-obj_name ).
*       Zeichen &apos;=&apos; anfuegen (kann nicht bei Anlage verwendet werden)
        IF lcl_len &lt; 30.
          CONCATENATE lcl_wa_e071-obj_name &apos;=%CO&apos; INTO lcl_such.
        ELSE.
          CONCATENATE lcl_wa_e071-obj_name &apos;%CO&apos; INTO lcl_such.
        ENDIF.
*       das Include suchen
        CLEAR lcl_include.
        SELECT SINGLE name FROM trdir INTO lcl_include
                  WHERE name LIKE lcl_such.
*       Include herunterladen
        CLEAR ok.
        PERFORM download_include USING lcl_include &apos;C&apos;
                                 CHANGING ok.
*       Download war erfolgreich
        IF ok = &apos;X&apos;.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;ProtectedHeaderInclude&apos;
                                        lcl_include
                                        global_main_name.
        ENDIF.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;CPUB&apos;. &quot;Public Header-Include einer Klasse
*       Laenge des Klassennamens
        lcl_len = STRLEN( lcl_wa_e071-obj_name ).
*       Zeichen &apos;=&apos; anfuegen (kann nicht bei Anlage verwendet werden)
        IF lcl_len &lt; 30.
          CONCATENATE lcl_wa_e071-obj_name &apos;=%CU&apos; INTO lcl_such.
        ELSE.
          CONCATENATE lcl_wa_e071-obj_name &apos;%CU&apos; INTO lcl_such.
        ENDIF.
*       das Include suchen
        CLEAR lcl_include.
        SELECT SINGLE name FROM trdir INTO lcl_include
                  WHERE name LIKE lcl_such.
*       Include herunterladen
        CLEAR ok.
        PERFORM download_include USING lcl_include &apos;C&apos;
                                 CHANGING ok.
*       Download war erfolgreich
        IF ok = &apos;X&apos;.
*         Stueckliste schreiben
          PERFORM write_stueckliste USING &apos;PublicHeaderInclude&apos;
                                        lcl_include
                                        global_main_name.
        ENDIF.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;METH&apos;. &quot;Methodeninclude einer Klasse
        PERFORM trkorr_handle_single_method USING lcl_wa_e071-obj_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;CINC&apos;. &quot;Klasseninclude
*       Wegen Typkonformitaet Objektname umkopieren; hier entspricht
*       der Objektname der Typ-Vereinbarung.
        lcl_include = lcl_wa_e071-obj_name.
        CLEAR ok.
        PERFORM download_include USING lcl_include &apos;C&apos;
                                 CHANGING ok.
*       Download war erfolgreich
        IF ok = &apos;X&apos;.
*         Stueckliste schreiben fuer dieses Objekt
          PERFORM write_stueckliste USING lcl_wa_e071-object
                                          lcl_wa_e071-obj_name
                                          p_name.
        ENDIF.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;CLAS&apos; OR &apos;CLSD&apos;. &quot;objektorientierte Klasse
*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.
*       Globale Daten aufbereiten, um IDOC-Routine aufrufen zu koennen
        global_main_name = lcl_wa_e071-obj_name.
*       Klassen-Routine ausfuehren
*       Intitialisieren der globalen Tabellen
        PERFORM initialize.
        PERFORM handle_class_extern USING lcl_wa_e071-obj_name.
*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = p_name.
*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                       it_prog_stueckliste.

        PERFORM write_stueckliste USING &apos;Class&apos;
                                   lcl_wa_e071-obj_name
                                   global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


      WHEN &apos;INTF&apos;. &quot;Interface
*       Stueckliste sichern
        REFRESH lcl_it_prog_stueckliste.
        APPEND LINES OF it_prog_stueckliste TO lcl_it_prog_stueckliste.

*Sicherung der Verzeichnisstruktur: Aenderungen der Variablen in Routine
        lcl_tmp_dir = dir.
        lcl_tmp_new_dir = new_dir.
*Zuweisen des erzeugten Verzeichnisses des Transportauftrages zur root,
*damit die Rahmenprogramme unter dem Verzeichnis des Transportauftrages
*       liegen.
        dir = new_dir.
*       Sicherung globales Bezeichnungsfeld
        global_main_name = lcl_wa_e071-obj_name.

        PERFORM handle_interface USING lcl_wa_e071-obj_name.

*       Wiederherstellen der Verzeichnisstruktur,
        dir = lcl_tmp_dir.
        new_dir = lcl_tmp_new_dir.
*       Wiederherstellen des globalen Feldes global_main_name
        CLEAR wa_trdir.
        global_main_name = p_name.
*       Stückliste wiederherstellen und schreiben
        REFRESH it_prog_stueckliste.
        APPEND LINES OF lcl_it_prog_stueckliste TO
                                       it_prog_stueckliste.

*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Interface&apos;
                                   lcl_wa_e071-obj_name
                                   global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      WHEN &apos;CUAD&apos;. &quot;Programmoberflaeche
*       pf-Stati verarbeiten
        PERFORM handle_pf_status USING lcl_wa_e071-obj_name
                                       &apos;R&apos;.
*       Titlebars suchen
        REFRESH it_d347t.
        PERFORM handle_titlebar USING lcl_wa_e071-obj_name
                                       &apos;R&apos;.
        APPEND LINES OF it_d347t TO lcl_it_d347t.


*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

    ENDCASE.  &quot;Welcher Objekttyp liegt vor

  ENDLOOP. &quot;Schleife ueber Objekte eines Transportrequests

*Verarbeitung der globalen Elemente dieses Transportauftrages


* Datenelemente herunterladen
  REFRESH it_dataelements.
  APPEND LINES OF lcl_it_dataelements TO it_dataelements.
  PERFORM download_dataelements.

* Domaenen downloaden
  PERFORM handle_trkorr_domains USING lcl_it_domains.

* Titlebars herunterladen
  REFRESH it_d347t.
  APPEND LINES  OF lcl_it_d347t TO it_d347t.
  PERFORM download_titlebar.

* Meldungen herunterladen
  PERFORM download_messages.

* Liste mit allen Berechtigungsfelder des Auftrages sichern
  PERFORM trkorr_download_authorityfield USING lcl_it_authx.

* Gesamtliste der Parameter herunterschreiben
  REFRESH it_tpara.
  APPEND LINES OF lcl_it_tpara TO it_tpara.
  PERFORM download_setgetparams.

* Gesamtliste der Transaktionscodes herunterladen (Reps/Modulpools/Fkgrp
  REFRESH it_tstc.
  APPEND LINES OF lcl_it_tstc TO it_tstc.
  PERFORM download_tacodelist.
* Gesamtliste der Transaktionscodes fuer Klasse herunterladen
  REFRESH it_tstcp.
  APPEND LINES OF lcl_it_tstcp TO it_tstcp.
  PERFORM download_tacodelist_for_class.
* Stueckliste diese Transportauftrages herunterladen
  PERFORM download_stueckliste.
* Hot-Package-Stand des Systems herunterladen
  PERFORM download_hpstand.

  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


ENDFORM.                    &quot; handle_transportrequest
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_tacode_for_class
*&amp;---------------------------------------------------------------------*
*      Feststellen, ob einer Klasse ein Transaktionscode zugeordnet ist.
*----------------------------------------------------------------------*
FORM handle_tacode_for_class USING p_name TYPE c.
*Bereich fuer die Parametertabelle von Transaktionscodes
  DATA: lcl_it_tstcp TYPE STANDARD TABLE OF tstcp,
        lcl_wa_tstcp LIKE LINE OF lcl_it_tstcp.

*Variable fuer Suchstring der uebergebenen Klasse
  DATA: lcl_such TYPE string.

*Suchstring zusammensetzen.
  CONCATENATE &apos;CLASS=&apos; p_name INTO lcl_such.

*Alle Paramertercodes in Kundennamensraum selektieren
  SELECT * FROM tstcp INTO TABLE lcl_it_tstcp
        WHERE tcode LIKE &apos;Z%&apos; OR tcode = &apos;Y%&apos; OR
              tcode = g_name.

  LOOP AT lcl_it_tstcp INTO lcl_wa_tstcp.

    SEARCH lcl_wa_tstcp-param FOR lcl_such.
    IF sy-subrc = 0.
      APPEND lcl_wa_tstcp TO it_tstcp.
    ENDIF.

  ENDLOOP.

ENDFORM.                    &quot; handle_tacode_for_class
*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_tacodelist_for_class
*&amp;---------------------------------------------------------------------*
*       Generierung und Sicherung der Transaktionscodeliste bei
*       Klassen, denen Transakrinen zugeordnet sind.
*----------------------------------------------------------------------*
FORM download_tacodelist_for_class.
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.

*Dateiname fuer Download
  DATA: lcl_tacode_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_tstcp IS INITIAL ).

*  Ueberschrift zusammenbauen
    CONCATENATE &apos;Transactioncodes (parameters) of&apos;  global_main_name
             INTO lcl_header SEPARATED BY space.
*  Headertabelle zusammenbauen
    APPEND &apos;Transactionscode&apos; TO lcl_it_headerrow.
    APPEND &apos;Parameters&apos; TO lcl_it_headerrow.


*  Umwandlung in HTML-Tabelle
*  *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_tstcp INTO wa_tstcp.
      PERFORM create_htmltab_body USING wa_tstcp.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************

    CONCATENATE &apos;Tacodeclass_&apos; global_main_name INTO lcl_tacode_name.


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_tacode_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tstc
                             CHANGING lcl_subrc.
    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  text034 lcl_tacode_name
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  text034 lcl_tacode_name
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Transactioncodelist(Class)&apos;
                                      &apos;Transactioncodelist(Class)&apos;
                                      global_main_name.
    ENDIF.
  ENDIF. &quot;ist it_tstcp überhaupt gefüllt

ENDFORM.                    &quot; download_tacodelist_for_class
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_intf
*&amp;---------------------------------------------------------------------*
*       Routine zur Generierung des HTML-Codes der Navigationsleiste
*       fuer Interfaces
*----------------------------------------------------------------------*
FORM create_html_for_intf.
  DATA: lcl_wa_prog_stueckliste TYPE prog_stueckliste.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  APPEND &apos;&lt;value&gt;Interfaceincludes&lt;/value&gt;&apos; TO it_html.
  CONCATENATE &apos;&lt;order&gt;&apos; g_order_intf_main &apos;&lt;/order&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.

  READ TABLE it_prog_stueckliste WITH KEY type = &apos;Interface(OO)&apos;
    INTO wa_prog_stueckliste.
  IF sy-subrc = 0.
    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
          WHERE obername = wa_prog_stueckliste-name
            AND type = &apos;Include&apos;.

      IF lcl_wa_prog_stueckliste-name+30(2) = &apos;IP&apos;.
        CONCATENATE &apos;Intf_&apos; lcl_wa_prog_stueckliste-file_name &apos;.xml&apos;
           INTO lcl_url.
        lcl_name = &apos;Poolinclude&apos;.

      ELSE.
        CONCATENATE &apos;Intf_&apos; lcl_wa_prog_stueckliste-file_name
                &apos;.xml&apos; INTO lcl_url.
        lcl_name = &apos;Components&apos;.

      ENDIF. &quot;Poolinclude
      PERFORM nav_xml_add_subitem USING lcl_url
                                  lcl_name
               &apos;main&apos;.
    ENDLOOP.

    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

*Interfaces, die im Interface implementiert sind
  READ TABLE it_prog_stueckliste  WITH KEY type = &apos;Interface&apos;
    TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    APPEND &apos;&lt;item&gt;&apos; TO it_html.
    APPEND &apos;&lt;value&gt;Used Interfaces&lt;/value&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;order&gt;&apos; g_order_intf_used &apos;&lt;/order&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    LOOP AT it_prog_stueckliste INTO lcl_wa_prog_stueckliste
                WHERE type = &apos;Interface&apos;.

      IF  extern = &apos;X&apos; OR p_devc = &apos;X&apos; OR p_trkorr = &apos;X&apos;.
        CONCATENATE &apos;../OI_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.
        lcl_name = lcl_wa_prog_stueckliste-name.

      ELSE.
        CONCATENATE &apos;./OI_&apos; lcl_wa_prog_stueckliste-file_name
          &apos;/index.htm&apos; INTO lcl_url.
        lcl_name = lcl_wa_prog_stueckliste-name.

      ENDIF.
      PERFORM nav_xml_add_subitem USING lcl_url
                                        lcl_name
                                        c_target_new.
    ENDLOOP.
    APPEND &apos;&lt;/item&gt;&apos; TO it_html.
  ENDIF.

ENDFORM.                    &quot; create_html_for_intf
*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_protocol
*&amp;---------------------------------------------------------------------*
*       Mit dieser Routine wird die interne Tabelle fuer
*       die Protokollliste gefuellt.
*----------------------------------------------------------------------*
FORM write_protocol USING p_typus TYPE any
               p_objtype TYPE any
           p_objname TYPE any
           p_filename TYPE any.

*Arbeitsbereich initialisieren
  CLEAR wa_protocol.

*Arbeitsbereich fuellen
  wa_protocol-typus = p_typus.
  wa_protocol-objtype = p_objtype.
  wa_protocol-objname = p_objname.
  wa_protocol-filename = p_filename.

*Tabelle fuellen
  APPEND wa_protocol TO it_protocol.

ENDFORM.                    &quot; write_protocol
*&amp;---------------------------------------------------------------------*
*&amp;      Form  output_protocol
*&amp;---------------------------------------------------------------------*
*       Verarbeitung  der Protokolltabelle zum
*       Archivierungsprotokoll.
*----------------------------------------------------------------------*
FORM output_protocol.

*Warnausgabe, wenn Protokolltabelle leer ist.
  IF  it_protocol IS INITIAL.
    FORMAT INTENSIFIED COLOR = 6.
    WRITE: / &apos;All your Selections are not valid!&apos;,
          /  &apos;Please use valid selection criteria!&apos;.
    EXIT.
  ENDIF.

  LOOP AT it_protocol INTO wa_protocol.
    CASE wa_protocol-typus.
      WHEN &apos;L&apos;. &quot;Underline
        ULINE.
      WHEN &apos;S&apos;. &quot;Skip
        SKIP.
      WHEN &apos;U&apos;. &quot;Ueberschrift
        FORMAT COLOR COL_HEADING.
        WRITE: / wa_protocol-filename.
        FORMAT COLOR COL_BACKGROUND.
        ULINE.
      WHEN &apos;N&apos;. &quot;Normaler Eintrag
        WRITE: / wa_protocol-objtype, wa_protocol-objname, text004,
          wa_protocol-filename.
      WHEN &apos;E&apos;. &quot;Fehlerhafter Eintrag
        FORMAT INTENSIFIED COLOR = 6.
        WRITE: / wa_protocol-objtype, wa_protocol-objname, text013,
          wa_protocol-filename.
        FORMAT INTENSIFIED COLOR = 0.
    ENDCASE.
  ENDLOOP.

ENDFORM.                    &quot; output_protocol


*&amp;---------------------------------------------------------------------*
*&amp;      Form  convert_fugrname_for_partner
*&amp;---------------------------------------------------------------------*
*       Der interne Funktionsgruppenname wird für den Partnernamensraum
*       ermittelt.
*----------------------------------------------------------------------*
*      &lt;--P_WA_TADIR_OBJ_NAME  text
*----------------------------------------------------------------------*
FORM convert_fugrname_for_partner CHANGING p_name TYPE any.
  DATA: lcl_include TYPE rs38l-include.
  DATA: lcl_namespace TYPE rs38l-namespace.
  DATA: lcl_without TYPE rs38l-include.


*1. Get Partner name space:
  lcl_include = p_name.

  CALL FUNCTION &apos;RS_PROGNAME_SPLIT&apos;
    EXPORTING
      progname_with_namespace    = lcl_include
    IMPORTING
      namespace                  = lcl_namespace
      progname_without_namespace = lcl_without.
  IF sy-subrc &lt;&gt; 0.
    EXIT.
  ELSE.
    CONCATENATE lcl_namespace &apos;SAPL&apos; lcl_without
          INTO p_name.
  ENDIF.


ENDFORM.                    &quot; convert_fugrname_for_partner

*&amp;---------------------------------------------------------------------*
*&amp;      Form  convert_funcname_for_partner
*&amp;---------------------------------------------------------------------*
*       Der interne Funktionsbausteinname wird für den Partnernamensraum
*       ermittelt. --&gt; Includename
*----------------------------------------------------------------------*
FORM convert_funcname_for_partner USING    p_wa_tfdir TYPE tfdir
                                  CHANGING p_include.
  DATA: lcl_include TYPE rs38l-include.
  DATA: lcl_namespace TYPE rs38l-namespace.
  DATA: lcl_without TYPE rs38l-include.

  lcl_include = p_wa_tfdir-pname.

  CALL FUNCTION &apos;RS_PROGNAME_SPLIT&apos;
    EXPORTING
      progname_with_namespace           = lcl_include
   IMPORTING
     namespace                         =  lcl_namespace
     progname_without_namespace        =  lcl_without
* EXPORTING
             .
  IF sy-subrc &lt;&gt; 0.
    EXIT.
  ELSE.
    CONCATENATE lcl_namespace lcl_without+3 &apos;U&apos; p_wa_tfdir-include
          INTO p_include.
  ENDIF.

ENDFORM.                    &quot; convert_funcname_for_partner


*&amp;---------------------------------------------------------------------*
*&amp;      Form  call_ws_download
*&amp;---------------------------------------------------------------------*
*       Gekapselter Aufruf des Funktionsbausteins
*       zum Download auf das Frontend
*----------------------------------------------------------------------*
FORM call_ws_download USING p_filename  LIKE filename
                            p_table     TYPE any
                      CHANGING p_subrc  TYPE sy-subrc.

  DATA: lcl_filename TYPE string.
  DATA: lcl_progress TYPE string.


* Map input parameters to parameters for function module
  ASSIGN p_table TO &lt;ty_downtab&gt;.
* Conversion for 6.x:
  lcl_filename = p_filename.
* Build text for progress indicator...
  CONCATENATE &apos;Downloading:&apos;  p_filename
      INTO lcl_progress SEPARATED BY space.
*  Explizit call of Progress Indicator.
  CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
    EXPORTING
      text          = lcl_progress
    EXCEPTIONS
      error_message = 98
      OTHERS        = 99.

  IF sy-subrc &lt;&gt; 0.
    CLEAR: sy-subrc.
  ENDIF.

*  Download for 6.x
  CALL FUNCTION &apos;GUI_DOWNLOAD&apos;
    EXPORTING
      filename                = lcl_filename
      filetype                = &apos;ASC&apos;
    IMPORTING
      filelength              = size
    TABLES
      data_tab                = &lt;ty_downtab&gt;
    EXCEPTIONS
      file_write_error        = 1
      no_batch                = 2
      gui_refuse_filetransfer = 3
      invalid_type            = 4
      no_authority            = 5
      unknown_error           = 6
      header_not_allowed      = 7
      separator_not_allowed   = 8
      filesize_not_allowed    = 9
      header_too_long         = 10
      dp_error_create         = 11
      dp_error_send           = 12
      dp_error_write          = 13
      unknown_dp_error        = 14
      access_denied           = 15
      dp_out_of_memory        = 16
      disk_full               = 17
      dp_timeout              = 18
      file_not_found          = 19
      dataprovider_exception  = 20
      control_flush_error     = 21
      OTHERS                  = 22.
  IF sy-subrc = 0.
    p_subrc = sy-subrc.
  ELSE.
    p_subrc = sy-subrc.
  ENDIF.

ENDFORM.                    &quot; call_ws_download
*&amp;---------------------------------------------------------------------*
*&amp;      Form  convert_include_to_xml
*&amp;---------------------------------------------------------------------*
*       Convert an abap-include source to an xml-file
*----------------------------------------------------------------------*
*      &lt;--P_LCL_IT_XML  text
*----------------------------------------------------------------------*
FORM convert_include_to_xml TABLES p_it_xml
                             USING  value(p_include).
  DATA: lcl_wa_xml TYPE tbl2048.
*data: lcl_wa_downtab like line of downtab.
  DATA: lcl_wa_downtab LIKE LINE OF downtab.
  DATA: lcl_split1 LIKE lcl_wa_downtab.
  DATA: lcl_split2 LIKE lcl_split1.
  DATA: lcl_counter TYPE i.
  DATA: lcl_c_counter TYPE string.
  DATA: lcl_modi(1) TYPE c.

*Unerlaubte Zeichen erstzen
  SEARCH p_include FOR &apos;&lt;&apos;.
  IF sy-subrc EQ 0.
    REPLACE &apos;&lt;&apos; WITH &apos;&amp;lt;&apos; INTO  p_include.
  ENDIF.
  SEARCH filename FOR &apos;&gt;&apos;.
  IF sy-subrc EQ 0.
    REPLACE &apos;&gt;&apos; WITH &apos;&amp;gt;&apos; INTO  p_include.
  ENDIF.

*  &lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;
  WRITE &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; ?&gt;&apos; TO lcl_wa_xml.
  APPEND lcl_wa_xml TO p_it_xml.

  APPEND &apos;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;ABAP.xsl&quot;?&gt;&apos; TO
  p_it_xml.

*Report-Tag
  APPEND  &apos;&lt;report&gt;&apos; TO p_it_xml.
*Title-Tag
  IF gv_funcname IS INITIAL.
    CONCATENATE &apos;&lt;title&gt;&apos; p_include &apos;&lt;/title&gt;&apos; INTO lcl_wa_xml.
  ELSE.
* Falls der Funktionsbausteinname gefüllt ist, wird der Name von dort
* abgeleitet.
    CONCATENATE &apos;&lt;title&gt;&apos; gv_funcname &apos;&lt;/title&gt;&apos; INTO lcl_wa_xml.
  ENDIF.
  APPEND lcl_wa_xml TO p_it_xml.

*Description-Tag
*concatenate &apos;&lt;description&gt;&apos; &apos;&lt;&apos; &apos;![CDATA[&apos; into lcl_wa_xml.
*append lcl_wa_xml to p_it_xml.

*Open Code Tag
  APPEND  &apos;&lt;code&gt;&apos; TO p_it_xml.

*Transform ABAP-Code
  LOOP AT downtab INTO lcl_wa_downtab.
    lcl_counter = lcl_counter + 1.
    lcl_c_counter = lcl_counter.

* Switch on for modification
    IF lcl_wa_downtab(2) = &apos;*{&apos;.
      lcl_modi = &apos;X&apos;.
    ENDIF.


* Modificated part
    IF lcl_modi = &apos;X&apos;.
*    Suche nach ]] wegen CDATA - Anweisung
      SEARCH lcl_wa_downtab FOR &apos;]]&apos;.

      IF sy-subrc = 0.

        SPLIT lcl_wa_downtab AT &apos;]]&apos; INTO lcl_split1 lcl_split2.
        CONCATENATE
        &apos;&lt;modi no=&quot;&apos; lcl_c_counter &apos;&quot;&gt;&lt;![CDATA[&apos; lcl_split1 &apos;]&apos; &apos;]&apos; &apos;&gt;&apos;
         &apos;]]&apos;
         &apos;&lt;![CDATA[&apos; lcl_split2 &apos;]&apos; &apos;]&apos; &apos;&gt;&apos;
         INTO lcl_wa_xml.


      ELSE. &quot;keine gefähliche Stelle

        CONCATENATE &apos;&lt;modi no=&quot;&apos; lcl_c_counter &apos;&quot;&gt;&lt;![CDATA[&apos;
            lcl_wa_downtab &apos;]&apos; &apos;]&apos; &apos;&gt;&apos; INTO lcl_wa_xml.
      ENDIF.
*   Close modi tag
      CONCATENATE lcl_wa_xml &apos;&lt;&apos; &apos;/modi&apos; &apos;&gt;&apos;   INTO lcl_wa_xml.
      APPEND lcl_wa_xml TO p_it_xml.

* Kommentare
    ELSEIF lcl_wa_downtab(1) =  &apos;*&apos;.
      CONCATENATE
     &apos;&lt;comment no=&quot;&apos; lcl_c_counter &apos;&quot;&gt;&lt;![CDATA[&apos; lcl_wa_downtab &apos;]&apos; &apos;]&apos;
         &apos;&gt;&apos; &apos;&lt;/comment&gt;&apos; INTO lcl_wa_xml.
      APPEND lcl_wa_xml TO p_it_xml.


* Normal Source code
    ELSE.
*    Open-Source Tag
*    Suche nach ]] wegen CDATA - Anweisung
      SEARCH lcl_wa_downtab FOR &apos;]]&apos;. &quot;&apos;&lt;![CDATA[&apos;.

      IF sy-subrc = 0.

        SPLIT lcl_wa_downtab AT &apos;]]&apos; INTO lcl_split1 lcl_split2.
        CONCATENATE
      &apos;&lt;source no=&quot;&apos; lcl_c_counter &apos;&quot;&gt;&lt;![CDATA[&apos; lcl_split1 &apos;]&apos; &apos;]&apos; &apos;&gt;&apos;
         &apos;]]&apos;
         &apos;&lt;![CDATA[&apos; lcl_split2 &apos;]&apos; &apos;]&apos; &apos;&gt;&apos;
         INTO lcl_wa_xml.


      ELSE. &quot;keine gefähliche Stelle

        CONCATENATE &apos;&lt;source no=&quot;&apos; lcl_c_counter &apos;&quot;&gt;&lt;![CDATA[&apos;
            lcl_wa_downtab &apos;]&apos; &apos;]&apos; &apos;&gt;&apos; INTO lcl_wa_xml.
      ENDIF.

* Close-Source Tag
      CONCATENATE lcl_wa_xml &apos;&lt;&apos; &apos;/source&apos; &apos;&gt;&apos;   INTO lcl_wa_xml.
      APPEND lcl_wa_xml TO p_it_xml.
    ENDIF.

*Switch off for modifications
    IF lcl_wa_downtab(2) = &apos;*}&apos;.
      CLEAR lcl_modi.
    ENDIF.

  ENDLOOP.

*Clodes

  APPEND &apos;&lt;/code&gt;&apos;  TO p_it_xml.
  APPEND  &apos;&lt;/report&gt;&apos; TO p_it_xml.
ENDFORM.                    &quot; convert_include_to_xml
*&amp;---------------------------------------------------------------------*
*&amp;      Form  nav_xml_add_subitem
*&amp;---------------------------------------------------------------------*
*       Einhängen eins Subitems in die Navigationsdatei
*----------------------------------------------------------------------*
FORM nav_xml_add_subitem USING    p_url
                                  p_name
                                  p_target.
*Unerlaubte Zeichen erstzen
  SEARCH p_url FOR &apos;&lt;&apos;.
  IF sy-subrc EQ 0.
    REPLACE &apos;&lt;&apos; WITH &apos;_&apos; INTO  p_url.
  ENDIF.
  SEARCH p_url FOR &apos;&gt;&apos;.
  IF sy-subrc EQ 0.
    REPLACE &apos;&gt;&apos; WITH &apos;_&apos; INTO  p_url.
  ENDIF.

  SEARCH p_name FOR &apos;&lt;&apos;.
  IF sy-subrc EQ 0.
    REPLACE &apos;&lt;&apos; WITH &apos;&amp;lt;&apos; INTO  p_name.
  ENDIF.
  SEARCH p_name FOR &apos;&gt;&apos;.
  IF sy-subrc EQ 0.
    REPLACE &apos;&gt;&apos; WITH &apos;&amp;gt;&apos; INTO  p_name.
  ENDIF.

  IF NOT p_url IS INITIAL.

    APPEND &apos;&lt;subitem&gt;&apos; TO it_html.

    CONCATENATE &apos;&lt;value&gt;&apos; p_name &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;&lt;url&gt;&apos; p_url &apos;&lt;/url&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    CONCATENATE &apos;&lt;target&gt;&apos; p_target &apos;&lt;/target&gt;&apos; INTO wa_html.
    APPEND wa_html TO it_html.

    APPEND &apos;&lt;/subitem&gt;&apos; TO it_html.

  ELSE.
    APPEND &apos;&lt;subitem_no_link&gt;&apos; TO it_html.
    CONCATENATE &apos;&lt;value&gt;&apos; p_name &apos;&lt;/value&gt;&apos; INTO wa_html.
    APPEND &apos;&lt;/subitem_no_link&gt;&apos; TO it_html.

  ENDIF.



ENDFORM.                    &quot; nav_xml_add_subitem
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_xsl_files
*&amp;---------------------------------------------------------------------*
*       This form-routine creates and downloads the static xsl and css
*       Files
*----------------------------------------------------------------------*
FORM create_xsl_files.
  DATA: lcl_line LIKE LINE OF it_html.

***********************
* Create and download ABAP.xsl

*create if empty
  IF it_abap_xsl IS INITIAL.

    APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;xsl:stylesheet language=&quot;JavaScript&quot;&apos;
      &apos;xmlns:xsl=&quot;http://www.w3.org/TR/WD-xsl&quot;&apos;
      &apos;xmlns:HTML=&quot;http://www.w3.org/Profiles/XHTML-transitional&quot;&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_abap_xsl.

    APPEND &apos;&lt;xsl:template&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;xsl:apply-templates/&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;report&quot; &gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;HTML xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&apos;
      &apos;xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;&apos; INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_abap_xsl.

    APPEND &apos;&lt;HEADER&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;title&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/title&gt;&apos; TO
    it_abap_xsl.

    APPEND &apos;&lt;LINK REL=&quot;STYLESHEET&quot; TYPE=&quot;text/css&quot; HREF=&quot;formate.css&quot;/&gt;&apos;
        TO it_abap_xsl.

    APPEND &apos;&lt;XML id=&quot;xmldso&quot;&gt;&lt;/XML&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;XML id=&quot;xsldso&quot;&gt;&lt;/XML&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;SCRIPT&gt;&lt;xsl:comment&gt;&lt;![CDATA[&apos; TO it_abap_xsl.
    APPEND &apos;function switchLineNo(){&apos; TO it_abap_xsl.

    APPEND &apos;xmldso.async = false;&apos; TO it_abap_xsl.
    APPEND  &apos;xsldso.load(&quot;blank.xsl&quot;);&apos; TO it_abap_xsl.
    APPEND  &apos;xmldso.load(document.URL);&apos; TO it_abap_xsl. &quot;DNE_KW11

    CONCATENATE &apos;listing.innerHTML =&apos;
      &apos;xmldso.transformNode(xsldso.cloneNode(true)) ;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_abap_xsl.

    APPEND &apos;}&apos; TO it_abap_xsl.
    APPEND &apos;]]&gt;&lt;/xsl:comment&gt;&lt;/SCRIPT&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;/HEADER&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;BODY&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;div id=&quot;listing&quot;/&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;table summary=&quot;Name&quot; border=&quot;0&quot; width=&quot;100%&quot;&gt;&apos; TO
    it_abap_xsl.
    APPEND &apos;&lt;tr&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;td&gt;&lt;H1&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/H1&gt;&lt;/td&gt;&apos;
        TO it_abap_xsl.
    APPEND &apos;&lt;/tr&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;tr&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;xsl:if test=&quot;description[.$ne$&apos;&apos; &apos;&apos;]&quot;&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;td&gt;&lt;H2&gt;&lt;xsl:value-of select=&quot;description&quot;/&gt;&lt;/H2&gt;&lt;/td&gt;&apos;
      TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:if&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/tr&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/table&gt;&apos; TO it_abap_xsl.

    CONCATENATE &apos;&lt;DIV onClick=&quot;switchLineNo()&quot;&apos;
      &apos;STYLE=&quot;color:#003399;cursor:hand;text-decoration:none;&quot;&gt;[&apos;
      &apos;Blank text to copy in MS-Word ]&lt;/DIV&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;PRE/&gt;&apos; TO it_abap_xsl.

    APPEND
    &apos;&lt;TABLE border=&quot;1&quot; width=&quot;100%&quot; cellspacing=&quot;1&quot; rules=&quot;cols&quot;&gt;&apos;
      TO it_abap_xsl.
    APPEND &apos;&lt;COLGROUP&gt;&lt;COL WIDTH=&quot;30&quot;/&gt;&lt;COL WIDTH=&quot;*&quot;/&gt;&lt;/COLGROUP&gt;&apos;
       TO it_abap_xsl.
    APPEND &apos;&lt;xsl:apply-templates select=&quot;code&quot;/&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/TABLE&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/BODY&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/HTML&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;code&quot;&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;xsl:apply-templates select=&quot;comment|source|modi&quot; /&gt;&apos;
      TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_abap_xsl.


    APPEND &apos;&lt;xsl:template match=&quot;comment&quot;&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;TR&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;TH class=&quot;source&quot;&apos;
      &apos;align=&quot;right&quot;&gt;&lt;xsl:value-of select=&quot;@no&quot;/&gt;&lt;/TH&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;TD class=&quot;source&quot;&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;nobr&gt;&lt;pre class=&quot;code&quot;/&gt;&lt;FONT&apos;
      &apos;color=&quot;green&quot;&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/FONT&gt;&lt;/nobr&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;/TD&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/TR&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;source&quot;&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;TR&gt;&apos; TO  it_abap_xsl.
    CONCATENATE &apos;&lt;TH class=&quot;source&quot;&apos;
      &apos;align=&quot;right&quot;&gt;&lt;xsl:value-of select=&quot;@no&quot;/&gt;&lt;/TH&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;TD class=&quot;source&quot;&gt;&lt;nobr&gt;&lt;pre class=&quot;code&quot;/&gt;&apos; TO it_abap_xsl
    ..
    APPEND &apos;&lt;xsl:choose&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;xsl:when test=&quot;anker&quot;&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;a&gt;&lt;xsl:attribute name=&quot;name&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;anker&quot;/&gt;&apos;
      &apos;&lt;/xsl:attribute&gt;&lt;xsl:value-of select=&quot;abap&quot;/&gt;&lt;/a&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:when&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;xsl:when test=&quot;abap|call_function|perform|include&quot;&gt;&apos;
      &apos;&lt;xsl:apply-templates /&gt;&lt;/xsl:when&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;xsl:otherwise&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/xsl:otherwise&gt;&apos;
      TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:choose&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/nobr&gt;&lt;/TD&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/TR&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;modi&quot;&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;TR&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;TH class=&quot;modi&quot; align=&quot;right&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;@no&quot;/&gt;&lt;/TH&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_abap_xsl.
    CONCATENATE &apos;&lt;TD class=&quot;modi&quot;&gt;&lt;nobr&gt;&lt;pre class=&quot;code&quot;/&gt;&apos;
      &apos;&lt;FONT color=&quot;red&quot;&gt;&lt;xsl:choose&gt;&apos;
     INTO lcl_line.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;xsl:when test=&quot;anker&quot;&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;a&gt;&lt;xsl:attribute name=&quot;name&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;anker&quot;/&gt;&lt;/xsl:attribute&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;abap&quot;/&gt;&lt;/a&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:when&gt;&apos; TO it_abap_xsl.
    CONCATENATE &apos;&lt;xsl:when test=&quot;abap|call_function|perform|include&quot;&gt;&apos;
      &apos;&lt;xsl:apply-templates /&gt;&lt;/xsl:when&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_abap_xsl.
    APPEND &apos;&lt;xsl:otherwise&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/xsl:otherwise&gt;&apos;
      TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:choose&gt;&lt;/FONT&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/nobr&gt;&lt;/TD&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/TR&gt;&apos; TO it_abap_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_abap_xsl.

    APPEND &apos;&lt;/xsl:stylesheet&gt;&apos; TO it_abap_xsl.

  ENDIF.

*Download der Tabelle
  PERFORM download_html_file USING &apos;1&apos;.

***********************


***********************
* Create and download nav.xsl
  IF it_nav_xsl IS INITIAL.

    APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&apos; TO it_nav_xsl.
*    CONCATENATE &apos;&lt;xsl:stylesheet language=&quot;JavaScript&quot;&apos;
*      &apos;xmlns:xsl=&quot;http://www.w3.org/TR/WD-xsl&quot;&apos;
    CONCATENATE &apos;&lt;xsl:stylesheet  version=&quot;1.0&quot;&apos;
                &apos;xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&apos;
      &apos;xmlns:HTML=&quot;http://www.w3.org/Profiles/XHTML-transitional&quot;&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_nav_xsl.
    APPEND &apos;&lt;xsl:template match=&quot;/&quot;&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:apply-templates/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_nav_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;Nav&quot;&gt;&apos; TO it_nav_xsl.
    APPEND
  &apos;&lt;HTML xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;&apos;
     TO it_nav_xsl.
    APPEND &apos;&lt;LINK REL=&quot;STYLESHEET&quot; TYPE=&quot;text/css&quot; HREF=&quot;formate.css&quot;/&gt;&apos;
      TO it_nav_xsl.
    APPEND &apos;&lt;H3 align=&quot;center&quot;&gt;&lt;i&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;header&quot;/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/i&gt;&lt;/H3&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;item&quot;&gt;&apos; TO it_nav_xsl.
    APPEND
    &apos;&lt;xsl:sort select=&quot;order&quot; order=&quot;ascending&quot; data-type=&quot;number&quot; /&gt;&apos;
          TO it_nav_xsl.
    APPEND &apos;&lt;h4&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;value&quot;/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/h4&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;ul&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;subitem&quot;&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;a&gt;&apos; TO it_nav_xsl.
    CONCATENATE &apos;&lt;xsl:attribute name=&quot;HREF&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;url&quot;/&gt;&lt;/xsl:attribute&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_nav_xsl.
    CONCATENATE &apos;&lt;xsl:attribute name=&quot;target&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;target&quot;/&gt;&lt;/xsl:attribute&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_nav_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;value&quot;/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/a&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;subitem_no_link&quot;&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;value&quot;/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/ul&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;item_linked&quot;&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;h4&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;a&gt;&apos; TO it_nav_xsl.
    CONCATENATE &apos;&lt;xsl:attribute name=&quot;HREF&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;url&quot;/&gt;&lt;/xsl:attribute&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_nav_xsl.
    CONCATENATE &apos;&lt;xsl:attribute name=&quot;target&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;target&quot;/&gt;&lt;/xsl:attribute&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_nav_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;value&quot;/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/a&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/h4&gt;&apos; TO  it_nav_xsl.
    APPEND &apos;&lt;ul&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;subitem&quot;&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;a&gt;&apos; TO it_nav_xsl.

    CONCATENATE &apos;&lt;xsl:attribute name=&quot;HREF&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;url&quot;/&gt;&lt;/xsl:attribute&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_nav_xsl.
    CONCATENATE &apos;&lt;xsl:attribute name=&quot;target&quot;&gt;&apos;
      &apos;&lt;xsl:value-of select=&quot;target&quot;/&gt;&lt;/xsl:attribute&gt;&apos;
      INTO lcl_line.
    APPEND lcl_line TO it_nav_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;value&quot;/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/a&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;subitem_no_link&quot;&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;value&quot;/&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/li&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/ul&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/HTML&gt;&apos; TO it_nav_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_nav_xsl.
    APPEND  &apos;&lt;/xsl:stylesheet&gt;&apos; TO it_nav_xsl.
  ENDIF.

*Download der Tabelle
  PERFORM download_html_file USING &apos;2&apos;.

**********************

***********************
* Create and download table.xsl
  IF it_table_xsl IS INITIAL.

    APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&apos; TO it_table_xsl
    .
    CONCATENATE &apos;&lt;xsl:stylesheet language=&quot;JavaScript&quot;&apos;
      &apos;xmlns:xsl=&quot;http://www.w3.org/TR/WD-xsl&quot;&apos;
      &apos;xmlns:HTML=&quot;http://www.w3.org/Profiles/XHTML-transitional&quot;&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_table_xsl.
    APPEND &apos;&lt;xsl:template&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;xsl:apply-templates/&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_table_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;Tabelle&quot;&gt;&apos; TO it_table_xsl.
    APPEND
  &apos;&lt;HTML xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;&apos;
     TO it_table_xsl.
    APPEND &apos;&lt;LINK REL=&quot;STYLESHEET&quot; TYPE=&quot;text/css&quot; HREF=&quot;formate.css&quot;/&gt;&apos;
      TO it_table_xsl.
    APPEND &apos;&lt;head&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;title&gt;&lt;xsl:value-of select=&quot;header&quot;/&gt;&lt;/title&gt;&apos;
      TO it_table_xsl.
    APPEND &apos;&lt;/head&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;body&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;h1&gt;&lt;xsl:value-of select=&quot;header&quot;/&gt;&lt;/h1&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;h2&gt;&lt;xsl:value-of select=&quot;short&quot;/&gt;&lt;/h2&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;br&gt;&lt;/br&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;table border=&quot;0&quot;&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;tab_header&quot;&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;tr&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;value&quot;&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;th&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;.&quot;/&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/th&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/tr&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;item&quot;&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;TBODY style=&quot;background-color: #fafad2;&quot;/&gt;&apos; TO it_table_xsl
    .
    APPEND &apos;&lt;tr&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;xsl:for-each select=&quot;value&quot;&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;td&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;xsl:value-of select=&quot;.&quot;/&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/td&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/tr&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/xsl:for-each&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/table&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/body&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/HTML&gt;&apos; TO it_table_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_table_xsl.

    APPEND &apos;&lt;/xsl:stylesheet&gt;&apos; TO it_table_xsl.

  ENDIF.
*Download der Tabelle
  PERFORM download_html_file USING &apos;3&apos;.

***********************

***********************
* Create and download formate.css
  IF it_formate_css IS INITIAL.

    APPEND &apos;thead { background-color:#EEEEEE; }&apos; TO it_formate_css.
    APPEND &apos;th { text-align: left; background-color:#EEEEEE; }&apos;
      TO it_formate_css.
    APPEND &apos;th.source { text-align: right; background-color:#EEEEEE; }&apos;
      TO it_formate_css.
    APPEND &apos;th.modi { text-align: right; background-color:#EEEEEE; }&apos;
      TO it_formate_css.
    APPEND &apos;th.center { text-align: center }&apos; TO it_formate_css.

    APPEND &apos;tbody.content { background-color:#FFFFE0; }&apos;
      TO it_formate_css.
    APPEND &apos;td.text { font-family:Arial,sans-serif; background-color:&apos; &amp;
      &apos;#FFFFFF; }&apos; TO it_formate_css.
    APPEND
    &apos;td.content { background-color:#FFFFE0; vertical-align: top; }&apos;
      TO it_formate_css.
    APPEND
    &apos;td.centerContent { background-color:#FFFFE0; vertical-align: &apos;
   &amp;
      &apos;top; align: center}&apos; TO it_formate_css.

    APPEND &apos;tr.zwisu { background-color:#EEEEEA; }&apos; TO it_formate_css.
    APPEND &apos;tr.highlight { background-color:#CCFFCC; }&apos; TO
    it_formate_css.
    APPEND
  &apos;DIV.clTopMenu{position:absolute; width:150px; height:150px; clip:&apos; &amp;
     &apos;rect(0px,150px,18px,0px); visibility:hidden; z-index:31; &apos; &amp;
     &apos;layer-background-color:#EEEEEE; background-color:#EEEEEE}&apos;
     TO it_formate_css.
    APPEND
     &apos;DIV.clTopMenuBottom{position:absolute; width:150px; &apos; &amp;
     &apos;height:3px; clip:rect(0px,150px,3px,0px); top:11px; &apos; &amp;
     &apos;layer-background-color:#CECFCE; background-color:#CECFCE; &apos; &amp;
     &apos;z-index:2}&apos;
     TO it_formate_css.
    APPEND
     &apos;DIV.clTopMenuText{position:absolute; width:140px; left:5px; &apos; &amp;
     &apos;top:20px; font-family:arial,helvetica; font-size:11px;&apos; &amp;
     &apos;background-color:#EEEEEE; z-index:1} &apos;
      TO it_formate_css.
    APPEND
      &apos;DIV.clTopSelect{position:absolute; width:250px; &apos; &amp;
      &apos;visibility:hidden; }&apos;
      TO it_formate_css.

    APPEND &apos;DIV.clHidden{visibility:hidden;}&apos; TO it_formate_css.
    APPEND &apos;DIV.clVisible{ position:absolute; top:50px; &apos; &amp;
      &apos;left:10px; visibility:visible;}&apos;
      TO it_formate_css.

    APPEND
      &apos;#divLoadCont{position:absolute; width:100%; height:100%; &apos; &amp;
      &apos;top:0px; left:0px; background-color:white; &apos; &amp;
      &apos;layer-background-color:white; font-family:arial,helvetica; &apos; &amp;
      &apos;z-index:100}&apos;
      TO it_formate_css.

    APPEND &apos;body { margin-top:10px; margin-bottom:10px; }&apos;
      TO it_formate_css.

    APPEND
      &apos;p, h1, h2, h3, h4, ul, ol, li, div, td, th, address, &apos; &amp;
      &apos;blockquote, nobr, b, i&apos;
      TO it_formate_css.

    APPEND &apos;{ font-family:Arial,sans-serif; }&apos; TO it_formate_css.
    APPEND &apos;h1 { font-size:18pt; }&apos; TO it_formate_css.
    APPEND &apos;h2 { font-size:16pt; }&apos; TO it_formate_css.
    APPEND &apos;h2.sh2 { font-size:16pt; }&apos; TO it_formate_css.
    APPEND &apos;h3, h3.xmp, h3.xpl, h3.inf, h3.tip &apos; &amp;
      &apos;{ font-size:12pt; }&apos;
      TO it_formate_css.

    APPEND &apos;h4 { font-size:10pt; }&apos; TO it_formate_css.
    APPEND &apos;p, ul, ol, li, div, td, th, address, nobr, b, i &apos; &amp;
      &apos;{ font-size:10pt; }&apos;
      TO it_formate_css.

    APPEND &apos;pre { font-family:&quot;Courier New,Courier&quot;; font-size:10pt; &apos; &amp;
      &apos;color:#0000C0; }&apos;
      TO it_formate_css.

    APPEND &apos;tt { font-family:Courier New,Courier; &apos; &amp;
      &apos;font-size:10pt; color:#0000C0; }&apos;
      TO it_formate_css.

    APPEND &apos;td.xmpcode { border-width:1pt; border-style:solid; &apos; &amp;
      &apos;border-color:#999999; background-color:#FFFFE0; }&apos;
      TO it_formate_css.

    APPEND &apos;td.source { font-family:&quot;Courier New,Courier&quot;; &apos; &amp;
      &apos;font-size:10pt; background-color:#FFFFE0; &apos; &amp;
      &apos;padding-left:2mm}&apos;
      TO it_formate_css.

    APPEND &apos;td.modi { font-family:&quot;Courier New,Courier&quot;; &apos; &amp;
      &apos;font-size:10pt; color:&quot;red&quot; background-color:#FFFFE0; &apos; &amp;
      &apos;padding-left:2mm}&apos;
      TO it_formate_css.

    APPEND &apos;.code { background-color:#FFFFE0; }&apos; TO it_formate_css.

    APPEND &apos;td.xplcode { background-color:#EEEEFF; }&apos; TO it_formate_css.
    APPEND &apos;.doc { background-color:#EEEEEE; }&apos; TO it_formate_css.

    APPEND &apos;.qbar { background-color:#FFFFE0; font-size:9pt; &apos; &amp;
      &apos;font-family:Arial,sans-serif; }&apos;
      TO it_formate_css.

    APPEND &apos;pre.normal { color:#000000; }&apos; TO it_formate_css.


    APPEND &apos;a:link { color:#000066; text-decoration:none; }&apos;
      TO it_formate_css.
    APPEND &apos;a:visited { color:#002266; text-decoration:none; }&apos;
      TO it_formate_css.
    APPEND &apos;a:active { color:#red; text-decoration:none; }&apos;
      TO it_formate_css.
    APPEND  &apos;a:hover {color:red; text-decoration:none }&apos;
      TO it_formate_css.

    APPEND &apos;a.an { text-decoration:none; }&apos; TO it_formate_css.

    APPEND &apos;.ColumnLabel {font-weight:bold}&apos; TO it_formate_css.

  ENDIF.

*Download der Tabelle
  PERFORM download_html_file USING &apos;4&apos;.

***********************


***********************
* Create and download blank.xsl
  IF it_blank_xsl IS INITIAL.

    APPEND &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&apos; TO it_blank_xsl
    .
    CONCATENATE &apos;&lt;xsl:stylesheet language=&quot;JavaScript&quot;&apos;
      &apos;xmlns:xsl=&quot;http://www.w3.org/TR/WD-xsl&quot;&apos;
      &apos;xmlns:HTML=&quot;http://www.w3.org/Profiles/XHTML-transitional&quot;&gt;&apos;
      INTO lcl_line SEPARATED BY space.
    APPEND lcl_line TO it_blank_xsl.

    APPEND &apos;&lt;xsl:template&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;xsl:apply-templates/&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_blank_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;report&quot; &gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;HTML xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &apos; &amp;
      &apos;xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;&apos;
      TO it_blank_xsl.

    APPEND &apos;&lt;HEADER&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;title&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/title&gt;&apos;
      TO it_blank_xsl.
    APPEND &apos;&lt;LINK REL=&quot;STYLESHEET&quot; TYPE=&quot;text/css&quot; HREF=&quot;formate.css&quot;/&gt;&apos;
      TO it_blank_xsl.

    APPEND &apos;&lt;SCRIPT&gt;&lt;xsl:comment&gt;&lt;![CDATA[&apos; TO it_blank_xsl.
    APPEND &apos;function switchLineNo(){&apos; TO it_blank_xsl.
    APPEND &apos;open(document.title+&quot;.xml&quot;);&apos; TO it_blank_xsl.
    APPEND &apos;}&apos; TO it_blank_xsl.
    APPEND &apos;]]&gt;&lt;/xsl:comment&gt;&lt;/SCRIPT&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;/HEADER&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;BODY&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;a href=&quot;javascript:open(document.title+&apos;&apos;.xml&apos;&apos;,&apos; &amp;
      &apos;&apos;&apos;_self&apos;&apos;)&quot; STYLE=&quot;color:#003399;cursor:hand;text-decoration:&apos; &amp;
        &apos;none;&quot;&gt;&apos; &amp;
        &apos;[ Formatted text with line numbers ]&lt;/a&gt;&apos;
       TO it_blank_xsl.
    APPEND &apos;&lt;xsl:apply-templates select=&quot;code&quot;/&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;/BODY&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;/HTML&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;xsl:template match=&quot;code&quot;&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;xsl:apply-templates select=&quot;comment|source|modi&quot; /&gt;&apos;
      TO it_blank_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;xsl:template match=&quot;comment&quot;&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;nobr&gt;&lt;pre&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/pre&gt;&lt;/nobr&gt;&apos;
      TO it_blank_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_blank_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;source&quot;&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;nobr&gt;&lt;pre&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/pre&gt;&lt;/nobr&gt;&apos;
        TO it_blank_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_blank_xsl.

    APPEND &apos;&lt;xsl:template match=&quot;modi&quot;&gt;&apos; TO it_blank_xsl.
    APPEND &apos;&lt;nobr&gt;&lt;pre&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;/pre&gt;&lt;/nobr&gt;&apos;
      TO it_blank_xsl.
    APPEND &apos;&lt;/xsl:template&gt;&apos; TO it_blank_xsl.

    APPEND &apos;&lt;/xsl:stylesheet&gt;&apos; TO it_blank_xsl.

  ENDIF.
*Download der Tabelle
  PERFORM download_html_file USING &apos;5&apos;.

***********************

ENDFORM.                    &quot; create_xsl_files
*&amp;---------------------------------------------------------------------*
*&amp;      Form  iac_service
*&amp;---------------------------------------------------------------------*
FORM iac_service .

  DATA: lcl_it_iacs TYPE STANDARD TABLE OF iachtml-service,
        lcl_wa_iacs LIKE LINE OF lcl_it_iacs.

*Aktive Kundenerweiterungprojekte aus modattr waehlen
  SELECT service FROM iacservice INTO TABLE lcl_it_iacs
          WHERE service IN o_iacs.

*Verlassen,wenn keine Werte gefunden worden sind
  IF lcl_it_iacs IS INITIAL.
    MESSAGE i888(sabapdocu) WITH
   &apos;No suitable selection&apos; &apos;for IAC-Service(ITS)! &apos;
   &apos;Please check your selection. &apos;
   &apos;The program will process your other selections.&apos;.

*Form-Routine verlassen
    EXIT.
  ENDIF.

  LOOP AT lcl_it_iacs INTO lcl_wa_iacs.

    PERFORM handle_iac_service USING lcl_wa_iacs.

*Stueckliste fuer logische Entwicklung
    IF NOT ( p_logic IS INITIAL ).
      PERFORM write_log_stueckliste USING   &apos;IACS&apos;
                                            lcl_wa_iacs
                                            p_logic.

    ENDIF.

  ENDLOOP.


ENDFORM.                    &quot; iac_service
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_iac_service
*&amp;---------------------------------------------------------------------*
FORM handle_iac_service  USING p_iacs TYPE c.

  DATA:
        lcl_it_dir_table  TYPE filetable,
        lcl_dir           LIKE LINE OF lcl_it_dir_table,
        lv_count          TYPE i,
        lcl_w3path        TYPE w3path,
        lcl_path          TYPE string,
        lcl_tmp_path      TYPE string,
        lcl_service       TYPE itsappl.



*global_main_name fuer globalen Gebrauch aufbereiten
*--&gt;Parametrisierung umgangen
*Globalen Namen setzen
  global_main_name = p_iacs.

*Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING p_iacs
                            &apos;S&apos;.
*Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

*Ueberschrift zusammenbauen
  CONCATENATE &apos;IAC-Service(ITS):&apos; global_main_name INTO header
        SEPARATED BY space.

*Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************
*Intitialisieren der globalen Tabellen
  PERFORM initialize.

*Stueckliste fuer allgemeine IAC-SERVICE
  PERFORM write_stueckliste USING &apos;IACS&apos;
                                  p_iacs
                                  &apos;&apos;.
********************************************
* Now we can download the whole service
  lcl_w3path = new_dir.
  lcl_service = p_iacs.
* Publish Service
  CALL FUNCTION &apos;W3_PUBLISH_SERVICE_LOCAL&apos;
    EXPORTING
      p_service          = lcl_service
      p_path             = lcl_w3path
    EXCEPTIONS
      object_not_found   = 1
      permission_failure = 2
      data_invalid       = 3
      action_cancelled   = 4
      no_publishing_path = 5
      wrong_or_no_gui    = 6
      error_occured      = 7
      OTHERS             = 8.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    EXIT.
  ENDIF.

* get all subirectories
  CALL METHOD cl_gui_frontend_services=&gt;directory_list_files
    EXPORTING
      directory                   = new_dir
      directories_only            = &apos;X&apos;
    CHANGING
      file_table                  = lcl_it_dir_table
      count                       = lv_count
    EXCEPTIONS
      cntl_error                  = 1
      directory_list_files_failed = 2
      wrong_parameter             = 3
      error_no_gui                = 4
      not_supported_by_gui        = 5
      OTHERS                      = 6.
  IF sy-subrc &lt;&gt; 0.
    EXIT.
  ENDIF.

  LOOP AT lcl_it_dir_table INTO lcl_dir.

    CONCATENATE new_dir &apos;\&apos; lcl_dir INTO lcl_tmp_path.

    PERFORM iac_check_rename_files USING lcl_tmp_path.


  ENDLOOP.

*********************************************
*End working on this item

**Gesamtstückliste:
  PERFORM download_stueckliste.

*Hotpackagestand sichern
  PERFORM download_hpstand.

*Leerzeile nach Ende dieser Verarbeitung
*        skip.
  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

ENDFORM.                    &quot; handle_iac_service
*&amp;---------------------------------------------------------------------*
*&amp;      Form  iac_check_rename_files
*&amp;---------------------------------------------------------------------*

FORM iac_check_rename_files  USING p_path TYPE string.
  DATA: lcl_path          TYPE string,
        lcl_it_dir        TYPE filetable,
        lcl_dir           LIKE LINE OF lcl_it_dir,
        lcl_it_file_table TYPE filetable,
        lcl_count         TYPE i.

* check whether there are some files
  CALL METHOD cl_gui_frontend_services=&gt;directory_list_files
    EXPORTING
      directory                   = p_path
      files_only                  = &apos;X&apos;
    CHANGING
      file_table                  = lcl_it_file_table
      count                       = lcl_count
    EXCEPTIONS
      cntl_error                  = 1
      directory_list_files_failed = 2
      wrong_parameter             = 3
      error_no_gui                = 4
      not_supported_by_gui        = 5
      OTHERS                      = 6.
  IF lcl_count = 0.

    CALL METHOD cl_gui_frontend_services=&gt;directory_list_files
      EXPORTING
        directory                   = p_path
        directories_only            = &apos;X&apos;
      CHANGING
        file_table                  = lcl_it_dir
        count                       = lcl_count
      EXCEPTIONS
        cntl_error                  = 1
        directory_list_files_failed = 2
        wrong_parameter             = 3
        error_no_gui                = 4
        not_supported_by_gui        = 5
        OTHERS                      = 6.
    IF sy-subrc &lt;&gt; 0.
      EXIT.

    ELSE.
      LOOP AT lcl_it_dir INTO lcl_dir.

        CONCATENATE p_path &apos;\&apos; lcl_dir INTO lcl_path.

        PERFORM iac_check_rename_files USING lcl_path.


      ENDLOOP.

    ENDIF.

  ELSE.

    PERFORM iac_do_renaming USING lcl_it_file_table
                                  p_path.

  ENDIF.


ENDFORM.                    &quot; iac_check_rename_files
*&amp;---------------------------------------------------------------------*
*&amp;      Form  iac_do_renaming
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LT_FILE_TABLE_FORM  text
*----------------------------------------------------------------------*
FORM iac_do_renaming  USING    pt_filetable TYPE filetable
                               p_path       TYPE string.

  DATA:
        lcl_file       LIKE LINE OF pt_filetable,
        lcl_source     TYPE string,
        lcl_dest       TYPE string,
        lcl_rc         TYPE i.


  LOOP AT pt_filetable INTO lcl_file.

    CONCATENATE p_path &apos;\&apos; lcl_file INTO lcl_source.
    CONCATENATE p_path &apos;\&apos; lcl_file INTO lcl_dest.
    REPLACE &apos;.html&apos; WITH &apos;.txt&apos; INTO lcl_dest.
    IF sy-subrc NE 0.
      REPLACE &apos;.htrc&apos; WITH &apos;.txt&apos; INTO lcl_dest.
      IF sy-subrc NE 0.
        REPLACE &apos;.srvc&apos; WITH &apos;.txt&apos; INTO lcl_dest.
        IF sy-subrc NE 0.
          CONTINUE.
        ENDIF.
      ENDIF.
    ENDIF.

    CALL METHOD cl_gui_frontend_services=&gt;file_copy
      EXPORTING
        SOURCE               = lcl_source
        DESTINATION          = lcl_dest
        overwrite            = &apos;X&apos;
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        wrong_parameter      = 3
        disk_full            = 4
        access_denied        = 5
        file_not_found       = 6
        destination_exists   = 7
        unknown_error        = 8
        path_not_found       = 9
        disk_write_protect   = 10
        drive_not_ready      = 11
        not_supported_by_gui = 12
        OTHERS               = 13.
    IF sy-subrc &lt;&gt; 0.
      CONTINUE.
    ENDIF.

    CALL METHOD cl_gui_frontend_services=&gt;file_delete
      EXPORTING
        filename             = lcl_source
      CHANGING
        rc                   = lcl_rc
      EXCEPTIONS
        file_delete_failed   = 1
        cntl_error           = 2
        error_no_gui         = 3
        file_not_found       = 4
        access_denied        = 5
        unknown_error        = 6
        not_supported_by_gui = 7
        wrong_parameter      = 8
        OTHERS               = 9.
    IF sy-subrc &lt;&gt; 0.
      CONTINUE.
    ENDIF.

  ENDLOOP.


ENDFORM.                    &quot; iac_do_renaming
*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_html_for_iacs
*&amp;---------------------------------------------------------------------*
FORM create_html_for_iacs .

*Arbeitsbereich fuer Stuecklisten
  DATA: lcl_wa_prog_stueckliste TYPE prog_stueckliste.
* Variables for subitem-generation
  DATA: lcl_url LIKE wa_html,
        lcl_name LIKE wa_html.

  READ TABLE it_prog_stueckliste INDEX 1 INTO
    lcl_wa_prog_stueckliste.

* Create the item with the subitem
  APPEND &apos;&lt;item&gt;&apos; TO it_html.
  CONCATENATE &apos;&lt;value&gt;IAC-Service(ITS):&apos;
      lcl_wa_prog_stueckliste-name &apos;&lt;/value&gt;&apos;
      INTO wa_html SEPARATED BY space.
  APPEND wa_html TO it_html.

  CONCATENATE &apos;&lt;order&gt;&apos; g_order_iasp &apos;&lt;/order&gt;&apos; INTO wa_html.
  APPEND wa_html TO it_html.

  IF p_trkorr IS INITIAL AND p_devc IS INITIAL.
    MOVE &apos;./&apos; TO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.
  ELSE.
    MOVE &apos;./&apos; TO lcl_url.

    lcl_name = lcl_wa_prog_stueckliste-name.
  ENDIF.



  PERFORM nav_xml_add_subitem USING lcl_url
                                    lcl_name
                                    c_target_new.

  APPEND &apos;&lt;/item&gt;&apos; TO it_html.
ENDFORM.                    &quot; create_html_for_iacs
*&amp;---------------------------------------------------------------------*
*&amp;      Form  download_iac_template
*&amp;---------------------------------------------------------------------*
FORM download_iac_template  USING    p_temp_id TYPE c
                                     p_dir     TYPE string.

  DATA:
    lcl_o_service_ref  TYPE REF TO if_w3_api_service,
    lcl_o_template_ref TYPE REF TO if_w3_api_template,
    lcl_wa_template    TYPE iacikeyt,
    lcl_it_dir_table   TYPE filetable,
    lcl_dir            LIKE LINE OF lcl_it_dir_table,
    lcl_tmp_path       TYPE string,
    lcl_count          TYPE i,
    lcl_w3path         TYPE w3path.

  lcl_wa_template-service = p_temp_id(14).
  lcl_wa_template-theme = p_temp_id+14(2).
  lcl_wa_template-dynpro = p_temp_id+16(4).
  lcl_wa_template-modulpool = p_temp_id+20.

  lcl_w3path = p_dir.

* load service
  CALL METHOD cl_w3_api_factory=&gt;load_service
    EXPORTING
      p_service_name      = lcl_wa_template-service
    IMPORTING
      p_service           = lcl_o_service_ref
    EXCEPTIONS
      object_not_existing = 1
      permission_failure  = 2
      error_occured       = 3.


* get template
  CALL METHOD cl_w3_api_factory=&gt;load_template
    EXPORTING
      p_template_name     = lcl_wa_template
    IMPORTING
      p_template          = lcl_o_template_ref
    EXCEPTIONS
      object_not_existing = 1
      permission_failure  = 2
      error_occured       = 3.

  CALL METHOD lcl_o_template_ref-&gt;if_w3_api_object~publish_local
    EXPORTING
      p_path           = lcl_w3path
    EXCEPTIONS
      object_invalid   = 1
      object_changed   = 2
      action_cancelled = 3
      error_occured    = 4
      name_too_long    = 5.
  IF sy-subrc &lt;&gt; 0.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;E&apos; &apos;IAC-Template&apos;
                                 p_temp_id lcl_w3path.

  ELSE.
*Protokollliste schreiben.
    PERFORM write_protocol USING &apos;N&apos;  &apos;IAC-Template&apos;
                                 p_temp_id lcl_w3path.
  ENDIF.


* get all subirectories
  CALL METHOD cl_gui_frontend_services=&gt;directory_list_files
    EXPORTING
      directory                   = p_dir
      directories_only            = &apos;X&apos;
    CHANGING
      file_table                  = lcl_it_dir_table
      count                       = lcl_count
    EXCEPTIONS
      cntl_error                  = 1
      directory_list_files_failed = 2
      wrong_parameter             = 3
      error_no_gui                = 4
      not_supported_by_gui        = 5
      OTHERS                      = 6.
  IF sy-subrc &lt;&gt; 0.
    EXIT.
  ENDIF.

  LOOP AT lcl_it_dir_table INTO lcl_dir.

    CONCATENATE p_dir &apos;\&apos; lcl_dir INTO lcl_tmp_path.

    PERFORM iac_check_rename_files USING lcl_tmp_path.


  ENDLOOP.

ENDFORM.                    &quot; download_iac_template
*&amp;---------------------------------------------------------------------*
*&amp;      Form  rs_program_index
*&amp;---------------------------------------------------------------------*
*       this replaces function module RS_PROGRAM_INDEX for 6.X
*       Mainly copied from cl_wb_crossreference=&gt;program_index
*----------------------------------------------------------------------*
FORM rs_program_index  USING    p_name
                       CHANGING pt_cross TYPE ANY TABLE.

  DATA: lcl_it_include_tab TYPE programt,
        lcl_wa_include_tab LIKE LINE OF lcl_it_include_tab,
        lcl_with_reserved_includes  TYPE char1,
        lcl_it_cross       TYPE STANDARD TABLE OF cross.

  IF p_name+30(1) NE space.
    lcl_with_reserved_includes = &apos;X&apos;.
  ENDIF.

  CALL FUNCTION &apos;RS_GET_ALL_INCLUDES&apos;
    EXPORTING
      program                = p_name
      with_inactive_incls    = &apos;X&apos;
      with_reserved_includes = lcl_with_reserved_includes
    TABLES
      includetab             = lcl_it_include_tab
    EXCEPTIONS
      OTHERS                 = 3.

  IF sy-subrc NE 0.
    EXIT.
  ENDIF.

* Consider also the main include
  lcl_wa_include_tab = p_name.
  APPEND lcl_wa_include_tab TO lcl_it_include_tab.
  SORT lcl_it_include_tab.
  DELETE ADJACENT DUPLICATES FROM lcl_it_include_tab
    COMPARING ALL FIELDS.
  LOOP AT lcl_it_include_tab INTO lcl_wa_include_tab.

    SELECT * FROM  cross APPENDING TABLE pt_cross
                   WHERE include = lcl_wa_include_tab.

  ENDLOOP.


ENDFORM.                    &quot; rs_program_index
*&amp;---------------------------------------------------------------------*
*&amp;      Form  handle_single_limu
*&amp;---------------------------------------------------------------------*
*       Bearbeitet die einzeln selektierten Einzelobjekte
*----------------------------------------------------------------------*
FORM handle_single_limu .

  DATA: lcl_it_include  TYPE STANDARD TABLE OF d010inc,
        lcl_wa_include   LIKE LINE OF lcl_it_include,
        lcl_it_tfdir     TYPE STANDARD TABLE OF tfdir,
        lcl_wa_tfdir     LIKE LINE OF lcl_it_tfdir,
        lcl_include      LIKE c_includename,
        lcl_it_dd02l     TYPE STANDARD TABLE OF dd02l,
        lcl_wa_dd02l     TYPE dd02l,
        lcl_it_dd40vv    TYPE STANDARD TABLE OF dd40vv,
        lcl_wa_dd40vv    LIKE LINE OF lcl_it_dd40vv,
        lcl_it_tadir     TYPE STANDARD TABLE OF tadir,
        lcl_wa_tadir     LIKE LINE OF lcl_it_tadir,
        lcl_it_info_dtel TYPE STANDARD TABLE OF info_dtel,
        lcl_wa_info_dtel TYPE info_dtel,
        lcl_it_info_doma TYPE STANDARD TABLE OF info_doma,
        lcl_wa_info_doma TYPE info_doma,
        lcl_it_dd07v     TYPE STANDARD TABLE OF dd07v,
        lcl_wa_dd07v     LIKE LINE OF lcl_it_dd07v,
        lcl_it_dd25l     TYPE STANDARD TABLE OF dd25l,
        lcl_wa_dd25l     TYPE dd25l,
        lcl_wa_cross     TYPE cross,
        lcl_it_info_suso TYPE STANDARD TABLE OF info_suso,
        lcl_wa_info_suso TYPE info_suso,
***********************************************************************
*Addition of code for search help.
***********************************************************************
        lcl_it_dd30l    TYPE STANDARD TABLE OF dd30l,
        lcl_wa_dd30l    LIKE LINE OF lcl_it_dd30l.
***********************************************************************

  global_main_name = &apos;Single Selected Objects&apos;.
* Erzeugen des Ausgabeverzeichnisses fuer dieses Rahmenprogramm
  PERFORM create_directory USING &apos;Single_Selected_Objects&apos;
                                 &apos;L&apos;. &quot;Name genau so übernhemen!
* Abbrechen da es schon existiert
  IF direxists = &apos;X&apos;.
    EXIT.
  ENDIF.

* Ueberschrift zusammenbauen
  MOVE global_main_name TO header.
* Protokollliste schreiben.
  PERFORM write_protocol USING &apos;U&apos;  &apos;&apos; &apos;&apos; header.
****************

* Intitialisieren der globalen Tabellen
  PERFORM initialize.

* Suppress the download of denpendend objects...
  g_nodep = &apos;X&apos;.

* Stueckliste schreiben fuer dieses Objekt
  PERFORM write_stueckliste USING &apos;SINGLE_LIMU&apos;
                                  global_main_name
                                  space.

***************************************************************
* Includes
***************************************************************
  IF NOT o_sireps IS INITIAL.
*   Relevante Objekte selektieren
    SELECT * FROM d010inc INTO TABLE lcl_it_include
           WHERE include IN o_sireps.
    LOOP AT lcl_it_include INTO lcl_wa_include .

      CLEAR ok.
      PERFORM download_include USING lcl_wa_include-include &apos;I&apos;
                                CHANGING ok.
*       Download war erfolgreich
      IF ok = &apos;X&apos;.
*         Stueckliste schreiben fuer dieses Objekt
        PERFORM write_stueckliste USING &apos;REPS&apos;
                                        lcl_wa_include-include
                                        global_main_name.
*      Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      ENDIF.

    ENDLOOP.
  ENDIF.


***************************************************************
* Funktionsbausteine
***************************************************************
  IF NOT o_sifunc IS INITIAL.

*       Lesen, um zu dem Funktionsnamen den Includename zu finden
    SELECT * FROM tfdir INTO TABLE lcl_it_tfdir
          WHERE funcname IN o_sifunc.

    LOOP AT  lcl_it_tfdir INTO lcl_wa_tfdir.

*     Verarbeitung abhängig von Namensraum
      IF lcl_wa_tfdir-pname(1) = &apos;/&apos;.
*       Partnernamensraum
        PERFORM convert_funcname_for_partner USING lcl_wa_tfdir
                                             CHANGING lcl_include.
      ELSE.
*Zusammensetzen des Includenamens; Beim Funktionsgruupennamen Praefix
*       &apos;SAP&apos; abschneiden: --&gt;Offset
        CONCATENATE lcl_wa_tfdir-pname+3 &apos;U&apos; lcl_wa_tfdir-include
            INTO lcl_include.
      ENDIF.

*     Download des Includes
      CLEAR ok.
      gv_funcname = lcl_wa_tfdir-funcname.
      PERFORM download_include USING lcl_include &apos;F&apos;
                               CHANGING ok.
      CLEAR gv_funcname.
      IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*       Stueckliste schreiben, wenn download erfolgreich
*       Funktionsbauseinname:
        PERFORM write_stueckliste USING &apos;FUNC&apos;
                                          lcl_wa_tfdir-funcname
                                          global_main_name.
*       Includename des Funktionsbaustein
        PERFORM write_stueckliste USING &apos;IN&apos;
                                lcl_include
                                lcl_wa_tfdir-funcname.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


      ENDIF. &quot;downnload erfolgreich???

    ENDLOOP.

  ENDIF.

***************************************************************
* Tabellen / Strukturen
***************************************************************
  IF NOT o_sitabl IS INITIAL.

*   Daten selektieren
    SELECT * FROM dd02l INTO TABLE lcl_it_dd02l
        WHERE tabname IN o_sitabl
          AND tabclass IN (&apos;TRANSP&apos;, &apos;VIEW&apos;,
                           &apos;INTTAB&apos;, &apos;APPEND&apos;).

    LOOP AT lcl_it_dd02l INTO lcl_wa_dd02l .

*     Fuer Typ T feststellen ob Struktur, oder Taelle
      IF lcl_wa_dd02l-tabclass = &apos;TRANSP&apos;. &quot;normale Tabelle
*       Infos suchen und diese Downloaden
        PERFORM download_table USING lcl_wa_dd02l
                                      &apos;T&apos;.

*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Table&apos;
                                      lcl_wa_dd02l-tabname
                                      global_main_name.

      ELSEIF lcl_wa_dd02l-tabclass = &apos;INTTAB&apos;. &quot;Struktur

*       Infos suchen und diese Downloaden
        PERFORM download_table USING lcl_wa_dd02l
                                      &apos;S&apos;.
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Structure&apos;
                                      lcl_wa_dd02l-tabname
                                      global_main_name.

      ELSEIF lcl_wa_dd02l-tabclass = &apos;APPEND&apos;. &quot;Appendstruktur

*       Infos suchen und diese Downloaden
        PERFORM download_table USING lcl_wa_dd02l
                                     &apos;A&apos;.
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;Append&apos;
                                      lcl_wa_dd02l-tabname
                                      global_main_name.

      ELSEIF lcl_wa_dd02l-tabclass = &apos;VIEW&apos;. &quot;View
        PERFORM download_table USING  lcl_wa_dd02l &apos;V&apos;.
*       Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;View&apos;
                                    lcl_wa_dd02l-tabname
                                    global_main_name.

      ENDIF.

*     Markierungen zur Trennung von naechstem Objekt
      PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
      PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

    ENDLOOP.

  ENDIF.

***************************************************************
* Tabellentypen
***************************************************************
  IF NOT o_sittyp IS INITIAL.

*   Überüfung, ob Tabellentyp überhaupt noch existiert.
    SELECT * FROM dd40vv INTO TABLE lcl_it_dd40vv
      WHERE typename IN o_sittyp.

    LOOP AT lcl_it_dd40vv INTO lcl_wa_dd40vv .

      PERFORM handle_tabletype USING lcl_wa_dd40vv-typename.

*     Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Tabletype&apos;
                                      lcl_wa_dd40vv-typename
                                      global_main_name.

*     Markierungen zur Trennung von naechstem Objekt
      PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
      PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

    ENDLOOP.

  ENDIF.


***************************************************************
* Typepools
***************************************************************
  IF NOT o_sitypd IS INITIAL.

    SELECT * FROM tadir INTO TABLE lcl_it_tadir
             WHERE pgmid  = &apos;R3TR&apos;
               AND object = &apos;TYPE&apos;
               AND obj_name IN o_sitypd.

    LOOP AT  lcl_it_tadir INTO lcl_wa_tadir.

*Zusammensetzen des Includenamens der Typgruppe: Praefix %_C vor Namen
      CONCATENATE &apos;%_C&apos; lcl_wa_tadir-obj_name INTO lcl_include.
*      Uebergabe des Typ des Includes, um Dateinamen festlegen zu können
      CLEAR ok.
      PERFORM download_include USING lcl_include &apos;T&apos;
                               CHANGING ok.
      IF ok = &apos;X&apos;. &quot;Download include war erfolgreich
*          Stueckliste schreiben, wenn download erfolgreich
        PERFORM write_stueckliste USING &apos;Typgroup&apos;
                                          lcl_wa_tadir-obj_name
                                          global_main_name.

*       Markierungen zur Trennung von naechstem Objekt
        PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
        PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

      ENDIF. &quot;downnload erfolgreich???

    ENDLOOP.

  ENDIF.

  IF NOT o_sidtel IS INITIAL.

    SELECT * FROM info_dtel INTO TABLE lcl_it_info_dtel
             WHERE rollname IN o_sidtel.
    LOOP AT lcl_it_info_dtel INTO lcl_wa_info_dtel.

*    Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Datenelement&apos;
                                    lcl_wa_info_dtel-rollname
                                    global_main_name.

      PERFORM write_dataelements USING lcl_wa_info_dtel-rollname.

    ENDLOOP.

*   Gesammelte Datenelemente herunterladen.
    PERFORM download_dataelements.

*   Markierungen zur Trennung von naechstem Objekt
    PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
    PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.


  ENDIF.

  IF NOT o_sidoma IS INITIAL.

    SELECT * FROM info_doma INTO TABLE lcl_it_info_doma
                  WHERE domname IN o_sidoma.
    LOOP AT  lcl_it_info_doma INTO lcl_wa_info_doma.

      LOOP AT it_lan INTO wa_lan.
        REFRESH lcl_it_dd07v.
        CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
          EXPORTING
            name          = lcl_wa_info_doma-domname
            state         = &apos;A&apos;
            langu         = wa_lan
          IMPORTING
            dd01v_wa      = wa_dd01v
          TABLES
            dd07v_tab     = lcl_it_dd07v
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc = 0.
*Domaeneninfos in Gesamttabelle schreiben, wenn im Kundennamensraum.
          APPEND wa_dd01v TO it_dd01v.
*          Wertelistetabelle (dd07v) in Gesamtwerteliste schreiben.
*          Nur ausführen wenn lcl_it_dd07v nicht leer ist. Nur aus-
*          fuehren wenn Domaenen im Kundennamensraum liegen.
          IF NOT ( lcl_it_dd07v IS INITIAL ).
            LOOP AT lcl_it_dd07v INTO lcl_wa_dd07v.
              APPEND lcl_wa_dd07v TO it_dd07v.
            ENDLOOP.
          ENDIF. &quot;initialpruefung
        ENDIF. &quot;sy-subrc

      ENDLOOP. &quot;Sprachtabelle

    ENDLOOP. &quot;Seletected data elements

*   Initialisieren der globalen Tabelle der Datenelemente um die
*   normale Standardroutine verwenden zu können, die abhängig von den
*   Datenelementen it_dd07v füllt.
    REFRESH it_dataelements.

*   Domaenen downloaden
    PERFORM download_domains.

  ENDIF.

  IF NOT o_sienqu IS INITIAL.

    SELECT * FROM dd25l INTO TABLE lcl_it_dd25l
             WHERE viewname IN o_sienqu
               AND aggtype = &apos;E&apos;.
    LOOP AT lcl_it_dd25l INTO lcl_wa_dd25l.

      CLEAR lcl_wa_cross-name.
      lcl_wa_cross-name = lcl_wa_dd25l-viewname.
*     Sperrobjekt-Routine aufrufen
      PERFORM handle_lockobject USING lcl_wa_cross
                                      &apos;S&apos;. &quot;Name ist Sperrobjektname

*     Markierungen zur Trennung von naechstem Objekt
      PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
      PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

    ENDLOOP.


  ENDIF.

  IF NOT o_sisuso IS INITIAL.

    SELECT * FROM info_suso INTO TABLE lcl_it_info_suso
          WHERE objct IN o_sisuso.
    LOOP AT lcl_it_info_suso INTO lcl_wa_info_suso.

      PERFORM trkorr_handleauthorityobject USING
                            lcl_wa_info_suso-objct.

    ENDLOOP.

  ENDIF.

  IF NOT o_sitran IS INITIAL.

*   Select data
    SELECT * FROM tstc INTO CORRESPONDING FIELDS OF TABLE it_tstc
             WHERE tcode IN o_sitran.

    SELECT * FROM tstcp INTO TABLE it_tstcp
          WHERE tcode IN o_sitran.

*   Download selected data
    PERFORM download_tacodelist.
    PERFORM download_tacodelist_for_class.

  ENDIF.

***********************************************************************
*Addition of code for search help, Enhancement Spot, new core BADI.
***********************************************************************

*---- When selection is made for Search Help.

  IF NOT o_srchep IS INITIAL.
    PERFORM handle_searchelp.

*   Download selected data
    PERFORM download_searchelp.

*   Markierungen zur Trennung von naechstem Objekt
    PERFORM write_protocol USING &apos;L&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
    PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.
  ENDIF.


*----When selection is made for Enhancement Spot.

  IF NOT o_enhspt IS INITIAL.
    PERFORM handle_enhns_spot.

*   Download selected data
    PERFORM download_enhns_spot.

  ENDIF.

*----When selection is made for New Core BADI
  IF NOT o_badi IS INITIAL.
    PERFORM handle_new_badi.

*    Download selected data.
    PERFORM download_new_badi.

  ENDIF.

*----Selection made for web dyn pro

  IF NOT ( o_webd IS INITIAL ).
    PERFORM web_dyn_services.
  ENDIF.
**********************************************************
***********************************************************************
* Stueckliste der Einzelobjekte herunterladen
  PERFORM download_stueckliste.
* Hot-Package-Stand des Systems herunterladen
  PERFORM download_hpstand.

  PERFORM write_protocol USING &apos;S&apos;  &apos;&apos; &apos;&apos; &apos;&apos;.

*Stueckliste fuer logische Entwicklung schreiben
  IF NOT ( p_logic IS INITIAL ).
    PERFORM write_log_stueckliste USING &apos;SINGLE_LIMU&apos;
                                        &apos;Single Selected Objects&apos;
                                        p_logic.

  ENDIF.

ENDFORM.                    &quot; handle_single_limu

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_SEARCHELP
*&amp;---------------------------------------------------------------------*
* Selection of data for search help from database
*----------------------------------------------------------------------*
FORM handle_searchelp .

* Select data for searchhelp
  SELECT shlpname
         as4local
         issimple
         selmethod
         selmexit
         FROM dd30l INTO CORRESPONDING FIELDS OF TABLE it_dd30l
         WHERE shlpname IN o_srchep.

  READ TABLE it_dd30l INDEX 1 INTO wa_dd30l.

* Selecting search help text.
  SELECT shlpname
         ddlanguage
         as4local
         ddtext
         FROM dd30t INTO TABLE it_dd30t
         WHERE shlpname = wa_dd30l-shlpname AND
         ddlanguage = sy-langu.

* Selecting search help parameters
  SELECT *
    FROM dd32s
    INTO TABLE it_dd32s
    WHERE shlpname = wa_dd30l-shlpname.

  READ TABLE it_dd30t INDEX 1 INTO wa_dd30t.

  LOOP AT it_dd32s INTO wa_dd32s.

    wa_serchlp-shlpname   = wa_dd30l-shlpname.
    wa_serchlp-as4local   = wa_dd30l-as4local.
    wa_serchlp-issimple   = wa_dd30l-issimple.
    wa_serchlp-selmethod  = wa_dd30l-selmethod.
    wa_serchlp-selmexit   = wa_dd30l-selmexit.
    wa_serchlp-fieldname  = wa_dd32s-fieldname.
    wa_serchlp-flposition = wa_dd32s-flposition.
    wa_serchlp-rollname   = wa_dd32s-rollname.
    wa_serchlp-shlpinput  = wa_dd32s-shlpinput.
    wa_serchlp-shlpoutput = wa_dd32s-shlpoutput .
    wa_serchlp-shlpselpos = wa_dd32s-shlpselpos.
    wa_serchlp-shlplispos = wa_dd32s-shlplispos.
    wa_serchlp-ddlanguage = wa_dd30t-ddlanguage.
    wa_serchlp-ddtext     = wa_dd30t-ddtext.

    APPEND wa_serchlp TO it_serchlp.
    CLEAR: wa_serchlp, wa_dd30t, wa_dd30l,wa_dd32s.

  ENDLOOP.

ENDFORM.                    &quot; HANDLE_SEARCHELP



*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_ENHNS_SPOT
*&amp;---------------------------------------------------------------------*
*Selecting data for Enhancement Spot.
*----------------------------------------------------------------------*

FORM handle_enhns_spot .

*----Select data for enhancement spot

  SELECT enhspot
         version
         obj_type
         obj_name
         pgmid
         main_name
         FROM enhspotobj INTO CORRESPONDING FIELDS OF TABLE it_enhspot
         WHERE enhspot IN o_enhspt.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE e888(sabapdocu) WITH
            &apos;Selected Enhancement Spot not found&apos;.
  ENDIF.

ENDFORM.                    &quot; HANDLE_ENHNS_SPOT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_ENHNS_SPOT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*

FORM download_enhns_spot .
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Dateiname fuer Download
  DATA: lcl_enhspt_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_enhspot IS INITIAL ).

*  Ueberschrift zusammenbauen
    CONCATENATE &apos;Enhancement Spot&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.

*  Headertabelle zusammenbauen
    APPEND &apos;Enhancement Spot &apos; TO lcl_it_headerrow.
    APPEND &apos;ABAP: Program Status  &apos; TO lcl_it_headerrow.
    APPEND &apos;Object Type &apos; TO lcl_it_headerrow.
    APPEND &apos;Object Name in Object List &apos; TO lcl_it_headerrow.
    APPEND &apos;Program ID &apos; TO lcl_it_headerrow.
    APPEND &apos;Dev. TADIR Name &apos; TO lcl_it_headerrow.

*  Umwandlung in HTML-Tabelle
*  *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_enhspot INTO wa_enhspot.
      PERFORM create_htmltab_body USING wa_enhspot.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************

    CONCATENATE &apos;Enhancement Spot&apos; global_main_name INTO lcl_enhspt_name.


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_enhspt_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html  &quot;it_tstc
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  &apos;Enhancement List&apos; lcl_enhspt_name &quot;DNE_KW11
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  &apos;Enhancement List&apos; lcl_enhspt_name &quot;DNE_KW11
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Enhancement Spot List&apos;
                                      &apos;Enhnsptlist&apos;
                                      global_main_name.
    ENDIF.
  ENDIF.

ENDFORM.                    &quot; DOWNLOAD_ENHNS_SPOT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  WEB_DYN_SERVICES
*&amp;---------------------------------------------------------------------*
*----CODE FOR PROVIDING DOCUMENTATION FOR WEB-DYNPRO.
*----------------------------------------------------------------------*
FORM web_dyn_services .

  PERFORM handle_web_dyn.

  PERFORM download_web_dyn.
ENDFORM.                    &quot; WEB_DYN_SERVICES

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_WEB_DYN
*&amp;---------------------------------------------------------------------*
*selecting data for WEB-DynPro.
*----------------------------------------------------------------------*
FORM handle_web_dyn .

*----Selecting Component, comp. controller, comp. interface

  SELECT component_name
         cmp_controller
         cmp_interface
         FROM wdy_component INTO CORRESPONDING FIELDS OF TABLE it_wdy_comp
         WHERE component_name IN o_webd.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE e888(sabapdocu) WITH
            &apos;Web-Dynpro does not exist&apos;.
  ENDIF.

*----Selecting views (interface &amp; views) depending upon the
*----type of class.
  SELECT component_name
         view_name
         type
         view_controller
         FROM wdy_view INTO CORRESPONDING FIELDS OF TABLE it_wdy_view
         WHERE component_name IN o_webd.
*----Selecting Application name by giving component name.

  SELECT application_name
         component
         FROM wdy_application INTO CORRESPONDING FIELDS OF TABLE  it_wdy_appl
         WHERE component IN o_webd.

  LOOP AT it_wdy_comp INTO wa_wdy_comp.

    wa_webdyn_f-component_name = wa_wdy_comp-component_name.
    wa_webdyn_f-cmp_controller = wa_wdy_comp-cmp_controller.
    wa_webdyn_f-cmp_interface  = wa_wdy_comp-cmp_interface.

    DATA i TYPE char1.
    i = 0.

    LOOP AT it_wdy_view INTO wa_wdy_view.
      i = i + 1.
      IF wa_wdy_view-type = &apos;CL_WDY_MD_WINDOW&apos;.
        wa_webdyn_f-windows = wa_wdy_view-view_name.
        APPEND wa_webdyn_f TO it_webdyn_f.
        CLEAR wa_webdyn_f-windows.

      ELSEIF wa_wdy_view-type = &apos;CL_WDY_MD_VIEW&apos;.
        wa_webdyn_f-view = wa_wdy_view-view_name.
        APPEND wa_webdyn_f TO it_webdyn_f.
        CLEAR wa_webdyn_f-view.

      ELSEIF wa_wdy_view-type = &apos;CL_WDY_MD_EMPTY_VIEW&apos;.
        wa_webdyn_f-view = wa_wdy_view-view_name.
        APPEND wa_webdyn_f TO it_webdyn_f.
        CLEAR wa_webdyn_f-view.

      ELSEIF wa_wdy_view-type = &apos;CL_WDY_MD_INTERFACE_VIEW&apos;.
        wa_webdyn_f-view = wa_wdy_view-view_name.
        APPEND wa_webdyn_f TO it_webdyn_f.
        CLEAR wa_webdyn_f-view.

      ENDIF.

    ENDLOOP.
  ENDLOOP.
  CLEAR:  wa_webdyn_f-cmp_controller,
          wa_webdyn_f-cmp_interface.

  LOOP AT it_wdy_appl INTO wa_wdy_appl.
    wa_webdyn_f-application_name = wa_wdy_appl-application_name.
    APPEND wa_webdyn_f TO it_webdyn_f.
    CLEAR wa_webdyn_f-application_name.
  ENDLOOP.
*  append WA_WEBDYN_F to it_WEBDYN_F.
ENDFORM.                    &quot; HANDLE_WEB_DYN
*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_WEB_DYN
*&amp;---------------------------------------------------------------------*
* for downloading the content of WEB-DynPro.
*----------------------------------------------------------------------*

FORM download_web_dyn .
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Dateiname fuer Download
  DATA: lcl_webd_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_webdyn_f IS INITIAL ).

*  Ueberschrift zusammenbauen
    CONCATENATE &apos;Webdyn DynPro&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*  Headertabelle zusammenbauen
    APPEND &apos;WebDyn pro  &apos; TO lcl_it_headerrow.
    APPEND &apos;Component Name  &apos; TO lcl_it_headerrow.
    APPEND &apos;Controller Name  &apos; TO lcl_it_headerrow.
    APPEND &apos;Windows  &apos; TO lcl_it_headerrow.
    APPEND &apos;Views  &apos; TO lcl_it_headerrow.
    APPEND &apos;Application Name  &apos; TO lcl_it_headerrow.

*  Umwandlung in HTML-Tabelle
*  *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_webdyn_f INTO wa_webdyn_f.
      PERFORM create_htmltab_body USING wa_webdyn_f.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************

    CONCATENATE &apos;Web-Dyn Pro&apos; global_main_name INTO lcl_webd_name.


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_webd_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  &apos;Web Dynpro&apos; lcl_webd_name  &quot;DNE_KW11
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  &apos;Web Dynpro&apos; lcl_webd_name  &quot;DNE_KW11
          filename.

*Stueckliste schreiben
      PERFORM write_stueckliste USING &apos;Web-Dyn Pro List&apos;
                                      &apos;Webdynprolist&apos;
                                      global_main_name.
    ENDIF.
  ENDIF.


ENDFORM.                    &quot; DOWNLOAD_WEB_DYN

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_NEW_BADI
*&amp;---------------------------------------------------------------------*
*Selecting data from table
*----------------------------------------------------------------------*

FORM handle_new_badi .

*----Select data for enhancement spot

  SELECT *
         FROM badi_impl INTO TABLE it_badi_impl
         WHERE badi_name IN o_badi.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE e888(sabapdocu) WITH
            &apos;Selected BADI not found&apos;.
  ENDIF.

  READ TABLE it_badi_impl INDEX 1 INTO wa_badi_impl.

  SELECT badi_name
         interface_name
    FROM badi_main
    INTO TABLE it_badi_int
    WHERE badi_name = wa_badi_impl-badi_name.

  READ TABLE it_badi_int INDEX 1 INTO wa_badi_int.

  LOOP AT it_badi_impl INTO wa_badi_impl.
    wa_badi-badi_name      = wa_badi_impl-badi_name.
    wa_badi-interface_name = wa_badi_int-interface_name.
    wa_badi-enhname        = wa_badi_impl-enhname.
    wa_badi-badi_impl      = wa_badi_impl-badi_impl.
    wa_badi-class_name     = wa_badi_impl-class_name.
    wa_badi-is_default     = wa_badi_impl-is_default.

    APPEND wa_badi TO it_badi.
  ENDLOOP.
  CLEAR: wa_badi, wa_badi_impl, wa_badi_int.

ENDFORM.                    &quot; HANDLE_NEW_BADI
*&amp;---------------------------------------------------------------------*
*&amp;      Form  DOWNLOAD_NEW_BADI
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM download_new_badi .
* subrc für Downloadform-routine
  DATA: lcl_subrc TYPE sy-subrc.
*Dateiname fuer Download
  DATA: lcl_badi_name TYPE string.
*Variable fuer Kopfzeile
  DATA: lcl_header TYPE string.
*Headertabelle fuer HTML-Tabelle
  DATA: lcl_it_headerrow TYPE STANDARD TABLE OF string.


*Nur Herunterladen wenn Tabelle nicht initial ist
  IF NOT ( it_badi IS INITIAL ).

*  Ueberschrift zusammenbauen
    CONCATENATE &apos;New Core BADI&apos;  global_main_name
          INTO lcl_header SEPARATED BY space.
*  Headertabelle zusammenbauen
    APPEND &apos;BADI Name &apos; TO lcl_it_headerrow.
    APPEND &apos;Interface Name &apos; TO lcl_it_headerrow.
    APPEND &apos;Enhancement Name  &apos; TO lcl_it_headerrow.
    APPEND &apos;BADI Implemetation  &apos; TO lcl_it_headerrow.
    APPEND &apos;Class Name  &apos; TO lcl_it_headerrow.
    APPEND &apos;Default Implementation &apos; TO lcl_it_headerrow.
*  Umwandlung in HTML-Tabelle
*  *******************************************************
    PERFORM create_htmltab_header  USING lcl_it_headerrow
                                         lcl_header.

    LOOP AT it_badi INTO wa_badi.
      PERFORM create_htmltab_body USING wa_badi.
    ENDLOOP.

    PERFORM create_html_tab_foot.
*  ********************************************************

    CONCATENATE &apos;New BADI&apos; global_main_name INTO lcl_badi_name.


    CLEAR filename.
    CONCATENATE new_dir &apos;\&apos; lcl_badi_name &apos;.xml&apos; INTO filename.

*   begin of changes for partner namespace
    TRANSLATE filename USING &apos;/_&apos;.
*   end of changes for partner namespace
    PERFORM call_ws_download USING    filename
                                      it_html
                             CHANGING lcl_subrc.

    IF lcl_subrc &lt;&gt; 0.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;E&apos;  &apos;Core BADI&apos; lcl_badi_name &quot;DNE_KW11
          filename.
    ELSE.
*Protokollliste schreiben.
      PERFORM write_protocol USING &apos;N&apos;  &apos;Core BADI&apos; lcl_badi_name &quot;DNE_KW11
          filename.

*Stueckliste schreiben
        PERFORM write_stueckliste USING &apos;New BADI List&apos;
                                      &apos;BADIlist&apos;
                                      global_main_name.
    ENDIF.
  ENDIF.



ENDFORM.                    &quot; DOWNLOAD_NEW_BADI</source>
 </PROG>
 <PROG NAME="YEGGACHE" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT Eggache Version: Hey man, got a eggache hum..." LENGTH="51 "/>
   </language>
  </textPool>
  <source>* This small, stupid program aims to reduce the eggache and effort of note pre-implement documentation.
* However, you may get other kind of eggache when you use it, who knows what will happen, hum?
* Warning: You might feel uncomfortable both physically and spritually when you run this program
* The author, who is acutally a Joker, won&apos;t be responsible for this cause you may get an Easter Egg
* If you get a eggache when using this program, contact that Joker via Email: joker.yang@sap.corp
REPORT yeggache.
* Types Definition: utility types
INCLUDE msdxxdef_const.
TYPE-POOLS: icon.
TYPES: BEGIN OF s_objtype_order,
       object  TYPE trobjtype,
       sort_no TYPE int1,
       END OF s_objtype_order.
TYPES: ht_objtype_order TYPE HASHED TABLE OF s_objtype_order WITH UNIQUE KEY object.

TYPES: BEGIN OF s_obj_header,
       pgmid          TYPE  pgmid,
       object         TYPE trobjtype,
       obj_name	      TYPE sobj_name,
       primary_sort   TYPE i,
       secondary_sort TYPE numc2,
       devclass       TYPE devclass,
       short_text     TYPE ddtext,
       screenshots    TYPE int1,
       END OF s_obj_header.
TYPES: BEGIN OF s_value_desc,
       fieldname   TYPE fieldname,
       ddfixvalues TYPE ddfixvalues,
       END OF s_value_desc.
* Types Definition: supported kinds of objects
* Naming Convention: s_{objtype}, thus part of the codes can be generated
TYPES: BEGIN OF s_devc.
        INCLUDE TYPE s_obj_header.
TYPES: parentcl               TYPE parentcl.
TYPES: pdevclass              TYPE devlayer.
TYPES: component              TYPE uffctr.
TYPES: dlvunit                TYPE dlvunit.
TYPES: applicat               TYPE trdevcappl.
TYPES: mainpack               TYPE mainpack.
TYPES: korrflag               TYPE korrflag.
TYPES: project_id             TYPE pak_project_id.
TYPES: translation_depth_text TYPE pak_translation_depth_text.
TYPES: use_accesses           TYPE permis_tab.
TYPES: END OF s_devc.

TYPES: BEGIN OF s_fugr.
        INCLUDE TYPE s_obj_header.
TYPES: END OF s_fugr.

TYPES: BEGIN OF s_doma.
        INCLUDE TYPE s_obj_header.
TYPES: datatype    TYPE datatype_d.
TYPES: leng        TYPE ddleng.
TYPES: outputlen   TYPE outputlen.
TYPES: decimals    TYPE decimals.
TYPES: lowercase   TYPE lowercase.
TYPES: signflag    TYPE signflag.
TYPES: valexi      TYPE valexi.
TYPES: entitytab   TYPE entitytab.
TYPES: value_range TYPE dd07v_tab.
TYPES: END OF s_doma.

TYPES: BEGIN OF s_dtel.
        INCLUDE TYPE s_obj_header.
TYPES: domname   TYPE domname.
TYPES: headlen   TYPE headlen.
TYPES: scrlen1   TYPE scrlen_s.
TYPES: scrlen2   TYPE scrlen_m.
TYPES: scrlen3   TYPE scrlen_l.
TYPES: reptext   TYPE reptext.
TYPES: scrtext_s TYPE scrtext_s.
TYPES: scrtext_m TYPE scrtext_m.
TYPES: scrtext_l TYPE scrtext_l.
TYPES: END OF s_dtel.

TYPES: BEGIN OF s_tabl.
        INCLUDE TYPE s_obj_header.
TYPES:  tabclass  TYPE  tabclass.
TYPES:  contflag  TYPE  contflag.
TYPES:  mainflag  TYPE  maintflag.
TYPES:  fields  TYPE  dd03ttyp.
TYPES:  tech_setting  TYPE  dd09v.
TYPES:  namespace  TYPE  db6tresc_tab.
TYPES:  foreign_key_header  TYPE  dd08vttyp.
TYPES:  foreign_keys  TYPE  dd05mttyp.
TYPES:  assignments  TYPE  dd35vttyp.
TYPES:  index_header  TYPE  dd12vtab.
TYPES:  index_fields  TYPE  dd17vtab.
TYPES: END OF s_tabl.

TYPES: BEGIN OF s_view.
        INCLUDE TYPE s_obj_header.
TYPES:  viewclass  TYPE  viewclass.
TYPES:  customauth  TYPE  contflag.
TYPES:  viewgrant  TYPE  viewgrant.
TYPES:  globalflag  TYPE  maintflag.
TYPES:  table_join  TYPE  /gc1/tab_dd26v.
TYPES:  fields  TYPE  /gc1/tab_dd27p.
TYPES:  join_condition  TYPE  /gc1/tab_dd28j.
TYPES:  selection_condition  TYPE  /gc1/tab_dd28v.
TYPES: END OF s_view.

TYPES: t_vclstruc TYPE STANDARD TABLE OF v_vclstruc WITH DEFAULT KEY.
TYPES: t_vclstdep TYPE STANDARD TABLE OF  v_vclstdep WITH DEFAULT KEY.
TYPES: t_maintenance_events TYPE STANDARD TABLE OF tvimf WITH DEFAULT KEY.
TYPES: t_viewcluster_events TYPE STANDARD TABLE OF v_vclmf WITH DEFAULT KEY.

TYPES: BEGIN OF s_vcls.
        INCLUDE TYPE s_obj_header.
TYPES:  hieropsoff  TYPE  sychar01.
TYPES:  readkind  TYPE  sychar01.
TYPES:  basevcl  TYPE  vcl_name.
TYPES:  object_stru TYPE t_vclstruc.
TYPES:  field_dep  TYPE  t_vclstdep.
TYPES:  events  TYPE  t_viewcluster_events.
TYPES: END OF s_vcls.

TYPES: BEGIN OF s_tobj.
        INCLUDE TYPE s_obj_header.
TYPES:  tabname  TYPE  vim_name.
TYPES:  area  TYPE  funct_pool.
TYPES:  fg_devclass  TYPE  devclass.
TYPES:  type  TYPE  maint_type.
TYPES:  liste  TYPE  list_scr.
TYPES:  detail  TYPE  single_scr.
TYPES:  mclass  TYPE  ddmclass.
TYPES:  cclass  TYPE  dicbercls.
TYPES:  events  TYPE  t_maintenance_events.
TYPES: END OF s_tobj.

TYPES: BEGIN OF s_shlp.
        INCLUDE TYPE s_obj_header.
TYPES:  issimple  TYPE  ddshsimple.
TYPES:  selmethod  TYPE  selmethod.
TYPES:  selmtype  TYPE  selmtype.
TYPES:  selmexit  TYPE  ddshselext.
TYPES:  hotkey  TYPE  ddshhotkey.
TYPES:  dialogtype  TYPE  ddshdiatyp.
TYPES:  params  TYPE  rsdg_t_dd32p.
TYPES: END OF s_shlp.

TYPES: t_base_table TYPE STANDARD TABLE OF dd26e WITH DEFAULT KEY.
TYPES: t_lock_param TYPE STANDARD TABLE OF ddena WITH DEFAULT KEY.
TYPES: BEGIN OF s_enqu.
        INCLUDE TYPE s_obj_header.
TYPES:  rfcenable  TYPE  rfcenable.
TYPES:  base_tables  TYPE  t_base_table.
TYPES:  lock_params  TYPE  t_lock_param.
TYPES: END OF s_enqu.

TYPES: BEGIN OF s_ttyp.
        INCLUDE TYPE s_obj_header.
TYPES:  rowtype  TYPE  ttrowtype.
TYPES:  accessmode  TYPE  accessmode.
TYPES:  keydef  TYPE  ttypkeydef.
TYPES:  keykind  TYPE  keykind.
TYPES:  keyfdcount  TYPE  keyfdcnt.
TYPES:  generic  TYPE  typgeneric.
TYPES:  typelen  TYPE  ddleng.
TYPES:  ttypkind  TYPE  ttypkind.
TYPES:  range_ctyp  TYPE  range_ctyp.
TYPES:  reftype  TYPE  ddreftype.
TYPES:  occurs  TYPE  ddoccurs.
TYPES:  primary_key  TYPE  dd42v_tab.
TYPES:  secondary_key  TYPE  dd43v_tab.
TYPES: END OF s_ttyp.

TYPES: BEGIN OF s_nrob.
        INCLUDE TYPE s_obj_header.
TYPES:  txt  TYPE  nrobjtxt.
TYPES:  dtelsobj  TYPE  nrsobjnam.
TYPES:  domlen  TYPE  nrlendom.
TYPES:  percentage  TYPE  nrperc.
TYPES:  code  TYPE  nrcode.
TYPES:  buffer  TYPE  nrbuffer.
TYPES:  noivbuffer  TYPE  nrivbuffer.
TYPES:  nonrswap  TYPE  nrswap.
TYPES:  yearind  TYPE  nryearind.
TYPES: END OF s_nrob.

TYPES: t_message_txt TYPE STANDARD TABLE OF t100 WITH DEFAULT KEY.
TYPES: BEGIN OF s_msad.
        INCLUDE TYPE s_obj_header.
TYPES:  message_texts  TYPE t_message_txt.
TYPES: END OF s_msad.

TYPES: BEGIN OF s_msag.
        INCLUDE TYPE s_msad.
TYPES: END OF s_msag.

TYPES: BEGIN OF s_mess.
        INCLUDE TYPE s_obj_header.
TYPES: arbgb TYPE   arbgb.
TYPES: msgnr TYPE   msgnr.
TYPES: text	 TYPE natxt.
TYPES: END OF s_mess.

TYPES: t_table_content TYPE STANDARD TABLE OF trobj_name WITH DEFAULT KEY.
TYPES: BEGIN OF s_vdat.
        INCLUDE TYPE s_obj_header.
TYPES:  entries  TYPE  t_table_content.
TYPES: END OF s_vdat.

TYPES: BEGIN OF s_cdat.
        INCLUDE TYPE s_vdat.
TYPES: END OF s_cdat.

TYPES: BEGIN OF s_tabu.
        INCLUDE TYPE s_vdat.
TYPES: END OF s_tabu.

TYPES: t_tcode_authority TYPE STANDARD TABLE OF tstca WITH DEFAULT KEY.
TYPES: BEGIN OF s_tran.
        INCLUDE TYPE s_obj_header.
TYPES: authority  TYPE  t_tcode_authority.
TYPES: basic_info TYPE  tstcv.
TYPES: ext_info TYPE  tstcc.
TYPES: uiclass  TYPE  tstcclass.
TYPES: param  TYPE  tcdparam.
TYPES: END OF s_tran.

TYPES: BEGIN OF s_common_msg,
       msgty TYPE sy-msgty,
       msg TYPE string,
       END OF s_common_msg.

TYPES: BEGIN OF s_obj_gen_msg.
        INCLUDE TYPE s_obj_header.
        INCLUDE TYPE s_common_msg.
TYPES: END OF s_obj_gen_msg.

* Constants/Global Data Definition
CONSTANTS: gcv_supported_objtypes TYPE string VALUE &apos;DEVC,FUGR,DOMA,DTEL,TABL,VIEW,VCLS,TOBJ,SHLP,ENQU,TTYP,NROB,MSAD,MSAG,MESS,VDAT,TRAN&apos;,
* Html template definition, place holder like $XXX will be replaced by content
           gcv_header_html TYPE string VALUE &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                              &apos;&lt;b&gt;&lt;span style=&quot;font-size:20.0pt;line-height:115%&quot;&gt;$HEADER_NO.$OBJECT_DESC&lt;/span&gt;&lt;/b&gt;&apos; &amp;
                                            &apos;&lt;/p&gt;&apos;,
           gcv_title_html  TYPE string VALUE
                                   &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;&lt;span style=&quot;font-size:16.0pt;line-height:115%&quot;&gt;$TITLE_NOCreate&amp;nbsp;$OBJECT_DESC&amp;nbsp;$OBJ_NAME&lt;/span&gt;&apos; &amp;
                                   &apos;&lt;/p&gt;&apos;,
           gcv_small_title_html  TYPE string VALUE
                                   &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;&lt;span style=&quot;font-size:14.0pt;line-height:115%&quot;&gt;$TITLE&lt;/span&gt;&apos; &amp;
                                   &apos;&lt;/p&gt;&apos;,
           gcv_paragraph_html  TYPE string VALUE
                                    &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;$PARAGRAPH&apos; &amp;
                                    &apos;&lt;/p&gt;&apos;,
           gcv_td_label  TYPE string VALUE
                                &apos;&lt;td valign=&quot;top&quot; style=&quot;border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt&quot;&gt;&apos; &amp;
                                  &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;&lt;b&gt;$LABEL&lt;/b&gt;&apos; &amp;
                                  &apos;&lt;/p&gt;&apos; &amp;
                                &apos;&lt;/td&gt;&apos;,
           gcv_td_content TYPE string VALUE
                                &apos;&lt;td valign=&quot;top&quot; style=&quot;border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt&quot;&gt;&apos; &amp;
                                  &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;$VALUE&apos; &amp;
                                  &apos;&lt;/p&gt;&apos; &amp;
                                &apos;&lt;/td&gt;&apos;,
           gcv_td_inner_table TYPE string VALUE &apos;&lt;td&gt;$VALUE&lt;/td&gt;&apos;,
           gcv_img_content TYPE string VALUE &apos;&lt;p&gt;&lt;img width=600 height=450 src=&quot;$IMAGE.jpg&quot;&gt;&lt;/p&gt;&apos;,
           gcv_table_begin TYPE string VALUE &apos;&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot; style=&quot;100.0%;border-collapse:collapse;border:none&quot;&gt;&apos;,
           gcv_table_end   TYPE string VALUE &apos;&lt;/table&gt;&apos;.

DATA: gt_objtype_order TYPE ht_objtype_order,
      gt_objtype_desc  TYPE HASHED TABLE OF ko100 WITH UNIQUE KEY object,
      gt_value_desc    TYPE HASHED TABLE OF s_value_desc WITH UNIQUE KEY fieldname,
      gv_trans_dir     TYPE trtppvalue,
      go_zip           TYPE REF TO cl_abap_zip,
      &quot; global internal data table for each kind of object, name convention: gt_{objtype}
      gt_devc TYPE TABLE OF s_devc,
      gt_fugr TYPE TABLE OF s_fugr,
      gt_doma TYPE TABLE OF s_doma,
      gt_dtel TYPE TABLE OF s_dtel,
      gt_tabl TYPE TABLE OF s_tabl,
      gt_view TYPE TABLE OF s_view,
      gt_vcls TYPE TABLE OF s_vcls,
      gt_tobj TYPE TABLE OF s_tobj,
      gt_shlp TYPE TABLE OF s_shlp,
      gt_enqu TYPE TABLE OF s_enqu,
      gt_ttyp TYPE TABLE OF s_ttyp,
      gt_nrob TYPE TABLE OF s_nrob,
      gt_msad TYPE TABLE OF s_msad,
      gt_msag TYPE TABLE OF s_msag,
      gt_mess TYPE TABLE OF s_mess,
      gt_vdat TYPE TABLE OF s_vdat,
      gt_tran TYPE TABLE OF s_tran,

      gv_header_no   TYPE numc2,
      gv_img_folder  TYPE string,
      gt_html        TYPE TABLE OF string,
      gt_common_msg  TYPE TABLE OF s_common_msg,
      gt_obj_gen_msg TYPE TABLE OF s_obj_gen_msg,

      gv_male       TYPE abap_bool,
      gv_username   TYPE string,
      gv_zip_str    TYPE xstring.

DATA: lt_trans TYPE e070-trkorr.
SELECTION-SCREEN BEGIN OF BLOCK b0 WITH FRAME TITLE gc_case.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_exp FOR FIELD export.
PARAMETERS export TYPE c RADIOBUTTON GROUP 2 DEFAULT &apos;X&apos; USER-COMMAND updown.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_imp FOR FIELD import.
PARAMETERS import TYPE c RADIOBUTTON GROUP 2.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b0.

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE gc_opt.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_trans FOR FIELD so_trans MODIF ID exp.
SELECT-OPTIONS: so_trans FOR lt_trans NO INTERVALS MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_dir FOR FIELD p_dir MODIF ID exp.
PARAMETERS: p_dir TYPE string  MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_doc FOR FIELD p_doc MODIF ID exp.
PARAMETERS: p_doc TYPE char20 LOWER CASE DEFAULT &apos;Correction_Pre&apos; MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_scr FOR FIELD p_screen MODIF ID exp.
PARAMETERS: p_screen TYPE abap_bool AS CHECKBOX MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_bin FOR FIELD p_bin MODIF ID exp.
PARAMETERS: p_bin TYPE abap_bool AS CHECKBOX DEFAULT abap_true MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_file FOR FIELD p_file MODIF ID imp.
PARAMETERS: p_file TYPE string MODIF ID imp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_snd FOR FIELD p_voice.
PARAMETERS: p_voice TYPE abap_bool AS CHECKBOX MODIF ID egg.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b1.

SELECTION-SCREEN BEGIN OF BLOCK e0 WITH FRAME TITLE gc_egg.
SELECTION-SCREEN COMMENT /1(79) egg1 MODIF ID egg.
SELECTION-SCREEN COMMENT /1(79) egg2 MODIF ID egg.
SELECTION-SCREEN COMMENT /1(79) egg3 MODIF ID egg.
SELECTION-SCREEN COMMENT /1(79) egg4 MODIF ID egg.
SELECTION-SCREEN COMMENT /1(79) egg5 MODIF ID egg.
SELECTION-SCREEN COMMENT /1(79) egg6 MODIF ID egg.
SELECTION-SCREEN COMMENT /1(79) egg7 MODIF ID egg.
SELECTION-SCREEN END OF BLOCK e0.

SELECTION-SCREEN BEGIN OF BLOCK e1 WITH FRAME TITLE gc_bugt.
SELECTION-SCREEN COMMENT /1(79) gc_bug MODIF ID lad.
SELECTION-SCREEN END OF BLOCK e1.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR so_trans-low.
  PERFORM f4_request.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_dir.
  PERFORM select_download_dir CHANGING p_dir.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
  PERFORM select_transport_file CHANGING p_file.

INITIALIZATION.
  PERFORM initialize_selection_texts.
  PERFORM initialize_buffer.

AT SELECTION-SCREEN OUTPUT.
  PERFORM scenario_switch.

START-OF-SELECTION.
  DATA: lv_msg TYPE string.
  PERFORM validate_params CHANGING lv_msg.
  IF lv_msg IS NOT INITIAL.
    EXIT.
  ENDIF.

  PERFORM you_shall_not_eggache.

* Includes/Subroutines
FORM you_shall_not_eggache.
  IF export EQ abap_true.
    IF p_screen EQ abap_true.
      PERFORM create_img_folder.
    ENDIF.

    PERFORM prepare_html_header.
    PERFORM prepare_html_body.
    PERFORM prepare_html_tail.

    PERFORM export_docu.
    IF p_bin EQ abap_true.
      PERFORM export_transport_files.
    ENDIF.
  ENDIF.

  IF import EQ abap_true.
    PERFORM upload_transport_files.
    MESSAGE &apos;This feature is under construction, please kindly wait for a while.&apos; TYPE &apos;S&apos;.
  ENDIF.

  PERFORM display_result.
  PERFORM easter_egg.
ENDFORM.

FORM f4_request.
  DATA: ls_selected_request TYPE trwbo_request_header,
        lv_organizer_type TYPE trwbo_calling_organizer VALUE &apos;W&apos;,
        ls_selection TYPE trwbo_selection.

  ls_selection-reqstatus = &apos;R&apos;.
  CALL FUNCTION &apos;TR_PRESENT_REQUESTS_SEL_POPUP&apos;
    EXPORTING
      iv_organizer_type   = lv_organizer_type
      is_selection        = ls_selection
    IMPORTING
      es_selected_request = ls_selected_request.

  so_trans-low = ls_selected_request-trkorr.
ENDFORM.

FORM select_download_dir CHANGING cv_dir TYPE string.
  cl_gui_frontend_services=&gt;directory_browse(
  EXPORTING
    window_title         =     &apos;Hey man, folder or eggache, which one will you choose?&apos; &quot;#EC NOTEXT
  CHANGING
    selected_folder      =     cv_dir
  EXCEPTIONS
    cntl_error           = 1
    error_no_gui         = 2
    not_supported_by_gui = 3
    OTHERS               = 4
    ).
ENDFORM.

FORM select_transport_file CHANGING cv_file TYPE string.
  DATA: lv_desktop_path TYPE string,
        lt_filetable TYPE filetable,
        lv_user_action TYPE i,
        lv_rc TYPE i.

  cl_gui_frontend_services=&gt;get_desktop_directory(
  CHANGING
    desktop_directory = lv_desktop_path
    ).

  cl_gui_frontend_services=&gt;file_open_dialog(
  EXPORTING
    window_title            = &apos;Choose the transport file you want to upload&apos;
    default_extension       = &apos;*.zip&apos;                       &quot;#EC NOTEXT
    initial_directory       = lv_desktop_path
    file_filter             = cl_gui_frontend_services=&gt;filetype_all
    multiselection          = abap_false
  CHANGING
    file_table              = lt_filetable
    user_action             = lv_user_action
    rc                      = lv_rc
  EXCEPTIONS
    file_open_dialog_failed = 1
    cntl_error              = 2
    error_no_gui            = 3
    not_supported_by_gui    = 4
    OTHERS                  = 5
    ).

  IF sy-subrc EQ 0.
    READ TABLE lt_filetable INDEX 1 INTO cv_file.
  ELSE.
    PERFORM show_error_msg.
  ENDIF.
ENDFORM.

FORM initialize_selection_texts.
  PERFORM initialize_eggache_texts.
  gc_egg = &apos;Disclaimer&apos;.
  gc_case = &apos;Scenario Selection&apos;.
  gc_exp = &apos;Generate Note Pre-Impl Documentation&apos;.
  gc_imp = &apos;Upload Transport Files&apos;.
  gc_opt = &apos;Options&apos;.
  gc_trans = &apos;Transport Request&apos;.
  gc_dir = &apos;Export Folder&apos;.
  gc_doc = &apos;Document Title&apos;.
  gc_scr = &apos;Get Screen Shot&apos;.
  gc_bin = &apos;Download Transport Files&apos;.
  gc_file = &apos;Upload Transport File(Zip)&apos;.
  gc_snd = &apos;Want Eggache With 10% Chance&apos;.
  gc_bugt = &apos;Report Message&apos;.
  gc_bug = &apos;Write to joker.yang@sap.corp if you find any issue when you use this tool.&apos;.
ENDFORM.

FORM initialize_eggache_texts.
  egg1 = &apos;This small, stupid program aims to reduce the eggache of note documentation.&apos;.
  egg2 = &apos;However, you may get other kind of eggache when you use it, who knows?&apos;.
  egg3 = &apos;Then you might feel slightly uncomfortable both physically and spritually.&apos;.
  egg4 = &apos;But the author won&apos;&apos;t be responsible for this cause you may get an Easter Egg.&apos;.
  egg5 = &apos;If you get a eggache due to this tool, report a message using contact below:&apos;.
  egg6 = &apos;Joker, deadly enemy of Batman, founder of Gang Of Eggache: joker.yang@sap.corp&apos;.
  egg7 = &apos;I wish you would laugh in joy everyday, how about join Gang Of Eggache?&apos;.
ENDFORM.

FORM initialize_buffer.
  DATA: ls_objtype_order TYPE s_objtype_order,
        lt_object        TYPE TABLE OF trobjtype,
        lv_object        TYPE trobjtype,
        lt_ko100         TYPE TABLE OF ko100.

  FIELD-SYMBOLS &lt;fs_ko100&gt; TYPE ko100.

  SPLIT gcv_supported_objtypes AT &apos;,&apos; INTO TABLE lt_object.
  LOOP AT lt_object INTO lv_object.
    CONDENSE lv_object NO-GAPS.
    ls_objtype_order-object = lv_object.
    ls_objtype_order-sort_no = sy-tabix.

    INSERT ls_objtype_order INTO TABLE gt_objtype_order.
  ENDLOOP.

  CALL FUNCTION &apos;TR_OBJECT_TABLE&apos;
    TABLES
      wt_object_text = lt_ko100.

* there are nearly thousands kinds of object type and we just fetch those in our change request
  LOOP AT lt_ko100 ASSIGNING &lt;fs_ko100&gt;.
    READ TABLE gt_objtype_order WITH TABLE KEY object = &lt;fs_ko100&gt;-object TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      INSERT &lt;fs_ko100&gt; INTO TABLE gt_objtype_desc.
    ENDIF.
  ENDLOOP.

  PERFORM add_value_desc USING &apos;DD02L&apos; &apos;TABCLASS&apos; &apos;TABCLASS&apos;.
  PERFORM add_value_desc USING &apos;DD02L&apos; &apos;MAINFLAG&apos; &apos;MAINFLAG&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos; &apos;VIEWCLASS&apos; &apos;VIEWCLASS&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos; &apos;VIEWGRANT&apos; &apos;VIEWGRANT&apos;.
  PERFORM add_value_desc USING &apos;DD09L&apos; &apos;BUFALLOW&apos; &apos;BUFALLOW&apos;.
  PERFORM add_value_desc USING &apos;DD03P_D&apos; &apos;F_REFTYPE&apos; &apos;F_REFTYPE&apos;.
  PERFORM add_manual_value_desc.

  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos; FIELD &apos;DIR_TRANS&apos; ID &apos;VALUE&apos; FIELD gv_trans_dir.
ENDFORM.

FORM add_value_desc USING iv_tabname TYPE ddobjname iv_fieldname TYPE fieldname iv_lfield_name TYPE dfies-lfieldname.
  DATA: lt_diff_values TYPE ddfixvalues,
        ls_value_desc  TYPE s_value_desc.

  CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
    EXPORTING
      tabname      = iv_tabname
      fieldname    = iv_fieldname
      lfieldname   = iv_lfield_name
    TABLES
      fixed_values = lt_diff_values.

  ls_value_desc-fieldname = iv_fieldname.
  ls_value_desc-ddfixvalues = lt_diff_values.
  INSERT ls_value_desc INTO TABLE gt_value_desc.
ENDFORM.

FORM add_manual_value_desc.
  DATA: ls_value_desc TYPE s_value_desc,
        lt_diff_values TYPE ddfixvalues.

  ls_value_desc-fieldname = &apos;PUFFERUNG&apos;.
  PERFORM add_ddfixvalue USING: &apos;&apos;  &apos;&apos; CHANGING ls_value_desc-ddfixvalues,
                                &apos;P&apos;  &apos;Single records buff.&apos; CHANGING ls_value_desc-ddfixvalues,
                                &apos;G&apos;  &apos;Generic Area Buffered&apos; CHANGING ls_value_desc-ddfixvalues,
                                &apos;X&apos;  &apos;Fully Buffered&apos; CHANGING ls_value_desc-ddfixvalues.
  INSERT ls_value_desc INTO TABLE gt_value_desc.

  CLEAR ls_value_desc.
  ls_value_desc-fieldname = &apos;FRKART&apos;.
  PERFORM add_ddfixvalue USING: &apos;&apos;  &apos;Not Specified&apos; CHANGING ls_value_desc-ddfixvalues,
                                &apos;OPT&apos;  &apos;Optional foreign key&apos; CHANGING ls_value_desc-ddfixvalues,
                                &apos;OBL&apos;  &apos;Mandatory foreign key&apos; CHANGING ls_value_desc-ddfixvalues,
                                &apos;ID&apos;  &apos;Identifying foreign key&apos; CHANGING ls_value_desc-ddfixvalues,
                                &apos;TEXT&apos;  &apos;Key fields of a text table&apos; CHANGING ls_value_desc-ddfixvalues.
  INSERT ls_value_desc INTO TABLE gt_value_desc.
ENDFORM.

FORM add_ddfixvalue USING iv_value TYPE ddfixvalue-low iv_text TYPE ddtext CHANGING ct_ddfixvalue TYPE ddfixvalues.
  DATA ls_ddfixvalue TYPE ddfixvalue.
  ls_ddfixvalue-low = iv_value.
  ls_ddfixvalue-ddtext = iv_text.
  APPEND ls_ddfixvalue TO ct_ddfixvalue.
ENDFORM.

FORM get_value_desc USING iv_fieldname TYPE fieldname iv_value TYPE ddfixvalue-low CHANGING cv_desc TYPE ddtext.
  DATA: ls_value_desc  TYPE s_value_desc.
  FIELD-SYMBOLS: &lt;fs_ddfixvalue&gt; TYPE ddfixvalue.

  CLEAR cv_desc.
  READ TABLE gt_value_desc INTO ls_value_desc WITH TABLE KEY fieldname = iv_fieldname.
  READ TABLE ls_value_desc-ddfixvalues ASSIGNING &lt;fs_ddfixvalue&gt; WITH KEY low = iv_value.

  IF sy-subrc EQ 0 AND &lt;fs_ddfixvalue&gt; IS ASSIGNED.
    cv_desc = &lt;fs_ddfixvalue&gt;-ddtext.
  ENDIF.

  LOOP AT ls_value_desc-ddfixvalues ASSIGNING &lt;fs_ddfixvalue&gt; WHERE low = iv_value.
    cv_desc = &lt;fs_ddfixvalue&gt;-ddtext.
  ENDLOOP.
ENDFORM.

FORM scenario_switch.
  DATA lv_hidid TYPE c LENGTH 3.
  IF export EQ abap_true.
    lv_hidid = &apos;IMP&apos;.
  ELSE.
    lv_hidid = &apos;EXP&apos;.
  ENDIF.

  PERFORM get_user_info CHANGING gv_male gv_username.

  LOOP AT SCREEN.
    &quot; Disclaimer will be visible only to those who have eggs, forgive my repulsive addiction
    &quot; Ladies will only see a vapid instruction on reporting message
    IF screen-group1 EQ lv_hidid
      OR ( gv_male EQ abap_false AND screen-group1 EQ &apos;EGG&apos; )
      OR ( gv_male EQ abap_true AND screen-group1 EQ &apos;LAD&apos;).
      screen-active = &apos;0&apos;.
      screen-invisible = &apos;1&apos;.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
ENDFORM.

FORM validate_params CHANGING cv_msg TYPE string.
  CLEAR cv_msg.

  IF export EQ abap_true.
    IF so_trans IS INITIAL.
      cv_msg = &apos;Eggache comes cause no transport request was chosen&apos;.
    ENDIF.

    IF p_dir IS INITIAL.
      cv_msg = &apos;Eggache comes cause no export folder was selected&apos;.
    ENDIF.

    IF p_doc IS INITIAL.
      cv_msg = &apos;Eggache comes cause no valid document title was given&apos;.
    ENDIF.
  ENDIF.

  IF import EQ abap_true.
    IF p_file IS INITIAL.
      cv_msg = &apos;Eggache comes cause no zip transport file was uploaded&apos;.
    ELSE.
      PERFORM check_transport_zip CHANGING cv_msg.
    ENDIF.
  ENDIF.
ENDFORM.

FORM create_img_folder.
  DATA: lv_folder TYPE string,
        lv_len    TYPE i,
        lv_rc     TYPE sy-subrc.

  lv_len = strlen( p_doc ).
  CONCATENATE p_doc(lv_len) &apos;_files&apos; INTO gv_img_folder RESPECTING BLANKS.
  CONCATENATE p_dir &apos;\&apos; gv_img_folder INTO lv_folder.

  CALL METHOD cl_gui_frontend_services=&gt;directory_create
    EXPORTING
      directory                = lv_folder
    CHANGING
      rc                       = lv_rc
    EXCEPTIONS
      directory_create_failed  = 1
      cntl_error               = 2
      error_no_gui             = 3
      directory_access_denied  = 4
      directory_already_exists = 5
      path_not_found           = 6
      unknown_error            = 7
      not_supported_by_gui     = 8
      wrong_parameter          = 9
      OTHERS                   = 10.

  IF sy-subrc NE 0 AND sy-subrc NE 5.
    MESSAGE &apos;Eggache: I tried but failed to create the image folder for you.&apos; TYPE &apos;E&apos;.
  ENDIF.
ENDFORM.

FORM prepare_html_header.
  APPEND &apos;&lt;html&gt;&apos; TO gt_html.
  APPEND &apos;&lt;head&gt;&apos; TO gt_html.
  APPEND &apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&apos; TO gt_html.
  APPEND &apos;&lt;meta name=&quot;Generator&quot; content=&quot;Microsoft Word 14 (filtered)&quot;&gt;&apos; TO gt_html.
  APPEND &apos;&lt;style type=&quot;text/css&quot;&gt;&apos; TO gt_html.
  APPEND &apos;&lt;!--&apos; TO gt_html.
  APPEND &apos;/* Font Definitions */&apos; TO gt_html.
  APPEND &apos;@font-face&apos; TO gt_html.
  APPEND &apos;{font-family:Calibri;&apos; TO gt_html.
  APPEND &apos;panose-1:2 15 5 2 2 2 4 3 2 4;}&apos; TO gt_html.
  APPEND &apos;@font-face&apos; TO gt_html.
  APPEND &apos;{font-family:Tahoma;&apos; TO gt_html.
  APPEND &apos;panose-1:2 11 6 4 3 5 4 4 2 4;}&apos; TO gt_html.
  APPEND &apos;/* Style Definitions */&apos; TO gt_html.
  APPEND &apos;p.MsoNormal, li.MsoNormal, div.MsoNormal&apos; TO gt_html.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html.
  APPEND &apos;margin-right:0in;&apos; TO gt_html.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html.
  APPEND &apos;margin-left:0in;&apos; TO gt_html.
  APPEND &apos;line-height:115%;&apos; TO gt_html.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html.
  APPEND &apos;p.MsoAcetate, li.MsoAcetate, div.MsoAcetate&apos; TO gt_html.
  APPEND &apos;p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph&apos; TO gt_html.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html.
  APPEND &apos;margin-right:0in;&apos; TO gt_html.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html.
  APPEND &apos;line-height:115%;&apos; TO gt_html.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html.
  APPEND &apos;p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst&apos; TO gt_html.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html.
  APPEND &apos;margin-right:0in;&apos; TO gt_html.
  APPEND &apos;margin-bottom:0in;&apos; TO gt_html.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html.
  APPEND &apos;margin-bottom:.0001pt;&apos; TO gt_html.
  APPEND &apos;line-height:115%;&apos; TO gt_html.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html.
  APPEND &apos;p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle&apos; TO gt_html.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html.
  APPEND &apos;margin-right:0in;&apos; TO gt_html.
  APPEND &apos;margin-bottom:0in;&apos; TO gt_html.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html.
  APPEND &apos;margin-bottom:.0001pt;&apos; TO gt_html.
  APPEND &apos;line-height:115%;&apos; TO gt_html.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html.
  APPEND &apos;p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast&apos; TO gt_html.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html.
  APPEND &apos;margin-right:0in;&apos; TO gt_html.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html.
  APPEND &apos;line-height:115%;&apos; TO gt_html.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html.
  APPEND &apos;.MsoChpDefault&apos; TO gt_html.
  APPEND &apos;{font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html.
  APPEND &apos;.MsoPapDefault&apos; TO gt_html.
  APPEND &apos;{margin-bottom:10.0pt;&apos; TO gt_html.
  APPEND &apos;line-height:115%;}&apos; TO gt_html.
  APPEND &apos;/* Page Definitions */&apos; TO gt_html.
  APPEND &apos;@page WordSection1&apos; TO gt_html.
  APPEND &apos;{size:8.5in 11.0in;&apos; TO gt_html.
  APPEND &apos;margin:1.0in 1.0in 1.0in 1.0in;}&apos; TO gt_html.
  APPEND &apos;div.WordSection1&apos; TO gt_html.
  APPEND &apos;{page:WordSection1;}&apos; TO gt_html.
  APPEND &apos;/* List Definitions */&apos; TO gt_html.
  APPEND &apos;ol&apos; TO gt_html.
  APPEND &apos;{margin-bottom:0in;}&apos; TO gt_html.
  APPEND &apos;ul&apos; TO gt_html.
  APPEND &apos;{margin-bottom:0in;}&apos; TO gt_html.
  APPEND &apos;--&gt;&apos; TO gt_html.
  APPEND &apos;&lt;/style&gt;&apos; TO gt_html.
  APPEND &apos;&lt;title&gt;&apos; TO gt_html.
  APPEND &apos;Note Implementation Documentation&apos; TO gt_html.
  APPEND &apos;&lt;/title&gt;&apos; TO gt_html.
  APPEND &apos;&lt;/head&gt;&apos; TO gt_html.
  APPEND &apos;&lt;body lang=&quot;EN-US&quot;&gt;&apos; TO gt_html.
  APPEND &apos;&lt;div class=&quot;WordSection1&quot;&gt;&apos; TO gt_html.
  APPEND &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; TO gt_html.
  APPEND &apos;&lt;b&gt;Notice:&lt;/b&gt; Please create objects in the below refer to this documentation and your own system settings(such as transport layer and etc).&apos; TO gt_html.
  APPEND &apos;&lt;/p&gt;&apos; TO gt_html.
ENDFORM.

FORM prepare_html_body.
  DATA: lt_object_header TYPE TABLE OF s_obj_header,
        lv_subroutine    TYPE c LENGTH 12.

  FIELD-SYMBOLS: &lt;fs_object_header&gt; TYPE s_obj_header,
  &lt;fs_objtype_order&gt; TYPE s_objtype_order.

  SELECT pgmid object obj_name FROM e071              ##too_many_itab_fields
    INTO CORRESPONDING FIELDS OF TABLE lt_object_header FOR ALL ENTRIES IN gt_objtype_order
    WHERE trkorr IN so_trans AND objfunc NE &apos;D&apos; AND object = gt_objtype_order-object.

  LOOP AT lt_object_header ASSIGNING &lt;fs_object_header&gt;.
    READ TABLE gt_objtype_order WITH TABLE KEY object = &lt;fs_object_header&gt;-object ASSIGNING &lt;fs_objtype_order&gt;.
    &lt;fs_object_header&gt;-primary_sort = &lt;fs_objtype_order&gt;-sort_no.
  ENDLOOP.

  SORT lt_object_header BY primary_sort obj_name.

  LOOP AT lt_object_header ASSIGNING &lt;fs_object_header&gt;.
    CONCATENATE &apos;GETDATA_&apos; &lt;fs_object_header&gt;-object INTO lv_subroutine. &quot;#EC NOTEXT
    PERFORM (lv_subroutine) IN PROGRAM (sy-repid) USING &lt;fs_object_header&gt; IF FOUND.
    CLEAR lv_subroutine.

    AT END OF object.
      ADD 1 TO gv_header_no.
      &quot; usually abstract routine can cover 80% of the case, however 20% are special and need to handle separately
      &quot; so we will try to call subroutine of special case and then fall back to common mode
      TRY.
          CONCATENATE &apos;CONVERT_&apos; &lt;fs_object_header&gt;-object INTO lv_subroutine. &quot;#EC NOTEXT
          PERFORM (lv_subroutine) IN PROGRAM (sy-repid).
        CATCH cx_sy_dyn_call_illegal_form.
          PERFORM convert_obj_abstract USING &lt;fs_object_header&gt;-object.
      ENDTRY.
    ENDAT.
  ENDLOOP.
ENDFORM.

FORM prepare_html_tail.
  APPEND &apos;&lt;/div&gt;&apos; TO gt_html.
  APPEND &apos;&lt;/body&gt;&apos; TO gt_html.
  APPEND &apos;&lt;/html&gt;&apos; TO gt_html.
ENDFORM.

FORM export_docu.
  DATA: lv_html_file TYPE string,
        lv_len TYPE i.
  lv_len = strlen( p_doc ).
  CONCATENATE p_dir &apos;\&apos; p_doc(lv_len) &apos;.html&apos; INTO  lv_html_file RESPECTING BLANKS.
  PERFORM download_file USING &apos;ASC&apos; lv_html_file gt_html.
ENDFORM.

FORM export_transport_files.
  DATA: lv_zip TYPE xstring,
        lt_str TYPE solix_tab,
        lv_zipfile TYPE string.

  IF go_zip IS NOT BOUND.
    CREATE OBJECT go_zip.
  ENDIF.

  LOOP AT so_trans.
    PERFORM add_single_transport USING so_trans-low.
    lv_zipfile = so_trans-low.
  ENDLOOP.

  IF lines( so_trans ) GT 1.
    lv_zipfile = lv_zipfile(3).
    CONCATENATE p_dir &apos;\&apos; lv_zipfile &apos;_Transports.zip&apos; INTO lv_zipfile RESPECTING BLANKS.
  ELSE.
    CONCATENATE p_dir &apos;\&apos; lv_zipfile &apos;.zip&apos; INTO lv_zipfile RESPECTING BLANKS.
  ENDIF.

  lv_zip = go_zip-&gt;save( ).
  lt_str = cl_bcs_convert=&gt;xstring_to_solix( iv_xstring  = lv_zip ).
  PERFORM download_file USING &apos;BIN&apos; lv_zipfile lt_str.
ENDFORM.

FORM upload_transport_files.
ENDFORM.

FORM check_transport_zip CHANGING cv_msg TYPE string.
  DATA: lv_header TYPE xstring,
        lv_str TYPE xstring,
        lt_tab TYPE solix_tab.

  CALL METHOD cl_gui_frontend_services=&gt;gui_upload
    EXPORTING
      filename                = p_file
      filetype                = &apos;BIN&apos;
    IMPORTING
      header                  = lv_header
    CHANGING
      data_tab                = lt_tab
    EXCEPTIONS
      file_open_error         = 1
      file_read_error         = 2
      no_batch                = 3
      gui_refuse_filetransfer = 4
      invalid_type            = 5
      no_authority            = 6
      unknown_error           = 7
      bad_data_format         = 8
      header_not_allowed      = 9
      separator_not_allowed   = 10
      header_too_long         = 11
      unknown_dp_error        = 12
      access_denied           = 13
      dp_out_of_memory        = 14
      disk_full               = 15
      dp_timeout              = 16
      not_supported_by_gui    = 17
      error_no_gui            = 18
      OTHERS                  = 19.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
  ELSE.
    lv_str = cl_bcs_convert=&gt;solix_to_xstring( it_solix  = lt_tab ).
  ENDIF.

  IF go_zip IS NOT BOUND.
    CREATE OBJECT go_zip.

    go_zip-&gt;load(
      EXPORTING
        zip = lv_str
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
      ).
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
    ENDIF.


    &quot; if validity check passed but count of files mod 2 ne 0, give a warning message
    IF lines( go_zip-&gt;files ) MOD 2 NE 0.

    ENDIF.
  ENDIF.
ENDFORM.

FORM add_single_transport USING iv_tr TYPE e070-trkorr.
  DATA: server_file_k TYPE rlgrap-filename,
        server_file_r TYPE rlgrap-filename,
        local_file_k  TYPE string,
        local_file_r  TYPE string,
        lv_tr_no      TYPE e070-trkorr,
        lv_filename   TYPE string,
        lv_slah       TYPE c.

  lv_slah = gv_trans_dir(1).

  lv_tr_no = iv_tr.
  SHIFT lv_tr_no BY 4 PLACES LEFT.

  &quot; SI3K017810-&gt; K017810.SI3 &amp; R017810.SI3
  CONCATENATE &apos;K&apos; lv_tr_no &apos;.&apos; so_trans-low(3) INTO lv_filename.
  CONCATENATE gv_trans_dir lv_slah &apos;cofiles&apos; lv_slah  lv_filename INTO server_file_k. &quot;#EC NOTEXT
  CONCATENATE p_dir &apos;\K&apos; lv_tr_no &apos;.&apos; iv_tr(3) INTO local_file_k. &quot;#EC NOTEXT
  PERFORM add2zip USING lv_filename server_file_k local_file_k.
  CLEAR lv_filename.

  CONCATENATE &apos;R&apos; lv_tr_no &apos;.&apos; so_trans-low(3) INTO lv_filename.
  CONCATENATE gv_trans_dir lv_slah &apos;data&apos; lv_slah lv_filename INTO server_file_r. &quot;#EC NOTEXT
  CONCATENATE p_dir &apos;\R&apos; lv_tr_no &apos;.&apos; iv_tr(3) INTO local_file_r. &quot;#EC NOTEXT
  PERFORM add2zip USING lv_filename server_file_r local_file_r.
ENDFORM.

* actually, call function ARCHIVFILE_SERVER_TO_CLIENT will be much simpler and maybe, better...
FORM add2zip USING iv_filename TYPE string iv_server_file TYPE rlgrap-filename iv_local_file TYPE string.
  DATA: wa_input      TYPE solix,
        lt_input      TYPE solix_tab,
        lv_content    TYPE xstring.

  OPEN DATASET iv_server_file FOR INPUT IN BINARY MODE.
  IF sy-subrc NE 0.
    MESSAGE s208(00) WITH &apos;Eggache: I tried but failed to find or get the transport file for you...&apos;. &quot;#EC NOTEXT
  ENDIF.

  DO.
    READ DATASET iv_server_file INTO wa_input.
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ENDIF.
    APPEND wa_input TO lt_input.
    CLEAR wa_input.
  ENDDO.
  CLOSE DATASET iv_server_file.
* in case the last line is less than solix length, sy-subrc will be 4, yet we need to append this line
  IF wa_input IS NOT INITIAL.
    APPEND wa_input TO lt_input.
  ENDIF.

  lv_content = cl_bcs_convert=&gt;solix_to_xstring( it_solix = lt_input ).
  go_zip-&gt;add( name = iv_filename content = lv_content ).
ENDFORM.

FORM add_obj_gen_msg USING is_obj_header TYPE s_obj_header iv_msgty TYPE sy-msgty iv_msg TYPE string.
  DATA: ls_gen_msg TYPE s_obj_gen_msg,
        lv_objtype_desc TYPE ko100-text,
        lv_len1 TYPE i,
        lv_len2 TYPE i.

  MOVE-CORRESPONDING is_obj_header TO ls_gen_msg.
  ls_gen_msg-msgty = iv_msgty.

  PERFORM get_objtype_desc USING ls_gen_msg-object CHANGING lv_objtype_desc.
  lv_len1 = strlen( lv_objtype_desc ).
  lv_len2 = strlen( ls_gen_msg-obj_name ).

  IF iv_msgty EQ &apos;S&apos;.
    CONCATENATE lv_objtype_desc(lv_len1) &apos; &apos; ls_gen_msg-obj_name(lv_len2) &apos; : Success.&apos;
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ELSEIF iv_msgty EQ &apos;E&apos;.
    CONCATENATE lv_objtype_desc(lv_len1) &apos; &apos; ls_gen_msg-obj_name(lv_len2) &apos; : Failed.&apos;
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.

    CLEAR ls_gen_msg-msg.
    CONCATENATE &apos;--Error Reason: &apos; iv_msg INTO ls_gen_msg-msg.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ENDIF.
ENDFORM.

FORM display_result.
  FIELD-SYMBOLS: &lt;fs_gen_msg&gt; TYPE s_obj_gen_msg,
                 &lt;fs_common_msg&gt; TYPE s_common_msg.
  WRITE: / &apos;//Dear&apos;, gv_username, &apos;,here is documentation generation report\\&apos;, /.

  LOOP AT gt_obj_gen_msg ASSIGNING &lt;fs_gen_msg&gt;.
    PERFORM print_msg USING &lt;fs_gen_msg&gt;-msgty &lt;fs_gen_msg&gt;-msg.
  ENDLOOP.
  SKIP.

  LOOP AT gt_common_msg ASSIGNING &lt;fs_common_msg&gt;.
    PERFORM print_msg USING &lt;fs_common_msg&gt;-msgty &lt;fs_common_msg&gt;-msg.
  ENDLOOP.
  SKIP.

  WRITE: / &apos;\\Dear&apos;, gv_username, &apos;,thank you for using this tool, goodbye~//&apos;.
ENDFORM.

FORM print_msg USING iv_msgty TYPE sy-msgty iv_msg TYPE string.
  CASE iv_msgty.
    WHEN &apos;E&apos; OR &apos;A&apos; OR &apos;X&apos;.
      WRITE / icon_led_red AS ICON.
    WHEN &apos;W&apos;.
      WRITE / icon_led_yellow AS ICON.
    WHEN OTHERS.
      WRITE / icon_led_green AS ICON.
  ENDCASE.

  WRITE iv_msg.
ENDFORM.

FORM download_file USING iv_filetype TYPE char10 iv_filename TYPE string it_tab TYPE STANDARD TABLE.
  cl_gui_frontend_services=&gt;gui_download(
  EXPORTING
    filetype                  =     iv_filetype
    filename                  =     iv_filename
    confirm_overwrite         =     abap_false
  CHANGING
    data_tab                  =     it_tab
  EXCEPTIONS
    file_write_error          = 1
    no_batch                  = 2
    gui_refuse_filetransfer   = 3
    invalid_type              = 4
    no_authority              = 5
    unknown_error             = 6
    header_not_allowed        = 7
    separator_not_allowed     = 8
    filesize_not_allowed      = 9
    header_too_long           = 10
    dp_error_create           = 11
    dp_error_send             = 12
    dp_error_write            = 13
    unknown_dp_error          = 14
    access_denied             = 15
    dp_out_of_memory          = 16
    disk_full                 = 17
    dp_timeout                = 18
    file_not_found            = 19
    dataprovider_exception    = 20
    control_flush_error       = 21
    not_supported_by_gui      = 22
    error_no_gui              = 23
    OTHERS                    = 24
    ).

  IF sy-subrc NE 0.
    PERFORM show_error_msg.
  ENDIF.
ENDFORM.

FORM show_error_msg.
  DATA: lv_msg TYPE string.
  IF sy-msgid IS NOT INITIAL AND sy-msgty IS NOT INITIAL AND sy-msgno IS NOT INITIAL.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
    MESSAGE e208(00) WITH lv_msg.
  ELSE.
    MESSAGE e208(00) WITH &apos;Eggache: An unexpected error occurred.&apos;. &quot;#EC NOTEXT
  ENDIF.
ENDFORM.

FORM handle_rc USING is_obj_header TYPE s_obj_header.
  IF sy-subrc NE 0.
    DATA: ls_obj_gen_msg TYPE s_obj_gen_msg.

    MOVE-CORRESPONDING is_obj_header TO ls_obj_gen_msg.
    IF sy-msgid IS NOT INITIAL AND sy-msgty IS NOT INITIAL AND sy-msgno IS NOT INITIAL.
      ls_obj_gen_msg-msgty = sy-msgty.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO ls_obj_gen_msg-msg.
    ELSE.
      ls_obj_gen_msg-msgty = &apos;E&apos;.
      ls_obj_gen_msg-msg = &apos;Unexpected error occurred.&apos;.
    ENDIF.

    APPEND ls_obj_gen_msg TO gt_obj_gen_msg.
  ENDIF.
ENDFORM.

FORM get_devclass USING is_obj_header TYPE s_obj_header CHANGING cv_devclass TYPE devclass.
  SELECT SINGLE devclass FROM tadir INTO cv_devclass
    WHERE pgmid = is_obj_header-pgmid AND object = is_obj_header-object AND obj_name = is_obj_header-obj_name.
ENDFORM.

***************** HTML Ulitility Begin *****************
* if you give me 002, then two eggs will be cut off, only 2 will be displayed
FORM cut_off_eggs USING iv_sort_no TYPE numc2 CHANGING cv_str TYPE string.
  CLEAR cv_str.
  cv_str = iv_sort_no.
  IF iv_sort_no(1) EQ &apos;0&apos;.
    SHIFT cv_str.
  ENDIF.
ENDFORM.

FORM get_objtype_desc USING iv_objtype TYPE trobjtype CHANGING cv_str TYPE ko100-text.
  DATA: ls_ko100 TYPE ko100.
  READ TABLE gt_objtype_desc INTO ls_ko100 WITH TABLE KEY object = iv_objtype.
  CLEAR cv_str.
  cv_str = ls_ko100-text.
ENDFORM.

FORM get_header_html USING iv_objtype TYPE trobjtype CHANGING cv_html TYPE string.
  DATA: lv_desc        TYPE ddtext,
        lv_no_str      TYPE string.

  CLEAR cv_html.

  cv_html = gcv_header_html.
  PERFORM cut_off_eggs USING gv_header_no CHANGING lv_no_str.
  REPLACE FIRST OCCURRENCE OF &apos;$HEADER_NO&apos; IN cv_html WITH lv_no_str.
  PERFORM get_objtype_desc USING iv_objtype CHANGING lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJECT_DESC&apos; IN cv_html WITH lv_desc.
ENDFORM.

FORM get_title_html USING is_obj TYPE any iv_cnt TYPE i CHANGING cv_html TYPE string.
  DATA: lv_no1 TYPE string,
        lv_no2 TYPE string,
        lv_desc TYPE ddtext,
        ls_obj_header TYPE s_obj_header,
        lv_title_no TYPE string.

  MOVE-CORRESPONDING is_obj TO ls_obj_header.

  CLEAR cv_html.
  cv_html = gcv_title_html.
  IF iv_cnt EQ 1.
    REPLACE FIRST OCCURRENCE OF &apos;$TITLE_NO&apos; IN cv_html WITH &apos;&apos;.
  ELSE.
    PERFORM cut_off_eggs USING gv_header_no CHANGING lv_no1.
    PERFORM cut_off_eggs USING ls_obj_header-secondary_sort CHANGING lv_no2.
    CONCATENATE lv_no1 &apos;.&apos; lv_no2 &apos; &apos; INTO lv_title_no RESPECTING BLANKS.
    REPLACE FIRST OCCURRENCE OF &apos;$TITLE_NO&apos; IN cv_html WITH lv_title_no.
  ENDIF.

  PERFORM get_title_objtype_desc USING ls_obj_header-object is_obj CHANGING lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJECT_DESC&apos; IN cv_html WITH lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJ_NAME&apos; IN cv_html WITH ls_obj_header-obj_name.
ENDFORM.

FORM get_title_objtype_desc USING iv_objtype TYPE trobjtype is_obj TYPE any CHANGING cv_desc TYPE ddtext.
  DATA: lv_low TYPE ddfixvalue-low.
  FIELD-SYMBOLS &lt;fs_value&gt; TYPE any.

  CLEAR cv_desc.
  IF iv_objtype EQ &apos;TABL&apos;.
    ASSIGN COMPONENT &apos;TABCLASS&apos; OF STRUCTURE is_obj TO &lt;fs_value&gt;.
    IF &lt;fs_value&gt; IS ASSIGNED.
      lv_low = &lt;fs_value&gt;.
      PERFORM get_value_desc USING &apos;TABCLASS&apos; lv_low CHANGING cv_desc.
    ENDIF.
  ELSEIF iv_objtype EQ &apos;VIEW&apos;.
    ASSIGN COMPONENT &apos;VIEWCLASS&apos; OF STRUCTURE is_obj TO &lt;fs_value&gt;.
    IF &lt;fs_value&gt; IS ASSIGNED.
      lv_low = &lt;fs_value&gt;.
      PERFORM get_value_desc USING &apos;VIEWCLASS&apos; lv_low CHANGING cv_desc.
    ENDIF.
  ELSE.
    PERFORM get_objtype_desc USING iv_objtype CHANGING cv_desc.
  ENDIF.
ENDFORM.

FORM get_small_title_html USING iv_small_title TYPE string CHANGING cv_html TYPE string.
  cv_html = gcv_small_title_html.
  REPLACE FIRST OCCURRENCE OF &apos;$TITLE&apos; IN cv_html WITH iv_small_title.
ENDFORM.

FORM get_paragraph_html  USING iv_para TYPE string CHANGING cv_html TYPE string.
  cv_html = gcv_paragraph_html.
  REPLACE FIRST OCCURRENCE OF &apos;$PARAGRAPH&apos; IN cv_html WITH iv_para.
ENDFORM.

FORM get_column_label_html USING iv_label TYPE string CHANGING cv_td TYPE string.
  CLEAR cv_td.
  cv_td = gcv_td_label.
  REPLACE FIRST OCCURRENCE OF &apos;$LABEL&apos; IN cv_td WITH iv_label.
ENDFORM.

FORM get_column_value_html USING iv_value TYPE any CHANGING cv_td TYPE string.
  DATA lv_str TYPE string.
  lv_str = iv_value.

  CLEAR cv_td.
  cv_td = gcv_td_content.
  REPLACE FIRST OCCURRENCE OF &apos;$VALUE&apos; IN cv_td WITH lv_str.
ENDFORM.

FORM get_column_innertable_html USING iv_value TYPE any CHANGING cv_td TYPE string.
  DATA lv_str TYPE string.
  lv_str = iv_value.

  CLEAR cv_td.
  cv_td = gcv_td_inner_table.
  REPLACE FIRST OCCURRENCE OF &apos;$VALUE&apos; IN cv_td WITH lv_str.
ENDFORM.

FORM get_2column_label_html CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_label_html USING &apos;Attribute&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Value&apos; CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM get_2column_value_html USING iv_label TYPE string iv_value TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_value_html USING iv_label CHANGING lv_td1.
  PERFORM get_column_value_html USING iv_value CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM combine2td USING iv_td1 TYPE string iv_td2 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine3td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine4td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string iv_td4 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3 iv_td4  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine5td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string iv_td4 TYPE string iv_td5 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3 iv_td4 iv_td5  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine6td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string iv_td4 TYPE string iv_td5 TYPE string iv_td6 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3 iv_td4 iv_td5 iv_td6  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine7td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string iv_td4 TYPE string iv_td5 TYPE string iv_td6 TYPE string iv_td7 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3 iv_td4 iv_td5 iv_td6 iv_td7  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine8td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string iv_td4 TYPE string iv_td5 TYPE string iv_td6 TYPE string iv_td7 TYPE string iv_td8 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3 iv_td4 iv_td5 iv_td6 iv_td7 iv_td8  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine9td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string iv_td4 TYPE string iv_td5 TYPE string iv_td6 TYPE string iv_td7 TYPE string iv_td8 TYPE string iv_td9 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3 iv_td4 iv_td5 iv_td6 iv_td7 iv_td8 iv_td9  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM get_basic_attr_html USING is_obj_header TYPE s_obj_header CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_2column_label_html CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Object Name&apos; is_obj_header-obj_name CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Short Text&apos; is_obj_header-short_text CHANGING ct_html.
  IF is_obj_header-object NE &apos;DEVC&apos;.
    PERFORM get_2column_value_html USING &apos;Package&apos; is_obj_header-devclass CHANGING ct_html.
  ENDIF.
ENDFORM.

* abstract subroutine for all kinds of objects
* for a collection of objects with same kind, the rendering html should be build in the steps below:
* 1.get header html
* 2.render each object in same format
FORM convert_obj_abstract USING iv_objtype TYPE trobjtype.
  DATA: lv_cnt  TYPE i,
        lv_tab  TYPE string,
        lv_html TYPE string,
        lt_html TYPE TABLE OF string.

  FIELD-SYMBOLS: &lt;fs_t_obj&gt; TYPE STANDARD TABLE,
                 &lt;fs_obj&gt; TYPE any,
                 &lt;fs_sec_sort&gt; TYPE any.

  CONCATENATE &apos;(&apos; sy-repid &apos;)GT_&apos; iv_objtype INTO lv_tab.
  ASSIGN (lv_tab) TO &lt;fs_t_obj&gt;.
  CHECK &lt;fs_t_obj&gt; IS ASSIGNED AND &lt;fs_t_obj&gt; IS NOT INITIAL.

  lv_cnt  = lines( &lt;fs_t_obj&gt; ).
  PERFORM get_header_html USING iv_objtype CHANGING lv_html.
  APPEND lv_html TO lt_html.

  LOOP AT &lt;fs_t_obj&gt; ASSIGNING &lt;fs_obj&gt;.
    ASSIGN COMPONENT &apos;SECONDARY_SORT&apos; OF STRUCTURE &lt;fs_obj&gt; TO &lt;fs_sec_sort&gt;.
    IF &lt;fs_sec_sort&gt; IS ASSIGNED.
      &lt;fs_sec_sort&gt; = sy-tabix.
    ENDIF.
    PERFORM get_single_obj_html_abstract USING &lt;fs_obj&gt; lv_cnt CHANGING lt_html.

    UNASSIGN &lt;fs_sec_sort&gt;.
  ENDLOOP.
  UNASSIGN &lt;fs_obj&gt;.
  APPEND LINES OF lt_html TO gt_html.
ENDFORM.

* abstract subroutine as a template pattern for all kinds of objects to implement
* for a single object, the rendering html should be built in the steps below:
* 1.get title html
* 2.get basic attributes and always are obj_name, devclass, short_text
* 3.get additional attributes, for example, for package, its application component, software component and etc
* 4.get special attributes, for example, for table, its fields, technical settings, foreign key settings and etc
* 5.get screen shots, if there were screen shots snapped, we will handle this
* To keep things simple, name convention should be followed like this:
* GET_ADDITIONAL_HTML_{objtype}
* GET_SPECIAL_HTML_{objtype}
FORM get_single_obj_html_abstract USING is_obj TYPE any iv_cnt TYPE i CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_html TYPE string,
        lv_form_addi TYPE string,
        lv_form_spec TYPE string,
        ls_obj_header TYPE s_obj_header.

  MOVE-CORRESPONDING is_obj TO ls_obj_header.
  CONCATENATE &apos;GET_ADDITIONAL_HTML_&apos; ls_obj_header-object INTO lv_form_addi.
  CONCATENATE &apos;GET_SPECIAL_HTML_&apos; ls_obj_header-object INTO lv_form_spec.


  PERFORM get_title_html USING is_obj iv_cnt CHANGING lv_html.
  APPEND lv_html TO ct_html.

  APPEND gcv_table_begin TO ct_html.
  PERFORM get_basic_attr_html USING ls_obj_header CHANGING ct_html.
  PERFORM (lv_form_addi) IN PROGRAM (sy-repid) USING is_obj CHANGING ct_html IF FOUND.
  APPEND gcv_table_end TO ct_html.
  APPEND &apos;&lt;br&gt;&apos; TO ct_html.

  PERFORM (lv_form_spec) IN PROGRAM (sy-repid) USING is_obj CHANGING ct_html IF FOUND.

  IF p_screen EQ abap_true.
    PERFORM get_screenshot_html USING ls_obj_header CHANGING ct_html.
  ENDIF.

  PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
ENDFORM.

FORM get_screenshot_html USING is_obj_header TYPE s_obj_header CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tmp TYPE string,
        lv_len TYPE i,
        lv_img_name TYPE string.

  lv_tmp = gcv_img_content.
  lv_len = strlen( is_obj_header-obj_name ).
  CONCATENATE gv_img_folder &apos;\&apos; is_obj_header-pgmid &apos;_&apos; is_obj_header-object &apos;_&apos; is_obj_header-obj_name(lv_len)
    INTO lv_img_name RESPECTING BLANKS.
  REPLACE FIRST OCCURRENCE OF &apos;$IMAGE&apos; IN lv_tmp WITH lv_img_name.
  APPEND lv_tmp TO ct_html.
ENDFORM.
***************** HTML Ulitility Close *****************

***************** Package Begin *****************
FORM getdata_devc USING is_obj_header TYPE s_obj_header.
  DATA: lv_devclass     TYPE devclass,
        lo_package      TYPE REF TO if_package,
        lt_permission   TYPE tpak_permission_to_use_list,
        lo_permission   TYPE REF TO if_package_permission_to_use,
        ls_use_access   TYPE permission,
        ls_devc         TYPE s_devc.

  MOVE-CORRESPONDING is_obj_header TO ls_devc.

  lv_devclass = is_obj_header-obj_name.
  cl_package_factory=&gt;load_package(
    EXPORTING
      i_package_name             = lv_devclass
    IMPORTING
      e_package                  = lo_package
    EXCEPTIONS
      object_not_existing        = 1
      unexpected_error           = 2
      intern_err                 = 3
      no_access                  = 4
      object_locked_and_modified = 5
      OTHERS                     = 6
    ).
  PERFORM handle_rc USING is_obj_header.

  CHECK lo_package IS BOUND.
* basic attributes
  ls_devc-devclass = lo_package-&gt;package_name.
  ls_devc-short_text = lo_package-&gt;short_text.
  ls_devc-parentcl = lo_package-&gt;super_package_name.
  ls_devc-dlvunit = lo_package-&gt;software_component.
  ls_devc-applicat = lo_package-&gt;application_component_abbrev.
  ls_devc-project_id = lo_package-&gt;project_id.
  ls_devc-translation_depth_text = lo_package-&gt;translation_depth_text.
  ls_devc-mainpack =  lo_package-&gt;main_package.
  ls_devc-korrflag = lo_package-&gt;wbo_korr_flag.
  ls_devc-pdevclass = lo_package-&gt;transport_layer.
* use accesses
  lo_package-&gt;get_permissions_to_use(
    IMPORTING
      e_permissions    = lt_permission
    EXCEPTIONS
      object_invalid   = 1
      unexpected_error = 2
      OTHERS           = 3
    ).
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0.

  LOOP AT lt_permission INTO lo_permission.
    ls_use_access-intf_name = lo_permission-&gt;package_interface_name.
    ls_use_access-client_pak = lo_permission-&gt;publisher_package_name.
    ls_use_access-err_sever = lo_permission-&gt;error_severity.

    APPEND ls_use_access TO ls_devc-use_accesses.
  ENDLOOP.

  APPEND ls_devc TO gt_devc.
ENDFORM.

FORM get_additional_html_devc USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_devc TYPE s_devc.
  MOVE-CORRESPONDING is_obj TO ls_devc.

  PERFORM get_2column_value_html USING &apos;Application Component&apos; ls_devc-applicat CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Translation Relevance&apos; ls_devc-translation_depth_text CHANGING ct_html.
  IF ls_devc-parentcl IS NOT INITIAL.
    PERFORM get_2column_value_html USING &apos;Super Package&apos; ls_devc-parentcl CHANGING ct_html.
  ENDIF.
  PERFORM get_2column_value_html USING &apos;Transport Layer&apos; &apos;&lt;i style=mso-bidi-font-style:normal&gt;&lt;span style=color:red&gt;Please fill in according to your own system landscape settings&lt;/span&gt;&lt;/i&gt;&apos; CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Software Component&apos; ls_devc-dlvunit CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Record Object Changes in Transport Requests&apos; ls_devc-korrflag CHANGING ct_html.
  IF ls_devc-project_id IS NOT INITIAL.
    PERFORM get_2column_value_html USING &apos;cProjects Project&apos; ls_devc-project_id CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_special_html_devc USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_devc TYPE s_devc,
        lv_html TYPE string,
        lv_tr TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string.
  FIELD-SYMBOLS: &lt;fs_use_access&gt; TYPE permission.

  MOVE-CORRESPONDING is_obj TO ls_devc.
  CHECK ls_devc-use_accesses IS NOT INITIAL.

  PERFORM get_small_title_html USING &apos;Use Accesses&apos; CHANGING lv_html.
  APPEND lv_html TO ct_html.
  APPEND gcv_table_begin TO ct_html.

  PERFORM get_column_label_html USING &apos;Package Interface&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Package&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Error Severity&apos; CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING ct_html.

  LOOP AT ls_devc-use_accesses ASSIGNING &lt;fs_use_access&gt;.
    PERFORM get_column_value_html USING &lt;fs_use_access&gt;-intf_name CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_use_access&gt;-client_pak CHANGING lv_td2.
    PERFORM get_column_value_html USING &lt;fs_use_access&gt;-err_sever CHANGING lv_td3.
    PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING ct_html.
  ENDLOOP.

  APPEND gcv_table_end TO ct_html.
  APPEND &apos;&lt;br&gt;&apos; TO ct_html.
ENDFORM.
***************** Package Close *****************

***************** Function Group Begin *****************
FORM getdata_fugr USING is_obj_header TYPE s_obj_header.
  DATA: ls_fugr TYPE s_fugr.

  MOVE-CORRESPONDING is_obj_header TO ls_fugr.
  PERFORM get_devclass USING is_obj_header CHANGING ls_fugr-devclass.
  SELECT SINGLE areat FROM tlibt INTO ls_fugr-short_text WHERE spras = sy-langu AND area = ls_fugr-obj_name.
  APPEND ls_fugr TO gt_fugr.
ENDFORM.
***************** Function Group Close *****************

***************** Domain Begin *****************
FORM getdata_doma USING is_obj_header TYPE s_obj_header.
  DATA: ls_doma        TYPE s_doma,
        lv_dm_name     TYPE ddobjname,
        ls_dd01v       TYPE dd01v.

  MOVE-CORRESPONDING is_obj_header TO ls_doma.
  PERFORM get_devclass USING is_obj_header CHANGING ls_doma-devclass.

  lv_dm_name = ls_doma-obj_name.
  CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
    EXPORTING
      name          = lv_dm_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd01v_wa      = ls_dd01v
    TABLES
      dd07v_tab     = ls_doma-value_range
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  MOVE-CORRESPONDING ls_dd01v TO ls_doma.
  ls_doma-short_text = ls_dd01v-ddtext.
  APPEND ls_doma TO gt_doma.
ENDFORM.

FORM get_additional_html_doma USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_doma TYPE s_doma.
  MOVE-CORRESPONDING is_obj TO ls_doma.

  PERFORM get_2column_value_html USING &apos;Data Type&apos; ls_doma-datatype  CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;No.Characters&apos; ls_doma-leng  CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Output Length&apos; ls_doma-outputlen  CHANGING ct_html.
  IF ls_doma-decimals GT 0.
    PERFORM get_2column_value_html USING &apos;Decimals&apos; ls_doma-decimals  CHANGING ct_html.
  ENDIF.
  IF ls_doma-lowercase IS NOT INITIAL.
    PERFORM get_2column_value_html USING &apos;Lower Case&apos; ls_doma-lowercase  CHANGING ct_html.
  ENDIF.
  IF ls_doma-signflag IS NOT INITIAL.
    PERFORM get_2column_value_html USING &apos;Sign Flag&apos; ls_doma-signflag  CHANGING ct_html.
  ENDIF.
* handle value table/value range
  IF ls_doma-entitytab IS NOT INITIAL.
    PERFORM get_2column_value_html USING &apos;Value Table&apos; ls_doma-entitytab  CHANGING ct_html.
  ENDIF.

  IF ls_doma-valexi EQ abap_true.
    DATA: lv_tr  TYPE string,
          lv_td1 TYPE string,
          lv_td2 TYPE string,
          lt_tab TYPE TABLE OF string.
    FIELD-SYMBOLS: &lt;fs_vr&gt; LIKE LINE OF ls_doma-value_range,
                   &lt;fs_htm&gt; TYPE string.

    PERFORM get_column_value_html USING &apos;Value Range&apos; CHANGING lv_td1.
    CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

    APPEND gcv_table_begin TO lt_tab.
    PERFORM get_column_label_html USING &apos;Fix.Val.&apos; CHANGING lv_td1.
    PERFORM get_column_label_html USING &apos;Short Description&apos; CHANGING lv_td2.
    PERFORM combine2td USING lv_td1 lv_td2 CHANGING lt_tab.

    LOOP AT ls_doma-value_range ASSIGNING &lt;fs_vr&gt;.
      PERFORM get_column_value_html USING &lt;fs_vr&gt;-domvalue_l CHANGING lv_td1.
      PERFORM get_column_value_html USING &lt;fs_vr&gt;-ddtext CHANGING lv_td2.
      PERFORM combine2td USING lv_td1 lv_td2 CHANGING lt_tab.
    ENDLOOP.
    APPEND gcv_table_end TO lt_tab.

    LOOP AT lt_tab ASSIGNING &lt;fs_htm&gt;.
      CONCATENATE lv_tr &lt;fs_htm&gt; INTO lv_tr.
    ENDLOOP.
    CONCATENATE lv_tr &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr.
    APPEND lv_tr TO ct_html.
  ENDIF.
ENDFORM.
***************** Domain Close *****************

***************** Data Element Begin *****************
FORM getdata_dtel USING is_obj_header TYPE s_obj_header.
  DATA: ls_dtel    TYPE s_dtel,
        lv_de_name TYPE ddobjname,
        ls_dd04v   TYPE dd04v,
        ls_tpara   TYPE tpara.

  MOVE-CORRESPONDING is_obj_header TO ls_dtel.
  PERFORM get_devclass USING is_obj_header CHANGING ls_dtel-devclass.

  lv_de_name = ls_dtel-obj_name.
  CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
    EXPORTING
      name          = lv_de_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd04v_wa      = ls_dd04v
      tpara_wa      = ls_tpara
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  MOVE-CORRESPONDING ls_dd04v TO ls_dtel.
  ls_dtel-short_text = ls_dd04v-ddtext.
  APPEND ls_dtel TO gt_dtel.
ENDFORM.

FORM get_additional_html_dtel USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_dtel TYPE s_dtel,
        lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lt_tab TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_htm&gt; TYPE string.

  MOVE-CORRESPONDING is_obj TO ls_dtel.

  PERFORM get_2column_value_html USING &apos;Domain&apos; ls_dtel-domname  CHANGING ct_html.
* field label
  PERFORM get_column_value_html USING &apos;Field Label&apos; CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  PERFORM get_column_label_html USING &apos;&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Length&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Field Label&apos; CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING &apos;Short&apos; CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen1 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_s CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING &apos;Medium&apos; CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen2 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_m CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING &apos;Long&apos; CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen3 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_l CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING &apos;Heading&apos; CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-headlen CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-reptext CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  APPEND gcv_table_end TO lt_tab.

  LOOP AT lt_tab ASSIGNING &lt;fs_htm&gt;.
    CONCATENATE lv_tr &lt;fs_htm&gt; INTO lv_tr.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr.
  APPEND lv_tr TO ct_html.
ENDFORM.
***************** Data Element Close *****************

***************** Table Begin *****************
FORM getdata_tabl USING is_obj_header TYPE s_obj_header.
  DATA: ls_tabl TYPE s_tabl,
        lv_tabname TYPE ddobjname,
        lt_dd03p   TYPE dd03ttyp,
        ls_dd02v   TYPE dd02v,
        lt_dd36m   TYPE dd36mttyp.
  FIELD-SYMBOLS: &lt;fs_dd03p&gt; TYPE dd03p.

  MOVE-CORRESPONDING is_obj_header TO ls_tabl.
  PERFORM get_devclass USING is_obj_header CHANGING ls_tabl-devclass.
  lv_tabname = ls_tabl-obj_name.

  CALL FUNCTION &apos;DDIF_TABL_GET&apos;
    EXPORTING
      name          = lv_tabname
      langu         = sy-langu
    IMPORTING
      dd02v_wa      = ls_dd02v                      &quot; table header information
      dd09l_wa      = ls_tabl-tech_setting          &quot; technical setting
    TABLES
      dd03p_tab     = ls_tabl-fields                  &quot; fields
      dd05m_tab     = ls_tabl-foreign_keys          &quot; foreign key
      dd08v_tab     = ls_tabl-foreign_key_header    &quot; foreign key headers and texts
      dd12v_tab     = ls_tabl-index_header          &quot; indexes with text
      dd17v_tab     = ls_tabl-index_fields          &quot; secondary indexes
      dd35v_tab     = ls_tabl-assignments           &quot; assignment of structure fields and search helps
      dd36m_tab     = lt_dd36m                      &quot; interface structure for field assignments table-search help
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

* namespace reservation
  SELECT * FROM tresc INTO TABLE ls_tabl-namespace WHERE object = ls_tabl-object AND tabname = ls_tabl-obj_name.
  MOVE-CORRESPONDING ls_dd02v TO ls_tabl.
  ls_tabl-short_text = ls_dd02v-ddtext.

  APPEND ls_tabl TO gt_tabl.
ENDFORM.

FORM get_additional_html_tabl USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_tabl TYPE s_tabl,
        lv_value TYPE ddfixvalue-low,
        lv_desc TYPE ddtext.
  MOVE-CORRESPONDING is_obj TO ls_tabl.

  IF ls_tabl-tabclass EQ &apos;TRANSP&apos;.
    PERFORM get_2column_value_html USING &apos;Delivery Class&apos; ls_tabl-contflag CHANGING ct_html.
    lv_value = ls_tabl-mainflag.
    PERFORM get_value_desc USING &apos;MAINFLAG&apos; lv_value CHANGING lv_desc.
    PERFORM get_2column_value_html USING &apos;Data Browser/Table View Maint.&apos; lv_desc CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_special_html_tabl USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_fields_html USING is_tabl CHANGING ct_html.
  PERFORM get_tech_setting_html USING is_tabl CHANGING ct_html.
  PERFORM get_fk_setting_html USING is_tabl CHANGING ct_html.
  PERFORM get_index_html USING is_tabl CHANGING ct_html.
  PERFORM get_namespace_html USING is_tabl CHANGING ct_html.
ENDFORM.

FORM get_fields_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_tpm TYPE string,
        lv_tmp TYPE string.

  FIELD-SYMBOLS: &lt;fs_fld&gt; LIKE LINE OF is_tabl-fields,
                 &lt;fs_htm&gt; TYPE string.

  IF is_tabl-tabclass EQ &apos;TRANSP&apos;.
    PERFORM get_small_title_html USING &apos;Fields:&apos; CHANGING lv_tmp.
    APPEND lv_tmp TO ct_html.
    CLEAR lv_tmp.

    PERFORM get_paragraph_html USING &apos;Please notice that those fields marked as blue and italic are contained in included structure/table and you don&apos;&apos;t need to add them.&apos; CHANGING lv_tmp.
    APPEND lv_tmp TO ct_html.
    CLEAR lv_tmp.
  ELSEIF is_tabl-tabclass EQ &apos;INTTAB&apos;.
    PERFORM get_small_title_html USING &apos;Components:&apos; CHANGING lv_tmp.
    APPEND lv_tmp TO ct_html.
    CLEAR lv_tmp.

    PERFORM get_paragraph_html USING &apos;Please notice that those components marked as blue and italic are contained in included structure/table and you don&apos;&apos;t need to add them.&apos; CHANGING lv_tmp.
    APPEND lv_tmp TO ct_html.
    CLEAR lv_tmp.
  ENDIF.

  APPEND gcv_table_begin TO ct_html.
  IF is_tabl-tabclass EQ &apos;TRANSP&apos;.
    DATA: lv_show_check_table_column TYPE abap_bool VALUE abap_false,
          lv_show_shlp_column TYPE abap_bool VALUE abap_false.
    LOOP AT is_tabl-fields ASSIGNING &lt;fs_fld&gt; WHERE checktable IS NOT INITIAL OR shlpname IS NOT INITIAL.
      IF &lt;fs_fld&gt;-checktable IS NOT INITIAL.
        lv_show_check_table_column = abap_true.
      ENDIF.

      IF &lt;fs_fld&gt;-shlpname IS NOT INITIAL.
        lv_show_shlp_column = abap_true.
      ENDIF.
    ENDLOOP.

    PERFORM get_column_label_html USING &apos;Field name&apos; CHANGING lv_td1.
    PERFORM get_column_label_html USING &apos;Key&apos; CHANGING lv_td2.
    PERFORM get_column_label_html USING &apos;Data Element&apos; CHANGING lv_td3.
    IF lv_show_check_table_column EQ abap_true.
      PERFORM get_column_label_html USING &apos;Check Table&apos; CHANGING lv_td4.
    ELSE.
      lv_td4 = &apos;&apos;.
    ENDIF.
    IF lv_show_shlp_column EQ abap_true.
      PERFORM get_column_label_html USING &apos;Search Help&apos; CHANGING lv_td5.
    ELSE.
      lv_td5 = &apos;&apos;.
    ENDIF.
    PERFORM combine5td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 CHANGING ct_html.

    LOOP AT is_tabl-fields ASSIGNING &lt;fs_fld&gt;.
      PERFORM get_column_value_html USING &lt;fs_fld&gt;-fieldname CHANGING lv_td1.
      PERFORM get_column_value_html USING &lt;fs_fld&gt;-keyflag CHANGING lv_td2.
      IF &lt;fs_fld&gt;-fieldname EQ &apos;.INCLUDE&apos;.
        lv_tmp = &lt;fs_fld&gt;-precfield.
      ELSE.
        lv_tmp = &lt;fs_fld&gt;-rollname.
      ENDIF.
      PERFORM get_column_value_html USING lv_tmp CHANGING lv_td3.

      IF &lt;fs_fld&gt;-adminfield NE 0.
        lv_tmp = &apos;&lt;tr style=&quot;color:blue;font-style:italic;&quot;&gt;&apos;.
      ELSE.
        lv_tmp = &apos;&lt;tr&gt;&apos;.
      ENDIF.

      IF lv_show_check_table_column EQ abap_true.
        PERFORM get_column_value_html USING &lt;fs_fld&gt;-checktable CHANGING lv_td4.
      ELSE.
        lv_td4 = &apos;&apos;.
      ENDIF.
      IF lv_show_shlp_column EQ abap_true.
        PERFORM get_column_value_html USING &lt;fs_fld&gt;-shlpname CHANGING lv_td5.
      ELSE.
        lv_td5 = &apos;&apos;.
      ENDIF.

      CONCATENATE lv_tmp lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
      APPEND lv_tr TO ct_html.
      CLEAR: lv_tr, lv_tmp.
    ENDLOOP.

  ELSEIF is_tabl-tabclass EQ &apos;INTTAB&apos;.
    PERFORM get_column_label_html USING &apos;Component&apos; CHANGING lv_td1.
    PERFORM get_column_label_html USING &apos;Typing Method&apos; CHANGING lv_td2.
    PERFORM get_column_label_html USING &apos;Data Element&apos; CHANGING lv_td3.
    PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING ct_html.

    LOOP AT is_tabl-fields ASSIGNING &lt;fs_fld&gt;.
      PERFORM get_column_value_html USING &lt;fs_fld&gt;-fieldname CHANGING lv_td1.

      PERFORM get_typing_method USING &lt;fs_fld&gt; CHANGING lv_tpm.
      PERFORM get_column_value_html USING lv_tpm CHANGING lv_td2.


      IF &lt;fs_fld&gt;-fieldname EQ &apos;.INCLUDE&apos;.
        lv_tmp = &lt;fs_fld&gt;-precfield.
      ELSE.
        lv_tmp = &lt;fs_fld&gt;-rollname.
      ENDIF.
      PERFORM get_column_value_html USING lv_tmp CHANGING lv_td3.

      IF &lt;fs_fld&gt;-adminfield NE 0.
        lv_tmp = &apos;&lt;tr style=&quot;color:blue;font-style:italic;&quot;&gt;&apos;.
      ELSE.
        lv_tmp = &apos;&lt;tr&gt;&apos;.
      ENDIF.
      CONCATENATE lv_tmp lv_td1 lv_td2 lv_td3 &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
      APPEND lv_tr TO ct_html.
      CLEAR: lv_tr, lv_tmp.
    ENDLOOP.
  ENDIF.
  APPEND gcv_table_end TO ct_html.
  APPEND &apos;&lt;br&gt;&apos; TO ct_html.
ENDFORM.

FORM get_typing_method USING is_fld TYPE dd03p CHANGING cv_typing_method TYPE string.
  DATA: lv_txt TYPE ddtext,
        lv_low TYPE ddfixvalue-low,
        lv_f_reftype TYPE f_reftype.

  CLEAR cv_typing_method.

  IF is_fld-comptype EQ c_t_ref.
    IF is_fld-reftype = c_t_boxed.    &quot; rd 05/2007
      lv_f_reftype = c_type_boxed.
    ELSE.
      lv_f_reftype = c_type_ref_to.
    ENDIF.
  ELSE.
    lv_f_reftype = c_type.
  ENDIF.

  lv_low = lv_f_reftype.
  PERFORM get_value_desc USING &apos;F_REFTYPE&apos; lv_low CHANGING lv_txt.
  CONCATENATE lv_f_reftype &apos; &apos; lv_txt INTO cv_typing_method RESPECTING BLANKS.
ENDFORM.

FORM get_tech_setting_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_td6 TYPE string,
        lv_low TYPE ddfixvalue-low,
        lv_text TYPE ddtext,
        lv_tmp TYPE string.

  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos;.

  PERFORM get_small_title_html USING &apos;Technical Settings:&apos; CHANGING lv_tmp.
  APPEND lv_tmp TO ct_html.

  APPEND gcv_table_begin TO ct_html.
  PERFORM get_column_label_html USING &apos;Data Class&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Size Category&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Buffering&apos; CHANGING lv_td3.
  PERFORM get_column_label_html USING &apos;Buffering Type&apos; CHANGING lv_td4.
  PERFORM get_column_label_html USING &apos;Log Data Changes&apos; CHANGING lv_td5.
  PERFORM get_column_label_html USING &apos;Write Access Only with Java&apos; CHANGING lv_td6.
  PERFORM combine6td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 CHANGING ct_html.

  PERFORM get_column_value_html USING is_tabl-tech_setting-tabart CHANGING lv_td1.
  PERFORM get_column_value_html USING is_tabl-tech_setting-tabkat CHANGING lv_td2.
  PERFORM get_column_value_html USING is_tabl-tech_setting-bufallow CHANGING lv_td3.

  lv_low = is_tabl-tech_setting-pufferung.
  PERFORM get_value_desc USING &apos;PUFFERUNG&apos; lv_low CHANGING lv_text.
  PERFORM get_column_value_html USING lv_text CHANGING lv_td4.

  PERFORM get_column_value_html USING is_tabl-tech_setting-protokoll CHANGING lv_td5.
  PERFORM get_column_value_html USING is_tabl-tech_setting-javaonly CHANGING lv_td6.
  PERFORM combine6td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 CHANGING ct_html.
  APPEND gcv_table_end TO ct_html.
  APPEND &apos;&lt;br&gt;&apos; TO ct_html.
ENDFORM.

FORM get_fk_setting_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_tmp TYPE string,
        lv_low TYPE ddfixvalue-low,
        lv_fkt TYPE ddtext.
  FIELD-SYMBOLS: &lt;fs_header&gt; LIKE LINE OF is_tabl-foreign_key_header,
                 &lt;fs_fk&gt; LIKE LINE OF is_tabl-foreign_keys.

  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-foreign_key_header IS NOT INITIAL AND is_tabl-foreign_keys IS NOT INITIAL.

  PERFORM get_small_title_html USING &apos;Foreign Keys:&apos; CHANGING lv_tmp.
  APPEND lv_tmp TO ct_html.

  LOOP AT is_tabl-foreign_key_header ASSIGNING &lt;fs_header&gt;.
    APPEND gcv_table_begin TO ct_html.
    PERFORM get_2column_label_html CHANGING ct_html.
    PERFORM get_2column_value_html USING &apos;Field Name&apos; &lt;fs_header&gt;-fieldname CHANGING ct_html.
    PERFORM get_2column_value_html USING &apos;Check Table&apos; &lt;fs_header&gt;-checktable CHANGING ct_html.

    PERFORM get_fk_fld_definition_html USING is_tabl &lt;fs_header&gt;-fieldname CHANGING lv_tmp.
    PERFORM get_column_value_html USING &apos;Foreign Key Fields&apos; CHANGING lv_td1.
    PERFORM get_column_innertable_html USING lv_tmp CHANGING lv_td2.
    PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
    CLEAR lv_tmp.

    CONCATENATE &apos;Check required: &apos; &lt;fs_header&gt;-checkflag &apos;&lt;br&gt;MsgNo: &apos; &lt;fs_header&gt;-msgnr &apos;&amp;nbsp;&amp;nbsp;AArea: &apos; &lt;fs_header&gt;-arbgb
      INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_2column_value_html USING &apos;Screen check&apos; lv_tmp CHANGING ct_html.
    CLEAR lv_tmp.

    lv_low = &lt;fs_header&gt;-frkart.
    PERFORM get_value_desc USING &apos;FRKART&apos; lv_low CHANGING lv_fkt.
    CONCATENATE &apos;Foreign key field type: &apos; lv_fkt &apos;&lt;br&gt;Cardinality:[&apos; &lt;fs_header&gt;-cardleft &apos; : &apos; &lt;fs_header&gt;-card &apos;]&apos;
      INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_2column_value_html USING &apos;Semantic attributes&apos; lv_tmp CHANGING ct_html.
    CLEAR lv_tmp.

    IF &lt;fs_header&gt;-ddtext IS NOT INITIAL.
      PERFORM get_2column_value_html USING &apos;Short Text&apos; &lt;fs_header&gt;-ddtext CHANGING ct_html.
    ENDIF.
    APPEND gcv_table_end TO ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDLOOP.
ENDFORM.

FORM get_fk_fld_definition_html USING is_tabl TYPE s_tabl iv_fieldname TYPE fieldname CHANGING cv_html TYPE string.
  DATA: lt_html TYPE TABLE OF string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_td6 TYPE string,
        lv_tmp TYPE string.

  FIELD-SYMBOLS: &lt;fs_fk&gt; LIKE LINE OF is_tabl-foreign_keys.

  APPEND gcv_table_begin TO lt_html.
  PERFORM get_column_label_html USING &apos;Check table&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;ChkTablFld&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;For.key table&apos; CHANGING lv_td3.
  PERFORM get_column_label_html USING &apos;Foreign Key Field&apos; CHANGING lv_td4.
  PERFORM get_column_label_html USING &apos;Generic&apos; CHANGING lv_td5.
  PERFORM get_column_label_html USING &apos;Constant&apos; CHANGING lv_td6.
  PERFORM combine6td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 CHANGING lt_html.

  LOOP AT is_tabl-foreign_keys ASSIGNING &lt;fs_fk&gt; WHERE fieldname = iv_fieldname.
    PERFORM get_column_value_html USING &lt;fs_fk&gt;-checktable CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_fk&gt;-checkfield CHANGING lv_td2.

    IF &lt;fs_fk&gt;-forkey IS INITIAL.
      lv_tmp = &apos;&apos;.
    ELSE.
      lv_tmp = &lt;fs_fk&gt;-fortable.
    ENDIF.
    PERFORM get_column_value_html USING lv_tmp CHANGING lv_td3.
    CLEAR lv_tmp.

    PERFORM get_column_value_html USING &lt;fs_fk&gt;-forkey CHANGING lv_td4.
    IF &lt;fs_fk&gt;-fortable EQ &apos;*&apos;.
      lv_tmp = abap_true.
    ELSE.
      lv_tmp = &apos;&apos;.
    ENDIF.
    PERFORM get_column_value_html USING lv_tmp CHANGING lv_td5.
    CLEAR lv_tmp.

    IF &lt;fs_fk&gt;-forkey IS INITIAL AND &lt;fs_fk&gt;-fortable NE &apos;*&apos;.
      lv_tmp = &lt;fs_fk&gt;-fortable.
    ELSE.
      lv_tmp = &apos;&apos;.
    ENDIF.
    PERFORM get_column_value_html USING lv_tmp CHANGING lv_td6.
    PERFORM combine6td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 CHANGING lt_html.
  ENDLOOP.
  APPEND gcv_table_end TO lt_html.

  PERFORM join_str USING lt_html CHANGING cv_html.
ENDFORM.

FORM join_str USING it_tab TYPE STANDARD TABLE CHANGING cv_str TYPE string.
  CLEAR cv_str.

  FIELD-SYMBOLS: &lt;fs_str&gt; TYPE string.
  LOOP AT it_tab ASSIGNING &lt;fs_str&gt;.
    CONCATENATE cv_str &lt;fs_str&gt; INTO cv_str RESPECTING BLANKS.
  ENDLOOP.
ENDFORM.

FORM get_namespace_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_tmp TYPE string.
  FIELD-SYMBOLS: &lt;fs_ns&gt; LIKE LINE OF is_tabl-namespace.
* only transparent table with delivery class E need to display namespace maintainance settings
  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-contflag EQ &apos;E&apos; AND is_tabl-namespace IS NOT INITIAL.

  PERFORM get_small_title_html USING &apos;Maintain Customer Namespace:&apos; CHANGING lv_tmp.
  APPEND lv_tmp TO ct_html.
  CLEAR lv_tmp.

  APPEND gcv_table_begin TO ct_html.
  PERFORM get_column_label_html USING &apos;Key Field&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Namespace&apos; CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.

  LOOP AT is_tabl-namespace ASSIGNING &lt;fs_ns&gt;.
    PERFORM get_column_value_html USING &lt;fs_ns&gt;-fieldname CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_ns&gt;-keylow CHANGING lv_td2.
    PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
  ENDLOOP.
  APPEND gcv_table_end TO ct_html.
ENDFORM.

FORM get_index_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_td6 TYPE string,
        lv_td7 TYPE string,
        lv_td8 TYPE string,
        lv_tmp TYPE string.
  FIELD-SYMBOLS: &lt;fs_index_header&gt; LIKE LINE OF is_tabl-index_header,
                 &lt;fs_index_fld&gt; LIKE LINE OF is_tabl-index_fields.

  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-index_header IS NOT INITIAL.

  PERFORM get_small_title_html USING &apos;Indexes:&apos; CHANGING lv_tmp.
  APPEND lv_tmp TO ct_html.
  CLEAR lv_tmp.

  APPEND gcv_table_begin TO ct_html.
  PERFORM get_column_label_html USING &apos;Index Name&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Ext.Index&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Short Text&apos; CHANGING lv_td3.
  PERFORM get_column_label_html USING &apos;Unique&apos; CHANGING lv_td4.
  PERFORM get_column_label_html USING &apos;DB index name&apos; CHANGING lv_td5.
  PERFORM get_column_label_html USING &apos;DB status&apos; CHANGING lv_td6.
  PERFORM get_column_label_html USING &apos;Inclusion/Exclusion&apos; CHANGING lv_td7.
  PERFORM get_column_label_html USING &apos;Index Flds&apos; CHANGING lv_td8.
  PERFORM combine8td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 lv_td7 lv_td8 CHANGING ct_html.

  LOOP AT is_tabl-index_header ASSIGNING &lt;fs_index_header&gt;.
    PERFORM get_column_value_html USING &lt;fs_index_header&gt;-indexname CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_index_header&gt;-isextind CHANGING lv_td2.
    PERFORM get_column_value_html USING &lt;fs_index_header&gt;-ddtext CHANGING lv_td3.
    PERFORM get_column_value_html USING &lt;fs_index_header&gt;-uniqueflag CHANGING lv_td4.
    PERFORM get_column_value_html USING &lt;fs_index_header&gt;-dbindex CHANGING lv_td5.
    PERFORM get_column_value_html USING &lt;fs_index_header&gt;-dbstate CHANGING lv_td6.
    PERFORM get_column_value_html USING &lt;fs_index_header&gt;-dbinclexcl CHANGING lv_td7.

    LOOP AT is_tabl-index_fields ASSIGNING &lt;fs_index_fld&gt; WHERE indexname = &lt;fs_index_header&gt;-indexname.
      CONCATENATE &apos;&lt;br&gt;&apos; &lt;fs_index_fld&gt;-fieldname INTO lv_tmp.
    ENDLOOP.
    SHIFT lv_tmp BY 4 PLACES.
    PERFORM get_column_value_html USING lv_tmp CHANGING lv_td8.
    CLEAR lv_tmp.

    PERFORM combine8td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 lv_td7 lv_td8 CHANGING ct_html.
  ENDLOOP.
  APPEND gcv_table_end TO ct_html.
  APPEND &apos;&lt;br&gt;&apos; TO ct_html.
ENDFORM.
***************** Table Close *****************

***************** View Begin *****************
FORM getdata_view USING is_obj_header TYPE s_obj_header.
  DATA: ls_view  TYPE s_view,
        lv_view_name TYPE ddobjname,
        ls_dd25v TYPE dd25v.

  MOVE-CORRESPONDING is_obj_header TO ls_view.
  PERFORM get_devclass USING is_obj_header CHANGING ls_view-devclass.

  lv_view_name = ls_view-obj_name.

  CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
    EXPORTING
      name          = lv_view_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v
    TABLES
      dd26v_tab     = ls_view-table_join
      dd27p_tab     = ls_view-fields
      dd28j_tab     = ls_view-join_condition
      dd28v_tab     = ls_view-selection_condition
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  MOVE-CORRESPONDING ls_dd25v TO ls_view.
  ls_view-short_text = ls_dd25v-ddtext.
  APPEND ls_view TO gt_view.
ENDFORM.

FORM get_additional_html_view USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_view TYPE s_view,
        lv_low TYPE ddfixvalue-low,
        lv_txt TYPE ddfixvalue-ddtext.
  MOVE-CORRESPONDING is_obj TO ls_view.

  lv_low = ls_view-viewgrant.
  PERFORM get_value_desc USING &apos;VIEWGRANT&apos; lv_low CHANGING lv_txt.
  PERFORM get_2column_value_html USING &apos;Access&apos; lv_txt CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Delivery Class&apos; ls_view-customauth CHANGING ct_html.

  lv_low = ls_view-globalflag.
  PERFORM get_value_desc USING &apos;MAINFLAG&apos; lv_low CHANGING lv_txt.
  PERFORM get_2column_value_html USING &apos;Data Browser/Table View Maint.&apos; lv_txt CHANGING ct_html.
ENDFORM.

FORM get_special_html_view USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_view TYPE s_view.
  MOVE-CORRESPONDING is_obj TO ls_view.
  PERFORM get_jointable_html USING ls_view CHANGING ct_html.
  PERFORM get_view_fields_html USING ls_view CHANGING ct_html.
  PERFORM get_selcondition_html USING ls_view CHANGING ct_html.
ENDFORM.

FORM get_jointable_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_tmp TYPE string,
        lv_html TYPE string,
        lt_html TYPE TABLE OF string,
        lv_cnt TYPE i.
  FIELD-SYMBOLS: &lt;fs_tb&gt; LIKE LINE OF is_view-table_join,
                 &lt;fs_jo&gt; LIKE LINE OF is_view-join_condition.

  PERFORM get_small_title_html USING &apos;Table/Join Conditions:&apos; CHANGING lv_html.
  APPEND lv_html TO ct_html.

  LOOP AT is_view-table_join ASSIGNING &lt;fs_tb&gt;.
    CONCATENATE &apos;, &apos; &lt;fs_tb&gt;-tabname INTO lv_tmp RESPECTING BLANKS.
  ENDLOOP.
  SHIFT lv_tmp BY 2 PLACES.
  CONCATENATE &apos;Tables: &apos; lv_tmp INTO lv_tmp RESPECTING BLANKS.

  PERFORM get_paragraph_html USING lv_tmp CHANGING lv_html.
  APPEND lv_html TO ct_html.

  PERFORM get_paragraph_html USING &apos;Join Conditions: &apos; CHANGING lv_html.
  APPEND lv_html TO ct_html.
  IF lines( is_view-join_condition ) GT 0.
    APPEND gcv_table_begin TO lt_html.
    PERFORM get_column_label_html USING &apos;Table&apos; CHANGING lv_td1.
    PERFORM get_column_label_html USING &apos;Field Name&apos; CHANGING lv_td2.
    PERFORM get_column_label_html USING &apos;=&apos; CHANGING lv_td3.
    PERFORM get_column_label_html USING &apos;Table&apos; CHANGING lv_td4.
    PERFORM get_column_label_html USING &apos;Field Name&apos; CHANGING lv_td5.
    PERFORM combine5td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 CHANGING lt_html.

    LOOP AT is_view-join_condition ASSIGNING &lt;fs_jo&gt; WHERE rfield IS NOT INITIAL.
      ADD 1 TO lv_cnt.
      PERFORM get_column_value_html USING &lt;fs_jo&gt;-ltab CHANGING lv_td1.
      PERFORM get_column_value_html USING &lt;fs_jo&gt;-lfield CHANGING lv_td2.
      PERFORM get_column_value_html USING &apos;=&apos; CHANGING lv_td3.
      PERFORM get_column_value_html USING &lt;fs_jo&gt;-rtab CHANGING lv_td4.
      PERFORM get_column_value_html USING &lt;fs_jo&gt;-rfield CHANGING lv_td5.
      PERFORM combine5td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 CHANGING lt_html.
    ENDLOOP.

    APPEND gcv_table_end TO lt_html.
    CHECK lv_cnt GT 0.
    APPEND LINES OF lt_html TO ct_html.
  ELSE.
    PERFORM get_paragraph_html USING &apos;&lt;i&gt;No additional join condition needs to be maintained here.&lt;/i&gt;&apos; CHANGING lv_html.
    APPEND lv_html TO ct_html.
  ENDIF.

  APPEND &apos;&lt;br&gt;&apos; TO ct_html.
ENDFORM.

FORM get_view_fields_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_td6 TYPE string,
        lv_html TYPE string.
  FIELD-SYMBOLS: &lt;fs_fld&gt; LIKE LINE OF is_view-fields.

  PERFORM get_small_title_html USING &apos;View Flds:&apos; CHANGING lv_html.
  APPEND lv_html TO ct_html.

  APPEND gcv_table_begin TO ct_html.
  PERFORM get_column_label_html USING &apos;View Field&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Table&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Field&apos; CHANGING lv_td3.
  PERFORM get_column_label_html USING &apos;P&apos; CHANGING lv_td4.
  PERFORM get_column_label_html USING &apos;Key&apos; CHANGING lv_td5.
  PERFORM get_column_label_html USING &apos;Mod&apos; CHANGING lv_td6.
  PERFORM combine6td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 CHANGING ct_html.

  LOOP AT is_view-fields ASSIGNING &lt;fs_fld&gt;.
    PERFORM get_column_value_html USING &lt;fs_fld&gt;-viewfield CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_fld&gt;-tabname CHANGING lv_td2.
    PERFORM get_column_value_html USING &lt;fs_fld&gt;-fieldname CHANGING lv_td3.
    PERFORM get_column_value_html USING &lt;fs_fld&gt;-rdonly CHANGING lv_td4.
    PERFORM get_column_value_html USING &lt;fs_fld&gt;-keyflag CHANGING lv_td5.
    PERFORM get_column_value_html USING &lt;fs_fld&gt;-rollchange CHANGING lv_td6.
    PERFORM combine6td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 CHANGING ct_html.
  ENDLOOP.

  APPEND gcv_table_end TO ct_html.
  APPEND &apos;&lt;br&gt;&apos; TO ct_html.
ENDFORM.

FORM get_selcondition_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_html TYPE string.
  FIELD-SYMBOLS: &lt;fs_sel&gt; LIKE LINE OF is_view-selection_condition.

  PERFORM get_small_title_html USING &apos;Selection conditions:&apos; CHANGING lv_html.
  APPEND lv_html TO ct_html.

  IF is_view-selection_condition IS INITIAL.
    PERFORM get_paragraph_html USING &apos;&lt;i&gt;No additional selection condition needs to be maintained here.&lt;/i&gt;&apos; CHANGING lv_html.
    APPEND lv_html TO ct_html.
  ELSE.
    APPEND gcv_table_begin TO ct_html.
    PERFORM get_column_label_html USING &apos;Table&apos; CHANGING lv_td1.
    PERFORM get_column_label_html USING &apos;Field name&apos; CHANGING lv_td2.
    PERFORM get_column_label_html USING &apos;Operator&apos; CHANGING lv_td3.
    PERFORM get_column_label_html USING &apos;Comparison value&apos; CHANGING lv_td4.
    PERFORM get_column_label_html USING &apos;AND/OR&apos; CHANGING lv_td5.
    PERFORM combine5td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 CHANGING ct_html.

    LOOP AT is_view-selection_condition ASSIGNING &lt;fs_sel&gt;.
      PERFORM get_column_value_html USING &lt;fs_sel&gt;-tabname CHANGING lv_td1.
      PERFORM get_column_value_html USING &lt;fs_sel&gt;-fieldname CHANGING lv_td2.
      PERFORM get_column_value_html USING &lt;fs_sel&gt;-operator CHANGING lv_td3.
      PERFORM get_column_value_html USING &lt;fs_sel&gt;-constants CHANGING lv_td4.
      PERFORM get_column_value_html USING &lt;fs_sel&gt;-and_or CHANGING lv_td5.
      PERFORM combine5td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 CHANGING ct_html.
    ENDLOOP.

    APPEND gcv_table_end TO ct_html.
  ENDIF.
  APPEND &apos;&lt;br&gt;&apos; TO ct_html.
ENDFORM.
***************** View Close *****************

***************** View cluster Begin *****************
FORM getdata_vcls USING is_obj_header TYPE s_obj_header.
  DATA: ls_vcls         TYPE s_vcls,
        lv_vcls_name    TYPE vcl_name,
        ls_vcldir       TYPE v_vcldir.

  MOVE-CORRESPONDING is_obj_header TO ls_vcls.
  PERFORM get_devclass USING is_obj_header CHANGING ls_vcls-devclass.

  lv_vcls_name = ls_vcls-obj_name.
  CALL FUNCTION &apos;VIEWCLUSTER_GET_DEFINITION&apos;
    EXPORTING
      vclname                = lv_vcls_name
    IMPORTING
      vcldir_entry           = ls_vcldir
    TABLES
      vclstruc_tab           = ls_vcls-object_stru
      vclstrudep_tab         = ls_vcls-field_dep
      vclmf_tab              = ls_vcls-events
    EXCEPTIONS
      viewcluster_not_found  = 1
      incomplete_viewcluster = 2
      OTHERS                 = 3.                           &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

* TODO : variants
  ls_vcls-short_text = ls_vcldir-text.
  APPEND ls_vcls TO gt_vcls.
ENDFORM.

FORM get_additional_html_vcls USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_vcls TYPE s_vcls,
        lv_objstru TYPE string,
        lv_fld_dep TYPE string.
  MOVE-CORRESPONDING is_obj TO ls_vcls.

  PERFORM get_2column_value_html USING &apos;Hierarchical Maintenance Operation Handling&apos; ls_vcls-hieropsoff CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Read Type&apos; ls_vcls-readkind CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Object Structure&apos; lv_objstru CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Field Dependence&apos; lv_fld_dep CHANGING ct_html.
  PERFORM get_maint_events_html USING ls_vcls-events CHANGING ct_html.
ENDFORM.
***************** View cluster Close *****************

***************** Definition of a Maintenance and Transport Object Begin *****************
FORM getdata_tobj USING is_obj_header TYPE s_obj_header.
  DATA: ls_tobj TYPE s_tobj,
        ls_tvdir TYPE tvdir,
        lv_len   TYPE i,
        ls_tddat TYPE tddat.

  MOVE-CORRESPONDING is_obj_header TO ls_tobj.
  PERFORM get_devclass USING is_obj_header CHANGING ls_tobj-devclass.
  lv_len = strlen( ls_tobj-obj_name ) - 1.
  SELECT SINGLE * FROM tvdir INTO ls_tvdir WHERE tabname = ls_tobj-obj_name(lv_len).
  MOVE-CORRESPONDING ls_tvdir TO ls_tobj.
  ls_tobj-fg_devclass = ls_tvdir-devclass.
  SELECT SINGLE * FROM tddat INTO ls_tddat WHERE tabname = ls_tvdir-tabname.
  MOVE-CORRESPONDING ls_tddat TO ls_tobj.
  SELECT * FROM tvimf INTO CORRESPONDING FIELDS OF TABLE ls_tobj-events WHERE tabname = ls_tobj-obj_name.

  APPEND ls_tobj TO gt_tobj.
ENDFORM.

FORM get_additional_html_tobj USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_tobj TYPE s_tobj,
        lv_type TYPE string VALUE &apos;One Step&apos;.
  MOVE-CORRESPONDING is_obj TO ls_tobj.


  PERFORM get_2column_value_html USING &apos;View&apos; ls_tobj-tabname CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Authorization Group&apos; ls_tobj-cclass CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Function Group&apos; ls_tobj-area CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Package&apos; ls_tobj-fg_devclass CHANGING ct_html.
  IF ls_tobj-type EQ 2.
    lv_type = &apos;Two Step&apos;.
  ENDIF.
  PERFORM get_2column_value_html USING &apos;Maintenance type&apos; lv_type CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Overview screen&apos; ls_tobj-liste CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Single screen&apos; ls_tobj-detail CHANGING ct_html.
  PERFORM get_maint_events_html USING ls_tobj-events CHANGING ct_html.
ENDFORM.

FORM get_maint_events_html USING it_events TYPE STANDARD TABLE CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_tmp TYPE string,
        lt_tab TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_ev&gt; TYPE any,
                 &lt;fs_tmp&gt; TYPE any,
                 &lt;fs_htm&gt; TYPE string.

  CHECK it_events IS NOT INITIAL.

  PERFORM get_column_value_html USING &apos;Events&apos; CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  PERFORM get_column_label_html USING &apos;Event Type&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Form routine&apos; CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING lt_tab.

  LOOP AT it_events ASSIGNING &lt;fs_ev&gt;.
    ASSIGN COMPONENT &apos;EVENT&apos; OF STRUCTURE &lt;fs_ev&gt; TO &lt;fs_tmp&gt;.
    lv_tmp = &lt;fs_tmp&gt;.
    PERFORM get_column_value_html USING lv_tmp CHANGING lv_td1.
    CLEAR lv_tmp.
    UNASSIGN &lt;fs_tmp&gt;.

    ASSIGN COMPONENT &apos;FORMNAME&apos; OF STRUCTURE &lt;fs_ev&gt; TO &lt;fs_tmp&gt;.
    lv_tmp = &lt;fs_tmp&gt;.
    PERFORM get_column_value_html USING lv_tmp CHANGING lv_td2.
    CLEAR lv_tmp.
    UNASSIGN &lt;fs_tmp&gt;.

    PERFORM combine2td USING lv_td1 lv_td2 CHANGING lt_tab.
  ENDLOOP.
  APPEND gcv_table_end TO lt_tab.

  LOOP AT lt_tab ASSIGNING &lt;fs_htm&gt;.
    CONCATENATE lv_tr &lt;fs_htm&gt; INTO lv_tr.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr.
  APPEND lv_tr TO ct_html.
ENDFORM.
***************** Definition of a Maintenance and Transport Object Close *****************

***************** Search Help Begin *****************
FORM getdata_shlp USING is_obj_header TYPE s_obj_header.
  DATA: ls_shlp TYPE s_shlp,
        lv_shlp_name TYPE ddobjname,
        ls_dd30v TYPE dd30v,
        lt_dd31v TYPE TABLE OF dd31v,
        lt_dd33v TYPE TABLE OF dd33v.

  MOVE-CORRESPONDING is_obj_header TO ls_shlp.
  PERFORM get_devclass USING is_obj_header CHANGING ls_shlp-devclass.

  lv_shlp_name = ls_shlp-obj_name.
  CALL FUNCTION &apos;DDIF_SHLP_GET&apos;
    EXPORTING
      name          = lv_shlp_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd30v_wa      = ls_dd30v
    TABLES
      dd31v_tab     = lt_dd31v
      dd32p_tab     = ls_shlp-params
      dd33v_tab     = lt_dd33v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  MOVE-CORRESPONDING ls_dd30v TO ls_shlp.
  ls_shlp-short_text = ls_dd30v-ddtext.
  APPEND ls_shlp TO gt_shlp.
ENDFORM.

FORM get_additional_html_shlp USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_shlp TYPE s_shlp,
        lv_type TYPE string VALUE &apos;Collective&apos;.
  MOVE-CORRESPONDING is_obj TO ls_shlp.

  IF ls_shlp-issimple EQ abap_true.
    lv_type = &apos;Elementary&apos;.
  ENDIF.
  PERFORM get_2column_value_html USING &apos;Type&apos; lv_type CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Selection method&apos; ls_shlp-selmethod CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Dialog type&apos; ls_shlp-dialogtype CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Hot key&apos; ls_shlp-hotkey CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Search help exit&apos; ls_shlp-selmexit CHANGING ct_html.

  CHECK ls_shlp-params IS NOT INITIAL.

  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lv_td5 TYPE string,
        lv_td6 TYPE string,
        lv_td7 TYPE string,
        lv_td8 TYPE string,
        lv_td9 TYPE string,
        lt_tab TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_param&gt; LIKE LINE OF ls_shlp-params,
                 &lt;fs_htm&gt; TYPE string.

  PERFORM get_column_value_html USING &apos;Parameters&apos; CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  PERFORM get_column_label_html USING &apos;Search help Parameter&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;IMP&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;EXP&apos; CHANGING lv_td3.
  PERFORM get_column_label_html USING &apos;LPos&apos; CHANGING lv_td4.
  PERFORM get_column_label_html USING &apos;SPos&apos; CHANGING lv_td5.
  PERFORM get_column_label_html USING &apos;SDis&apos; CHANGING lv_td6.
  PERFORM get_column_label_html USING &apos;Data element&apos; CHANGING lv_td7.
  PERFORM get_column_label_html USING &apos;Modified&apos; CHANGING lv_td8.
  PERFORM get_column_label_html USING &apos;Default value&apos; CHANGING lv_td9.
  PERFORM combine9td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 lv_td7 lv_td8 lv_td9 CHANGING lt_tab.

  LOOP AT ls_shlp-params ASSIGNING &lt;fs_param&gt;.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-fieldname CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-shlpinput CHANGING lv_td2.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-shlpoutput CHANGING lv_td3.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-shlpselpos CHANGING lv_td4.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-shlplispos CHANGING lv_td5.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-shlpseldis CHANGING lv_td6.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-rollname CHANGING lv_td7.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-rollchange CHANGING lv_td8.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-defaultval CHANGING lv_td9.
    PERFORM combine9td USING lv_td1 lv_td2 lv_td3 lv_td4 lv_td5 lv_td6 lv_td7 lv_td8 lv_td9 CHANGING lt_tab.
  ENDLOOP.
  APPEND gcv_table_end TO lt_tab.

  LOOP AT lt_tab ASSIGNING &lt;fs_htm&gt;.
    CONCATENATE lv_tr &lt;fs_htm&gt; INTO lv_tr.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr.
  APPEND lv_tr TO ct_html.
ENDFORM.
***************** Search Help Close *****************

***************** Lock Object Begin *****************
FORM getdata_enqu USING is_obj_header TYPE s_obj_header.
  DATA: ls_enqu TYPE s_enqu,
        ls_dd25v     TYPE dd25v,
        lt_dd27p     TYPE TABLE OF dd27p,
        lv_lock_name TYPE ddobjname.

  MOVE-CORRESPONDING is_obj_header TO ls_enqu.
  PERFORM get_devclass USING is_obj_header CHANGING ls_enqu-devclass.

  lv_lock_name = ls_enqu-obj_name.
  CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
    EXPORTING
      name          = lv_lock_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v &quot;lock object attributes(similar as that of view)
    TABLES
      dd26e_tab     = ls_enqu-base_tables &quot;base tables
      dd27p_tab     = lt_dd27p &quot;view fields
      ddena_tab     = ls_enqu-lock_params &quot;lock argument fields
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  ls_enqu-short_text = ls_dd25v-ddtext.
  APPEND ls_enqu TO gt_enqu.
ENDFORM.

FORM get_additional_html_enqu USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_enqu TYPE s_enqu.
  MOVE-CORRESPONDING is_obj TO ls_enqu.

  PERFORM get_2column_value_html USING &apos;Allow RFC&apos; ls_enqu-rfcenable CHANGING ct_html.
  PERFORM get_base_tables_html USING ls_enqu CHANGING ct_html.
  PERFORM get_lock_params_html USING ls_enqu CHANGING ct_html.
ENDFORM.

FORM get_base_tables_html USING is_enqu TYPE s_enqu CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lt_tab TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_bt&gt; LIKE LINE OF is_enqu-base_tables,
                 &lt;fs_htm&gt; TYPE string.

  PERFORM get_column_value_html USING &apos;Tables&apos; CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  PERFORM get_column_label_html USING &apos;Type&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Name&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Lock Mode&apos; CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  LOOP AT is_enqu-base_tables ASSIGNING &lt;fs_bt&gt;.
    PERFORM get_column_value_html USING &lt;fs_bt&gt;-tabpos CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_bt&gt;-tabname CHANGING lv_td2.
    PERFORM get_column_value_html USING &lt;fs_bt&gt;-enqmode CHANGING lv_td3.
    PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.
  ENDLOOP.
  APPEND gcv_table_end TO lt_tab.

  LOOP AT lt_tab ASSIGNING &lt;fs_htm&gt;.
    CONCATENATE lv_tr &lt;fs_htm&gt; INTO lv_tr.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr.
  APPEND lv_tr TO ct_html.
ENDFORM.

FORM get_lock_params_html USING is_enqu TYPE s_enqu CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string,
        lv_td4 TYPE string,
        lt_tab TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_param&gt; LIKE LINE OF is_enqu-lock_params,
                 &lt;fs_htm&gt; TYPE string.

  PERFORM get_column_value_html USING &apos;Parameters&apos; CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  PERFORM get_column_label_html USING &apos;W&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Lock Parameter&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Table&apos; CHANGING lv_td3.
  PERFORM get_column_label_html USING &apos;Field&apos; CHANGING lv_td3.
  PERFORM combine4td USING lv_td1 lv_td2 lv_td3 lv_td4 CHANGING lt_tab.

  LOOP AT is_enqu-lock_params ASSIGNING &lt;fs_param&gt;.
    PERFORM get_column_value_html USING abap_true CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-viewfield CHANGING lv_td2.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-tabname CHANGING lv_td3.
    PERFORM get_column_value_html USING &lt;fs_param&gt;-fieldname CHANGING lv_td4.
    PERFORM combine4td USING lv_td1 lv_td2 lv_td3 lv_td4 CHANGING lt_tab.
  ENDLOOP.
  APPEND gcv_table_end TO lt_tab.

  LOOP AT lt_tab ASSIGNING &lt;fs_htm&gt;.
    CONCATENATE lv_tr &lt;fs_htm&gt; INTO lv_tr.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr.
  APPEND lv_tr TO ct_html.
ENDFORM.
***************** Lock Object Close *****************

***************** Table Type Begin *****************
FORM getdata_ttyp USING is_obj_header TYPE s_obj_header.
  DATA: ls_ttyp TYPE s_ttyp,
        lv_ttype_name TYPE ddobjname,
        ls_dd40v      TYPE dd40v.

  MOVE-CORRESPONDING is_obj_header TO ls_ttyp.
  PERFORM get_devclass USING is_obj_header CHANGING ls_ttyp-devclass.

  lv_ttype_name = ls_ttyp-obj_name.
  CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
    EXPORTING
      name          = lv_ttype_name
      langu         = sy-langu
    IMPORTING
      dd40v_wa      = ls_dd40v
    TABLES
      dd42v_tab     = ls_ttyp-primary_key
      dd43v_tab     = ls_ttyp-secondary_key
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  MOVE-CORRESPONDING ls_dd40v TO ls_ttyp.
  ls_ttyp-short_text = ls_dd40v-ddtext.
  APPEND ls_ttyp TO gt_ttyp.
ENDFORM.

FORM get_additional_html_ttyp USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_ttyp TYPE s_ttyp.
  MOVE-CORRESPONDING is_obj TO ls_ttyp.

  PERFORM get_2column_value_html USING &apos;Line Type&apos; ls_ttyp-rowtype CHANGING ct_html.
ENDFORM.
***************** Table Type Close *****************

***************** Number Range Objects Begin *****************
FORM getdata_nrob USING is_obj_header TYPE s_obj_header.
  DATA: ls_nrob TYPE s_nrob,
        lv_object TYPE tnro-object,
        ls_tnro   TYPE tnro,
        ls_tnrot  TYPE tnrot.

  MOVE-CORRESPONDING is_obj_header TO ls_nrob.
  PERFORM get_devclass USING is_obj_header CHANGING ls_nrob-devclass.

  lv_object = ls_nrob-obj_name.
  CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_READ&apos;
    EXPORTING
      object            = lv_object
    IMPORTING
      object_attributes = ls_tnro
      object_text       = ls_tnrot
    EXCEPTIONS
      object_not_found  = 1
      OTHERS            = 2.                                &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  MOVE-CORRESPONDING ls_tnro TO ls_nrob.
  MOVE-CORRESPONDING ls_tnrot TO ls_nrob.
  ls_nrob-short_text = ls_tnrot-txtshort.
  ls_nrob-object = is_obj_header-object.
  APPEND ls_nrob TO gt_nrob.
ENDFORM.

FORM get_additional_html_nrob USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_nrob TYPE s_nrob.
  MOVE-CORRESPONDING is_obj TO ls_nrob.

  PERFORM get_2column_value_html USING &apos;Long text&apos; ls_nrob-txt CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Subobject Data Element&apos; ls_nrob-dtelsobj CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Number Length Domain&apos; ls_nrob-domlen CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;% Warning&apos; ls_nrob-percentage CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;To-year Flag&apos; ls_nrob-yearind CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;No rolling &apos; ls_nrob-nonrswap CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;NR Transaction&apos; ls_nrob-code CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Buffering&apos; ls_nrob-buffer CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;No. of Numbers in Buffer&apos; ls_nrob-noivbuffer CHANGING ct_html.
ENDFORM.
***************** Number Range Objects Close *****************

***************** Message Class: Definition and All Short Texts Begin *****************
FORM getdata_msad USING is_obj_header TYPE s_obj_header.
  DATA: ls_msad TYPE s_msad.
  PERFORM get_msg_attr USING is_obj_header CHANGING ls_msad.
  APPEND ls_msad TO gt_msad.
ENDFORM.

FORM get_msg_attr USING is_obj_header TYPE s_obj_header CHANGING cs_msg TYPE s_msad.
  CLEAR cs_msg.

  MOVE-CORRESPONDING is_obj_header TO cs_msg.
  PERFORM get_devclass USING is_obj_header CHANGING cs_msg-devclass.
  SELECT SINGLE stext FROM t100t INTO cs_msg-short_text
    WHERE sprsl = sy-langu AND arbgb = cs_msg-obj_name.
* TODO: delta change records: not all message texts but only thoese we added or modified
  SELECT * FROM t100 INTO TABLE cs_msg-message_texts WHERE sprsl = sy-langu AND arbgb = cs_msg-obj_name.
ENDFORM.

FORM get_additional_html_msad USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_msad TYPE s_msad.
  MOVE-CORRESPONDING is_obj TO ls_msad.

  DATA: lv_tr  TYPE string,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lt_tab TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_msg&gt; LIKE LINE OF ls_msad-message_texts,
                 &lt;fs_htm&gt; TYPE string.

  PERFORM get_column_value_html USING &apos;Messages&apos; CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  PERFORM get_column_label_html USING &apos;Message&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Message Short Text&apos; CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING lt_tab.

  LOOP AT ls_msad-message_texts ASSIGNING &lt;fs_msg&gt;.
    PERFORM get_column_value_html USING &lt;fs_msg&gt;-msgnr CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_msg&gt;-text CHANGING lv_td2.
    PERFORM combine2td USING lv_td1 lv_td2 CHANGING lt_tab.
  ENDLOOP.
  APPEND gcv_table_end TO lt_tab.

  LOOP AT lt_tab ASSIGNING &lt;fs_htm&gt;.
    CONCATENATE lv_tr &lt;fs_htm&gt; INTO lv_tr.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr.
  APPEND lv_tr TO ct_html.
ENDFORM.
***************** Message Class: Definition and All Short Texts Close *****************

***************** Message Class Begin *****************
FORM getdata_msag USING is_obj_header TYPE s_obj_header.
  DATA: ls_msag TYPE s_msag.
  PERFORM get_msg_attr USING is_obj_header CHANGING ls_msag.
  APPEND ls_msag TO gt_msag.
ENDFORM.

FORM get_additional_html_msag USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_additional_html_msad USING is_obj CHANGING ct_html.
ENDFORM.
***************** Message Class Close *****************

***************** Message Class Begin *****************
FORM getdata_mess USING is_obj_header TYPE s_obj_header.
  DATA: ls_mess TYPE s_mess,
        lv_len  TYPE i.
  lv_len = strlen( is_obj_header-obj_name ) - 3.
  ls_mess-arbgb = is_obj_header-obj_name(lv_len).
  ls_mess-msgnr = is_obj_header-obj_name+lv_len(3).
  SELECT SINGLE text FROM t100 INTO ls_mess-text WHERE sprsl = sy-langu AND arbgb = ls_mess-arbgb.
  APPEND ls_mess TO gt_mess.
ENDFORM.

FORM convert_mess.
  DATA: lv_html TYPE string,
        lt_html TYPE TABLE OF string,
        ls_obj_header TYPE s_obj_header,
        lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_td3 TYPE string.
  FIELD-SYMBOLS: &lt;fs_mess&gt; TYPE s_mess.

  CHECK gt_mess IS NOT INITIAL.
  PERFORM get_header_html USING &apos;MESS&apos; CHANGING lv_html.
  APPEND lv_html TO lt_html.
  PERFORM get_small_title_html USING &apos;Main messages with short text under message class as listed in the below&lt;br&gt;&apos; CHANGING lv_html.
  APPEND lv_html TO lt_html.

  APPEND gcv_table_begin TO lt_html.
  PERFORM get_column_label_html USING &apos;Message Class&apos; CHANGING lv_td1.
  PERFORM get_column_label_html USING &apos;Message&apos; CHANGING lv_td2.
  PERFORM get_column_label_html USING &apos;Message Short Text&apos; CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_html.
  LOOP AT gt_mess ASSIGNING &lt;fs_mess&gt;.
    PERFORM get_column_value_html USING &lt;fs_mess&gt;-arbgb CHANGING lv_td1.
    PERFORM get_column_value_html USING &lt;fs_mess&gt;-msgnr CHANGING lv_td2.
    PERFORM get_column_value_html USING &lt;fs_mess&gt;-text CHANGING lv_td3.
    PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_html.

    MOVE-CORRESPONDING &lt;fs_mess&gt; TO ls_obj_header.
    PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
  ENDLOOP.
  APPEND gcv_table_end TO lt_html.
  APPEND LINES OF lt_html TO gt_html.
ENDFORM.
***************** Message Class Close *****************

***************** View Maintenance: Data Begin *****************
FORM getdata_vdat USING is_obj_header TYPE s_obj_header.
  DATA: ls_vdat TYPE s_vdat.

  MOVE-CORRESPONDING is_obj_header TO ls_vdat.

  APPEND ls_vdat TO gt_vdat.
ENDFORM.

FORM get_additional_html_vdat USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_vdat TYPE s_vdat.
  MOVE-CORRESPONDING is_obj TO ls_vdat.
ENDFORM.
FORM get_special_html_vdat USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA ls_vdat TYPE s_vdat.
  MOVE-CORRESPONDING is_obj TO ls_vdat.
ENDFORM.
***************** View Maintenance: Data Close *****************

***************** Transaction Begin *****************
FORM getdata_tran USING is_obj_header TYPE s_obj_header.
  DATA: ls_tran TYPE s_tran.

  MOVE-CORRESPONDING is_obj_header TO ls_tran.
  PERFORM get_devclass USING is_obj_header CHANGING ls_tran-devclass.

  SELECT SINGLE * FROM tstcv INTO ls_tran-basic_info WHERE tcode = ls_tran-obj_name AND sprsl = sy-langu.
  SELECT SINGLE * FROM tstcc INTO ls_tran-ext_info WHERE tcode = ls_tran-obj_name.
  SELECT SINGLE param FROM tstcp INTO ls_tran-param WHERE tcode = ls_tran-obj_name.
  SELECT * FROM tstca INTO TABLE ls_tran-authority WHERE tcode = ls_tran-obj_name.
  SELECT SINGLE * FROM tstcclass INTO ls_tran-uiclass WHERE tcode = ls_tran-obj_name.
  ls_tran-short_text = ls_tran-basic_info-ttext.

  APPEND ls_tran TO gt_tran.
ENDFORM.

FORM get_additional_html_tran USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_tran TYPE s_tran,
        lv_tcode_type TYPE string,
        lv_classfication TYPE string,
        lv_default_values TYPE string.

  MOVE-CORRESPONDING is_obj TO ls_tran.
  PERFORM get_classfication_html USING ls_tran CHANGING lv_classfication.
  PERFORM get_default_values_html USING ls_tran CHANGING lv_default_values.

  PERFORM get_2column_value_html USING &apos;Transaction Type&apos; lv_tcode_type CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Classfication&apos; lv_classfication CHANGING ct_html.
  PERFORM get_2column_value_html USING &apos;Default Values&apos; lv_default_values CHANGING ct_html.
ENDFORM.

FORM get_classfication_html USING is_tran TYPE s_tran CHANGING cv_html TYPE string.
  DATA: lv_tmp TYPE string,
        lt_html TYPE TABLE OF string.
  PERFORM get_small_title_html USING &apos;Classfication&apos; CHANGING lv_tmp.

ENDFORM.

FORM get_default_values_html USING is_tran TYPE s_tran CHANGING cv_html TYPE string.
  DATA: lv_tmp TYPE string,
        lt_html TYPE TABLE OF string.
  PERFORM get_small_title_html USING &apos;Default Values for&apos; CHANGING lv_tmp.
ENDFORM.
***************** Transaction Close *****************

***************** Easter Eggs By Gang Of Eggache *****************
FORM get_user_info CHANGING cv_male TYPE abap_bool cv_fullname TYPE string.
  DATA: ls_user_addr  TYPE bapiaddr3,
        lv_len1  TYPE i,
        lv_len2  TYPE i,
        lt_return_tab TYPE TABLE OF bapiret2.

  CALL FUNCTION &apos;BAPI_USER_GET_DETAIL&apos;
    EXPORTING
      username      = sy-uname
      cache_results = &apos;X&apos;
    IMPORTING
      address       = ls_user_addr
    TABLES
      return        = lt_return_tab.

  CLEAR: cv_male, cv_fullname.

  IF ls_user_addr-title_p IS NOT INITIAL AND strlen( ls_user_addr-title_p ) GE 2.
    TRANSLATE ls_user_addr-title_p TO UPPER CASE.
    cv_male = boolc( sy-langu EQ &apos;E&apos; AND ls_user_addr-title_p(2) EQ &apos;MR&apos; ).
  ENDIF.

  cv_fullname = ls_user_addr-fullname.
ENDFORM.

FORM easter_egg.
  DATA: lv_random TYPE i,
        lv_result TYPE tzonref-tstamps,
        ole       TYPE ole2_object,
        voice     TYPE ole2_object,
        lt_return_tab TYPE TABLE OF bapiret2,
        lv_text  TYPE string.

  CHECK p_voice EQ abap_true.

  CREATE OBJECT voice &apos;sapi.spvoice&apos;.
* Sound Of Eggache, you might feel not so good, or you might laugh in joy
  lv_text = &apos;Hey man, my eggs had been shaken so that yours will not. &apos; &amp;
            &apos;Come on, join the Gang founded by Brother Egg now, DO NOT hesitate anymore!&apos;.

  CALL FUNCTION &apos;GENERAL_GET_RANDOM_INT&apos;
    EXPORTING
      range  = 10
    IMPORTING
      random = lv_random.
  lv_result = lv_random MOD 7.

* I dare not to let system read an eggache message to ladies
  IF gv_male EQ abap_false OR lv_result NE 0.
    CLEAR lv_text.
* Sound Of Eggachelessness, you might feel good, but you won&apos;t laugh in joy
    CONCATENATE &apos;Dear &apos; gv_username &apos;, thank you for using this small tool, have a nice day and hope to see you again, goodbye&apos;
     INTO lv_text RESPECTING BLANKS.
  ENDIF.

  CALL METHOD OF
      voice
      &apos;Speak&apos; = ole
    EXPORTING
      #1      = lv_text.
ENDFORM.
***************** Easter Eggs By Gang Of Eggache *****************</source>
 </PROG>
 <PROG NAME="YNOT" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Note Pre-Implementation Documentation Automatic Generation Tool" LENGTH="69 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  YNOT
*&amp; Author: Joker @ SAP Labs China FGI
*&amp;---------------------------------------------------------------------*
*&amp; Function Description:
*&amp; This report will collect objects data from several released transport
*&amp;  request and generate a documentation for note pre-implementation.
*&amp; Those objects cannot be shipped via note automatically need to be
*&amp;  maintained by customer according to instruction step by step, and this
*&amp;  tool aims to reduce the effort of writing instruction documentation.
*&amp;---------------------------------------------------------------------*
*&amp; Supported Object Types(Total: 33):
*&amp; -  DEVC : Package
*&amp; -  DEVP : Package: Usage
*&amp; -  PINF : Package: Interface
*&amp; -  FUGR/FUGT : Function Group (Texts)
*&amp; -  DOMA/DOMD : Domain (Definition)
*&amp; -  DTEL/DTED : Data Element (Definition)
*&amp; -  TABL/TABD/TABT/INDX : Table (Definition/Technical Setting/Index)
*&amp; -  VIEW/VIED/VIET : View (Definition / Technical Attributes)
*&amp; -  VCLS : View cluster
*&amp; -  TOBJ : Definition of a Maintenance and Transport Object
*&amp; -  SHLP/SHLD : Search Help (Definition)
*&amp; -  ENQU/ENQD : Lock Object (Definition)
*&amp; -  TTYP/TTYD : Table Type (Definition)
*&amp; -  NROB : Number Range Objects
*&amp; -  DOCU : Documentation(TODO: DOCT/DOCV)
*&amp; -  MSAD/MSAG : Message Class (Definition and All Short Texts)
*&amp; -  MESS : Single Message
*&amp; -  TRAN : Transaction
*&amp; -  CDAT : View Cluster Maintenance Data
*&amp; -  VDAT : View Maintenance Data
*&amp; -  TABU : Table Contents
*&amp;---------------------------------------------------------------------*
*&amp; Limitations(including but not limited to):
*&amp;  1.Generated File is html which is word compatible, but the auto list
*&amp;    item adjustment(and maybe some other features also) is missing
*&amp;  2.Only English and German are available
*&amp;  3.Cannot detect delta change mode for all objects, however we can add
*&amp;    objects into excluded list as a workaround.
*&amp;---------------------------------------------------------------------*
*&amp; Report Message:
*&amp;  This tool as a infant is not robust and might result in new troubules,
*&amp;    any feedback is of great help to let it grows up and becomes strong.
*&amp;  So if you find any issue when you use this tool, please kindly write
*&amp;    email to joker.yang@sap.corp, I will try to fix them ASAP.
*&amp;---------------------------------------------------------------------*
*&amp; Inspiration From &amp; Thanks To:
*&amp;  1.Z_METH_ABAP_TECH_DOCU,  Author: SAP Custom Development
*&amp;  2.ZSAPLINK, http://saplink.org
*&amp;---------------------------------------------------------------------*
REPORT ynot.
*&amp;----------------Types/Constants/Global Data Declarations-------------*
INCLUDE ynot_types.
INCLUDE ynot_constants.
INCLUDE ynot_global_data.
*&amp;---------------------Selection Screen Components---------------------*
DATA: lt_trans TYPE e070-trkorr,
      lt_exclu TYPE e071-obj_name,
      lt_objtype TYPE trobjtype.
SELECTION-SCREEN BEGIN OF BLOCK b0 WITH FRAME TITLE gc_case.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_exp FOR FIELD export.
PARAMETERS export TYPE c RADIOBUTTON GROUP a DEFAULT &apos;X&apos; USER-COMMAND updown.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_imp FOR FIELD import.
PARAMETERS import TYPE c RADIOBUTTON GROUP a.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_code FOR FIELD code.
PARAMETERS code TYPE c RADIOBUTTON GROUP a.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b0.

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE gc_opt.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_trans FOR FIELD so_trans MODIF ID exp.
SELECT-OPTIONS: so_trans FOR lt_trans NO INTERVALS MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_exclu FOR FIELD so_exclu MODIF ID exp.
SELECT-OPTIONS: so_exclu FOR lt_exclu NO INTERVALS MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_dir FOR FIELD p_dir MODIF ID exp.
PARAMETERS: p_dir TYPE string  MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_doc FOR FIELD p_doc MODIF ID exp.
PARAMETERS: p_doc TYPE string LOWER CASE DEFAULT &apos;Correction_Pre&apos; MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_open FOR FIELD p_open MODIF ID exp.
PARAMETERS: p_open TYPE abap_bool AS CHECKBOX MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_bin FOR FIELD p_bin MODIF ID exp.
PARAMETERS: p_bin TYPE c AS CHECKBOX DEFAULT abap_true MODIF ID exp.
PARAMETERS: p_test TYPE abap_bool NO-DISPLAY.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_file FOR FIELD p_file MODIF ID imp.
PARAMETERS: p_file TYPE string MODIF ID imp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_objt FOR FIELD so_objt MODIF ID cod.
SELECT-OPTIONS: so_objt FOR lt_objtype NO INTERVALS MODIF ID cod.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b1.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR so_trans-low.
  PERFORM f4_request.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR so_exclu-low.
  PERFORM f4_exclude_objects.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_dir.
  PERFORM select_download_dir CHANGING p_dir.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
  PERFORM select_transport_file CHANGING p_file.

INITIALIZATION.
  PERFORM init_texts USING sy-langu.
  PERFORM initialize_buffer.

AT SELECTION-SCREEN OUTPUT.
  PERFORM scenario_switch.

START-OF-SELECTION.
  PERFORM response.
*&amp;--------------------------Text Elements: English and German available--------------------------*
  INCLUDE ynot_texts.
*&amp;---------------Common Routines &amp; UI Logic &amp; HTML Ultility &amp; Upload &amp; Code Helper---------------*
  INCLUDE ynot_ui.
  INCLUDE ynot_export_tr.
  INCLUDE ynot_html.
  INCLUDE ynot_upload_tr.
  INCLUDE ynot_code_helper.
  INCLUDE ynot_commons.
*&amp;---------------------Supported Object Types Data Retrieve &amp; HTML Conversion--------------------*
  INCLUDE ynot_devc.  &quot; Package &amp; Package: Usage &amp; Package: Interface
  INCLUDE ynot_fugr.  &quot; Function Group &amp; Function Group Texts
  INCLUDE ynot_doma.  &quot; Domain
  INCLUDE ynot_dtel.  &quot; Data Element
  INCLUDE ynot_tabl.  &quot; Table &amp; Table Definition
  INCLUDE ynot_tabt.  &quot; Table Technical Setting &amp; Index
  INCLUDE ynot_view.  &quot; View &amp; View Definition
  INCLUDE ynot_shlp.  &quot; Search Help
  INCLUDE ynot_enqu.  &quot; Lock Object
  INCLUDE ynot_ttyp.  &quot; Table Type
  INCLUDE ynot_tobj.  &quot; Definition of a Maintenance and Transport Object
  INCLUDE ynot_vcls.  &quot; View cluster
  INCLUDE ynot_nrob.  &quot; Number Range Objects
  INCLUDE ynot_docu.  &quot; Documentation
  INCLUDE ynot_msad.  &quot; Message Class: Definition and All Short Texts &amp; Message Class
  INCLUDE ynot_mess.  &quot; Single Message
  INCLUDE ynot_tran.  &quot; Transaction
  INCLUDE ynot_vdat.  &quot; View Maintenance: Data &amp; View Cluster Maintenance: Data &amp; Table Contents</source>
 </PROG>
 <PROG NAME="YNOT_ALL_IN_ONE" VARCL="X" DBAPL="S" DBNA="D$" SUBC="1" APPL="S" RMAND="002" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: All In One Version Built at 20130620 143241" LENGTH="49 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report YNOT_ALL_IN_ONE built as all-in-one program at 20130620 143241
*&amp; Author: Joker @ SAP Labs China FGI
*&amp;---------------------------------------------------------------------*
*&amp; Function Description:
*&amp; This report will collect objects data from several released transport
*&amp;  request and generate a documentation for note pre-implementation.
*&amp; Those objects cannot be shipped via note automatically need to be
*&amp;  maintained by customer according to instruction step by step, and this
*&amp;  tool aims to reduce the effort of writing instruction documentation.
*&amp;---------------------------------------------------------------------*
*&amp; Supported Object Types(Total: 33):
*&amp; -  DEVC : Package
*&amp; -  DEVP : Package: Usage
*&amp; -  PINF : Package: Interface
*&amp; -  FUGR/FUGT : Function Group (Texts)
*&amp; -  DOMA/DOMD : Domain (Definition)
*&amp; -  DTEL/DTED : Data Element (Definition)
*&amp; -  TABL/TABD/TABT/INDX : Table (Definition/Technical Setting/Index)
*&amp; -  VIEW/VIED/VIET : View (Definition / Technical Attributes)
*&amp; -  VCLS : View cluster
*&amp; -  TOBJ : Definition of a Maintenance and Transport Object
*&amp; -  SHLP/SHLD : Search Help (Definition)
*&amp; -  ENQU/ENQD : Lock Object (Definition)
*&amp; -  TTYP/TTYD : Table Type (Definition)
*&amp; -  NROB : Number Range Objects
*&amp; -  DOCU : Documentation(TODO: DOCT/DOCV)
*&amp; -  MSAD/MSAG : Message Class (Definition and All Short Texts)
*&amp; -  MESS : Single Message
*&amp; -  TRAN : Transaction
*&amp; -  CDAT : View Cluster Maintenance Data
*&amp; -  VDAT : View Maintenance Data
*&amp; -  TABU : Table Contents
*&amp;---------------------------------------------------------------------*
*&amp; Limitations(including but not limited to):
*&amp;  1.Generated File is html which is word compatible, but the auto list
*&amp;    item adjustment(and maybe some other features also) is missing
*&amp;  2.Only English and German are available
*&amp;  3.Cannot detect delta change mode for all objects, however we can add
*&amp;    objects into excluded list as a workaround.
*&amp;---------------------------------------------------------------------*
*&amp; Report Message:
*&amp;  This tool as a infant is not robust and might result in new troubules,
*&amp;    any feedback is of great help to let it grows up and becomes strong.
*&amp;  So if you find any issue when you use this tool, please kindly write
*&amp;    email to joker.yang@sap.corp, I will try to fix them ASAP.
*&amp;---------------------------------------------------------------------*
*&amp; Inspiration From &amp; Thanks To:
*&amp;  1.Z_METH_ABAP_TECH_DOCU,  Author: SAP Custom Development
*&amp;  2.ZSAPLINK, http://saplink.org
*&amp;---------------------------------------------------------------------*
REPORT YNOT_ALL_IN_ONE.
*&amp;----------------Types/Constants/Global Data Declarations-------------*
*&amp;---------------------Types Definition: utility types-----------------*
TYPE-POOLS: icon, trwbo.
TYPES: BEGIN OF s_objtype_order,
       object          TYPE trobjtype,
       sort_no         TYPE i,
       show_basic_attr TYPE abap_bool,
       END OF s_objtype_order.
TYPES: ht_objtype_order TYPE HASHED TABLE OF s_objtype_order WITH UNIQUE KEY object.

TYPES: BEGIN OF s_object_instruction,
       object      TYPE trobjtype,
       instruction TYPE string,
       END OF s_object_instruction.
TYPES: ht_object_instruction TYPE HASHED TABLE OF s_object_instruction WITH UNIQUE KEY object.

TYPES: BEGIN OF s_lintype,
       line(1024) TYPE x,
       END OF s_lintype.
TYPES: t_linetype TYPE STANDARD TABLE OF s_lintype WITH DEFAULT KEY.
TYPES: t_string TYPE STANDARD TABLE OF string WITH DEFAULT KEY.

TYPES: BEGIN OF s_obj_header,
       pgmid          TYPE  pgmid,
       object         TYPE trobjtype,
       obj_name	      TYPE sobj_name,
       primary_sort   TYPE i,
       secondary_sort TYPE numc2,
       devclass       TYPE devclass,
       short_text     TYPE ddtext,
       screenshots    TYPE int1,
       activity       TYPE char6,
       END OF s_obj_header.

TYPES: BEGIN OF s_value_desc,
       fieldname   TYPE fieldname,
       ddfixvalues TYPE ddfixvalues,
       END OF s_value_desc.

TYPES: BEGIN OF s_common_msg,
       msgty TYPE sy-msgty,
       msg TYPE string,
       END OF s_common_msg.

TYPES: BEGIN OF s_obj_gen_msg.
        INCLUDE TYPE s_obj_header.
        INCLUDE TYPE s_common_msg.
TYPES: END OF s_obj_gen_msg.
*&amp;--Types for supported kinds of objects, Naming Convention: s_{objtype}--*
TYPES: t_package_interface TYPE TABLE OF vintf WITH DEFAULT KEY.
TYPES: BEGIN OF s_devc.
        INCLUDE TYPE s_obj_header.
TYPES: parentcl               TYPE parentcl.
TYPES: pdevclass              TYPE devlayer.
TYPES: component              TYPE uffctr.
TYPES: dlvunit                TYPE dlvunit.
TYPES: applicat               TYPE trdevcappl.
TYPES: mainpack               TYPE mainpack.
TYPES: korrflag               TYPE korrflag.
TYPES: project_id             TYPE pak_project_id.
TYPES: translation_relevance  TYPE c LENGTH 60.
TYPES: use_accesses           TYPE permis_tab.
TYPES: interfaces             TYPE t_package_interface.
TYPES: END OF s_devc.

TYPES: BEGIN OF s_devp.
        INCLUDE TYPE s_devc.
TYPES: END OF s_devp.

TYPES: BEGIN OF s_pinf.
        INCLUDE TYPE s_obj_header.
        INCLUDE STRUCTURE vintf.
TYPES: END OF s_pinf.

TYPES: BEGIN OF s_fugr.
        INCLUDE TYPE s_obj_header.
TYPES: END OF s_fugr.

TYPES: BEGIN OF s_fugt.
        INCLUDE TYPE s_fugr.
TYPES: END OF s_fugt.

TYPES: t_dd07v TYPE STANDARD TABLE OF dd07v WITH DEFAULT KEY.
TYPES: BEGIN OF s_doma.
        INCLUDE TYPE s_obj_header.
TYPES: datatype    TYPE datatype_d.
TYPES: leng        TYPE ddleng.
TYPES: outputlen   TYPE outputlen.
TYPES: decimals    TYPE decimals.
TYPES: lowercase   TYPE lowercase.
TYPES: signflag    TYPE signflag.
TYPES: valexi      TYPE valexi.
TYPES: entitytab   TYPE entitytab.
TYPES: value_range TYPE t_dd07v.
TYPES: END OF s_doma.

TYPES: BEGIN OF s_domd.
        INCLUDE TYPE s_doma.
TYPES: END OF s_domd.

TYPES: BEGIN OF s_dtel.
        INCLUDE TYPE s_obj_header.
TYPES: domname   TYPE domname.
TYPES: headlen   TYPE headlen.
TYPES: scrlen1   TYPE scrlen_s.
TYPES: scrlen2   TYPE scrlen_m.
TYPES: scrlen3   TYPE scrlen_l.
TYPES: reptext   TYPE reptext.
TYPES: scrtext_s TYPE scrtext_s.
TYPES: scrtext_m TYPE scrtext_m.
TYPES: scrtext_l TYPE scrtext_l.
TYPES: datatype  TYPE datatype_d.
TYPES: leng      TYPE ddleng.
TYPES: END OF s_dtel.

TYPES: BEGIN OF s_dted.
        INCLUDE TYPE s_dtel.
TYPES: END OF s_dted.

TYPES: BEGIN OF s_tabl_fk_def,
        fieldname   TYPE  forfield,
        fortable    TYPE  fortable,
        forkey      TYPE  forkey,
        checktable  TYPE  checktable,
        checkfield  TYPE  fieldname,
        generic     TYPE  c,
        constant    TYPE  c LENGTH 30,
       END OF s_tabl_fk_def.
TYPES: t_tabl_fk_def TYPE TABLE OF s_tabl_fk_def WITH DEFAULT KEY.

TYPES: BEGIN OF s_tabl_field,
       fieldname    TYPE fieldname,
       keyflag      TYPE keyflag,
       rollname     TYPE rollname,
       checktable   TYPE checktable,
       shlpname     TYPE shlpname,
       typing_method TYPE string,
       END OF s_tabl_field.
TYPES: t_tabl_field TYPE STANDARD TABLE OF s_tabl_field WITH DEFAULT KEY.

TYPES: BEGIN OF s_tabl_index,
       indexname TYPE indexid,
       isextind  TYPE ddisextind,
       ddtext    TYPE ddtext,
       uniqueflag TYPE uniqueflag,
       dbindex    TYPE dbindex_d,
       dbstate    TYPE ddixdbstat,
       dbinclexcl TYPE ddixincex,
       index_fields TYPE string,
       END OF s_tabl_index.
TYPES: t_tabl_index TYPE STANDARD TABLE OF s_tabl_index WITH DEFAULT KEY.

TYPES: BEGIN OF s_tabl.
        INCLUDE TYPE s_obj_header.
TYPES:  tabclass  TYPE  tabclass.
TYPES:  contflag  TYPE  contflag.
TYPES:  mainflag  TYPE  maintflag.
TYPES:  fields    TYPE  t_tabl_field.
TYPES:  tech_setting  TYPE  dd09v.
TYPES:  namespace     TYPE  db6tresc_tab.
TYPES:  foreign_key_header  TYPE  dd08vttyp.
TYPES:  foreign_keys  TYPE  t_tabl_fk_def.
TYPES:  assignments   TYPE  dd35vttyp.
TYPES:  index         TYPE  t_tabl_index.
TYPES: END OF s_tabl.

TYPES: BEGIN OF s_tabd.
        INCLUDE TYPE s_tabl.
TYPES: END OF s_tabd.

TYPES: t_table_join          TYPE STANDARD TABLE OF dd26v WITH DEFAULT KEY.
TYPES: t_view_fields         TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY.
TYPES: t_join_condition      TYPE STANDARD TABLE OF dd28j WITH DEFAULT KEY.
TYPES: t_selection_condition TYPE STANDARD TABLE OF dd28v WITH DEFAULT KEY.

TYPES: BEGIN OF s_view.
        INCLUDE TYPE s_obj_header.
TYPES:  viewclass   TYPE  viewclass.
TYPES:  customauth  TYPE  contflag.
TYPES:  viewgrant   TYPE  viewgrant.
TYPES:  globalflag  TYPE  maintflag.
TYPES:  table_join  TYPE  t_table_join.
TYPES:  fields      TYPE  t_view_fields.
TYPES:  join_condition       TYPE  t_join_condition.
TYPES:  selection_condition  TYPE  t_selection_condition.
TYPES:  tech_setting         TYPE  dd09v.
TYPES: END OF s_view.

TYPES: BEGIN OF s_vied.
        INCLUDE TYPE s_view.
TYPES: END OF s_vied.

TYPES: t_vclstruc TYPE STANDARD TABLE OF v_vclstruc WITH DEFAULT KEY.
TYPES: t_vclstdep TYPE STANDARD TABLE OF  v_vclstdep WITH DEFAULT KEY.
TYPES: t_maintenance_events TYPE STANDARD TABLE OF tvimf WITH DEFAULT KEY.
TYPES: t_viewcluster_events TYPE STANDARD TABLE OF v_vclmf WITH DEFAULT KEY.

TYPES: BEGIN OF s_vcls.
        INCLUDE TYPE s_obj_header.
TYPES:  hieropsoff  TYPE  sychar01.
TYPES:  readkind    TYPE  sychar01.
TYPES:  basevcl     TYPE  vcl_name.
TYPES:  exitprog    TYPE  programm.
TYPES:  object_stru TYPE  t_vclstruc.
TYPES:  field_dep   TYPE  t_vclstdep.
TYPES:  events      TYPE  t_viewcluster_events.
TYPES: END OF s_vcls.

TYPES: BEGIN OF s_tobj.
        INCLUDE TYPE s_obj_header.
TYPES:  tabname TYPE  vim_name.
TYPES:  area    TYPE  funct_pool.
TYPES:  maint_type    TYPE  maint_type.
TYPES:  liste   TYPE  list_scr.
TYPES:  detail  TYPE  single_scr.
TYPES:  mclass  TYPE  ddmclass.
TYPES:  cclass  TYPE  dicbercls.
TYPES:  events  TYPE  t_maintenance_events.
TYPES: END OF s_tobj.

TYPES: BEGIN OF s_shlp.
        INCLUDE TYPE s_obj_header.
TYPES:  issimple   TYPE  ddshsimple.
TYPES:  selmethod  TYPE  selmethod.
TYPES:  selmtype   TYPE  selmtype.
TYPES:  selmexit   TYPE  ddshselext.
TYPES:  hotkey     TYPE  ddshhotkey.
TYPES:  dialogtype TYPE  ddshdiatyp.
TYPES:  params     TYPE  rsdg_t_dd32p.
TYPES: END OF s_shlp.

TYPES: BEGIN OF s_shld.
        INCLUDE TYPE s_shlp.
TYPES: END OF s_shld.

TYPES: t_base_table TYPE STANDARD TABLE OF dd26e WITH DEFAULT KEY.
TYPES: t_lock_param TYPE STANDARD TABLE OF ddena WITH DEFAULT KEY.
TYPES: BEGIN OF s_enqu.
        INCLUDE TYPE s_obj_header.
TYPES:  rfcenable    TYPE  rfcenable.
TYPES:  base_tables  TYPE  t_base_table.
TYPES:  lock_params  TYPE  t_lock_param.
TYPES: END OF s_enqu.

TYPES: BEGIN OF s_enqd.
        INCLUDE TYPE s_enqu.
TYPES: END OF s_enqd.

TYPES: t_dd42v TYPE STANDARD TABLE OF dd42v WITH DEFAULT KEY.
TYPES: t_dd43v TYPE STANDARD TABLE OF dd43v WITH DEFAULT KEY.
TYPES: BEGIN OF s_ttyp.
        INCLUDE TYPE s_obj_header.
TYPES:  rowtype     TYPE  ttrowtype.
TYPES:  accessmode  TYPE  accessmode.
TYPES:  keydef   TYPE  ttypkeydef.
TYPES:  keykind  TYPE  keykind.
TYPES:  keyfdcount  TYPE  keyfdcnt.
TYPES:  generic     TYPE  typgeneric.
TYPES:  typelen     TYPE  ddleng.
TYPES:  ttypkind    TYPE  ttypkind.
TYPES:  range_ctyp  TYPE  range_ctyp.
TYPES:  reftype     TYPE  ddreftype.
TYPES:  occurs      TYPE  ddoccurs.
TYPES:  primary_key    TYPE  t_dd42v.
TYPES:  secondary_key  TYPE  t_dd43v.
TYPES: END OF s_ttyp.

TYPES: BEGIN OF s_ttyd.
        INCLUDE TYPE s_ttyp.
TYPES: END OF s_ttyd.

TYPES: BEGIN OF s_nrob.
        INCLUDE TYPE s_obj_header.
TYPES:  txt  TYPE  nrobjtxt.
TYPES:  dtelsobj    TYPE  nrsobjnam.
TYPES:  domlen      TYPE  nrlendom.
TYPES:  percentage  TYPE  nrperc.
TYPES:  code        TYPE  nrcode.
TYPES:  buffer      TYPE  nrbuffer.
TYPES:  noivbuffer  TYPE  nrivbuffer.
TYPES:  nonrswap    TYPE  nrswap.
TYPES:  yearind     TYPE  nryearind.
TYPES: END OF s_nrob.

TYPES: BEGIN OF s_msg_txt.
        INCLUDE TYPE t100.
TYPES: self_explanatory TYPE c.
TYPES: END  OF s_msg_txt.
TYPES: t_message_txt TYPE STANDARD TABLE OF s_msg_txt WITH DEFAULT KEY.

TYPES: t_tline TYPE STANDARD TABLE OF tline WITH DEFAULT KEY.
TYPES: BEGIN OF s_long_text.
        INCLUDE TYPE t100.
TYPES: long_text TYPE t_tline.
TYPES: END OF  s_long_text.
TYPES: t_long_text TYPE STANDARD TABLE OF s_long_text WITH DEFAULT KEY.

TYPES: BEGIN OF s_msad.
        INCLUDE TYPE s_obj_header.
TYPES:  message_texts  TYPE t_message_txt.
TYPES:  long_texts     TYPE t_long_text.
TYPES: END OF s_msad.

TYPES: BEGIN OF s_msag.
        INCLUDE TYPE s_msad.
TYPES: END OF s_msag.

TYPES: BEGIN OF s_mess.
        INCLUDE TYPE s_obj_header.
        INCLUDE TYPE s_msg_txt.
TYPES: long_text TYPE t_tline.
TYPES: END OF s_mess.

TYPES: BEGIN OF s_docu.
        INCLUDE TYPE s_obj_header.
TYPES: long_text TYPE t_tline.
TYPES: END OF s_docu.

TYPES: t_primary_key TYPE STANDARD TABLE OF e071k  WITH DEFAULT KEY.
TYPES: t_field_info  TYPE STANDARD TABLE OF e071kf WITH DEFAULT KEY.
TYPES: BEGIN OF s_vdat.
        INCLUDE TYPE s_obj_header.
TYPES: primary_keys TYPE t_primary_key.
TYPES: field_info   TYPE t_field_info.
TYPES: END OF s_vdat.
TYPES: t_vdat TYPE STANDARD TABLE OF s_vdat WITH DEFAULT KEY.

TYPES: BEGIN OF s_cdat.
        INCLUDE TYPE s_vdat.
TYPES:  object_stru TYPE t_vclstruc.
TYPES: END OF s_cdat.

TYPES: BEGIN OF s_vdat_ignore,
        vcls_name TYPE sobj_name,
        obj_name TYPE sobj_name,
       END OF s_vdat_ignore.

TYPES: BEGIN OF s_tabu.
        INCLUDE TYPE s_vdat.
TYPES: END OF s_tabu.

TYPES: t_tcode_authority TYPE STANDARD TABLE OF tstca WITH DEFAULT KEY.
TYPES: BEGIN OF s_tran_default_value,
       screen_field TYPE eu_para_fn,
       value        TYPE eu_para_vl,
       END OF s_tran_default_value.
TYPES: t_tran_default_value TYPE STANDARD TABLE OF s_tran_default_value WITH DEFAULT KEY.
TYPES: BEGIN OF s_tran.
        INCLUDE TYPE s_obj_header.
TYPES: transaction_type TYPE  c.
TYPES: authority        TYPE  t_tcode_authority.
TYPES: basic_info       TYPE  tstcv.
TYPES: gui_attributes   TYPE  tstcc.
TYPES: uiclass          TYPE  tstcclass.
TYPES: param            TYPE  tcdparam.
TYPES: param_values     TYPE  t_tran_default_value.
TYPES: transaction      TYPE  tcode.
TYPES: END OF s_tran.
*&amp;-------------------------Constants/Global Data Definition-------------------------*
CONSTANTS: gcv_act_update TYPE char6 VALUE &apos;Update&apos;,
           gcv_act_create TYPE char6 VALUE &apos;Create&apos;,
* Html template definition, place holder like $XXX will be replaced by content
           gcv_header_html TYPE string VALUE &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                             &apos;&lt;b&gt;&lt;span style=&quot;font-size:20.0pt;line-height:115%&quot;&gt;$HEADER_NO.$OBJECT_DESC&lt;/span&gt;&lt;/b&gt;&apos; &amp;
                                             &apos;&lt;/p&gt;&apos;,
           gcv_title_html  TYPE string VALUE
                                   &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                   &apos;&lt;span style=&quot;font-size:16.0pt;line-height:115%&quot;&gt;$TITLE_NO $ACTIVITY $OBJECT_DESC $OBJ_NAME&lt;/span&gt;&apos; &amp;
                                   &apos;&lt;/p&gt;&apos;,
           gcv_small_title_html  TYPE string VALUE
                                   &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                   &apos;&lt;span style=&quot;font-size:14.0pt;line-height:115%&quot;&gt;$TITLE&lt;/span&gt;&apos; &amp;
                                   &apos;&lt;/p&gt;&apos;,
           gcv_paragraph_html  TYPE string VALUE
                                    &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;$PARAGRAPH&apos; &amp;
                                    &apos;&lt;/p&gt;&apos;,
           gcv_td_label  TYPE string VALUE
                                &apos;&lt;td valign=&quot;top&quot; style=&quot;border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt&quot;&gt;&apos; &amp;
                                  &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;&lt;b&gt;$LABEL&lt;/b&gt;&apos; &amp;
                                  &apos;&lt;/p&gt;&apos; &amp;
                                &apos;&lt;/td&gt;&apos;,
           gcv_td_content TYPE string VALUE
                                &apos;&lt;td valign=&quot;top&quot; style=&quot;border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt&quot;&gt;&apos; &amp;
                                  &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;$VALUE&apos; &amp;
                                  &apos;&lt;/p&gt;&apos; &amp;
                                &apos;&lt;/td&gt;&apos;,
           gcv_td_inner_table TYPE string VALUE &apos;&lt;td&gt;$VALUE&lt;/td&gt;&apos;,
           gcv_img_content TYPE string VALUE &apos;&lt;p&gt;&lt;img width=600 height=450 src=&quot;$IMAGE.jpg&quot;&gt;&lt;/p&gt;&apos;,  &quot;#EC NEEDED
           gcv_table_begin TYPE string VALUE &apos;&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot; style=&quot;100.0%;border-collapse:collapse;border:none&quot;&gt;&apos;,
           gcv_table_end   TYPE string VALUE &apos;&lt;/table&gt;&apos;.

CONSTANTS: BEGIN OF c_trans_type,
            dialog TYPE c VALUE &apos;1&apos;,
            report TYPE c VALUE &apos;2&apos;,
            oo     TYPE c VALUE &apos;3&apos;,
            trans_with_variant TYPE c VALUE &apos;4&apos;,
            trans_with_param   TYPE c VALUE &apos;5&apos;,
           END OF c_trans_type.
DATA: gt_ko100         TYPE HASHED TABLE OF ko100 WITH UNIQUE KEY object,
      gt_objtype_desc  TYPE HASHED TABLE OF ko100 WITH UNIQUE KEY object,
      gt_objtype_order TYPE ht_objtype_order,
      gt_value_desc    TYPE HASHED TABLE OF s_value_desc WITH UNIQUE KEY fieldname,
      gv_trans_dir     TYPE string,
      &quot; global internal data table for each kind of object, name convention: gt_{objtype}
      gt_devc TYPE TABLE OF s_devc,                         &quot;#EC NEEDED
      gt_devp TYPE TABLE OF s_devp,                         &quot;#EC NEEDED
      gt_pinf TYPE TABLE OF s_pinf,                         &quot;#EC NEEDED
      gt_fugr TYPE TABLE OF s_fugr,                         &quot;#EC NEEDED
      gt_fugt TYPE TABLE OF s_fugt,                         &quot;#EC NEEDED
      gt_doma TYPE TABLE OF s_doma,                         &quot;#EC NEEDED
      gt_domd TYPE TABLE OF s_domd,                         &quot;#EC NEEDED
      gt_dtel TYPE TABLE OF s_dtel,                         &quot;#EC NEEDED
      gt_dted TYPE TABLE OF s_dted,                         &quot;#EC NEEDED
      gt_tabl TYPE TABLE OF s_tabl,                         &quot;#EC NEEDED
      gt_tabd TYPE TABLE OF s_tabd,                         &quot;#EC NEEDED
      gt_view TYPE TABLE OF s_view,                         &quot;#EC NEEDED
      gt_vied TYPE TABLE OF s_vied,                         &quot;#EC NEEDED
      gt_vcls TYPE TABLE OF s_vcls,                         &quot;#EC NEEDED
      gt_tobj TYPE TABLE OF s_tobj,                         &quot;#EC NEEDED
      gt_shlp TYPE TABLE OF s_shlp,                         &quot;#EC NEEDED
      gt_shld TYPE TABLE OF s_shld,                         &quot;#EC NEEDED
      gt_enqu TYPE TABLE OF s_enqu,                         &quot;#EC NEEDED
      gt_enqd TYPE TABLE OF s_enqd,                         &quot;#EC NEEDED
      gt_ttyp TYPE TABLE OF s_ttyp,                         &quot;#EC NEEDED
      gt_ttyd TYPE TABLE OF s_ttyd,                         &quot;#EC NEEDED
      gt_nrob TYPE TABLE OF s_nrob,                         &quot;#EC NEEDED
      gt_msad TYPE TABLE OF s_msad,                         &quot;#EC NEEDED
      gt_msag TYPE TABLE OF s_msag,                         &quot;#EC NEEDED
      gt_mess TYPE TABLE OF s_mess,                         &quot;#EC NEEDED
      gt_docu TYPE TABLE OF s_docu,                         &quot;#EC NEEDED
      gt_tran TYPE TABLE OF s_tran,                         &quot;#EC NEEDED
      gt_cdat TYPE TABLE OF s_cdat,                         &quot;#EC NEEDED
      gt_vdat TYPE t_vdat,                                  &quot;#EC NEEDED
      gt_tabu TYPE t_vdat,                                  &quot;#EC NEEDED

      gt_vdat_ignore   TYPE HASHED TABLE OF s_vdat_ignore WITH UNIQUE KEY obj_name,
      gv_tr_date       TYPE as4date,
      gv_header_no     TYPE numc2,
      &quot; screen shot folder, however currently this feature is not available
      gv_img_folder    TYPE string,                         &quot;#EC NEEDED
      gt_object_instruction TYPE ht_object_instruction,
      gt_html          TYPE TABLE OF string,
      gt_html_all      TYPE TABLE OF string,
      &quot; template code: a helper when add support for new object types
      gt_code_template TYPE TABLE OF char255,
      gt_objtype2codes TYPE TABLE OF trobjtype,
      gt_obj_gen_msg   TYPE TABLE OF s_obj_gen_msg,
      gt_sys_msg       TYPE TABLE OF s_common_msg,
      gv_username      TYPE string,
      go_zip           TYPE REF TO cl_abap_zip,
      gv_slash         TYPE c.

DATA: gcv_text_unexpected_error TYPE string,
      BEGIN OF text_common,
        label_col_attr  TYPE string,
        label_col_value TYPE string,
        title_tobj      TYPE string,
        txt_notice      TYPE string,
        title_html      TYPE string,
        msg_success     TYPE string,
        msg_ignore      TYPE string,
        msg_error       TYPE string,
        msg_error_msg   TYPE string,
        rep_none        TYPE string,
        rep_docu        TYPE string,
        action_en       TYPE string,
        action2_en      TYPE string,
        action_de       TYPE string,
        thanks          TYPE string,
        time_cost       TYPE string,
      END OF text_common,
      BEGIN OF text_devc,
        label_tp_layer    TYPE string,
        txt_tp_note       TYPE string,
        title_access      TYPE string,
        title_interface   TYPE string,
        inst_devc         TYPE string,
        inst_devp         TYPE string,
        inst_devp_sub     TYPE string,
        inst_pinf         TYPE string,
        inst_pinf_sub     TYPE string,
      END OF text_devc,
      BEGIN OF text_fugr,
        inst_fugr TYPE string,
        inst_fugt TYPE string,
      END OF text_fugr,
      BEGIN OF text_doma,
        label_value_range TYPE string,
        inst_doma         TYPE string,
        inst_domd         TYPE string,
      END OF text_doma,
      BEGIN OF text_dtel,
        label_domain     TYPE string,
        label_data_type  TYPE string,
        label_predf_type TYPE string,
        label_fld_lab    TYPE string,
        label_length     TYPE string,
        label_short      TYPE string,
        label_medium     TYPE string,
        label_long       TYPE string,
        label_heading    TYPE string,
        txt_mt_docu_title TYPE string,
        txt_mt_docu_para  TYPE string,
        inst_dtel         TYPE string,
        inst_dted         TYPE string,
      END OF text_dtel,
      BEGIN OF text_tabl,
        title_tech  TYPE string,
        title_flds  TYPE string,
        title_comps TYPE string,
        title_fks   TYPE string,
        title_namespace TYPE string,
        title_index     TYPE string,
        note_flds  TYPE string,
        note_comps TYPE string,
        note_fks   TYPE string,
        inst_tabl  TYPE string,
        inst_tabd  TYPE string,
        inst_tabt  TYPE string,
        inst_indx  TYPE string,
        label_fk_flds  TYPE string,
        label_check_rq TYPE string,
        label_msg_no   TYPE string,
        label_aarea    TYPE string,
        label_screen_check TYPE string,
        label_card     TYPE string,
        label_fk_type  TYPE string,
        label_fk_semantic  TYPE string,
      END OF text_tabl,
      BEGIN OF text_view,
        inst_view TYPE string,
        inst_vied TYPE string,
        inst_viet TYPE string,
        title_tables TYPE string,
        title_fields TYPE string,
        title_join_conds TYPE string,
        title_sel_conds  TYPE string,
        note_join_cond   TYPE string,
        note_sel_cond    TYPE string,
      END OF text_view,
      BEGIN OF text_shlp,
        txt_type_ele  TYPE string,
        txt_type_col  TYPE string,
        txt_type      TYPE string,
        inst_shlp     TYPE string,
        inst_shld     TYPE string,
      END OF text_shlp,
      BEGIN OF text_enqu,
        label_allow_rfc TYPE string,
        label_tables    TYPE string,
        label_params    TYPE string,
        inst_enqu       TYPE string,
        inst_enqd       TYPE string,
      END OF text_enqu,
      BEGIN OF text_nrob,
        inst_nrob TYPE string,
      END OF text_nrob,
      BEGIN OF text_docu,
        inst_docu TYPE string,
        inst_doct TYPE string,
        inst_docv TYPE string,
      END OF text_docu,
      BEGIN OF text_mess,
        txt_title       TYPE string,
        txt_mt_longtext TYPE string,
        inst_mess       TYPE string,
      END OF text_mess,
      BEGIN OF text_msag,
        label_messages  TYPE string,
        inst_msag       TYPE string,
        inst_msad       TYPE string,
        inst_mess       TYPE string,
      END OF text_msag,
      BEGIN OF text_tobj,
        msg_obj_invalid TYPE string,
        label_events    TYPE string,
        inst_tobj       TYPE string,
        txt_mt_event   TYPE string,
      END OF text_tobj,
      BEGIN OF text_vcls,
        title_obj_stru TYPE string,
        title_fld_dep  TYPE string,
        title_events   TYPE string,
        label_hier     TYPE string,
        label_type     TYPE string,
        txt_type_comp  TYPE string,
        txt_type_sub   TYPE string,
        txt_mt_event   TYPE string,
      END OF text_vcls,
      BEGIN OF text_ttyp,
        label_row_type  TYPE string,
        inst_ttyp       TYPE string,
        inst_ttyd       TYPE string,
      END OF text_ttyp,
      BEGIN OF text_tran,
        inst_tran            TYPE string,
        label_type           TYPE string,
        label_default_values TYPE string,
        label_classification TYPE string,
        label_inherit_gui    TYPE string,
        label_prof_user      TYPE string,
        label_easy_web       TYPE string,
        label_service        TYPE string,
        label_pervasive      TYPE string,
        label_auth_values    TYPE string,
        label_oo_mode        TYPE string,
        label_oo_clas        TYPE string,
        label_oo_meth        TYPE string,
        label_oo_local_prog  TYPE string,
        label_oo_update_mode TYPE string,
        label_transaction    TYPE string,
        label_transaction_variant TYPE string,
        label_skip_init_screen    TYPE string,
      END OF text_tran,
      BEGIN OF text_tabu,
        inst_cdat  TYPE string,
        inst_vdat  TYPE string,
        inst_tabu  TYPE string,
        txt_maint_node TYPE string,
      END OF text_tabu.
*&amp;---------------------Selection Screen Components---------------------*
DATA: lt_trans TYPE e070-trkorr,
      lt_exclu TYPE e071-obj_name,
      lt_objtype TYPE trobjtype.
SELECTION-SCREEN BEGIN OF BLOCK b0 WITH FRAME TITLE gc_case.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_exp FOR FIELD export.
PARAMETERS export TYPE c RADIOBUTTON GROUP a DEFAULT &apos;X&apos; USER-COMMAND updown.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_imp FOR FIELD import.
PARAMETERS import TYPE c RADIOBUTTON GROUP a.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) gc_code FOR FIELD code.
PARAMETERS code TYPE c RADIOBUTTON GROUP a.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b0.

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE gc_opt.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_trans FOR FIELD so_trans MODIF ID exp.
SELECT-OPTIONS: so_trans FOR lt_trans NO INTERVALS MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_exclu FOR FIELD so_exclu MODIF ID exp.
SELECT-OPTIONS: so_exclu FOR lt_exclu NO INTERVALS MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_dir FOR FIELD p_dir MODIF ID exp.
PARAMETERS: p_dir TYPE string  MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_doc FOR FIELD p_doc MODIF ID exp.
PARAMETERS: p_doc TYPE string LOWER CASE DEFAULT &apos;Correction_Pre&apos; MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_open FOR FIELD p_open MODIF ID exp.
PARAMETERS: p_open TYPE abap_bool AS CHECKBOX MODIF ID exp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_bin FOR FIELD p_bin MODIF ID exp.
PARAMETERS: p_bin TYPE c AS CHECKBOX DEFAULT abap_true MODIF ID exp.
PARAMETERS: p_test TYPE abap_bool NO-DISPLAY.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_file FOR FIELD p_file MODIF ID imp.
PARAMETERS: p_file TYPE string MODIF ID imp.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_objt FOR FIELD so_objt MODIF ID cod.
SELECT-OPTIONS: so_objt FOR lt_objtype NO INTERVALS MODIF ID cod.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b1.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR so_trans-low.
  PERFORM f4_request.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR so_exclu-low.
  PERFORM f4_exclude_objects.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_dir.
  PERFORM select_download_dir CHANGING p_dir.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
  PERFORM select_transport_file CHANGING p_file.

INITIALIZATION.
  PERFORM init_texts USING sy-langu.
  PERFORM initialize_buffer.

AT SELECTION-SCREEN OUTPUT.
  PERFORM scenario_switch.

START-OF-SELECTION.
  PERFORM response.
*&amp;--------------------------Text Elements: English and German available--------------------------*
***************** i18n Begin *****************
FORM init_texts USING iv_langu TYPE sy-langu.
  IF iv_langu EQ &apos;D&apos;.
    PERFORM init_german_texts.
  ELSE.
    PERFORM init_english_texts.
  ENDIF.
  PERFORM init_object_instructions.
ENDFORM.

FORM init_english_texts.
* selection screen texts
  gc_case   = &apos;Scenario Selection&apos;.
  gc_exp    = &apos;Generate Note Pre-Impl Documentation&apos;.
  gc_imp    = &apos;Upload Transport Files&apos;.
  gc_code   = &apos;Code Helper For New Object Type&apos;.
  gc_opt    = &apos;Options&apos;.
  gc_trans  = &apos;Transport Request&apos;.
  gc_exclu  = &apos;Excluded Objects&apos;.
  gc_dir    = &apos;Export Folder&apos;.
  gc_doc    = &apos;Document Title&apos;.
  gc_open   = &apos;Open Document In MS Word&apos;.
  gc_bin    = &apos;Download Transport Files&apos;.
  gc_file   = &apos;Upload Transport File(Zip)&apos;.
  gc_objt   = &apos;New Object Types&apos;.
* documentation/message texts
  gcv_text_unexpected_error = &apos;An unexpected error occurred.&apos;.
  text_common-label_col_attr = &apos;Attribute&apos;.
  text_common-label_col_value = &apos;Value&apos;.
  text_common-title_tobj = &apos;Maintenance Object&apos;.
  text_common-title_html = &apos;Note Pre-Impl Documentation&apos;.
  text_common-txt_notice = &apos;Dear customer, please maintain objects in the below refer to this documentation and your own system settings.&apos; &amp;
                           &apos;In case some of the objects exist already and are exactly same as described in the documentation, you may simply igore them.&apos;.
  text_common-msg_success = &apos;Success&apos;.
  text_common-msg_ignore = &apos;Ignored.Nothing needs to be done on this object&apos;.
  text_common-msg_error = &apos;Failed&apos;.
  text_common-msg_error_msg = &apos;Error Message&apos;.
  text_common-rep_none = &apos;Dear $USERNAME, it seems there is no need to prepare documentation for the not.&apos;.
  text_common-rep_docu = &apos;Dear $USERNAME, here is documentation generation report : &apos;.
  text_common-action_en = &apos;Please open the generated html file using MS Office Word, save as DOCX&apos;.
  text_common-action2_en = &apos;Then review and make necessary modifications for your usage.&apos;.
  text_common-action_de = &apos;Please open the generated html file using IE , copy all the content to Word and save.&apos;.
  text_common-thanks = &apos;Thank you for using this tool, have a nice day ^_^&apos;.
  text_common-time_cost = &apos;Job finished in $TIME seconds.&apos;.

  text_devc-label_tp_layer = &apos;Transport Layer&apos;.
  text_devc-txt_tp_note = &apos;&lt;i style=mso-bidi-font-style:normal&gt;&lt;span style=color:red&gt;&apos; &amp;
                          &apos;Please fill in according to your own system landscape settings&apos; &amp;
                          &apos;&lt;/span&gt;&lt;/i&gt;&apos;.
  text_devc-title_access = &apos;Use Accesses&apos;.
  text_devc-title_interface = &apos;Package Interfaces&apos;.

  text_doma-label_value_range = &apos;Value Range&apos;.

  text_dtel-label_domain = &apos;Domain&apos;.
  text_dtel-label_data_type = &apos;Data Type &apos;.
  text_dtel-label_predf_type = &apos;Predefined type&apos;.
  text_dtel-label_fld_lab = &apos;Field Label&apos;.
  text_dtel-label_length = &apos;Length&apos;.
  text_dtel-label_short = &apos;Short&apos;.
  text_dtel-label_medium = &apos;Medium&apos;.
  text_dtel-label_long = &apos;Long&apos;.
  text_dtel-label_heading = &apos;Heading&apos;.
  text_dtel-txt_mt_docu_title = &apos;Maintain documentation for this data element:&apos;.
  text_dtel-txt_mt_docu_para = &apos;Please add documentation according to the format and content listed in the below.&lt;br&gt;&apos;.

  text_tabl-title_tech = &apos;Technical Settings:&apos;.
  text_tabl-label_fk_flds = &apos;Foreign Key Fields&apos;.
  text_tabl-title_flds = &apos;Fields: &apos;.
  text_tabl-title_comps = &apos;Components: &apos;.

  DATA lcv_note_fc TYPE string.
  lcv_note_fc = &apos;Please notice that those $ELE marked as italic are contained in included structure/table and you &lt;b&gt;DON&apos;&apos;T&lt;/b&gt; need to add them.&apos;.
  text_tabl-note_flds = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_flds WITH &apos;fields&apos;.
  text_tabl-note_comps = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_comps WITH &apos;components&apos;.

  text_tabl-title_fks = &apos;Foreign Keys:&apos;.
  text_tabl-note_fks = &apos;Maintain foreign key relationship for field: &apos;.
  text_tabl-title_namespace = &apos;Maintain Customer Namespace: &apos;.
  text_tabl-title_index = &apos;Indexes:&apos;.
  text_tabl-label_check_rq = &apos;Check required: &apos;.
  text_tabl-label_msg_no = &apos;MsgNo: &apos;.
  text_tabl-label_aarea = &apos;AArea: &apos;.
  text_tabl-label_screen_check = &apos;Screen check&apos;.
  text_tabl-label_card = &apos;Cardinality: &apos;.
  text_tabl-label_fk_type = &apos;Foreign key field type: &apos;.
  text_tabl-label_fk_semantic = &apos;Semantic attributes&apos;.

  text_view-title_tables = &apos;Tables: &apos;.
  text_view-title_join_conds = &apos;Join Conditions: &apos;.
  text_view-title_sel_conds = &apos;Selection conditions: &apos;.
  text_view-title_fields = &apos;View Flds:&apos;.
  text_view-note_join_cond = &apos;&lt;i&gt;No additional join condition needs to be maintained here.&lt;/i&gt;&apos;.
  text_view-note_sel_cond = &apos;&lt;i&gt;No additional selection condition needs to be maintained here.&lt;/i&gt;&apos;.

  text_enqu-label_allow_rfc = &apos;Allow RFC&apos;.
  text_enqu-label_tables = &apos;Tables&apos;.
  text_enqu-label_params = &apos;Parameters&apos;.

  text_shlp-txt_type_ele = &apos;Elementary&apos;.
  text_shlp-txt_type_col = &apos;Collective&apos;.
  text_shlp-txt_type = &apos;Type&apos;.

  text_ttyp-label_row_type = &apos;Line Type&apos;.

  text_msag-label_messages = &apos;Messages&apos;.

  text_mess-txt_title = &apos;Maintain messages with short text under message class as listed in the below&lt;br&gt;&apos;.
  text_mess-txt_mt_longtext = &apos;Maintain long text for message: &apos;.

  text_tobj-msg_obj_invalid = &apos;Maintenance Object does not exist any more, it might be deleted by someone else.&apos;.
  text_tobj-label_events = &apos;Events&apos;.
  text_tobj-txt_mt_event = &apos;In the maintenance object screen, click menu Enviroment-&gt;Modification-&gt;Events, &apos; &amp;
                           &apos;click &apos;&apos;New Entries&apos;&apos; button, input event type and FORM routine name, then save.&apos; &amp;
                           &apos;The code of the routines will be imported in the process of implementing note&apos;.

  text_vcls-title_obj_stru = &apos;Object Structure&apos;.
  text_vcls-title_fld_dep = &apos;Field Dependence&apos;.
  text_vcls-title_events = text_tobj-label_events.
  text_vcls-label_hier = &apos;Hierarchical Maintenance Operation Handling&apos;.
  text_vcls-label_type = &apos;Read Type&apos;.
  text_vcls-txt_type_comp = &apos;Complete&apos;.
  text_vcls-txt_type_sub = &apos;Subtree&apos;.
  text_vcls-txt_mt_event = &apos;In the maintenance screen of view cluster, double click node &apos;&apos;Events&apos;&apos;, &apos; &amp;
                           &apos;input main program name, event type, form routine and save.&apos;.

  text_tran-label_type           = &apos;Transaction Type&apos;.
  text_tran-label_default_values = &apos;Default Values&apos;.
  text_tran-label_classification = &apos;Classfication&apos;.
  text_tran-label_inherit_gui    = &apos;Inherit GUI Attributes&apos;.
  text_tran-label_prof_user      = &apos;Professional User Transaction&apos;.
  text_tran-label_easy_web       = &apos;Easy Web Transaction&apos;.
  text_tran-label_service        = &apos;Service&apos;.
  text_tran-label_pervasive      = &apos;Pervasive enabled&apos;.
  text_tran-label_auth_values    = &apos;Values&apos;.
  text_tran-label_oo_mode        = &apos;OO Transaction Mode&apos;.
  text_tran-label_oo_clas        = &apos;Class Name&apos;.
  text_tran-label_oo_meth        = &apos;Method&apos;.
  text_tran-label_oo_local_prog  = &apos;Local In Program&apos;.
  text_tran-label_oo_update_mode = &apos;Update mode&apos;.
  text_tran-label_transaction    = &apos;Transaction&apos;.
  text_tran-label_transaction_variant = &apos;Transaction Variant&apos;.
  text_tran-label_skip_init_screen    = &apos;Skip initial screen&apos;.

  text_tabu-txt_maint_node = &apos;Maintain entries for node : &apos;.
* instructions of supported object types
  text_devc-inst_devc = &apos;Run TCODE SE80 and enter in Repository Browser, select &apos;&apos;Package&apos;&apos; from dropdown list, &apos; &amp;
            &apos;input package name and press enter, click &apos;&apos;Yes&apos;&apos; in the pop up dialog box to create package, &apos; &amp;
            &apos;input necessary attribute values according to the documentation and save.&apos;.
  text_devc-inst_devp = &apos;Run TCODE SE21, input package name listed in the below, click &apos;&apos;Change&apos;&apos; button,&apos; &amp;
            &apos; click &apos;&apos;Use Accesses&apos;&apos; tab, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;&amp;
            &apos;input package interface name and error severity according to the documentation and save.&apos;.
  text_devc-inst_pinf = &apos;Run TCODE SE21, input package name listed in the below, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
            &apos;click &apos;&apos;Package Interfaces&apos;&apos; tab, click &apos;&apos;Add&apos;&apos; button, &apos; &amp;
            &apos;input package interface name and short description according to documentation and save.&apos;.
  text_devc-inst_devp_sub = &apos;Click &apos;&apos;Use Accesses&apos;&apos; tab, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
            &apos;input package interface name and error severity according to the documentation and save.&apos;.
  text_devc-inst_pinf_sub = &apos;Click &apos;&apos;Package Interfaces&apos;&apos; tab, click &apos;&apos;Add&apos;&apos; button, &apos; &amp;
            &apos;input package interface name and short description according to documentation and save.&apos;.
  text_fugr-inst_fugr = &apos;Select package where function group will be created, right click-&gt;Create-&gt;Function Group, &apos; &amp;
                        &apos;input attribute values and save.&apos;.
  text_fugr-inst_fugt = &apos;Select function group and right click-&gt;Change, input attribute values and save.&apos;.
  text_doma-inst_doma = &apos;Run TCODE SE11, select radio box &apos;&apos;Domain&apos;&apos;, input domain name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;input attribute values, save and activate.&apos;.
  text_dtel-inst_dtel = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input data element name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Data element&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tabl-inst_tabl = &apos;Run TCODE SE11, for database table, select radio box &apos;&apos;Database table&apos;&apos;, input table name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;maintain the attributes, fields, technical settings, indexes and etc.&apos; &amp;
                        &apos;For structure, select radio box &apos;&apos;Data type&apos;&apos;, input structure name, &apos; &amp;&amp;
                        &apos;click &apos;&apos;Create&apos;&apos; button, select radio box &apos;&apos;Structure&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tabl-inst_tabd = &apos;Run TCODE SE11, select radio box &apos;&apos;Database table&apos;&apos;, input table/structure name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;maintain the attributes, then save and activate.&apos;.
  text_view-inst_view = &apos;Run TCODE SE11, select radio box &apos;&apos;View&apos;&apos;, input view name, click &apos;&apos;Create&apos;&apos; button, select the view type,&apos; &amp;
                        &apos; maintain attributes, table/join conditions, &apos; &amp;
                        &apos;View fields, Selection Conditions, Maint Status and etc, then save and activate.&apos;.
  text_view-inst_vied = &apos;Run TCODE SE11, select radio box &apos;&apos;View&apos;&apos;, input view name, click &apos;&apos;Change&apos;&apos; button, maintain attributes, &apos; &amp;
                        &apos;table/join conditions, View fields, Selection Conditions, Maint Status and etc, then save and activate.&apos;.
  text_shlp-inst_shlp = &apos;Run TCODE SE11, select radio box &apos;&apos;Search help&apos;&apos;, input search help name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;select the search help type, maintain attributes, search help parameters and etc, then save and activate.&apos;.
  text_enqu-inst_enqu = &apos;Run TCODE SE11, select radio box &apos;&apos;Lock Object&apos;&apos;, input lock object name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;maintain attributes, tables, lock parameters and etc, then save and activate.&apos;.
  text_ttyp-inst_ttyp = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input table type name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Table Type&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tobj-inst_tobj = &apos;Run TCODE SE54, input maintenance view name, select radio box &apos;&apos;Generated Objects&apos;&apos;, click &apos;&apos;Create/Change&apos;&apos; button, &apos; &amp;&amp;
                        &apos;select &apos;&apos;Yes&apos;&apos; in the popup confirmation dialog box, input attribute values and click the create button above, &apos; &amp;
                        &apos;choose package according to documentation and save.&apos;.
  text_nrob-inst_nrob = &apos;Run TCODE SNRO, input number range object name, click &apos;&apos;Create&apos;&apos; button, input attribute values and save, &apos; &amp;
                        &apos;choose package according to documentation.&apos;.
  text_msag-inst_msad = &apos;Run TCODE SE91, input message class name and click &apos;&apos;Create&apos;&apos; button, input attribute values, messages and save,&apos; &amp;
                        &apos; choose package according to documentation.&apos;.
  text_msag-inst_msag =  text_msag-inst_msad.
  text_msag-inst_mess = &apos;Run TCODE SE91, input message class name and click &apos;&apos;Change&apos;&apos; button, maintain message short texts, &apos; &amp;
                        &apos;for message with long text, uncheck the checkbox &apos; &amp;
                        &apos;&apos;&apos;Self-explanatory&apos;&apos;, then click menu &apos;&apos;Long text&apos;&apos;, maintain the long text according to documentation.&apos;.
  text_docu-inst_docu = &apos;For data element, run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input data element name and click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos; click menu &apos;&apos;Documentation&apos;&apos; and maintain the documentation as described in the below.&lt;br&gt;&apos; &amp;&amp;
                        &apos;For long text of message short text, run TCODE SE91, input message class name and click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select the message, uncheck the checkbox &apos;&apos;Self-explanatory&apos;&apos;, then click menu &apos;&apos;Long text&apos;&apos;, &apos; &amp;
                        &apos;maintain the long text as described in the below.&apos;.
  text_tran-inst_tran = &apos;Run TCODE SE93, input transaction code, click &apos;&apos;Create&apos;&apos; button, if &apos; &amp;
                        &apos;input short text and select Start object, if it already exists, simply ignore it, if not, &apos; &amp;
                        &apos;maintain the attribute values and choose package according to documentation, then save your work.&apos;.
  text_doma-inst_domd = &apos;Run TCODE SE11, select radio box &apos;&apos;Domain&apos;&apos;, input domain name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;input attribute values, save and activate.&apos;.
  text_dtel-inst_dted = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input data element name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Data element&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tabl-inst_tabt = &apos;Run TCODE SE11, select radio box &apos;&apos;Database table&apos;&apos;, input table name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;click menu &apos;&apos;Technical Settings&apos;&apos;, maintain attribute values according documentation and save.&apos;.
  text_tabl-inst_indx = &apos;Run TCODE SE11, select radio box &apos;&apos;Database table&apos;&apos;, input table name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;click menu &apos;&apos;Indexes&apos;&apos;, maintain attribute values according documentation and save.&apos;.
  text_ttyp-inst_ttyd = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input table type name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Table Type&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_shlp-inst_shld = &apos;Run TCODE SE11, select radio box &apos;&apos;Search help&apos;&apos;, input search help name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select the search help type, maintain attributes, search help parameters and etc, then save and activate.&apos;.
  text_enqu-inst_enqd = &apos;Run TCODE SE11, select radio box &apos;&apos;Lock Object&apos;&apos;, input lock object name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;maintain attributes, tables, lock parameters and etc, then save and activate.&apos;.
  text_view-inst_viet = &apos;Run TCODE SE11, select radio box &apos;&apos;View&apos;&apos;, input view name, click &apos;&apos;Change&apos;&apos; button,  &apos; &amp;
                        &apos;click menu &apos;&apos;Goto&apos;&apos;-&gt;&apos;&apos;Technical Settings&apos;&apos;, maintain attribute values, then save and activate.&apos;.
  text_docu-inst_doct = &apos;&apos;.
  text_docu-inst_docv = &apos;&apos;.

  DATA: lcv_inst_dat TYPE string.
  lcv_inst_dat = &apos;Run TCODE $CODE, input $DATYPE name, click button &apos;&apos;Maintain&apos;&apos;,&apos; &amp;
          &apos; if warning message&apos;&apos;Caution: The table is cross-client&apos;&apos; popup, &apos; &amp; &apos;simply confirm it, then add entries in the below.&lt;br&gt;&apos; &amp;&amp;
          &apos;Notice that these entries might be dependent on other repository ojects, if you cannot go further, &apos; &amp;
          &apos;try to add the dependent objects first or do it again after implementing the note.&apos; &amp;&amp;
          &apos;Meanwhile, only those fields have a valid value need to maintain are listed, &apos; &amp;
          &apos;which means you don&apos;&apos;t need to care about other fields.&apos;.
  text_tabu-inst_cdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_cdat WITH &apos;SM34&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_cdat WITH &apos;view cluster&apos;.

  text_tabu-inst_vdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_vdat WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_vdat WITH &apos;maintenance view&apos;.

  text_tabu-inst_tabu = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_tabu WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_tabu WITH &apos;table&apos;.
ENDFORM.

FORM init_german_texts.
* I&apos;m sorry, but most of these German texts are actually translated by google and babylon...
* Auswahl Bildschirm Texte
  gc_case = &apos;Szenario Auswahl&apos;.
  gc_exp = &apos;erzeugen Anmerkung Vor-einführen Dokumentation&apos;.
  gc_imp = &apos;Antriebskraft-Transport-Dateien&apos;.
  gc_code = &apos;Kodieren Sie Helfer für neuen Objekt-Typ&apos;.
  gc_opt = &apos;Optionen&apos;.
  gc_trans = &apos;Transport-Antrag&apos;.
  gc_exclu = &apos;Ausgeschlossene Objekte&apos;.
  gc_dir = &apos;Export-Ordner&apos;.
  gc_doc = &apos;Dokument Title&apos;.
  gc_open = &apos;Offenes Dokument im Wort&apos;.
  gc_bin = &apos;Herunterladen Transport Files&apos;.
  gc_file = &apos;Hochladen Transport-Datei (zip)&apos;.
  gc_objt = &apos;Neue Objekt-Typen der&apos;.
* Dokumentation / Meldetexte
  gcv_text_unexpected_error = &apos;Ein unerwarteter Fehler ist aufgetreten.&apos;.
  text_common-label_col_attr = &apos;Attribut&apos;.
  text_common-label_col_value = &apos;Value&apos;.
  text_common-title_tobj = &apos;Wartung Object&apos;.
  text_common-title_html = &apos;Hinweis Pre-Impl Dokumentation&apos;.
  text_common-txt_notice = &apos;Sehr geehrter Kunde, bitte halten Objekte in der unten an dieser Dokumentation und Ihr eigenes System Einstellungen beziehen.&apos; &amp;&amp;
                           &apos;Bei einigen der Objekte bereits vorhanden sind und genau das gleiche wie in der Dokumentation beschrieben, können Sie einfach igore ihnen.&apos;.
  text_common-msg_success = &apos;Erfolg&apos;.
  text_common-msg_ignore = &apos;Ignored.Nothing muss auf diesem Gegenstand getan werden&apos;.
  text_common-msg_error = &apos;Ausfallen&apos;.
  text_common-msg_error_msg = &apos;Fehlermeldung&apos;.
  text_common-rep_none = &apos;Lieber $USERNAME, scheint es, dass es keinen Bedarf gibt, Dokumentation für die Anmerkung vorzubereiten.&apos;.
  text_common-rep_docu = &apos;Lieber $USERNAME, ist hier Dokumentationsgenerationsbericht : &apos;.
  text_common-action_en = &apos;Öffnen Sie bitte die erzeugte HTML-Datei unter Verwendung Mitgliedstaates Office Word, Abwehr als DOCX&apos;.
  text_common-action2_en = &apos;Dann wiederholen Sie und machen Sie notwendige Änderungen für Ihre Verwendung.&apos;.
  text_common-action_de = &apos;Öffnen Sie bitte die erzeugte HTML-Datei unter Verwendung IE, kopieren Sie den ganzen Inhalt, um abzufassen und zu speichern.&apos;.
  text_common-thanks = &apos;Danke für die Anwendung dieses Werkzeugs, haben Sie ein schöner Tag-^_^&apos;.
  text_common-time_cost = &apos;Job beendet in $TIME Sekunden.&apos;.

  text_devc-label_tp_layer = &apos;Transport Layer&apos;.
  text_devc-txt_tp_note = &apos;&lt;i style=mso-bidi-font-style:normal&gt;&lt;span style=color:red&gt;&apos; &amp;
                          &apos;Bitte in Bezug auf Ihre eigene Systemlandschaft Einstellungen füllen&apos; &amp;
                          &apos;&lt;/span&gt;&lt;/i&gt;&apos;.
  text_devc-title_access = &apos;Use Greift&apos;.
  text_devc-title_interface = &apos;Paket Interfaces&apos;.

  text_doma-label_value_range = &apos;Wert-Strecke&apos;.

  text_dtel-label_domain = &apos;Domain&apos;.
  text_dtel-label_data_type = &apos;Datentyp&apos;.
  text_dtel-label_predf_type = &apos;Vordefinierte Typ&apos;.
  text_dtel-label_fld_lab = &apos;Das Feld Label:&apos;.
  text_dtel-label_length = &apos;Länge&apos;.
  text_dtel-label_short = &apos;Kurzes&apos;.
  text_dtel-label_medium = &apos;mittleres&apos;.
  text_dtel-label_long = &apos;langes&apos;.
  text_dtel-label_heading = &apos;Überschrift&apos;.
  text_dtel-txt_mt_docu_title = &apos;Pflege der Dokumentation für dieses Datenelement:&apos;.
  text_dtel-txt_mt_docu_para = &apos;Bitte fügen Dokumentation nach Form und Inhalt in der unten. &lt;br&gt; aufgeführt.&apos;.

  text_tabl-title_tech = &apos;Technische Einstellungen:&apos;.
  text_tabl-label_fk_flds = &apos;Foreign Key Fields&apos;.
  text_tabl-title_flds = &apos;Fields:&apos;.
  text_tabl-title_comps = &apos;Komponenten:&apos;.

  DATA lcv_note_fc TYPE String.
  lcv_note_fc = &apos;Bitte beachten Sie, dass die $ELE als kursiv markiert inkludierten Struktur / Tabelle enthalten sind und Sie &lt;b&gt; DON&apos;&apos;T &lt;/b&gt; brauchen, um sie hinzuzufügen.&apos;.
  text_tabl-note_flds = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_flds WITH &apos;fields&apos;.
  text_tabl-note_comps = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_flds WITH &apos;Komponenten&apos;.

  text_tabl-title_fks = &apos;Foreign Keys:&apos;.
  text_tabl-note_fks = &apos;Pflegen Fremdschlüsselbeziehung für field:&apos;.
  text_tabl-title_namespace = &apos;Pflegen Kunde Namensraum:&apos;.
  text_tabl-title_index = &apos;Indexes:&apos;.
  text_tabl-label_check_rq = &apos;Check-in erforderlich:&apos;.
  text_tabl-label_msg_no = &apos;MsgNr:&apos;.
  text_tabl-label_aarea = &apos;AAREA:&apos;.
  text_tabl-label_screen_check = &apos;Bildschirm überprüfen&apos;.
  text_tabl-label_card = &apos;Kardinalität:&apos;.
  text_tabl-label_fk_type = &apos;Fremdschlüsselfeld Typ:&apos;.
  text_tabl-label_fk_semantic = &apos;Semantic Attribute&apos;.

  text_view-title_tables = &apos;Tabellen:&apos;.
  text_view-title_join_conds = &apos;Join-Bedingungen:&apos;.
  text_view-title_sel_conds = &apos;Selection Bedingungen:&apos;.
  text_view-title_fields = &apos;View Flds:&apos;.
  text_view-note_join_cond = &apos;&lt;i&gt; Keine zusätzliche Join-Bedingung muss hier gehalten werden. &lt;/i&gt;&apos;.
  text_view-note_sel_cond = &apos;&lt;i&gt; keine zusätzliche Auswahl Bedingung muss hier gehalten werden. &lt;/i&gt;&apos;.

  text_enqu-label_allow_rfc = &apos;Erlaube RFC&apos;.
  text_enqu-label_tables = &apos;Tabellen&apos;.
  text_enqu-label_params = &apos;Parameter&apos;.

  text_shlp-txt_type_ele = &apos;Elementary&apos;.
  text_shlp-txt_type_col = &apos;Collective&apos;.
  text_shlp-txt_type = &apos;Type&apos;.

  text_ttyp-label_row_type = &apos;Line Type&apos;.

  text_msag-label_messages = &apos;Nachrichten&apos;.

  text_mess-txt_title = &apos;Nachrichten pflegen mit kurzen Text unter Nachricht Klasse wie in der unten aufgeführten &lt;br&gt;&apos;.
  text_mess-txt_mt_longtext = &apos;Pflegen Langtext Nachricht:&apos;.

  text_tobj-msg_obj_invalid = &apos;Wartung Objekt nicht mehr existiert, könnte es von jemand anderem gelöscht werden.&apos;.
  text_tobj-label_events = &apos;Events&apos;.
  text_tobj-txt_mt_event = &apos;Im Instandhaltungsobjekt Bildschirm, klicken Sie auf Menü Enviroment-&gt; Modification-&gt; Veranstaltungen, &apos; &amp;&amp;
                           &apos;Klick &apos;&apos;New Entries&apos;&apos; Knopf, Eingang Event-Typ und FORM-Routine Namen, dann speichern. &apos; &amp;
                           &apos;Der Code der Routinen werden in den Prozess der Umsetzung beachten importiert werden.&apos;.

  text_vcls-title_obj_stru = &apos;Objekt-Struktur&apos;.
  text_vcls-title_fld_dep = &apos;Das Feld Dependence&apos;.
  text_vcls-title_events = text_tobj-label_events.
  text_vcls-label_hier = &apos;Hierarchische Instandhaltung Betrieb Handhabung&apos;.
  text_vcls-label_type = &apos;Read Type&apos;.
  text_vcls-txt_type_comp = &apos;Beenden&apos;.
  text_vcls-txt_type_sub = &apos;Subtree&apos;.
  text_vcls-txt_mt_event = &apos;In der Pflege von Viewclusters, doppelklicken Sie auf Knoten &apos;&apos;Events&apos;&apos;, Eingang Attributwerte und sparen.&apos;.

  text_tran-label_type           = &apos;Transaction Type&apos;.
  text_tran-label_default_values = &apos;Vorschlagswerte&apos;.
  text_tran-label_classification = &apos;Klassifikation&apos;.
  text_tran-label_inherit_gui    = &apos;GUI-Eigenschaften erben&apos;.
  text_tran-label_prof_user      = &apos;Professional User Transaction&apos;.
  text_tran-label_easy_web       = &apos;Easy Web Transaction&apos;.
  text_tran-label_service        = &apos;Service&apos;.
  text_tran-label_pervasive      = &apos;Pervasive enabled&apos;.
  text_tran-label_auth_values    = &apos;Werte&apos;.
  text_tran-label_oo_mode        = &apos;OO-Transaktionsmodell&apos;.
  text_tran-label_oo_clas        = &apos;Klassenname&apos;.
  text_tran-label_oo_meth        = &apos;Methode&apos;.
  text_tran-label_oo_local_prog  = &apos;lokal_in_Programm&apos;.
  text_tran-label_oo_update_mode = &apos;Verbuchungsmodus&apos;.
  text_tran-label_transaction    = &apos;Transaktion&apos;.
  text_tran-label_transaction_variant = &apos;Transaktionsvariante&apos;.
  text_tran-label_skip_init_screen    = &apos;Einstiegsbild überspringen&apos;.

  text_tabu-txt_maint_node = &apos;Pflegen Sie die Einträge für den Knoten:&apos;.
* Anweisungen der unterstützten Objekttypen
  text_devc-inst_devc = &apos;Run TCODE SE80 und geben in Repository Browser, wählen Sie&apos;&apos; Paket&apos;&apos; von Dropdown-Liste&apos; &amp;
            &apos;Input Paket Namen, klicken Sie auf&apos;&apos; Ja&apos;&apos; in der Pop-up-Dialogfeld Input notwendiges Attribut-Werte entsprechend der Dokumentation und sparen.&apos;.
  text_devc-inst_devp = &apos;Run TCODE SE21, Eingang Package-Namen in der unten aufgeführt ist, klicken&apos;&apos; ändern&apos;&apos; Knopf, klicken Sie auf &apos;&apos;Use Zugriffe Registerkarte auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;&amp;
            &apos;Input Paketschnittstelle Namen und Fehlerschwere entsprechend der Dokumentation und sparen.&apos;.
  text_devc-inst_pinf = &apos;Run TCODE SE21, Eingang Package-Namen in der unten aufgeführt ist, klicken&apos;&apos; ändern&apos;&apos; Knopf, klicken Sie auf &apos;&apos;Paketschnittstellen Registerkarte, klicken Sie auf&apos;&apos; Add&apos;&apos; Knopf,&apos; &amp;&amp;
            &apos;Input Paketschnittstelle Namen und eine kurze Beschreibung nach Dokumentation und sparen.&apos;.
  text_devc-inst_devp_sub = &apos;Klicken Sie auf &apos;&apos;Use Zugriffe Registerkarte auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;&amp;
            &apos;Input Paketschnittstelle Namen und Fehlerschwere entsprechend der Dokumentation und sparen.&apos;.
  text_devc-inst_pinf_sub = &apos;Klicken Sie auf &apos;&apos;&apos;&apos;Paketschnittstellen Registerkarte, klicken Sie auf&apos;&apos; Add&apos;&apos; Knopf,&apos; &amp;
            &apos;Input Paketschnittstelle Namen und eine kurze Beschreibung nach Dokumentation und sparen.&apos;.
  text_fugr-inst_fugr = &apos;Select-Paket, wo Funktion Gruppe erstellt werden soll, rechte Maustaste&gt; Create-&gt; Funktion Group, Eingang Attributwerte und sparen.&apos;.
  text_fugr-inst_fugt = &apos;Select Funktion Gruppe und klicken Sie rechts-&gt; Ändern Eingang Attributwerte und sparen.&apos;.
  text_doma-inst_doma = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Domain&apos;&apos;, Eingang Domain-Namen, klicken Sie auf&apos;&apos; Erstellen&apos;&apos; Knopf, Eingang Attributwerte, dann speichern und zu aktivieren.&apos;.
  text_dtel-inst_dtel = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Datentyp&apos;&apos;, Eingabedaten Element Name, auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;
                        &apos;Wählen Radiokasten&apos;&apos; Datenelement&apos;&apos;, Eingang Attributwerte, dann speichern und zu aktivieren.&apos;.
  text_tabl-inst_tabl = &apos;Run TCODE SE11, für Datenbank-Tabelle, wählen Sie Radio-Box &apos;&apos;Database Tabelle&apos;&apos;, Eingabe-Tabelle ein, klicken Sie &apos;&apos;erstellen&apos;&apos; Knopf,&apos; &amp;&amp;
                        &apos;Halten die Attribute, Felder, technischen Einstellungen, Indizes und etc.&apos; &amp;
                        &apos;Für Struktur, wählen Sie Radio-Box &apos;&apos;Datentyp&apos;&apos;, Input-Struktur name, &apos; &amp;&amp;
                        &apos;Klick &apos;&apos;&apos;&apos; erstellen, wählen Sie Radio-Box&apos;&apos; Struktur&apos;&apos;, Eingang Attributwerte, dann speichern und zu aktivieren. &apos;.
  text_tabl-inst_tabd = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Datenbank&apos;&apos; Tisch, Eingang Tabelle / Struktur Namen, auf&apos;&apos; ändern&apos;&apos; Knopf, pflegen Sie die Attribute, dann speichern und zu aktivieren.&apos;.
  text_view-inst_view = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Ansicht&apos;&apos;, Eingang Ansicht Name, klicken Sie auf&apos;&apos; Erstellen&apos;&apos; Knopf, &apos; &amp;&amp;
                        &apos;wählen Sie die Ansicht Typ, pflegen Attribute, Tisch / Join-Bedingungen,&apos; &amp;
                        &apos;View Felder, Selection AGB, Status-und Wa. etc, dann speichern und zu aktivieren.&apos;.
  text_view-inst_vied = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Ansicht&apos;&apos;, Eingang Ansicht Name, klicken Sie auf&apos;&apos; ändern&apos;&apos; Knopf, pflegen Attribute, Tisch / Join-Bedingungen,&apos; &amp;
                        &apos;View Felder, Selection AGB, Status-und Wa. etc, dann speichern und zu aktivieren.&apos;.

  text_shlp-inst_shlp = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Suchhilfe&apos;&apos;, Eingang Suchhilfe Namen, auf&apos;&apos; Erstellen&apos;&apos; Taste, wählen Sie die Suchhilfe Art pflegen Attribute&apos; &amp;
                        &apos;Suchhilfeparameter und etc, dann speichern und zu aktivieren.&apos;.
  text_enqu-inst_enqu = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Sperrobjektname&apos;&apos;, Eingang Sperrobjektname auf&apos;&apos; Erstellen&apos;&apos; Knopf, pflegen Attribute&apos; &amp;
                        &apos;Tische, Sperrparameter und etc, dann speichern und zu aktivieren. &apos;.
  text_ttyp-inst_ttyp = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Datentyp&apos;&apos;, Eingänge Typnamen auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;
                        &apos;Wählen Radiokasten&apos;&apos; Table Type&apos;&apos;, Eingang Attributwerte, dann speichern und zu aktivieren.&apos;.
  text_tobj-inst_tobj = &apos;Run TCODE SE54, Eingang Pflege-View ein, wählen Sie Radio-Box&apos;&apos; generierte Objekte&apos;&apos; auf&apos;&apos; erstellen / ändern&apos;&apos; Knopf,&apos; &amp;&amp;
                        &apos;Wählen Sie&apos;&apos; Ja&apos;&apos; in den Popup-Dialogfeld zur Bestätigung, Eingang Attributwerte und klicken Sie auf die Schaltfläche Erstellen oben, wählen Sie Paket nach Dokumentation und sparen.&apos;.
  text_nrob-inst_nrob = &apos;Run TCODE SNRO, Eingang Nummernkreisobjekts Namen, auf&apos;&apos; Erstellen&apos;&apos; Knopf, Eingang Attributwerte und speichern, wählen Sie Paket nach Dokumentation.&apos;.
  text_msag-inst_msad = &apos;Run TCODE SE91, Input-Message-Klasse, und klicken Sie&apos;&apos; erstellen&apos;&apos; Knopf, Eingang Attribut, Meldungen und speichern, wählen Sie Paket nach Dokumentation.&apos;.
  text_msag-inst_msag = text_msag-inst_msad.
  text_msag-inst_mess = &apos;Run TCODE SE91, Input-Message-Klasse, und klicken Sie&apos;&apos; ändern&apos;&apos; Knopf, pflegen Nachricht kurze Texte, &apos; &amp;&amp;
                        &apos;für die Nachrichtenübertragung mit langen Text, deaktivieren Sie das Kontrollkästchen &apos; &amp;
                        &apos;&apos;&apos;Selbsterklärende&apos;&apos;, klicken Sie dann auf Menü&apos;&apos; Langtext&apos;&apos;, halten die lange Text nach der Dokumentation.&apos;.
  text_docu-inst_docu = &apos;Für Daten-Element, TCODE SE11 ausführen, wählen Sie Radio-Box &apos;&apos;Datentyp&apos;&apos;, Eingabedaten Element und klicken Sie auf &apos;&apos;ändern&apos;&apos; Knopf,&apos; &amp;&amp;
                        &apos;Klicken im Menü &apos;&apos;Documentation&apos;&apos; und pflegen die Dokumentation, wie in der unten beschrieben. &lt;br&gt;&apos; &amp;&amp;
                        &apos;Für Langtext Nachricht Kurztext, TCODE SE91, Input-Message-Klasse, und klicken Sie &apos;&apos;ändern&apos;&apos; Knopf, wählen Sie die Nachricht ausführen, deaktivieren Sie die Checkbox&apos; &amp;&amp;
                        &apos; &apos;&apos;Selbsterklärende&apos;&apos;, klicken Sie dann auf Menü &apos;&apos;Langtext&apos;&apos;, halten die lange Text wie im Folgenden beschrieben.&apos;.
  text_tran-inst_tran = &apos;Run TCODE SE93, Eingang Transaktionscode auf&apos;&apos; Erstellen&apos;&apos; Knopf, wenn&apos; &amp;&amp;
                        &apos;Input Kurztext und wählen Sie Start-Objekt, wenn es bereits vorhanden ist, einfach ignorieren, wenn nicht,&apos; &amp;
                        &apos;Halten die Werte der Attribute und wählen Sie Paket nach der Dokumentation, dann speichern Sie Ihre Arbeit.&apos;.

  DATA: lcv_inst_dat TYPE String.
  lcv_inst_dat = &apos;Run TCODE $CODE, Eingang $DATYPE Namen klicken&apos;&apos; pflegen&apos;&apos;,&apos; &amp;&amp;
          &apos;Wenn Warnmeldung&apos;&apos; Achtung: Der Tisch ist Cross-client&apos;&apos; Pop-up,&apos; &amp; &apos;einfach bestätigen, dann fügen Sie Einträge in der Event auswählen.&apos; &amp;&amp;
          &apos;Beachten Sie, dass diese Einträge könnten abhängig von anderen Repository ojekte, wenn Sie nicht weiter gehen kann, versuchen,&apos; &amp;&amp;
          &apos;Fügen Sie die abhängigen Objekte ersten oder es wieder tun nach der Umsetzung der note.Meanwhile, haben nur die Felder einen gültigen Wert muss &apos; &amp;&amp;
          &apos;Aufgeführt zu erhalten, das heißt, Sie don&apos;&apos; t müssen über andere Felder zu kümmern.&apos;.
  text_tabu-inst_cdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_cdat WITH &apos;SM34&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_cdat WITH &apos;Viewclusters&apos;.

  text_tabu-inst_vdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_vdat WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_vdat WITH &apos;Pflege-View&apos;.

  text_tabu-inst_tabu = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_tabu WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_tabu WITH &apos;table&apos;.
ENDFORM.

FORM init_object_instructions.
  PERFORM append_instruction USING &apos;DEVC&apos; text_devc-inst_devc.
  PERFORM append_instruction USING &apos;DEVP&apos; text_devc-inst_devp.
  PERFORM append_instruction USING &apos;PINF&apos; text_devc-inst_pinf.
  PERFORM append_instruction USING &apos;FUGR&apos; text_fugr-inst_fugr.
  PERFORM append_instruction USING &apos;FUGR&apos; text_fugr-inst_fugt.
  PERFORM append_instruction USING &apos;DOMA&apos; text_doma-inst_doma.
  PERFORM append_instruction USING &apos;DTEL&apos; text_dtel-inst_dtel.
  PERFORM append_instruction USING &apos;TABL&apos; text_tabl-inst_tabl.
  PERFORM append_instruction USING &apos;TABD&apos; text_tabl-inst_tabd.
  PERFORM append_instruction USING &apos;VIEW&apos; text_view-inst_view.
  PERFORM append_instruction USING &apos;VIED&apos; text_view-inst_vied.
  PERFORM append_instruction USING &apos;SHLP&apos; text_shlp-inst_shlp.
  PERFORM append_instruction USING &apos;ENQU&apos; text_enqu-inst_enqu.
  PERFORM append_instruction USING &apos;TTYP&apos; text_ttyp-inst_ttyp.
  PERFORM append_instruction USING &apos;TOBJ&apos; text_tobj-inst_tobj.
  PERFORM append_instruction USING &apos;VCLS&apos; text_tabl-inst_tabd.
  PERFORM append_instruction USING &apos;NROB&apos; text_nrob-inst_nrob.
  PERFORM append_instruction USING &apos;DOCU&apos; text_docu-inst_docu.
  PERFORM append_instruction USING &apos;MSAD&apos; text_msag-inst_msad.
  PERFORM append_instruction USING &apos;MSAG&apos; text_msag-inst_msag.
  PERFORM append_instruction USING &apos;MESS&apos; text_msag-inst_mess.
  PERFORM append_instruction USING &apos;TRAN&apos; text_tran-inst_tran.
  PERFORM append_instruction USING &apos;CDAT&apos; text_tabu-inst_cdat.
  PERFORM append_instruction USING &apos;VDAT&apos; text_tabu-inst_vdat.
  PERFORM append_instruction USING &apos;TABU&apos; text_tabu-inst_tabu.
ENDFORM.

FORM append_instruction USING iv_object TYPE trobjtype iv_txt TYPE string.
  DATA: ls_inst TYPE s_object_instruction.

  ls_inst-object = iv_object.
  ls_inst-instruction = iv_txt.

  READ TABLE gt_object_instruction WITH TABLE KEY object = iv_object TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  INSERT ls_inst INTO TABLE gt_object_instruction.
ENDFORM.
***************** i18n End *****************
*&amp;---------------Common Routines &amp; UI Logic &amp; HTML Ultility &amp; Upload &amp; Code Helper---------------*
FORM f4_request.
  DATA: ls_selected_request TYPE trwbo_request_header,
        lv_organizer_type   TYPE trwbo_calling_organizer VALUE &apos;W&apos;,
        ls_selection        TYPE trwbo_selection.

  ls_selection-reqstatus = &apos;R&apos;.
  CALL FUNCTION &apos;TR_PRESENT_REQUESTS_SEL_POPUP&apos;
    EXPORTING
      iv_organizer_type   = lv_organizer_type
      is_selection        = ls_selection
    IMPORTING
      es_selected_request = ls_selected_request.

  so_trans-low = ls_selected_request-trkorr.
ENDFORM.

FORM f4_exclude_objects.
  DATA: lt_objects TYPE TABLE OF s_obj_header,
        lt_ddsh    TYPE TABLE OF ddshretval.

  PERFORM collect_objects_header_in_tr CHANGING lt_objects.
  CHECK lt_objects IS NOT INITIAL.
  SORT lt_objects BY object obj_name ASCENDING.

  CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    EXPORTING
      retfield        = &apos;OBJ_NAME&apos;
      dynpprog        = sy-cprog
      dynpnr          = sy-dynnr
      dynprofield     = &apos;SO_EXCLU&apos;
      value_org       = &apos;S&apos;
      display         = &apos;F&apos;
    TABLES
      value_tab       = lt_objects
      return_tab      = lt_ddsh
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
ENDFORM.

FORM select_download_dir CHANGING cv_dir TYPE string.
  cl_gui_frontend_services=&gt;directory_browse(
    CHANGING
      selected_folder      =     cv_dir
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4
      ).

  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
ENDFORM.

FORM select_transport_file CHANGING cv_file TYPE string.
  DATA: lv_desktop_path TYPE string,
        lt_filetable    TYPE filetable,
        lv_user_action  TYPE i,
        lv_msg          TYPE string,
        lv_rc           TYPE i.

  cl_gui_frontend_services=&gt;get_desktop_directory(
    CHANGING
      desktop_directory = lv_desktop_path
    ).

  cl_gui_frontend_services=&gt;file_open_dialog(
    EXPORTING
      default_extension       = &apos;*.zip&apos;                     &quot;#EC NOTEXT
      initial_directory       = lv_desktop_path
      file_filter             = cl_gui_frontend_services=&gt;filetype_all
      multiselection          = abap_false
    CHANGING
      file_table              = lt_filetable
      user_action             = lv_user_action
      rc                      = lv_rc
    EXCEPTIONS
      file_open_dialog_failed = 1
      cntl_error              = 2
      error_no_gui            = 3
      not_supported_by_gui    = 4
      OTHERS                  = 5
    ).

  IF sy-subrc EQ 0.
    READ TABLE lt_filetable INDEX 1 INTO cv_file.
  ELSE.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
    MESSAGE e208(00) WITH lv_msg.
  ENDIF.
ENDFORM.

FORM scenario_switch.
  DATA: lv_hide_id1 TYPE c LENGTH 3,
        lv_hide_id2 TYPE c LENGTH 3.

  IF export EQ abap_true.
    lv_hide_id1 = &apos;IMP&apos;.
    lv_hide_id2 = &apos;COD&apos;.
  ELSEIF import EQ abap_true.
    lv_hide_id1 = &apos;EXP&apos;.
    lv_hide_id2 = &apos;COD&apos;.
  ELSEIF code EQ abap_true.
    lv_hide_id1 = &apos;EXP&apos;.
    lv_hide_id2 = &apos;IMP&apos;.
  ENDIF.

  LOOP AT SCREEN.
    IF screen-group1 EQ lv_hide_id1 OR screen-group1 EQ lv_hide_id2.
      screen-active = &apos;0&apos;.
      screen-invisible = &apos;1&apos;.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
ENDFORM.

FORM validate_params CHANGING cv_msg TYPE string.
  CLEAR cv_msg.

  IF export EQ abap_true.
    IF so_trans IS INITIAL.
      cv_msg = &apos;Please select transport request&apos;.
      RETURN.
    ELSE.
      DATA: lt_e070 TYPE TABLE OF e070,
            ls_e070 TYPE e070.

      SELECT * FROM e070 INTO TABLE lt_e070 WHERE trkorr IN so_trans AND trstatus EQ &apos;R&apos; ORDER BY as4date ASCENDING.
      LOOP AT so_trans.
        READ TABLE lt_e070 WITH KEY trkorr = so_trans-low TRANSPORTING NO FIELDS.
        IF sy-subrc NE 0.
          CONCATENATE &apos;Request &apos; so_trans-low &apos; does not exist or is not released yet.&apos; INTO cv_msg RESPECTING BLANKS.
          RETURN.
        ENDIF.
      ENDLOOP.

      READ TABLE lt_e070 INTO ls_e070 INDEX 1.
      gv_tr_date = ls_e070-as4date.
    ENDIF.

    IF p_dir IS INITIAL.
      cv_msg = &apos;Please select export folder&apos;.
      RETURN.
    ENDIF.

    IF p_doc IS INITIAL.
      cv_msg = &apos;Please input document title&apos;.
      RETURN.
    ENDIF.
  ENDIF.

  IF import EQ abap_true.
    IF p_file IS INITIAL.
      cv_msg = &apos;Please upload a transport zip file&apos;.
      RETURN.
    ELSE.
      PERFORM check_transport_zip CHANGING cv_msg.
      IF cv_msg IS NOT INITIAL.
        RETURN.
      ENDIF.
    ENDIF.
  ENDIF.

  IF code EQ abap_true.
    DATA: lv_confirm_msg TYPE string,
          lv_answer      TYPE c.

    CLEAR gt_objtype2codes.

    LOOP AT so_objt.
      READ TABLE gt_ko100 WITH TABLE KEY object = so_objt-low TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        CONCATENATE so_objt-low &apos; is a invalid object type, please check it.&apos; INTO cv_msg RESPECTING BLANKS.
        RETURN.
      ENDIF.

      READ TABLE gt_objtype_desc WITH TABLE KEY object = so_objt-low TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        CONCATENATE &apos;Object Type &apos; so_objt-low &apos; has been supported already, do you still want to print code template?&apos;
          INTO lv_confirm_msg RESPECTING BLANKS.

        CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
          EXPORTING
            text_question = lv_confirm_msg
          IMPORTING
            answer        = lv_answer.

        IF lv_answer EQ &apos;1&apos;.
          APPEND so_objt-low TO gt_objtype2codes.
        ENDIF.
        CLEAR lv_confirm_msg.
      ELSE.
        APPEND so_objt-low TO gt_objtype2codes.
      ENDIF.
    ENDLOOP.

    IF gt_objtype2codes IS INITIAL.
      cv_msg = &apos;Please select at least one valid object type&apos;.
      RETURN.
    ENDIF.
  ENDIF.
ENDFORM.

FORM response.
  DATA: lv_msg   TYPE string,
        lv_start TYPE i,
        lv_end   TYPE i,
        lv_str   TYPE string,
        lv_cost  TYPE p DECIMALS 2,
        lv_file  TYPE string.

  PERFORM validate_params CHANGING lv_msg.
  IF lv_msg IS NOT INITIAL.
    MESSAGE s208(00) WITH lv_msg.
    RETURN.
  ENDIF.

  GET RUN TIME FIELD lv_start.
  IF export EQ abap_true.
    PERFORM prepare_html_head.
    PERFORM prepare_html_body.
    IF gt_html IS NOT INITIAL.
      APPEND LINES OF gt_html TO gt_html_all.
      PERFORM prepare_html_tail.
      PERFORM export_docu CHANGING lv_file.
    ENDIF.
    IF p_bin EQ abap_true.
      PERFORM export_transport_files.
    ENDIF.

    CHECK p_test NE abap_true.
    PERFORM display_result.
    PERFORM open_html_in_msword USING lv_file.
  ENDIF.

  IF import EQ abap_true.
    PERFORM upload_transport_files.
  ENDIF.

  IF code EQ abap_true.
    PERFORM initialize_code_template.
    PERFORM print_template_codes.
  ENDIF.

  CHECK p_test NE abap_true.

  GET RUN TIME FIELD lv_end.
  lv_cost = ( lv_end - lv_start ) / 1000000.
  lv_str = lv_cost.
  lv_msg = text_common-time_cost.
  REPLACE FIRST OCCURRENCE OF &apos;$TIME&apos; IN lv_msg WITH lv_str.
  WRITE: / icon_time AS ICON, lv_msg.
ENDFORM.
FORM export_transport_files.
  DATA: lv_zip TYPE xstring,
        lt_str TYPE solix_tab,
        lv_msg TYPE string,
        lv_err_cnt     TYPE i,
        lv_zipfilename TYPE string.

  IF go_zip IS NOT BOUND.
    CREATE OBJECT go_zip.
  ENDIF.

  LOOP AT so_trans.
    PERFORM add_single_transport USING so_trans-low CHANGING lv_msg.
    IF lv_msg IS NOT INITIAL.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
      ADD 1 TO lv_err_cnt.
    ENDIF.
    CONCATENATE lv_zipfilename &apos;_&apos; so_trans-low INTO lv_zipfilename.
  ENDLOOP.

  IF lv_err_cnt GT 0.
    RETURN.
  ENDIF.
  SHIFT lv_zipfilename.
  CONCATENATE p_dir gv_slash lv_zipfilename &apos;.zip&apos; INTO lv_zipfilename RESPECTING BLANKS.

  lv_zip = go_zip-&gt;save( ).
  lt_str = cl_bcs_convert=&gt;xstring_to_solix( iv_xstring  = lv_zip ).
  PERFORM download_file USING &apos;BIN&apos; lv_zipfilename CHANGING lv_msg lt_str.
  IF lv_msg IS NOT INITIAL.
    PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
  ENDIF.
ENDFORM.

FORM add_single_transport USING iv_tr TYPE e070-trkorr CHANGING cv_msg TYPE string.
  DATA: server_file_k TYPE rlgrap-filename,
        server_file_r TYPE rlgrap-filename,
        lv_tr_no      TYPE e070-trkorr,
        lv_filename   TYPE string,
        lv_slah       TYPE c.

  CLEAR cv_msg.
  lv_slah = gv_trans_dir(1).
  lv_tr_no = iv_tr.
  SHIFT lv_tr_no BY 4 PLACES LEFT.

  &quot; SI3K017810-&gt; K017810.SI3 &amp; R017810.SI3
  CONCATENATE &apos;K&apos; lv_tr_no &apos;.&apos; so_trans-low(3) INTO lv_filename.
  CONCATENATE gv_trans_dir lv_slah &apos;cofiles&apos; lv_slah  lv_filename INTO server_file_k. &quot;#EC NOTEXT
  PERFORM add2zip USING lv_filename server_file_k CHANGING cv_msg.
  CLEAR lv_filename.
  IF cv_msg IS NOT INITIAL.
    EXIT.
  ENDIF.

  CONCATENATE &apos;R&apos; lv_tr_no &apos;.&apos; so_trans-low(3) INTO lv_filename.
  CONCATENATE gv_trans_dir lv_slah &apos;data&apos; lv_slah lv_filename INTO server_file_r. &quot;#EC NOTEXT
  PERFORM add2zip USING lv_filename server_file_r CHANGING cv_msg.
  IF cv_msg IS NOT INITIAL.
    RETURN.
  ENDIF.
ENDFORM.

FORM add2zip USING iv_filename TYPE string iv_server_file TYPE rlgrap-filename CHANGING cv_msg TYPE string.
  DATA: l_data     TYPE STANDARD TABLE OF tbl1024,
        l_size     TYPE i,
        lv_xstr    TYPE xstring.

  CALL FUNCTION &apos;SCMS_UPLOAD&apos;
    EXPORTING
      filename = iv_server_file
      binary   = &apos;X&apos;
      frontend = &apos; &apos;
    IMPORTING
      filesize = l_size
    TABLES
      data     = l_data
    EXCEPTIONS
      error    = 1
      OTHERS   = 2.
  IF sy-subrc NE 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
    PERFORM append_common_msg USING &apos;E&apos; cv_msg CHANGING gt_sys_msg.
    RETURN.
  ENDIF.

  CALL FUNCTION &apos;SCMS_BINARY_TO_XSTRING&apos;
    EXPORTING
      input_length = l_size
    IMPORTING
      buffer       = lv_xstr
    TABLES
      binary_tab   = l_data
    EXCEPTIONS
      failed       = 1
      OTHERS       = 2.

  go_zip-&gt;add( name = iv_filename content = lv_xstr ).
ENDFORM.
FORM prepare_html_body.
  DATA: lt_object_header TYPE TABLE OF s_obj_header,
        ls_tadir         TYPE tadir,
        lv_subroutine    TYPE string.

  FIELD-SYMBOLS: &lt;fs_object_header&gt; TYPE s_obj_header,
                 &lt;fs_objtype_order&gt; TYPE s_objtype_order.

  PERFORM collect_objects_header_in_tr CHANGING lt_object_header.
  LOOP AT lt_object_header ASSIGNING &lt;fs_object_header&gt;.
    READ TABLE so_exclu WITH KEY low = &lt;fs_object_header&gt;-obj_name TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      DELETE lt_object_header.
      CONTINUE.
    ENDIF.

    READ TABLE gt_objtype_order WITH TABLE KEY object = &lt;fs_object_header&gt;-object ASSIGNING &lt;fs_objtype_order&gt;.
    &lt;fs_object_header&gt;-primary_sort = &lt;fs_objtype_order&gt;-sort_no.
  ENDLOOP.
  CHECK lt_object_header IS NOT INITIAL.

  SORT lt_object_header BY primary_sort obj_name.

  LOOP AT lt_object_header ASSIGNING &lt;fs_object_header&gt;.
    SELECT SINGLE * FROM tadir INTO ls_tadir WHERE pgmid = &lt;fs_object_header&gt;-pgmid
      AND object = &lt;fs_object_header&gt;-object AND obj_name = &lt;fs_object_header&gt;-obj_name.
    IF sy-subrc EQ 0.
      &lt;fs_object_header&gt;-devclass = ls_tadir-devclass.
    ENDIF.
    &quot; set activity &apos;Create&apos; as default value, change mode will be detected in routine GETDATA_{objtype} if possible
    &lt;fs_object_header&gt;-activity = gcv_act_create.
    CONCATENATE &apos;GETDATA_&apos; &lt;fs_object_header&gt;-object INTO lv_subroutine. &quot;#EC NOTEXT
    PERFORM (lv_subroutine) IN PROGRAM (sy-repid) USING &lt;fs_object_header&gt; IF FOUND.
    CLEAR lv_subroutine.

    AT END OF object.
      &quot; usually abstract routine can cover 80% of the case, however 20% are special and need to handle separately
      &quot; so we will try to call subroutine of special case first and then fall back to common mode
      TRY.
          CONCATENATE &apos;CONVERT_&apos; &lt;fs_object_header&gt;-object INTO lv_subroutine. &quot;#EC NOTEXT
          PERFORM (lv_subroutine) IN PROGRAM (sy-repid).
        CATCH cx_sy_dyn_call_illegal_form.
          PERFORM convert_obj_abstract USING &lt;fs_object_header&gt;-object.
      ENDTRY.
    ENDAT.
  ENDLOOP.
ENDFORM.

* abstract subroutine for all kinds of objects
* for a collection of objects with same kind, the rendering html should be build in the steps below:
* 1.get header html
* 2.render each object in same format
FORM convert_obj_abstract USING iv_objtype TYPE trobjtype.
  DATA: lv_cnt  TYPE i,
        lv_tab  TYPE string,
        lt_html TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_t_obj&gt;       TYPE STANDARD TABLE,
                 &lt;fs_obj&gt;         TYPE any,
                 &lt;fs_sec_sort&gt;    TYPE any.

  CONCATENATE &apos;(&apos; sy-repid &apos;)GT_&apos; iv_objtype INTO lv_tab.
  ASSIGN (lv_tab) TO &lt;fs_t_obj&gt;.
  CHECK &lt;fs_t_obj&gt; IS ASSIGNED AND &lt;fs_t_obj&gt; IS NOT INITIAL.

  ADD 1 TO gv_header_no.
  lv_cnt  = lines( &lt;fs_t_obj&gt; ).
  PERFORM add_header_html USING iv_objtype CHANGING lt_html.
  PERFORM add_object_instruction_html USING iv_objtype CHANGING lt_html.

  LOOP AT &lt;fs_t_obj&gt; ASSIGNING &lt;fs_obj&gt;.
    ASSIGN COMPONENT &apos;SECONDARY_SORT&apos; OF STRUCTURE &lt;fs_obj&gt; TO &lt;fs_sec_sort&gt;.
    IF &lt;fs_sec_sort&gt; IS ASSIGNED.
      &lt;fs_sec_sort&gt; = sy-tabix.
    ENDIF.
    PERFORM get_single_obj_html_abstract USING &lt;fs_obj&gt; lv_cnt CHANGING lt_html.

    UNASSIGN &lt;fs_sec_sort&gt;.
  ENDLOOP.
  UNASSIGN &lt;fs_obj&gt;.
  APPEND LINES OF lt_html TO gt_html.
ENDFORM.

FORM add_object_instruction_html USING iv_object TYPE trobjtype CHANGING ct_html TYPE t_string.
  FIELD-SYMBOLS &lt;fs_instruction&gt; TYPE s_object_instruction.

  READ TABLE gt_object_instruction ASSIGNING &lt;fs_instruction&gt; WITH TABLE KEY object = iv_object.
  IF &lt;fs_instruction&gt; IS ASSIGNED AND &lt;fs_instruction&gt;-instruction IS NOT INITIAL.
    PERFORM get_paragraph_html USING &lt;fs_instruction&gt;-instruction CHANGING ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDIF.
ENDFORM.

* abstract subroutine as a template pattern for all kinds of objects to implement
* for a single object, the rendering html should be built in the steps below:
* 1.get title html
* 2.get basic attributes and always are obj_name, devclass, short_text
* 3.get additional attributes, for example, for package, its application component, software component and etc
* 4.get special attributes, for example, for table, its fields, technical settings, foreign key settings and etc
* To keep things simple, name convention should be followed like this:
* GET_ADDITIONAL_HTML_{objtype}
* GET_SPECIAL_HTML_{objtype}
FORM get_single_obj_html_abstract USING is_obj TYPE any iv_cnt TYPE i CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_form_addi  TYPE string,
        lv_form_spec  TYPE string,
        ls_obj_header TYPE s_obj_header.
  FIELD-SYMBOLS &lt;fs_objtype_order&gt; TYPE s_objtype_order.

  MOVE-CORRESPONDING is_obj TO ls_obj_header.
  CONCATENATE &apos;GET_ADDITIONAL_HTML_&apos; ls_obj_header-object INTO lv_form_addi.
  CONCATENATE &apos;GET_SPECIAL_HTML_&apos; ls_obj_header-object INTO lv_form_spec.

  PERFORM add_title_html USING is_obj iv_cnt CHANGING ct_html.
  READ TABLE gt_objtype_order WITH TABLE KEY object = ls_obj_header-object ASSIGNING &lt;fs_objtype_order&gt;.
  IF &lt;fs_objtype_order&gt;-show_basic_attr EQ abap_true.
    APPEND gcv_table_begin TO ct_html.
    PERFORM get_basic_attr_html USING ls_obj_header CHANGING ct_html.
    PERFORM (lv_form_addi) IN PROGRAM (sy-repid) USING is_obj CHANGING ct_html IF FOUND.
    APPEND gcv_table_end TO ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDIF.

  PERFORM (lv_form_spec) IN PROGRAM (sy-repid) USING is_obj CHANGING ct_html IF FOUND.
  PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
ENDFORM.

FORM get_basic_attr_html USING is_obj_header TYPE s_obj_header CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_default2column_html CHANGING ct_html.
  &quot; basic attributes of maintenance object is of little value
  CHECK is_obj_header-object NE &apos;TOBJ&apos;.
  DATA lv_fields TYPE string VALUE &apos;OBJ_NAME|SHORT_TEXT&apos;.
  IF is_obj_header-object NE &apos;DEVC&apos; AND is_obj_header-object NE &apos;FUGT&apos;.
    CONCATENATE lv_fields &apos;|&apos; &apos;DEVCLASS&apos; INTO lv_fields.
  ENDIF.
  PERFORM data2rows USING is_obj_header &apos;S_OBJ_HEADER&apos; lv_fields CHANGING ct_html.
ENDFORM.

FORM get_objtype_desc USING iv_objtype TYPE trobjtype CHANGING cv_str TYPE ko100-text.
  DATA: ls_ko100 TYPE ko100.
  READ TABLE gt_objtype_desc INTO ls_ko100 WITH TABLE KEY object = iv_objtype.
  CLEAR cv_str.
  &quot; TOBJ: Definition of a Maintenance and Transport Object -&gt; might be confusing to customer
  IF iv_objtype EQ &apos;TOBJ&apos;.
    cv_str = text_common-title_tobj.
  ELSE.
    cv_str = ls_ko100-text.
  ENDIF.
ENDFORM.

FORM add_header_html USING iv_objtype TYPE trobjtype CHANGING ct_html TYPE t_string.
  DATA: lv_html   TYPE string,
        lv_desc   TYPE ddtext,
        lv_no_str TYPE string.

  lv_html = gcv_header_html.
  PERFORM format_numc USING gv_header_no CHANGING lv_no_str.
  REPLACE FIRST OCCURRENCE OF &apos;$HEADER_NO&apos; IN lv_html WITH lv_no_str.
  PERFORM get_objtype_desc USING iv_objtype CHANGING lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJECT_DESC&apos; IN lv_html WITH lv_desc.

  APPEND lv_html TO ct_html.
ENDFORM.

FORM add_title_html USING is_obj TYPE any iv_cnt TYPE i CHANGING ct_html TYPE t_string.
  DATA: lv_no1 TYPE string,
        lv_no2 TYPE string,
        lv_desc TYPE ddtext,
        ls_obj_header TYPE s_obj_header,
        lv_title_no TYPE string,
        lv_html TYPE string VALUE gcv_title_html.

  MOVE-CORRESPONDING is_obj TO ls_obj_header.
  IF iv_cnt EQ 1.
    REPLACE FIRST OCCURRENCE OF &apos;$TITLE_NO&apos; IN lv_html WITH &apos;&apos;.
  ELSE.
    PERFORM format_numc USING gv_header_no CHANGING lv_no1.
    PERFORM format_numc USING ls_obj_header-secondary_sort CHANGING lv_no2.
    CONCATENATE lv_no1 &apos;.&apos; lv_no2 &apos; &apos; INTO lv_title_no RESPECTING BLANKS.
    REPLACE FIRST OCCURRENCE OF &apos;$TITLE_NO&apos; IN lv_html WITH lv_title_no.
  ENDIF.

  PERFORM get_title_objtype_desc USING ls_obj_header-object is_obj CHANGING lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$ACTIVITY&apos; IN lv_html WITH ls_obj_header-activity.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJECT_DESC&apos; IN lv_html WITH lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJ_NAME&apos; IN lv_html WITH ls_obj_header-obj_name.
  APPEND lv_html TO ct_html.
ENDFORM.

* some object type has sub category and we need to get that
FORM get_objtype_desc_deep USING is_obj_header TYPE s_obj_header CHANGING cv_desc TYPE string.
  DATA: lv_desc TYPE ddtext,
        lv_len  TYPE i.

  CASE is_obj_header-object.
    WHEN &apos;TABL&apos;.
      DATA ls_tabl TYPE s_tabl.
      READ TABLE gt_tabl INTO ls_tabl WITH KEY obj_name = is_obj_header-obj_name BINARY SEARCH.
      PERFORM get_title_objtype_desc USING is_obj_header-object ls_tabl CHANGING lv_desc.
    WHEN &apos;VIEW&apos;.
      DATA ls_view TYPE s_view.
      READ TABLE gt_view INTO ls_view WITH KEY obj_name = is_obj_header-obj_name BINARY SEARCH.
      PERFORM get_title_objtype_desc USING is_obj_header-object ls_view CHANGING lv_desc.
    WHEN OTHERS.
      PERFORM get_objtype_desc USING is_obj_header-object CHANGING lv_desc.
  ENDCASE.

  CLEAR cv_desc.
  CHECK lv_desc IS NOT INITIAL.
  lv_len = strlen( lv_desc ).
  cv_desc = lv_desc(lv_len).
ENDFORM.

FORM get_title_objtype_desc USING iv_objtype TYPE trobjtype is_obj TYPE any CHANGING cv_desc TYPE ddtext.
  DATA: lv_low TYPE ddfixvalue-low.
  FIELD-SYMBOLS &lt;fs_value&gt; TYPE any.

  CLEAR cv_desc.
  IF iv_objtype EQ &apos;TABL&apos;.
    ASSIGN COMPONENT &apos;TABCLASS&apos; OF STRUCTURE is_obj TO &lt;fs_value&gt;.
    IF &lt;fs_value&gt; IS ASSIGNED.
      lv_low = &lt;fs_value&gt;.
      PERFORM get_value_desc USING &apos;TABCLASS&apos; lv_low CHANGING cv_desc.
    ENDIF.
  ELSEIF iv_objtype EQ &apos;VIEW&apos;.
    ASSIGN COMPONENT &apos;VIEWCLASS&apos; OF STRUCTURE is_obj TO &lt;fs_value&gt;.
    IF &lt;fs_value&gt; IS ASSIGNED.
      lv_low = &lt;fs_value&gt;.
      PERFORM get_value_desc USING &apos;VIEWCLASS&apos; lv_low CHANGING cv_desc.
    ENDIF.
  ELSE.
    PERFORM get_objtype_desc USING iv_objtype CHANGING cv_desc.
  ENDIF.
ENDFORM.

FORM get_small_title_html USING iv_small_title TYPE string CHANGING ct_html TYPE t_string.
  DATA lv_html TYPE string VALUE gcv_small_title_html.
  REPLACE FIRST OCCURRENCE OF &apos;$TITLE&apos; IN lv_html WITH iv_small_title.
  APPEND lv_html TO ct_html.
ENDFORM.

FORM get_paragraph_html  USING iv_para TYPE string CHANGING ct_html TYPE t_string.
  DATA lv_html TYPE string VALUE gcv_paragraph_html.
  REPLACE FIRST OCCURRENCE OF &apos;$PARAGRAPH&apos; IN lv_html WITH iv_para.
  APPEND lv_html TO ct_html.
ENDFORM.

FORM get_column_label_html USING iv_label TYPE any CHANGING cv_td TYPE string.
  CLEAR cv_td.
  cv_td = gcv_td_label.
  REPLACE FIRST OCCURRENCE OF &apos;$LABEL&apos; IN cv_td WITH iv_label.
ENDFORM.

FORM get_tr_label_html USING iv_labels TYPE string CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td TYPE string,
        lv_tr TYPE string,
        lt_labels TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_label&gt; TYPE string.

  SPLIT iv_labels AT &apos;|&apos; INTO TABLE lt_labels.

  lv_tr = &apos;&lt;tr&gt;&apos;.
  LOOP AT lt_labels ASSIGNING &lt;fs_label&gt;.
    CHECK &lt;fs_label&gt; IS NOT INITIAL.
    CONDENSE &lt;fs_label&gt;.
    PERFORM get_column_label_html USING &lt;fs_label&gt; CHANGING lv_td.
    CONCATENATE lv_tr lv_td INTO lv_tr RESPECTING BLANKS.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
ENDFORM.

FORM get_column_value_html USING iv_value TYPE any CHANGING cv_td TYPE string.
  DATA: lv_str   TYPE string,
        lo_descr TYPE REF TO cl_abap_datadescr.

  lo_descr ?= cl_abap_typedescr=&gt;describe_by_data( iv_value ).
  IF lo_descr IS BOUND AND lo_descr-&gt;type_kind EQ &apos;N&apos;.
    PERFORM format_numc USING iv_value CHANGING lv_str.
  ELSE.
    lv_str = iv_value.
  ENDIF.

  CLEAR cv_td.
  cv_td = gcv_td_content.
  REPLACE FIRST OCCURRENCE OF &apos;$VALUE&apos; IN cv_td WITH lv_str.
ENDFORM.

FORM get_column_innertable_html USING iv_value TYPE any CHANGING cv_td TYPE string.
  DATA lv_str TYPE string.
  lv_str = iv_value.

  CLEAR cv_td.
  cv_td = gcv_td_inner_table.
  REPLACE FIRST OCCURRENCE OF &apos;$VALUE&apos; IN cv_td WITH lv_str.
ENDFORM.

FORM get_default2column_html CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_2column_label_html USING text_common-label_col_attr text_common-label_col_value CHANGING ct_html.
ENDFORM.

FORM get_2column_label_html USING iv_label1 TYPE string iv_label2 TYPE string CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_label_html USING iv_label1 CHANGING lv_td1.
  PERFORM get_column_label_html USING iv_label2 CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM get_2column_right_table_html USING iv_label1 TYPE string iv_inner_table_html TYPE string CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_value_html USING iv_label1 CHANGING lv_td1.
  PERFORM get_column_innertable_html USING iv_inner_table_html CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM get_2column_value_html USING iv_label TYPE any iv_value TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_value_html USING iv_label CHANGING lv_td1.
  PERFORM get_column_value_html USING iv_value CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM combine2td USING iv_td1 TYPE string iv_td2 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine3td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM join_str USING it_tab TYPE t_string CHANGING cv_str TYPE string.
  CLEAR cv_str.

  FIELD-SYMBOLS: &lt;fs_str&gt; TYPE string.
  LOOP AT it_tab ASSIGNING &lt;fs_str&gt;.
    CONCATENATE cv_str &lt;fs_str&gt; INTO cv_str RESPECTING BLANKS.
  ENDLOOP.
ENDFORM.

FORM table2tr USING iv_label TYPE string it_tab TYPE STANDARD TABLE iv_stru TYPE any iv_fldnames TYPE string CHANGING ct_html TYPE t_string.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_tmp TYPE string,
        lt_tab TYPE TABLE OF string.

  PERFORM get_column_value_html USING iv_label CHANGING lv_td1.
  PERFORM convert_table_html USING &apos;&apos; it_tab iv_stru iv_fldnames abap_false &apos;&apos; abap_true CHANGING lt_tab.
  PERFORM join_str USING lt_tab CHANGING lv_tmp.
  PERFORM get_column_innertable_html USING lv_tmp CHANGING lv_td2.

  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM convert_table_html USING iv_title TYPE string it_tab TYPE STANDARD TABLE iv_stru TYPE any
                              iv_fldnames TYPE string iv_remove TYPE abap_bool iv_remove_flds TYPE string
                              iv_innertable  TYPE abap_bool
                        CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lt_used_ddic TYPE ddfields,
        lv_tr        TYPE string,
        lv_td        TYPE string,
        lv_txt       TYPE ddtext.
  FIELD-SYMBOLS: &lt;fs_ddic&gt;  TYPE dfies,
                 &lt;fs_row&gt;   TYPE any,
                 &lt;fs_value&gt; TYPE any.

  CHECK it_tab IS NOT INITIAL.
  PERFORM get_used_ddfields USING iv_stru iv_fldnames CHANGING lt_used_ddic.
  CHECK sy-subrc EQ 0.

  IF iv_remove EQ abap_true.
    PERFORM remove_no_need_fields USING it_tab iv_remove_flds CHANGING lt_used_ddic.
  ENDIF.

  IF iv_title IS NOT INITIAL.
    PERFORM get_small_title_html USING iv_title CHANGING ct_html.
  ENDIF.

  APPEND gcv_table_begin TO ct_html.
  PERFORM get_table_head_html USING lt_used_ddic CHANGING lv_tr.
  APPEND lv_tr TO ct_html.

  LOOP AT it_tab ASSIGNING &lt;fs_row&gt;.
    lv_tr = &apos;&lt;tr&gt;&apos;.

    LOOP AT lt_used_ddic ASSIGNING &lt;fs_ddic&gt;.
      ASSIGN COMPONENT &lt;fs_ddic&gt;-fieldname OF STRUCTURE &lt;fs_row&gt; TO &lt;fs_value&gt;.
      CHECK &lt;fs_value&gt; IS ASSIGNED.

      PERFORM get_value_desc USING &lt;fs_ddic&gt;-fieldname &lt;fs_value&gt; CHANGING lv_txt.
      IF lv_txt IS NOT INITIAL.
        lv_txt = escape( val = lv_txt format = cl_abap_format=&gt;e_html_text ).
        PERFORM get_column_value_html USING lv_txt CHANGING lv_td.
      ELSE.
        PERFORM get_column_value_html USING &lt;fs_value&gt; CHANGING lv_td.
      ENDIF.
      CONCATENATE lv_tr lv_td INTO lv_tr RESPECTING BLANKS.

      CLEAR: lv_txt.
      UNASSIGN &lt;fs_value&gt;.
    ENDLOOP.

    CONCATENATE lv_tr &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
    APPEND lv_tr TO ct_html.
  ENDLOOP.
  APPEND gcv_table_end TO ct_html.

  IF iv_innertable EQ abap_false.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDIF.
ENDFORM.

FORM remove_no_need_fields USING it_tab TYPE STANDARD TABLE iv_remove_flds TYPE string CHANGING ct_ddfields TYPE ddfields.
  TYPES: BEGIN OF s_field_remain,
         fieldname TYPE fieldname,
         remain    TYPE abap_bool,
         END OF s_field_remain.
  TYPES: BEGIN OF s_field_to_check,
         fieldname TYPE fieldname,
         END OF s_field_to_check.

  DATA: lt_fld_remain TYPE HASHED TABLE OF s_field_remain WITH UNIQUE KEY fieldname,
        ls_fld_remain TYPE s_field_remain,
        lt_fldnames   TYPE TABLE OF s_field_to_check,
        lt_fld2check  TYPE HASHED TABLE OF s_field_to_check WITH UNIQUE KEY fieldname.
  FIELD-SYMBOLS: &lt;fs_ddic&gt;  TYPE dfies,
                 &lt;fs_fld&gt;   TYPE s_field_to_check,
                 &lt;fs_row&gt;   TYPE any,
                 &lt;fs_value&gt; TYPE any.

  IF iv_remove_flds IS NOT INITIAL.
    SPLIT iv_remove_flds AT &apos;|&apos; INTO TABLE lt_fldnames.
  ELSE.
    LOOP AT ct_ddfields ASSIGNING &lt;fs_ddic&gt;.
      APPEND &lt;fs_ddic&gt;-fieldname TO lt_fldnames.
    ENDLOOP.
  ENDIF.
  MOVE lt_fldnames TO lt_fld2check.

  LOOP AT it_tab ASSIGNING &lt;fs_row&gt;.
    LOOP AT lt_fldnames ASSIGNING &lt;fs_fld&gt;.
      ASSIGN COMPONENT &lt;fs_fld&gt;-fieldname OF STRUCTURE &lt;fs_row&gt; TO &lt;fs_value&gt;.
      IF &lt;fs_value&gt; IS ASSIGNED AND &lt;fs_value&gt; IS NOT INITIAL.
        READ TABLE lt_fld_remain WITH TABLE KEY fieldname = &lt;fs_fld&gt;-fieldname TRANSPORTING NO FIELDS.
        CHECK sy-subrc NE 0.

        ls_fld_remain-fieldname = &lt;fs_fld&gt;-fieldname.
        ls_fld_remain-remain = abap_true.
        INSERT ls_fld_remain INTO TABLE lt_fld_remain.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  LOOP AT ct_ddfields ASSIGNING &lt;fs_ddic&gt;.
    READ TABLE lt_fld2check WITH KEY fieldname = &lt;fs_ddic&gt;-fieldname TRANSPORTING NO FIELDS.
    CHECK sy-subrc EQ 0.

    READ TABLE lt_fld_remain WITH TABLE KEY fieldname = &lt;fs_ddic&gt;-fieldname TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.
    DELETE ct_ddfields.
  ENDLOOP.
ENDFORM.

FORM table2html USING iv_title TYPE string
                      it_tab   TYPE STANDARD TABLE
                      iv_stru  TYPE any
                      iv_fldnames    TYPE string
                      iv_remove      TYPE abap_bool
                      iv_remove_flds TYPE string
                CHANGING ct_html     TYPE STANDARD TABLE.
  PERFORM convert_table_html USING iv_title it_tab iv_stru iv_fldnames iv_remove iv_remove_flds abap_false CHANGING ct_html.
ENDFORM.

FORM data2rows_common USING iv_data TYPE any  iv_stru TYPE any iv_fldnames TYPE any iv_filter TYPE abap_bool CHANGING ct_html TYPE t_string.
  DATA: lt_ddfields TYPE ddfields,
        lv_label    TYPE string,
        lv_txt      TYPE ddtext.
  FIELD-SYMBOLS: &lt;fs_dfies&gt; TYPE dfies,
                 &lt;fs_value&gt; TYPE any.

  PERFORM get_used_ddfields USING iv_stru iv_fldnames CHANGING lt_ddfields.
  LOOP AT lt_ddfields ASSIGNING &lt;fs_dfies&gt;.
    ASSIGN COMPONENT &lt;fs_dfies&gt;-fieldname OF STRUCTURE iv_data TO &lt;fs_value&gt;.
    CHECK &lt;fs_value&gt; IS ASSIGNED.

    PERFORM get_value_desc USING &lt;fs_dfies&gt;-fieldname &lt;fs_value&gt; CHANGING lv_txt.
    IF iv_filter EQ abap_true.
      CHECK &lt;fs_value&gt; IS NOT INITIAL OR lv_txt IS NOT INITIAL.
    ENDIF.

    PERFORM get_field_label USING &lt;fs_dfies&gt; CHANGING lv_label.
    IF lv_txt IS NOT INITIAL.
      lv_txt = escape( val = lv_txt format = cl_abap_format=&gt;e_html_text ).
      PERFORM get_2column_value_html USING lv_label lv_txt CHANGING ct_html.
    ELSE.
      PERFORM get_2column_value_html USING lv_label &lt;fs_value&gt; CHANGING ct_html.
    ENDIF.

    UNASSIGN &lt;fs_value&gt;.
    CLEAR: lv_txt.
  ENDLOOP.
ENDFORM.

FORM data2rows USING iv_data TYPE any  iv_stru TYPE any iv_fldnames TYPE any CHANGING ct_html TYPE t_string.
  PERFORM data2rows_common USING iv_data iv_stru iv_fldnames abap_true CHANGING ct_html.
ENDFORM.

FORM get_used_ddfields USING iv_stru TYPE any iv_fldnames TYPE string CHANGING ct_ddfields TYPE ddfields.
  DATA: lo_stru      TYPE REF TO cl_abap_structdescr,
        lo_type      TYPE REF TO cl_abap_typedescr,
        lt_ddic      TYPE ddfields,
        lt_hash_ddic TYPE HASHED TABLE OF dfies WITH UNIQUE KEY fieldname,
        lt_used_ddic TYPE ddfields,
        lt_fldnames  TYPE TABLE OF fieldname,
        ls_ddic      TYPE dfies,
        lt_components TYPE abap_component_tab,
        lo_ele_descr  TYPE REF TO cl_abap_elemdescr,
        lv_msg       TYPE string.

  FIELD-SYMBOLS: &lt;fs_ddic&gt;  TYPE dfies,
                 &lt;fs_fld&gt;   TYPE fieldname,
                 &lt;fs_comp&gt;  TYPE abap_componentdescr.

  CHECK iv_stru IS NOT INITIAL.
  CALL METHOD cl_abap_typedescr=&gt;describe_by_name
    EXPORTING
      p_name         = iv_stru
    RECEIVING
      p_descr_ref    = lo_type
    EXCEPTIONS
      type_not_found = 1
      OTHERS         = 2.

  IF sy-subrc EQ 0.
    lo_stru ?= lo_type.
    IF lo_stru-&gt;is_ddic_type( ) EQ abap_true.
      lt_ddic = lo_stru-&gt;get_ddic_field_list( ).
    ELSE.
      lt_components = lo_stru-&gt;get_components( ).

      LOOP AT lt_components ASSIGNING &lt;fs_comp&gt; WHERE as_include EQ abap_false.
        &quot; include/table/structure is out of scope, only fields will be fetched
        CHECK &lt;fs_comp&gt;-type-&gt;type_kind NE cl_abap_typedescr=&gt;typekind_table AND
              &lt;fs_comp&gt;-type-&gt;type_kind NE cl_abap_typedescr=&gt;typekind_struct1 AND
              &lt;fs_comp&gt;-type-&gt;type_kind NE cl_abap_typedescr=&gt;typekind_struct2.

        lo_ele_descr ?= &lt;fs_comp&gt;-type.
        IF lo_ele_descr-&gt;is_ddic_type( ) EQ abap_true.
          ls_ddic = lo_ele_descr-&gt;get_ddic_field( ).
          ls_ddic-fieldname = &lt;fs_comp&gt;-name.
        ELSE.
          &quot; if component is not ddic type, then fall back to its field name
          ls_ddic-fieldname = &lt;fs_comp&gt;-name.
        ENDIF.
        APPEND ls_ddic TO lt_ddic.
        CLEAR ls_ddic.
      ENDLOOP.
    ENDIF.
  ELSE.
    CONCATENATE &apos;Type &apos; iv_stru &apos; not found.&apos; INTO lv_msg RESPECTING BLANKS.
    PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
    RETURN.
  ENDIF.

  IF iv_fldnames IS NOT INITIAL.
    MOVE lt_ddic TO lt_hash_ddic.

    SPLIT iv_fldnames AT &apos;|&apos; INTO TABLE lt_fldnames.
    LOOP AT lt_fldnames ASSIGNING &lt;fs_fld&gt;.
      CONDENSE &lt;fs_fld&gt; NO-GAPS.
      CHECK &lt;fs_fld&gt; IS NOT INITIAL.

      READ TABLE lt_hash_ddic WITH TABLE KEY fieldname = &lt;fs_fld&gt; ASSIGNING &lt;fs_ddic&gt;.
      IF &lt;fs_ddic&gt; IS ASSIGNED.
        APPEND &lt;fs_ddic&gt; TO lt_used_ddic.
        UNASSIGN &lt;fs_ddic&gt;.
      ELSE.
        ls_ddic-fieldname = &lt;fs_fld&gt;.
        APPEND ls_ddic TO lt_used_ddic.
      ENDIF.
    ENDLOOP.
  ELSE.
    lt_used_ddic = lt_ddic.
  ENDIF.

  CLEAR ct_ddfields.
  ct_ddfields = lt_used_ddic.
ENDFORM.

TYPES: BEGIN OF s_label,
       len TYPE headlen,
       txt TYPE string,
       END OF s_label.
TYPES: t_label TYPE STANDARD TABLE OF s_label.

FORM append_fld_label USING iv_txt TYPE c CHANGING ct_label TYPE t_label.
  DATA ls_label TYPE s_label.

  ls_label-len = strlen( iv_txt ).
  ls_label-txt = iv_txt.
  APPEND ls_label TO ct_label.
ENDFORM.

FORM get_field_label USING iv_dfies TYPE dfies CHANGING cv_label TYPE string.
  CHECK iv_dfies IS NOT INITIAL.
  CLEAR cv_label.

  DATA lt_table TYPE t_label.
  FIELD-SYMBOLS &lt;fs_label&gt; TYPE s_label.

  PERFORM append_fld_label USING iv_dfies-scrtext_s CHANGING lt_table.
  PERFORM append_fld_label USING iv_dfies-scrtext_m CHANGING lt_table.
  PERFORM append_fld_label USING iv_dfies-scrtext_l CHANGING lt_table.
  PERFORM append_fld_label USING iv_dfies-reptext   CHANGING lt_table.

  SORT lt_table BY len DESCENDING.
  READ TABLE lt_table ASSIGNING &lt;fs_label&gt; INDEX 1.
  IF &lt;fs_label&gt;-txt IS INITIAL.
    PERFORM format_fldname USING iv_dfies-fieldname CHANGING cv_label.
  ELSE.
    cv_label = &lt;fs_label&gt;-txt.
  ENDIF.
ENDFORM.

FORM format_fldname USING iv_fldname TYPE fieldname CHANGING cv_label TYPE string.
  DATA: lt_word TYPE TABLE OF fieldname,
        lv_char TYPE c.
  FIELD-SYMBOLS &lt;fs_word&gt; TYPE fieldname.
  SPLIT iv_fldname AT &apos;_&apos; INTO TABLE lt_word.
  LOOP AT lt_word ASSIGNING &lt;fs_word&gt;.
    lv_char = &lt;fs_word&gt;(1).
    TRANSLATE &lt;fs_word&gt; TO LOWER CASE.
    &lt;fs_word&gt;(1) = lv_char.
  ENDLOOP.

  CONCATENATE LINES OF lt_word INTO cv_label SEPARATED BY space.
ENDFORM.

FORM get_table_head_html USING it_dfies TYPE ddfields CHANGING cv_tr TYPE string.
  DATA: lv_tr    TYPE string VALUE &apos;&lt;tr&gt;&apos;,
        lv_td    TYPE string,
        lv_label TYPE string.

  FIELD-SYMBOLS: &lt;fs_ddic&gt; TYPE dfies.

  LOOP AT it_dfies ASSIGNING &lt;fs_ddic&gt;.
    PERFORM get_field_label USING &lt;fs_ddic&gt; CHANGING lv_label.
    PERFORM get_column_label_html USING lv_label CHANGING lv_td.
    CONCATENATE lv_tr lv_td INTO lv_tr RESPECTING BLANKS.

    CLEAR: lv_label, lv_td.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  CLEAR cv_tr.
  cv_tr = lv_tr.
ENDFORM.

FORM prepare_html_head.
  APPEND &apos;&lt;html&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;head&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;meta name=&quot;Generator&quot; content=&quot;Microsoft Word 14 (filtered)&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;style type=&quot;text/css&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;!--&apos; TO gt_html_all.
  APPEND &apos;/* Font Definitions */&apos; TO gt_html_all.
  APPEND &apos;@font-face&apos; TO gt_html_all.
  APPEND &apos;{font-family:Calibri;&apos; TO gt_html_all.
  APPEND &apos;panose-1:2 15 5 2 2 2 4 3 2 4;}&apos; TO gt_html_all.
  APPEND &apos;@font-face&apos; TO gt_html_all.
  APPEND &apos;{font-family:Tahoma;&apos; TO gt_html_all.
  APPEND &apos;panose-1:2 11 6 4 3 5 4 4 2 4;}&apos; TO gt_html_all.
  APPEND &apos;/* Style Definitions */&apos; TO gt_html_all.
  APPEND &apos;p.MsoNormal, li.MsoNormal, div.MsoNormal&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;margin-left:0in;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoAcetate, li.MsoAcetate, div.MsoAcetate&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:.0001pt;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:.0001pt;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;.MsoChpDefault&apos; TO gt_html_all.
  APPEND &apos;{font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;.MsoPapDefault&apos; TO gt_html_all.
  APPEND &apos;{margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;}&apos; TO gt_html_all.
  APPEND &apos;/* Page Definitions */&apos; TO gt_html_all.
  APPEND &apos;@page WordSection1&apos; TO gt_html_all.
  APPEND &apos;{size:8.5in 11.0in;&apos; TO gt_html_all.
  APPEND &apos;margin:1.0in 1.0in 1.0in 1.0in;}&apos; TO gt_html_all.
  APPEND &apos;div.WordSection1&apos; TO gt_html_all.
  APPEND &apos;{page:WordSection1;}&apos; TO gt_html_all.
  APPEND &apos;/* List Definitions */&apos; TO gt_html_all.
  APPEND &apos;ol&apos; TO gt_html_all.
  APPEND &apos;{margin-bottom:0in;}&apos; TO gt_html_all.
  APPEND &apos;ul&apos; TO gt_html_all.
  APPEND &apos;{margin-bottom:0in;}&apos; TO gt_html_all.
  APPEND &apos;--&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;/style&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;title&gt;&apos; TO gt_html_all.
  APPEND text_common-title_html TO gt_html_all.
  APPEND &apos;&lt;/title&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;/head&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;body lang=&quot;EN-US&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;div class=&quot;WordSection1&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&lt;span syle=&quot;font-size:14.0pt;line-height:115%&quot;&gt;&apos; TO gt_html_all.
  APPEND text_common-txt_notice TO gt_html_all.
  APPEND &apos;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&apos; TO gt_html_all.
ENDFORM.

FORM prepare_html_tail.
  APPEND &apos;&lt;/div&gt;&apos;  TO gt_html_all.
  APPEND &apos;&lt;/body&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;/html&gt;&apos; TO gt_html_all.
ENDFORM.

FORM export_docu CHANGING cv_file_name TYPE string.
  DATA: lv_html_file TYPE string,
        lv_msg       TYPE string,
        lv_len       TYPE i,
        lv_codepage  TYPE cpcodepage,
        lv_cp_dl     TYPE abap_encod.

  lv_len = strlen( p_doc ).
  CONCATENATE p_dir gv_slash p_doc(lv_len) &apos;.html&apos; INTO  lv_html_file RESPECTING BLANKS.
  cv_file_name = lv_html_file.
  IF sy-langu EQ &apos;E&apos;.
    PERFORM download_file USING &apos;ASC&apos; lv_html_file CHANGING lv_msg gt_html_all.
  ELSE.
    CALL FUNCTION &apos;SCP_CODEPAGE_BY_EXTERNAL_NAME&apos;
      EXPORTING
        external_name = &apos;UTF-16LE&apos;
        kind          = &apos;H&apos;
      IMPORTING
        sap_codepage  = lv_codepage
      EXCEPTIONS
        not_found     = 1
        OTHERS        = 2.
    IF sy-subrc NE 0.
      lv_codepage = &apos;4013&apos;.
    ENDIF.
    lv_cp_dl = lv_codepage.

    CALL METHOD cl_gui_frontend_services=&gt;gui_download
      EXPORTING
        filename                = lv_html_file
        confirm_overwrite       = boolc( p_test NE abap_true )
        codepage                = lv_cp_dl
      CHANGING
        data_tab                = gt_html_all
      EXCEPTIONS
        file_write_error        = 1
        no_batch                = 2
        gui_refuse_filetransfer = 3
        invalid_type            = 4
        no_authority            = 5
        unknown_error           = 6
        header_not_allowed      = 7
        separator_not_allowed   = 8
        filesize_not_allowed    = 9
        header_too_long         = 10
        dp_error_create         = 11
        dp_error_send           = 12
        dp_error_write          = 13
        unknown_dp_error        = 14
        access_denied           = 15
        dp_out_of_memory        = 16
        disk_full               = 17
        dp_timeout              = 18
        file_not_found          = 19
        dataprovider_exception  = 20
        control_flush_error     = 21
        not_supported_by_gui    = 22
        error_no_gui            = 23
        OTHERS                  = 24.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
ENDFORM.

FORM open_html_in_msword USING iv_filename TYPE string.
* German should be open by IE browser directly, MS WORD won&apos;t work
  CHECK sy-langu EQ &apos;E&apos; AND p_open EQ abap_true.

  DATA: lt_paths      TYPE TABLE OF string,
        lv_path_used  TYPE string,
        lv_params     TYPE string,
        lv_result     TYPE abap_bool.
  FIELD-SYMBOLS &lt;fs_path&gt; TYPE string.

  APPEND &apos;C:\Program Files (x86)\Microsoft Office\Office12\WINWORD.exe&apos; TO lt_paths.
  APPEND &apos;C:\Program Files (x86)\Microsoft Office\Office14\winword.exe&apos; TO lt_paths.

  LOOP AT lt_paths ASSIGNING &lt;fs_path&gt;.
    CALL METHOD cl_gui_frontend_services=&gt;file_exist
      EXPORTING
        file                 = &lt;fs_path&gt;
      RECEIVING
        result               = lv_result
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        wrong_parameter      = 3
        not_supported_by_gui = 4
        OTHERS               = 5.

    IF sy-subrc EQ 0 AND lv_result EQ abap_true.
      lv_path_used = &lt;fs_path&gt;.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF lv_path_used IS INITIAL.
    &quot;TODO read registry to get the installation path of MS Word
  ENDIF.
  CHECK lv_path_used IS NOT INITIAL.

  CONCATENATE &apos;/f &apos; iv_filename INTO lv_params RESPECTING BLANKS.
  CALL METHOD cl_gui_frontend_services=&gt;execute
    EXPORTING
      application            = lv_path_used
      parameter              = lv_params
      maximized              = &apos;X&apos;
    EXCEPTIONS
      cntl_error             = 1
      error_no_gui           = 2
      bad_parameter          = 3
      file_not_found         = 4
      path_not_found         = 5
      file_extension_unknown = 6
      error_execute_failed   = 7
      synchronous_failed     = 8
      not_supported_by_gui   = 9
      OTHERS                 = 10.
ENDFORM.
FORM upload_transport_files.
  DATA: lv_slah       TYPE c,
        lv_filename   TYPE c LENGTH 1024,
        lv_answer     TYPE c,
        lv_len        TYPE i,
        lv_contents   TYPE xstring,
        lt_data       TYPE t_linetype,
        lt_msg        TYPE TABLE OF s_common_msg,
        lv_msg        TYPE string,
        lv_stms       TYPE abap_bool VALUE abap_true.

  FIELD-SYMBOLS: &lt;fs_file&gt; TYPE cl_abap_zip=&gt;t_file,
                 &lt;fs_msg&gt;  TYPE s_common_msg.

  lv_slah = gv_trans_dir(1).
  LOOP AT go_zip-&gt;files ASSIGNING &lt;fs_file&gt;.
    CLEAR: lv_filename, lv_contents, lt_data, lv_msg, lv_len, lv_answer.

    IF &lt;fs_file&gt;-name(1) EQ &apos;K&apos;.
      CONCATENATE gv_trans_dir lv_slah &apos;cofiles&apos; lv_slah &lt;fs_file&gt;-name INTO lv_filename RESPECTING BLANKS.
    ELSEIF &lt;fs_file&gt;-name(1) EQ &apos;R&apos;.
      CONCATENATE gv_trans_dir lv_slah &apos;data&apos; lv_slah &lt;fs_file&gt;-name INTO lv_filename RESPECTING BLANKS.
    ENDIF.
    lv_len = strlen( lv_filename ).

    go_zip-&gt;get(
      EXPORTING
        name                    = &lt;fs_file&gt;-name
      IMPORTING
        content                 = lv_contents
      EXCEPTIONS
        zip_index_error         = 1
        zip_decompression_error = 2
        OTHERS                  = 3
      ).

    IF sy-subrc NE 0.
      PERFORM get_sys_error_msg CHANGING lv_msg.
      CONCATENATE &apos;Unable to get &apos; &lt;fs_file&gt;-name &apos; in zip file &apos; p_file &apos;.Reason: &apos; lv_msg INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING lt_msg.
    ELSE.
      CONCATENATE &apos;Unzip file &apos; p_file &apos; and get &apos; &lt;fs_file&gt;-name &apos; successfully.&apos; INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;S&apos; lv_msg CHANGING lt_msg.
    ENDIF.

    CLEAR lv_msg.
    PERFORM convert_zip2tbl1024 USING lv_contents CHANGING lt_data.
    PERFORM upload_overwrite_confirm USING lv_filename CHANGING lv_answer.
    IF lv_answer NE &apos;1&apos;.
      CONCATENATE lv_filename(lv_len) &apos; exists in server already and you choose to ignore.&apos; INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;W&apos; lv_msg CHANGING lt_msg.
      CONTINUE.
    ENDIF.

    CALL FUNCTION &apos;SCMS_DOWNLOAD&apos;
      EXPORTING
        filename = lv_filename
        filesize = &lt;fs_file&gt;-size
        binary   = &apos;X&apos;
        frontend = &apos; &apos;
      TABLES
        data     = lt_data
      EXCEPTIONS
        error    = 1
        OTHERS   = 2.

    IF sy-subrc &lt;&gt; 0.
      PERFORM get_sys_error_msg CHANGING lv_msg.
      CONCATENATE &apos;Failed to upload &apos; p_file &apos; to server: &apos; lv_filename(lv_len) &apos;.Reason: &apos; lv_msg INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING lt_msg.
    ELSE.
      CONCATENATE &apos;Upload &apos; p_file &apos; to server address &apos; lv_filename(lv_len) &apos; successfully.&apos; INTO lv_msg RESPECTING BLANKS.
      PERFORM append_common_msg USING &apos;S&apos; lv_msg CHANGING lt_msg.
    ENDIF.
  ENDLOOP.

  WRITE: / icon_icon_list AS ICON, &apos;Dear&apos;, gv_username, &apos;, here is transport file upload report:&apos;.
  SKIP.
  LOOP AT lt_msg ASSIGNING &lt;fs_msg&gt;.
    PERFORM print_msg USING &lt;fs_msg&gt;-msgty &lt;fs_msg&gt;-msg.
    IF &lt;fs_msg&gt;-msgty NE &apos;S&apos;.
      lv_stms = abap_false.
    ENDIF.
  ENDLOOP.
  SKIP.
  WRITE: / icon_tools AS ICON, text_common-thanks.

  CHECK lv_stms EQ abap_true.
  MESSAGE &apos;Now you can import the transport request.&apos; TYPE &apos;I&apos;.
  CALL TRANSACTION &apos;STMS_IMPORT&apos; AND SKIP FIRST SCREEN.
ENDFORM.

FORM append_common_msg USING iv_msgty TYPE sy-msgty iv_msg TYPE string CHANGING ct_msg TYPE STANDARD TABLE.
  DATA ls_common_msg TYPE s_common_msg.
  ls_common_msg-msgty = iv_msgty.
  ls_common_msg-msg = iv_msg.
  APPEND ls_common_msg TO ct_msg.
ENDFORM.

FORM upload_overwrite_confirm USING iv_server_file TYPE c CHANGING cv_answer TYPE c.
  CLEAR cv_answer.

  OPEN DATASET iv_server_file FOR INPUT IN BINARY MODE.
  IF sy-subrc EQ 0.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        text_question = &apos;This file exists on server already, do you really want to overwrite?&apos;
      IMPORTING
        answer        = cv_answer.
  ELSE.
    cv_answer = &apos;1&apos;.
  ENDIF.
  CLOSE DATASET iv_server_file.
ENDFORM.

FORM convert_zip2tbl1024 USING iv_xstr TYPE xstring CHANGING ct_tabl TYPE t_linetype.
  CONSTANTS: c_length_segment   TYPE i VALUE 1024.
  DATA: lv_line(1024) TYPE x,
        ls_line       TYPE s_lintype,
        len_src       TYPE i,
        len_wa        TYPE i,
        offset        TYPE i.

  offset = 0.
  len_src = xstrlen( iv_xstr ).

  WHILE offset &lt; len_src.
    len_wa = len_src - offset.
    IF len_wa &gt; c_length_segment.
      lv_line = iv_xstr+offset(c_length_segment).
      ls_line-line = lv_line.
      APPEND ls_line TO ct_tabl.
      offset = offset + c_length_segment.
    ELSE.
      lv_line = iv_xstr+offset(len_wa).
      ls_line-line = lv_line.
      APPEND ls_line TO ct_tabl.
      offset = offset + len_wa.
    ENDIF.
  ENDWHILE.
ENDFORM.

FORM check_transport_zip CHANGING cv_msg TYPE string.
  DATA: lv_str TYPE xstring,
        lt_tab TYPE solix_tab.

  CALL METHOD cl_gui_frontend_services=&gt;file_exist
    EXPORTING
      file                 = p_file
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      wrong_parameter      = 3
      not_supported_by_gui = 4
      OTHERS               = 5.
  IF sy-subrc &lt;&gt; 0.
    PERFORM get_sys_error_msg CHANGING cv_msg.
    RETURN.
  ENDIF.

  CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
    EXPORTING
      text = &apos;Upload transport zip file...&apos;.

  CALL METHOD cl_gui_frontend_services=&gt;gui_upload
    EXPORTING
      filename                = p_file
      filetype                = &apos;BIN&apos;
    CHANGING
      data_tab                = lt_tab
    EXCEPTIONS
      file_open_error         = 1
      file_read_error         = 2
      no_batch                = 3
      gui_refuse_filetransfer = 4
      invalid_type            = 5
      no_authority            = 6
      unknown_error           = 7
      bad_data_format         = 8
      header_not_allowed      = 9
      separator_not_allowed   = 10
      header_too_long         = 11
      unknown_dp_error        = 12
      access_denied           = 13
      dp_out_of_memory        = 14
      disk_full               = 15
      dp_timeout              = 16
      not_supported_by_gui    = 17
      error_no_gui            = 18
      OTHERS                  = 19.
  IF sy-subrc &lt;&gt; 0.
    PERFORM get_sys_error_msg CHANGING cv_msg.
    RETURN.
  ELSE.
    lv_str = cl_bcs_convert=&gt;solix_to_xstring( it_solix  = lt_tab ).
  ENDIF.

  IF go_zip IS NOT BOUND.
    CREATE OBJECT go_zip.
    CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
      EXPORTING
        percentage = 2
        text       = &apos;Load and parse transport zip file...&apos;.

    go_zip-&gt;load(
      EXPORTING
        zip = lv_str
      EXCEPTIONS
        zip_parse_error = 1
        OTHERS          = 2
      ).
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
    ENDIF.

    &quot; if validity check passed but count of files mod 2 ne 0, give a warning message
    IF lines( go_zip-&gt;files ) MOD 2 NE 0.
      cv_msg = &apos;There should a K/R file missing for a certain transport request, please check your zip file&apos;.
    ENDIF.

    FIELD-SYMBOLS: &lt;fs_file&gt; TYPE cl_abap_zip=&gt;t_file.
    LOOP AT go_zip-&gt;files ASSIGNING &lt;fs_file&gt;.
      &quot;TODO: replace by regex match
      IF &lt;fs_file&gt;-name(1) NE &apos;K&apos; AND &lt;fs_file&gt;-name(1) NE &apos;R&apos; AND strlen( &lt;fs_file&gt;-name ) NE 11.
        CONCATENATE &apos;Invalid file name in zip: &apos; &lt;fs_file&gt;-name INTO cv_msg RESPECTING BLANKS.
        RETURN.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.
***** Generate Code Template For New Object Type Begin ****
FORM initialize_code_template.
  APPEND &apos;TYPES: BEGIN OF s_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;INCLUDE TYPE s_obj_header.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;TYPES: END OF s_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;DATA gt_$OBJECT TYPE TABLE OF s_$OBJECT.  &quot;#EC NEEDED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;***************** $DESC Begin *****************&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;FORM getdata_$OBJECT USING is_obj_header TYPE s_obj_header.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  DATA: ls_$OBJECT TYPE s_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  MOVE-CORRESPONDING is_obj_header TO ls_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  &quot; add data retrive logic here&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  APPEND ls_$OBJECT TO gt_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT

  APPEND &apos;FORM get_additional_html_$OBJECT USING is_$OBJECT TYPE s_$OBJECT CHANGING ct_html TYPE t_string.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM data2rows USING is_$OBJECT &apos;&apos;S_$OBJECT&apos;&apos; &apos;&apos;${Field names separated by |}&apos;&apos; CHANGING ct_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT

  APPEND &apos;FORM get_special_html_$OBJECT USING is_$OBJECT TYPE s_$OBJECT CHANGING ct_html TYPE t_string.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM table2html USING &apos;&apos;${TITLE}&apos;&apos; is_$OBJECT-{$TABLE} &apos;&apos;${STRUC}&apos;&apos; &apos;&apos;${Field names separated by |}&apos;&apos; abap_false &apos;&apos;&apos;&apos; CHANGING ct_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT

  APPEND &apos;FORM convert_$OBJECT.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  CHECK gt_$OBJECT IS NOT INITIAL.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  ADD 1 TO gv_header_no.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM add_header_html USING &apos;&apos;$OBJECT&apos;&apos; CHANGING gt_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM add_object_instruction_html USING &apos;&apos;$OBJECT&apos;&apos; CHANGING gt_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM table2html USING &apos;&apos;${TITLE}&apos;&apos; gt_$OBJECT &apos;&apos;S_$OBJECT&apos;&apos; &apos;&apos;${Field names separated by |}&apos;&apos; abap_false &apos;&apos;&apos;&apos; CHANGING gt_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;***************** $DESC Close *****************&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT
ENDFORM.

FORM print_template_codes.
  DATA: lv_objtype  TYPE trobjtype,
        lv_tmp      TYPE char255,
        lv_rc       TYPE i,
        lt_code_tab TYPE TABLE OF char255.

  FIELD-SYMBOLS: &lt;fs_ko100&gt; TYPE ko100,
                 &lt;fs_code&gt;  TYPE char255.

  LOOP AT so_objt.
    READ TABLE gt_ko100 WITH KEY object = so_objt-low ASSIGNING &lt;fs_ko100&gt;.
    IF &lt;fs_ko100&gt; IS ASSIGNED.
      lv_objtype = so_objt-low.
      LOOP AT gt_code_template INTO lv_tmp.
        REPLACE ALL OCCURRENCES OF &apos;$OBJECT&apos; IN lv_tmp WITH lv_objtype.
        REPLACE ALL OCCURRENCES OF &apos;$DESC&apos; IN lv_tmp WITH &lt;fs_ko100&gt;-text.
        APPEND lv_tmp TO lt_code_tab.
      ENDLOOP.
    ENDIF.
    UNASSIGN &lt;fs_ko100&gt;.
  ENDLOOP.

  LOOP AT lt_code_tab ASSIGNING &lt;fs_code&gt;.
    IF &lt;fs_code&gt; IS INITIAL.
      SKIP.
    ENDIF.
    WRITE: / &lt;fs_code&gt;.
  ENDLOOP.

  CALL METHOD cl_gui_frontend_services=&gt;clipboard_export
    IMPORTING
      data                 = lt_code_tab
    CHANGING
      rc                   = lv_rc
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4.

  IF sy-subrc EQ 0 AND lv_rc NE -1.
    MESSAGE s208(00) WITH &apos;Generated Codes exported to clip board also.&apos;.
  ENDIF.
ENDFORM.
***** Generate Code Template For New Object Type Close ****
FORM collect_objects_header_in_tr CHANGING ct_objheaders TYPE STANDARD TABLE.
  CHECK so_trans IS NOT INITIAL.
  CLEAR ct_objheaders.

* since tadir is buffered by primary key, join e071 and tadir to get devclass is not necessary
  SELECT DISTINCT pgmid object obj_name FROM e071              ##too_many_itab_fields
    INTO CORRESPONDING FIELDS OF TABLE ct_objheaders FOR ALL ENTRIES IN gt_objtype_order
* object function marked as deletion is out of scope
    WHERE trkorr IN so_trans AND objfunc NE &apos;D&apos; AND object = gt_objtype_order-object.
ENDFORM.

FORM initialize_buffer.
  PERFORM init_objectype_config.
  PERFORM init_objectype_desc.
  PERFORM init_trans_dir.
  PERFORM init_texts_of_value.
  PERFORM get_user_info.
  CALL METHOD cl_gui_frontend_services=&gt;get_file_separator
    CHANGING
      file_separator       = gv_slash
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4.
  IF sy-subrc &lt;&gt; 0.
    gv_slash = &apos;\&apos;.
  ENDIF.
ENDFORM.

FORM add_objectype_config_entry USING iv_object TYPE trobjtype iv_sort_no TYPE i iv_show_basic_attr TYPE abap_bool
                                CHANGING ct_object_config TYPE ht_objtype_order.
  DATA ls_object_config TYPE s_objtype_order.

  ls_object_config-object = iv_object.
  CONDENSE ls_object_config-object NO-GAPS.

  ls_object_config-sort_no = iv_sort_no.
  ls_object_config-show_basic_attr = iv_show_basic_attr.

  READ TABLE gt_objtype_order WITH TABLE KEY object = iv_object TRANSPORTING NO FIELDS.
  IF sy-subrc NE 0.
    INSERT ls_object_config INTO TABLE ct_object_config.
  ENDIF.
ENDFORM.

FORM init_objectype_config.
  PERFORM add_objectype_config_entry USING :  &apos;DEVC&apos; 0010 abap_true  CHANGING gt_objtype_order,
                                              &apos;DEVP&apos; 0020 abap_false CHANGING gt_objtype_order,
                                              &apos;PINF&apos; 0021 abap_false CHANGING gt_objtype_order,
                                              &apos;FUGR&apos; 0030 abap_true  CHANGING gt_objtype_order,
                                              &apos;FUGT&apos; 0040 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOMA&apos; 0050 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOMD&apos; 0051 abap_true  CHANGING gt_objtype_order,
                                              &apos;DTEL&apos; 0060 abap_true  CHANGING gt_objtype_order,
                                              &apos;DTED&apos; 0061 abap_true  CHANGING gt_objtype_order,
                                              &apos;TABL&apos; 0070 abap_true  CHANGING gt_objtype_order,
                                              &apos;TABD&apos; 0080 abap_false CHANGING gt_objtype_order,
                                              &apos;TABT&apos; 0081 abap_false CHANGING gt_objtype_order,
                                              &apos;INDX&apos; 0082 abap_false CHANGING gt_objtype_order,
                                              &apos;VIEW&apos; 0090 abap_true  CHANGING gt_objtype_order,
                                              &apos;VIED&apos; 0091 abap_false CHANGING gt_objtype_order,
                                              &apos;VIET&apos; 0092 abap_false CHANGING gt_objtype_order,
                                              &apos;SHLP&apos; 0100 abap_true  CHANGING gt_objtype_order,
                                              &apos;SHLD&apos; 0101 abap_true  CHANGING gt_objtype_order,
                                              &apos;ENQU&apos; 0110 abap_true  CHANGING gt_objtype_order,
                                              &apos;ENQD&apos; 0111 abap_true  CHANGING gt_objtype_order,
                                              &apos;TTYP&apos; 0120 abap_true  CHANGING gt_objtype_order,
                                              &apos;TTYD&apos; 0121 abap_true  CHANGING gt_objtype_order,
                                              &apos;TOBJ&apos; 0130 abap_true  CHANGING gt_objtype_order,
                                              &apos;VCLS&apos; 0140 abap_true  CHANGING gt_objtype_order,
                                              &apos;NROB&apos; 0150 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOCU&apos; 0160 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOCT&apos; 0161 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOCV&apos; 0162 abap_true  CHANGING gt_objtype_order,
                                              &apos;MSAD&apos; 0170 abap_true  CHANGING gt_objtype_order,
                                              &apos;MSAG&apos; 0180 abap_true  CHANGING gt_objtype_order,
                                              &apos;MESS&apos; 0190 abap_true  CHANGING gt_objtype_order,
                                              &apos;TRAN&apos; 0200 abap_true  CHANGING gt_objtype_order,
                                              &apos;CDAT&apos; 0201 abap_false CHANGING gt_objtype_order,
                                              &apos;VDAT&apos; 0210 abap_false CHANGING gt_objtype_order,
                                              &apos;TABU&apos; 0220 abap_false CHANGING gt_objtype_order.
ENDFORM.

FORM init_objectype_desc.
  DATA: lt_ko100 TYPE TABLE OF ko100.
  FIELD-SYMBOLS &lt;fs_ko100&gt; TYPE ko100.

  CALL FUNCTION &apos;TR_OBJECT_TABLE&apos;
    TABLES
      wt_object_text = lt_ko100.
  MOVE lt_ko100 TO gt_ko100.

  LOOP AT gt_ko100 ASSIGNING &lt;fs_ko100&gt;.
    READ TABLE gt_objtype_order WITH TABLE KEY object = &lt;fs_ko100&gt;-object TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      INSERT &lt;fs_ko100&gt; INTO TABLE gt_objtype_desc.
    ENDIF.
  ENDLOOP.
ENDFORM.

FORM init_trans_dir.
  DATA: lv_trans_dir     TYPE trtppvalue,
        lv_len           TYPE i.

  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos; FIELD &apos;DIR_TRANS&apos; ID &apos;VALUE&apos; FIELD lv_trans_dir.
  lv_len = strlen( lv_trans_dir ).
  gv_trans_dir = lv_trans_dir(lv_len).
ENDFORM.

FORM init_texts_of_value.
  PERFORM add_value_desc USING &apos;DD02L&apos;   &apos;TABCLASS&apos;   &apos;TABCLASS&apos;.
  PERFORM add_value_desc USING &apos;DD02L&apos;   &apos;MAINFLAG&apos;   &apos;MAINFLAG&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos;   &apos;GLOBALFLAG&apos; &apos;GLOBALFLAG&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos;   &apos;VIEWCLASS&apos;  &apos;VIEWCLASS&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos;   &apos;VIEWGRANT&apos;  &apos;VIEWGRANT&apos;.
  PERFORM add_value_desc USING &apos;DD09L&apos;   &apos;BUFALLOW&apos;   &apos;BUFALLOW&apos;.
  PERFORM add_value_desc USING &apos;DD03P_D&apos; &apos;F_REFTYPE&apos;  &apos;F_REFTYPE&apos;.
  PERFORM manual_add_value_desc.
ENDFORM.

FORM add_value_desc USING iv_tabname TYPE ddobjname iv_fieldname TYPE fieldname iv_lfield_name TYPE dfies-lfieldname.
  DATA: ls_value_desc  TYPE s_value_desc.

  ls_value_desc-fieldname = iv_fieldname.
  CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
    EXPORTING
      tabname      = iv_tabname
      fieldname    = iv_fieldname
      lfieldname   = iv_lfield_name
      langu        = sy-langu
    TABLES
      fixed_values = ls_value_desc-ddfixvalues.

  READ TABLE gt_value_desc WITH TABLE KEY fieldname = iv_fieldname TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  INSERT ls_value_desc INTO TABLE gt_value_desc.
ENDFORM.

FORM manual_add_value_desc.
  DATA: ls_vd TYPE s_value_desc.

  ls_vd-fieldname = &apos;PUFFERUNG&apos;.
  PERFORM add_ddfixvalue USING: &apos;P&apos;  &apos;Single records buff.&apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;G&apos;  &apos;Generic Area Buffered&apos; CHANGING ls_vd-ddfixvalues,
                                &apos;X&apos;  &apos;Fully Buffered&apos;        CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;FRKART&apos;.
  PERFORM add_ddfixvalue USING: &apos;&apos;      &apos;Not Specified&apos;              CHANGING ls_vd-ddfixvalues,
                                &apos;OPT&apos;   &apos;Optional foreign key&apos;       CHANGING ls_vd-ddfixvalues,
                                &apos;OBL&apos;   &apos;Mandatory foreign key&apos;      CHANGING ls_vd-ddfixvalues,
                                &apos;ID&apos;    &apos;Identifying foreign key&apos;    CHANGING ls_vd-ddfixvalues,
                                &apos;TEXT&apos;  &apos;Key fields of a text table&apos; CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;TRANSACTION_TYPE&apos;.
  PERFORM add_ddfixvalue USING: c_trans_type-dialog &apos;Program and screen (dialog transaction)&apos;           CHANGING ls_vd-ddfixvalues,
                                c_trans_type-report &apos;Program and selection screen (report transaction)&apos; CHANGING ls_vd-ddfixvalues,
                                c_trans_type-oo &apos;Method of a class (OO transaction) &apos; CHANGING ls_vd-ddfixvalues,
                                c_trans_type-trans_with_variant &apos;Transaction with variant (variant transaction)&apos;    CHANGING ls_vd-ddfixvalues,
                                c_trans_type-trans_with_param &apos;Transaction with parameters (parameter transaction)&apos; CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;UPDATE_MODE&apos;.
  PERFORM add_ddfixvalue USING: &apos;U&apos; &apos;Asynchronous Update&apos; CHANGING ls_vd-ddfixvalues,
                                &apos;S&apos; &apos;Synchronous Update&apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;L&apos; &apos;LocalUpdate&apos;         CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;VCLS_HIERARCHY&apos;.
  PERFORM add_ddfixvalue USING: &apos;&apos;  &apos;Use in Hierarchy (Popup) &apos;      CHANGING ls_vd-ddfixvalues,
                                &apos;A&apos; &apos;Use in Hierarchy (Mandatory) &apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;X&apos; &apos;Limit to One Step&apos;              CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;MAINT_TYPE&apos;.
  PERFORM add_ddfixvalue USING: &apos;1&apos;  &apos;One Step&apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;2&apos;  &apos;Two Step&apos;  CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.
ENDFORM.

FORM add_ddfixvalue USING iv_value TYPE c iv_text TYPE ddtext CHANGING ct_ddfixvalue TYPE ddfixvalues.
  DATA ls_ddfixvalue TYPE ddfixvalue.
  ls_ddfixvalue-low = iv_value.
  ls_ddfixvalue-ddtext = iv_text.

  APPEND ls_ddfixvalue TO ct_ddfixvalue.
ENDFORM.

FORM get_value_desc USING iv_fieldname TYPE fieldname iv_value TYPE any CHANGING cv_desc TYPE ddtext.
  DATA: ls_value_desc  TYPE s_value_desc,
        lv_low  TYPE ddfixvalue-low.
  FIELD-SYMBOLS: &lt;fs_ddfixvalue&gt; TYPE ddfixvalue.

  CLEAR cv_desc.
  READ TABLE gt_value_desc INTO ls_value_desc WITH TABLE KEY fieldname = iv_fieldname.
  CHECK sy-subrc EQ 0.

  lv_low = iv_value.
  READ TABLE ls_value_desc-ddfixvalues ASSIGNING &lt;fs_ddfixvalue&gt; WITH KEY low = iv_value.
  IF sy-subrc EQ 0 AND &lt;fs_ddfixvalue&gt; IS ASSIGNED.
    cv_desc = &lt;fs_ddfixvalue&gt;-ddtext.
  ENDIF.
ENDFORM.

FORM get_user_info.
  DATA: ls_user_addr  TYPE bapiaddr3,
        lv_len        TYPE i,
        lv_title      TYPE string,
        lt_return_tab TYPE TABLE OF bapiret2.

  CALL FUNCTION &apos;BAPI_USER_GET_DETAIL&apos;
    EXPORTING
      username      = sy-uname
      cache_results = &apos;X&apos;
    IMPORTING
      address       = ls_user_addr
    TABLES
      return        = lt_return_tab.

  IF ls_user_addr-title_p IS NOT INITIAL.
    lv_title = ls_user_addr-title_p.
    CONDENSE lv_title NO-GAPS.
  ENDIF.

  lv_len = strlen( ls_user_addr-fullname ).
  CONCATENATE lv_title &apos; &apos; ls_user_addr-fullname(lv_len) INTO gv_username RESPECTING BLANKS.
ENDFORM.

FORM download_file USING iv_filetype TYPE char10 iv_filename TYPE string CHANGING cv_msg TYPE string ct_tab TYPE STANDARD TABLE .
  cl_gui_frontend_services=&gt;gui_download(
    EXPORTING
      filetype                  = iv_filetype
      filename                  = iv_filename
      confirm_overwrite         = boolc( p_test NE abap_true )
    CHANGING
      data_tab                  = ct_tab
    EXCEPTIONS
      file_write_error          = 1
      no_batch                  = 2
      gui_refuse_filetransfer   = 3
      invalid_type              = 4
      no_authority              = 5
      unknown_error             = 6
      header_not_allowed        = 7
      separator_not_allowed     = 8
      filesize_not_allowed      = 9
      header_too_long           = 10
      dp_error_create           = 11
      dp_error_send             = 12
      dp_error_write            = 13
      unknown_dp_error          = 14
      access_denied             = 15
      dp_out_of_memory          = 16
      disk_full                 = 17
      dp_timeout                = 18
      file_not_found            = 19
      dataprovider_exception    = 20
      control_flush_error       = 21
      not_supported_by_gui      = 22
      error_no_gui              = 23
      OTHERS                    = 24
    ).

  IF sy-subrc NE 0.
    PERFORM get_sys_error_msg CHANGING cv_msg.
    PERFORM append_common_msg USING &apos;E&apos; cv_msg CHANGING gt_sys_msg.
  ENDIF.
ENDFORM.

FORM get_sys_error_msg CHANGING cv_msg TYPE string.
  CLEAR cv_msg.
  IF sy-msgid IS NOT INITIAL AND sy-msgty IS NOT INITIAL AND sy-msgno IS NOT INITIAL.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
  ELSE.
    cv_msg = gcv_text_unexpected_error.                     &quot;#EC NOTEXT
  ENDIF.
ENDFORM.

FORM handle_rc USING is_obj_header TYPE s_obj_header.
  DATA lv_rc TYPE sy-subrc.
  IF sy-subrc NE 0.
    DATA: lv_msgty TYPE sy-msgty,
          lv_msg   TYPE string.

    lv_rc = sy-subrc.
    IF sy-msgid IS NOT INITIAL AND sy-msgty IS NOT INITIAL AND sy-msgno IS NOT INITIAL.
      lv_msgty = sy-msgty.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
    ELSE.
      lv_msgty = &apos;E&apos;.
      lv_msg = gcv_text_unexpected_error.
    ENDIF.
    PERFORM add_obj_gen_msg USING is_obj_header lv_msgty lv_msg.

    sy-subrc = lv_rc.
  ENDIF.
ENDFORM.

FORM add_obj_gen_msg USING is_obj_header TYPE s_obj_header iv_msgty TYPE sy-msgty iv_msg TYPE string.
  DATA: ls_gen_msg TYPE s_obj_gen_msg,
        lv_desc TYPE string,
        lv_len TYPE i.

  MOVE-CORRESPONDING is_obj_header TO ls_gen_msg.
  ls_gen_msg-msgty = iv_msgty.

  lv_len = strlen( ls_gen_msg-obj_name ).
  PERFORM get_objtype_desc_deep USING is_obj_header CHANGING lv_desc.
  IF iv_msgty EQ &apos;S&apos;.
    CONCATENATE lv_desc &apos; &apos; ls_gen_msg-obj_name(lv_len) &apos; : &apos; text_common-msg_success
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ELSEIF iv_msgty EQ &apos;W&apos;.
    CONCATENATE lv_desc &apos; &apos; ls_gen_msg-obj_name(lv_len) &apos; : &apos; text_common-msg_ignore
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ELSEIF iv_msgty EQ &apos;E&apos;.
    CONCATENATE lv_desc &apos; &apos; ls_gen_msg-obj_name(lv_len) &apos; : &apos; text_common-msg_error
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.

    CLEAR ls_gen_msg-msg.
    CONCATENATE &apos;  &apos; text_common-msg_error_msg &apos;: &apos; iv_msg INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ENDIF.
ENDFORM.

FORM display_result.
  DATA: lv_msg TYPE string.
  FIELD-SYMBOLS: &lt;fs_gen_msg&gt; TYPE s_obj_gen_msg,
                 &lt;fs_sys_msg&gt; TYPE s_common_msg.

  IF gt_obj_gen_msg IS INITIAL AND gt_sys_msg IS INITIAL.
    lv_msg = text_common-rep_none.
    REPLACE FIRST OCCURRENCE OF &apos;$USERNAME&apos; IN lv_msg WITH gv_username.
    WRITE: / icon_led_green AS ICON, lv_msg.
  ELSE.
    lv_msg = text_common-rep_docu.
    REPLACE FIRST OCCURRENCE OF &apos;$USERNAME&apos; IN lv_msg WITH gv_username.
    WRITE: / icon_led_green AS ICON, lv_msg.

    LOOP AT gt_obj_gen_msg ASSIGNING &lt;fs_gen_msg&gt;.
      PERFORM print_msg USING &lt;fs_gen_msg&gt;-msgty &lt;fs_gen_msg&gt;-msg.
    ENDLOOP.

    LOOP AT gt_sys_msg ASSIGNING &lt;fs_sys_msg&gt;.
      PERFORM print_msg USING &lt;fs_sys_msg&gt;-msgty &lt;fs_sys_msg&gt;-msg.
    ENDLOOP.

    SKIP.
    WRITE: / icon_information AS ICON, text_common-action_en.
    WRITE: / icon_information AS ICON, text_common-action2_en.
  ENDIF.
  WRITE: / icon_tools AS ICON, text_common-thanks.
ENDFORM.

FORM print_msg USING iv_msgty TYPE sy-msgty iv_msg TYPE string.
  CASE iv_msgty.
    WHEN &apos;E&apos; OR &apos;A&apos; OR &apos;X&apos;.
      WRITE / icon_led_red AS ICON.
    WHEN &apos;W&apos;.
      WRITE / icon_led_yellow AS ICON.
    WHEN OTHERS.
      WRITE / icon_led_green AS ICON.
  ENDCASE.

  WRITE iv_msg.
ENDFORM.

FORM get_activity USING iv_obj_create_date TYPE as4date CHANGING cv_activity TYPE s_obj_header-activity.
  &quot;TODO: it seems not reliable via compare object create/last change date with request create date
  RETURN.

  IF iv_obj_create_date LT gv_tr_date.
    cv_activity = gcv_act_update.
  ELSE.
    cv_activity = gcv_act_create.
  ENDIF.
ENDFORM.

FORM format_numc USING iv_num TYPE n CHANGING cv_oput TYPE string.
  CLEAR cv_oput.
  CALL FUNCTION &apos;CONVERSION_EXIT_ALPHA_OUTPUT&apos;
    EXPORTING
      input  = iv_num
    IMPORTING
      output = cv_oput.
ENDFORM.

FORM collect_tab_fld USING it_tab TYPE STANDARD TABLE iv_fld TYPE fieldname iv_sep TYPE string CHANGING cv_result TYPE string.
  CHECK it_tab IS NOT INITIAL AND iv_fld IS NOT INITIAL.
  CLEAR cv_result.

  FIELD-SYMBOLS: &lt;fs_row&gt; TYPE any,
                 &lt;fs_value&gt; TYPE any.
  LOOP AT it_tab ASSIGNING &lt;fs_row&gt;.
    ASSIGN COMPONENT iv_fld OF STRUCTURE &lt;fs_row&gt; TO &lt;fs_value&gt;.
    CHECK &lt;fs_value&gt; IS ASSIGNED.
    CONCATENATE cv_result iv_sep &lt;fs_value&gt; INTO cv_result RESPECTING BLANKS.
  ENDLOOP.

  IF iv_sep IS NOT INITIAL.
    DATA lv_len TYPE i.
    lv_len = strlen( iv_sep ).
    SHIFT cv_result BY lv_len PLACES.
  ENDIF.
ENDFORM.
*&amp;---------------------Supported Object Types Data Retrieve &amp; HTML Conversion--------------------*
***************** Package Begin *****************
FORM getdata_devc USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_devc_reuse USING is_obj_header.
ENDFORM.

FORM getdata_devc_reuse USING is_obj_header TYPE s_obj_header.
  DATA: lv_devclass     TYPE devclass,
        lo_package      TYPE REF TO if_package,
        lt_permission   TYPE tpak_permission_to_use_list,
        lo_permission   TYPE REF TO if_package_permission_to_use,
        ls_use_access   TYPE permission,
        lt_interface    TYPE tpak_package_interface_list,
        lo_interface    TYPE REF TO if_package_interface,
        ls_interface    TYPE vintf,
        ls_devc         TYPE s_devc.

  IF is_obj_header-object EQ &apos;DEVP&apos;.
    READ TABLE gt_devc WITH KEY obj_name = ls_devc-obj_name TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.
  ENDIF.

  lv_devclass = is_obj_header-obj_name.
  cl_package_factory=&gt;load_package(
    EXPORTING
      i_package_name             = lv_devclass
    IMPORTING
      e_package                  = lo_package
    EXCEPTIONS
      object_not_existing        = 1
      unexpected_error           = 2
      intern_err                 = 3
      no_access                  = 4
      object_locked_and_modified = 5
      OTHERS                     = 6
    ).
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND lo_package IS BOUND.
  MOVE-CORRESPONDING is_obj_header TO ls_devc.
* basic attributes
  ls_devc-devclass = lo_package-&gt;package_name.
  ls_devc-short_text = lo_package-&gt;short_text.
  ls_devc-parentcl = lo_package-&gt;super_package_name.
  ls_devc-dlvunit = lo_package-&gt;software_component.
  ls_devc-applicat = lo_package-&gt;application_component_abbrev.
  ls_devc-project_id = lo_package-&gt;project_id.
  ls_devc-translation_relevance = lo_package-&gt;translation_depth_text.
  ls_devc-mainpack =  lo_package-&gt;main_package.
  ls_devc-korrflag = lo_package-&gt;wbo_korr_flag.
  ls_devc-pdevclass = lo_package-&gt;transport_layer.
  PERFORM get_activity USING lo_package-&gt;created_on CHANGING ls_devc-activity.
* use accesses
  lo_package-&gt;get_permissions_to_use(
    IMPORTING
      e_permissions    = lt_permission
    EXCEPTIONS
      object_invalid   = 1
      unexpected_error = 2
      OTHERS           = 3
    ).
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0.

  LOOP AT lt_permission INTO lo_permission.
    ls_use_access-intf_name = lo_permission-&gt;package_interface_name.
    ls_use_access-client_pak = lo_permission-&gt;publisher_package_name.
    ls_use_access-err_sever = lo_permission-&gt;error_severity.
    APPEND ls_use_access TO ls_devc-use_accesses.
  ENDLOOP.
* interfaces published
  IF is_obj_header-object EQ &apos;DEVC&apos;.
    lo_package-&gt;get_interfaces(
      IMPORTING
        e_package_interfaces = lt_interface
      EXCEPTIONS
        object_invalid       = 1
        unexpected_error     = 2
        intern_err           = 3
        OTHERS               = 4
    ).
    PERFORM handle_rc USING is_obj_header.
    CHECK sy-subrc EQ 0.

    LOOP AT lt_interface INTO lo_interface.
      ls_interface-intf_name = lo_interface-&gt;interface_name.
      ls_interface-descript = lo_interface-&gt;short_text.
      ls_interface-pack_name = lo_interface-&gt;publisher_package_name.
      APPEND ls_interface TO ls_devc-interfaces.
    ENDLOOP.
  ENDIF.

  IF ls_devc-object EQ &apos;DEVC&apos;.
    APPEND ls_devc TO gt_devc.
  ELSEIF ls_devc-object EQ &apos;DEVP&apos;.
    ls_devc-activity = gcv_act_update.
    APPEND ls_devc TO gt_devp.
  ENDIF.
ENDFORM.

FORM get_additional_html_devc USING ls_devc TYPE s_devc CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_devc &apos;S_DEVC&apos; &apos;APPLICAT|TRANSLATION_RELEVANCE|PARENTCL|DLVUNIT|KORRFLAG&apos; CHANGING ct_html.
  PERFORM get_2column_value_html USING text_devc-label_tp_layer text_devc-txt_tp_note CHANGING ct_html.
ENDFORM.

FORM get_special_html_devc USING ls_devc TYPE s_devc CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  IF ls_devc-use_accesses IS NOT INITIAL.
    PERFORM get_small_title_html USING text_devc-title_access CHANGING ct_html.
    PERFORM get_paragraph_html USING text_devc-inst_devp_sub CHANGING ct_html.
    PERFORM table2html USING &apos;&apos; ls_devc-use_accesses &apos;PERMISSION&apos; &apos;INTF_NAME|CLIENT_PAK|ERR_SEVER&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.

  IF ls_devc-interfaces IS NOT INITIAL.
    PERFORM get_small_title_html USING text_devc-title_interface CHANGING ct_html.
    PERFORM get_paragraph_html USING text_devc-inst_pinf_sub CHANGING ct_html.
    PERFORM table2html USING &apos;&apos; ls_devc-interfaces &apos;VINTF&apos; &apos;INTF_NAME|DESCRIPT&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Package Close *****************

***************** Package: Usage Begin *****************
FORM getdata_devp USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_devc_reuse USING is_obj_header.
ENDFORM.

FORM get_special_html_devp USING is_devp TYPE s_devp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_small_title_html USING text_devc-title_access CHANGING ct_html.
  PERFORM get_paragraph_html USING text_devc-inst_devp CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; is_devp-use_accesses &apos;PERMISSION&apos; &apos;INTF_NAME|CLIENT_PAK|ERR_SEVER&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Package: Usage Close *****************

***************** Package: Interface Begin *****************
FORM getdata_pinf USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_pinf TYPE s_pinf.
  MOVE-CORRESPONDING is_obj_header TO ls_pinf.
  SELECT SINGLE * FROM vintf INTO CORRESPONDING FIELDS OF ls_pinf WHERE intf_name = ls_pinf-obj_name AND langu = sy-langu.
* check whether package interface is valid
  CHECK ls_pinf IS NOT INITIAL AND ls_pinf-pack_name IS NOT INITIAL.

  READ TABLE gt_devc WITH KEY obj_name = ls_pinf-pack_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  APPEND ls_pinf TO gt_pinf.
ENDFORM.

FORM convert_pinf.                                          &quot;#EC CALLED
  CHECK gt_pinf IS NOT INITIAL.
  SORT gt_pinf BY pack_name ASCENDING.
  ADD 1 TO gv_header_no.
  PERFORM add_header_html USING &apos;PINF&apos; CHANGING gt_html.
  PERFORM add_object_instruction_html USING &apos;PINF&apos; CHANGING gt_html.
  PERFORM table2html USING &apos;&apos; gt_pinf &apos;VINTF&apos; &apos;PACK_NAME|INTF_NAME|DESCRIPT&apos; abap_false &apos;&apos; CHANGING gt_html.
ENDFORM.
***************** Package: Interface Close *****************
***************** Function Group Begin *****************
FORM getdata_fugr USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_fugr TYPE s_fugr.

  MOVE-CORRESPONDING is_obj_header TO ls_fugr.
  SELECT SINGLE areat FROM tlibt INTO ls_fugr-short_text WHERE spras = sy-langu AND area = ls_fugr-obj_name.
  CHECK sy-subrc EQ 0.
  APPEND ls_fugr TO gt_fugr.
ENDFORM.
***************** Function Group Close *****************

***************** Function Group(Texts) Begin *****************
FORM getdata_fugt USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_fugt TYPE s_fugt.

  MOVE-CORRESPONDING is_obj_header TO ls_fugt.
  SELECT SINGLE areat FROM tlibt INTO ls_fugt-short_text WHERE spras = sy-langu AND area = ls_fugt-obj_name.
  CHECK sy-subrc EQ 0.
  ls_fugt-activity = gcv_act_update.
  APPEND ls_fugt TO gt_fugt.
ENDFORM.
***************** Function Group(Texts) Close *****************
***************** Domain Begin *****************
FORM getdata_doma USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_doma_reuse USING is_obj_header.
ENDFORM.

FORM getdata_doma_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_doma        TYPE s_doma,
        lv_dm_name     TYPE ddobjname,
        ls_dd01v       TYPE dd01v.
  lv_dm_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
    EXPORTING
      name          = lv_dm_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd01v_wa      = ls_dd01v
    TABLES
      dd07v_tab     = ls_doma-value_range
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd01v IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_doma.
  MOVE-CORRESPONDING ls_dd01v TO ls_doma.
  PERFORM get_activity USING ls_dd01v-as4date CHANGING ls_doma-activity.
  ls_doma-short_text = ls_dd01v-ddtext.

  IF ls_doma-object EQ &apos;DOMA&apos;.
    APPEND ls_doma TO gt_doma.
  ELSEIF ls_doma-object EQ &apos;DOMD&apos;.
    ls_doma-activity = gcv_act_update.
    APPEND ls_doma TO gt_doma.
  ENDIF.
ENDFORM.

FORM get_additional_html_doma USING is_doma TYPE s_doma CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING is_doma &apos;S_DOMA&apos; &apos;DATATYPE|LENG|OUTPUTLEN|DECIMALS|LOWERCASE|SIGNFLAG|ENTITYTAB&apos; CHANGING ct_html.
  IF is_doma-valexi EQ abap_true.
    PERFORM table2tr USING text_doma-label_value_range is_doma-value_range &apos;DD07V&apos; &apos;DOMVALUE_L|DDTEXT&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Domain Close *****************

***************** Domain Definition: Begin *****************
FORM getdata_domd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_doma_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_domd USING is_domd TYPE s_domd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM data2rows USING is_domd &apos;S_DOMA&apos; &apos;DATATYPE|LENG|OUTPUTLEN|DECIMALS|LOWERCASE|SIGNFLAG|ENTITYTAB&apos; CHANGING ct_html.
  IF is_domd-valexi EQ abap_true.
    PERFORM table2tr USING text_doma-label_value_range is_domd-value_range &apos;DD07V&apos; &apos;DOMVALUE_L|DDTEXT&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Domain Definition: Close *****************
***************** Data Element Begin *****************
FORM getdata_dtel USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_dtel_reuse USING is_obj_header.
ENDFORM.

FORM getdata_dtel_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_dtel    TYPE s_dtel,
        lv_de_name TYPE ddobjname,
        ls_dd04v   TYPE dd04v.

  lv_de_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
    EXPORTING
      name          = lv_de_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd04v_wa      = ls_dd04v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd04v IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_dtel.
  MOVE-CORRESPONDING ls_dd04v TO ls_dtel.
  PERFORM get_activity USING ls_dd04v-as4date CHANGING ls_dtel-activity.
  ls_dtel-short_text = ls_dd04v-ddtext.

  IF ls_dtel-object EQ &apos;DTEL&apos;.
    APPEND ls_dtel TO gt_dtel.
  ELSE.
    ls_dtel-activity = gcv_act_update.
    APPEND ls_dtel TO gt_dted.
  ENDIF.
ENDFORM.

FORM get_additional_html_dtel USING ls_dtel TYPE s_dtel CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: lv_tr   TYPE string,
        lv_td1  TYPE string,
        lv_td2  TYPE string,
        lv_td3  TYPE string,
        lv_tmp  TYPE string,
        lv_numc TYPE string,
        lt_tab  TYPE TABLE OF string,
        lv_labels  TYPE string.

  IF ls_dtel-domname IS NOT INITIAL.
    PERFORM get_2column_value_html USING text_dtel-label_domain ls_dtel-domname  CHANGING ct_html.
  ELSE.
    PERFORM format_numc USING ls_dtel-leng CHANGING lv_numc.
    CONCATENATE text_dtel-label_domain &apos;: &apos; ls_dtel-datatype &apos;&lt;br&gt;&apos; text_dtel-label_length &apos;: &apos; lv_numc INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_2column_value_html USING text_dtel-label_predf_type lv_tmp CHANGING ct_html.
  ENDIF.
  PERFORM get_column_value_html USING text_dtel-label_fld_lab CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  CONCATENATE &apos; |&apos; text_dtel-label_length &apos;|&apos; text_dtel-label_fld_lab INTO lv_labels RESPECTING BLANKS.
  PERFORM get_tr_label_html USING lv_labels CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_short CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen1 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_s CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_medium CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen2 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_m CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_long CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen3 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_l CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_heading CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-headlen CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-reptext CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  APPEND gcv_table_end TO lt_tab.
  PERFORM join_str USING lt_tab CHANGING lv_tmp.
  CONCATENATE lv_tr lv_tmp &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
ENDFORM.

FORM get_special_html_dtel USING ls_dtel TYPE s_dtel CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: ls_dokil TYPE dokil,
        lt_lines TYPE t_tline.

  SELECT SINGLE * FROM dokil INTO ls_dokil WHERE id = &apos;DE&apos;
    AND object = ls_dtel-obj_name AND langu = sy-langu AND typ = &apos;E&apos;.
  PERFORM read_docu_by_dokil USING ls_dokil CHANGING lt_lines.
  CHECK lt_lines IS NOT INITIAL.

  PERFORM get_small_title_html USING text_dtel-txt_mt_docu_title CHANGING ct_html.
  PERFORM get_paragraph_html USING text_dtel-txt_mt_docu_para CHANGING ct_html.
  PERFORM append_docu_html USING lt_lines CHANGING ct_html.
ENDFORM.

FORM read_docu_by_dokil USING is_dokil TYPE dokil CHANGING ct_lines TYPE t_tline.
  CHECK is_dokil IS NOT INITIAL.

  CALL FUNCTION &apos;DOCU_READ&apos;
    EXPORTING
      id      = is_dokil-id
      langu   = is_dokil-langu
      object  = is_dokil-object
      typ     = is_dokil-typ
      version = is_dokil-version
    TABLES
      line    = ct_lines.
ENDFORM.

FORM append_docu_html USING it_lines TYPE t_tline CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM table2html USING &apos;&apos; it_lines &apos;TLINE&apos; &apos;TDFORMAT|TDLINE&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Data Element Close *****************

***************** Data Element Definition Begin *****************
FORM getdata_dted USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_dtel_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_dted USING is_dted TYPE s_dted CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_dtel USING is_dted CHANGING ct_html.
ENDFORM.

FORM get_special_html_dted USING is_dted TYPE s_dted CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_special_html_dtel USING is_dted CHANGING ct_html.
ENDFORM.
***************** Data Element Definition Close *****************
***************** Table Begin *****************
FORM getdata_tabl USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_tabl_reuse USING is_obj_header.
ENDFORM.

FORM getdata_tabl_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_tabl    TYPE s_tabl,
        lv_tabname TYPE ddobjname,
        ls_dd02v   TYPE dd02v,
        lt_dd36m   TYPE dd36mttyp,
        lt_dd05m   TYPE dd05mttyp,
        lt_dd03p   TYPE dd03ttyp,
        lt_dd12v   TYPE dd12vtab,
        lt_dd17v   TYPE dd17vtab,
        ls_fk_def     TYPE s_tabl_fk_def,
        ls_tabl_fld   TYPE s_tabl_field,
        ls_tabl_index TYPE s_tabl_index.
  FIELD-SYMBOLS: &lt;fs_dd05m&gt; TYPE dd05m,
                 &lt;fs_dd03p&gt; TYPE dd03p,
                 &lt;fs_dd12v&gt; TYPE dd12v,
                 &lt;fs_dd17v&gt; TYPE dd17v.

  lv_tabname = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_TABL_GET&apos;
    EXPORTING
      name          = lv_tabname
      langu         = sy-langu
    IMPORTING
      dd02v_wa      = ls_dd02v                      &quot; table header information
      dd09l_wa      = ls_tabl-tech_setting          &quot; technical setting
    TABLES
      dd03p_tab     = lt_dd03p                      &quot; fields
      dd05m_tab     = lt_dd05m                      &quot; foreign key
      dd08v_tab     = ls_tabl-foreign_key_header    &quot; foreign key headers and texts
      dd12v_tab     = lt_dd12v                      &quot; indexes with text
      dd17v_tab     = lt_dd17v                      &quot; secondary indexes
      dd35v_tab     = ls_tabl-assignments           &quot; assignment of structure fields and search helps
      dd36m_tab     = lt_dd36m                      &quot; interface structure for field assignments table-search help
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd02v IS NOT INITIAL AND lt_dd03p IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_tabl.
  MOVE-CORRESPONDING ls_dd02v TO ls_tabl.
  ls_tabl-short_text = ls_dd02v-ddtext.
* convert table/structure fields
  LOOP AT lt_dd03p ASSIGNING &lt;fs_dd03p&gt;.
    MOVE-CORRESPONDING &lt;fs_dd03p&gt; TO ls_tabl_fld.
    IF &lt;fs_dd03p&gt;-fieldname EQ &apos;.INCLUDE&apos;.
      ls_tabl_fld-rollname = &lt;fs_dd03p&gt;-precfield.
    ENDIF.

    IF &lt;fs_dd03p&gt;-adminfield NE 0.
      CLEAR ls_tabl_fld-fieldname.
      CONCATENATE &apos;&lt;i&gt;&apos; &lt;fs_dd03p&gt;-fieldname &apos;&lt;/i&gt;&apos; INTO ls_tabl_fld-fieldname RESPECTING BLANKS.
    ENDIF.

    IF ls_tabl-tabclass EQ &apos;INTTAB&apos;.
      PERFORM get_tabl_comp_typing_method USING &lt;fs_dd03p&gt; CHANGING ls_tabl_fld-typing_method.
    ENDIF.
    APPEND ls_tabl_fld TO ls_tabl-fields.
    CLEAR ls_tabl_fld.
  ENDLOOP.
* convert foreign key definition
  LOOP AT lt_dd05m ASSIGNING &lt;fs_dd05m&gt;.
    MOVE-CORRESPONDING &lt;fs_dd05m&gt; TO ls_fk_def.
    IF &lt;fs_dd05m&gt;-forkey IS INITIAL.
      ls_fk_def-fortable = abap_false.
    ENDIF.

    IF &lt;fs_dd05m&gt;-fortable EQ &apos;*&apos;.
      ls_fk_def-generic = abap_true.
    ENDIF.

    IF &lt;fs_dd05m&gt;-forkey IS INITIAL AND &lt;fs_dd05m&gt;-fortable NE &apos;*&apos;.
      ls_fk_def-constant = &lt;fs_dd05m&gt;-fortable.
    ENDIF.
    APPEND ls_fk_def TO ls_tabl-foreign_keys.
    CLEAR ls_fk_def.
  ENDLOOP.
* convert table index
  LOOP AT lt_dd12v ASSIGNING &lt;fs_dd12v&gt;.
    MOVE-CORRESPONDING &lt;fs_dd12v&gt; TO ls_tabl_index.
    LOOP AT lt_dd17v ASSIGNING &lt;fs_dd17v&gt; WHERE indexname EQ &lt;fs_dd12v&gt;-indexname.
      CONCATENATE ls_tabl_index-index_fields &apos;&lt;br&gt;&apos; &lt;fs_dd17v&gt;-fieldname INTO ls_tabl_index-index_fields.
    ENDLOOP.

    SHIFT ls_tabl_index-index_fields BY 4 PLACES.
    APPEND ls_tabl_index TO ls_tabl-index.
    CLEAR ls_tabl_index.
  ENDLOOP.
* namespace reservation
  SELECT * FROM tresc INTO TABLE ls_tabl-namespace WHERE tabname = ls_tabl-obj_name.
  PERFORM get_activity USING ls_dd02v-as4date CHANGING ls_tabl-activity.

  IF ls_tabl-object EQ &apos;TABL&apos;.
    APPEND ls_tabl TO gt_tabl.
  ELSEIF ls_tabl-object EQ &apos;TABL&apos;.
    ls_tabl-activity = gcv_act_update.
    APPEND ls_tabl TO gt_tabd.
  ENDIF.
ENDFORM.

FORM get_additional_html_tabl USING ls_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  IF ls_tabl-tabclass EQ &apos;TRANSP&apos;.
    PERFORM data2rows USING ls_tabl &apos;S_TABL&apos; &apos;CONTFLAG|MAINFLAG&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_special_html_tabl USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_tabl_fields_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_fk_setting_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_techsetting_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_namespace_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_index_html USING is_tabl CHANGING ct_html.
ENDFORM.

FORM get_tabl_fields_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA lv_show_note_flds TYPE abap_bool.
  FIELD-SYMBOLS &lt;fs_fld&gt; TYPE s_tabl_field.

  LOOP AT is_tabl-fields ASSIGNING &lt;fs_fld&gt; WHERE fieldname EQ &apos;.INCLUDE&apos;.
    lv_show_note_flds = abap_true.
  ENDLOOP.
  &quot; we will handle transparent table and structure currently
  IF is_tabl-tabclass EQ &apos;TRANSP&apos;.
    PERFORM get_small_title_html USING text_tabl-title_flds CHANGING ct_html.
    IF lv_show_note_flds EQ abap_true.
      PERFORM get_paragraph_html USING text_tabl-note_flds CHANGING ct_html.
    ENDIF.
    PERFORM table2html USING &apos;&apos; is_tabl-fields &apos;S_TABL_FIELD&apos; &apos;FIELDNAME|KEYFLAG|ROLLNAME|CHECKTABLE|SHLPNAME&apos; abap_true &apos;CHECKTABLE|SHLPNAME&apos; CHANGING ct_html.
  ELSEIF is_tabl-tabclass EQ &apos;INTTAB&apos;.
    PERFORM get_small_title_html USING text_tabl-title_comps CHANGING ct_html.
    IF lv_show_note_flds EQ abap_true.
      PERFORM get_paragraph_html USING text_tabl-note_comps CHANGING ct_html.
    ENDIF.
    PERFORM table2html USING &apos;&apos; is_tabl-fields &apos;S_TABL_FIELD&apos; &apos;FIELDNAME|TYPING_METHOD|ROLLNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_tabl_comp_typing_method USING is_fld TYPE dd03p CHANGING cv_typing_method TYPE string.
  CONSTANTS: c_t_ref       VALUE &apos;R&apos;,
             c_t_boxed     VALUE &apos;J&apos;,
             c_type        TYPE f_reftype VALUE &apos;1&apos;,     &quot; type
             c_type_ref_to TYPE f_reftype VALUE &apos;3&apos;,     &quot; type ref to
             c_type_boxed  TYPE f_reftype VALUE &apos;5&apos;.     &quot; type ... boxed
  DATA: lv_txt TYPE ddtext,
        lv_low TYPE ddfixvalue-low,
        lv_f_reftype TYPE f_reftype.

  CLEAR cv_typing_method.

  IF is_fld-comptype EQ c_t_ref.
    IF is_fld-reftype = c_t_boxed.
      lv_f_reftype = c_type_boxed.
    ELSE.
      lv_f_reftype = c_type_ref_to.
    ENDIF.
  ELSE.
    lv_f_reftype = c_type.
  ENDIF.

  lv_low = lv_f_reftype.
  PERFORM get_value_desc USING &apos;F_REFTYPE&apos; lv_low CHANGING lv_txt.
  CONCATENATE lv_f_reftype &apos; &apos; lv_txt INTO cv_typing_method RESPECTING BLANKS.
ENDFORM.

FORM get_tabl_techsetting_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE t_string.
  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos;.
  PERFORM get_techsetting_html USING is_tabl-tech_setting CHANGING ct_html.
ENDFORM.

FORM get_techsetting_html USING is_dd09v TYPE dd09v CHANGING ct_html TYPE t_string.
  DATA lt_dd09v TYPE TABLE OF dd09v.
  APPEND is_dd09v TO lt_dd09v.
  PERFORM table2html USING text_tabl-title_tech lt_dd09v &apos;DD09V&apos; &apos;TABART|TABKAT|BUFALLOW|PUFFERUNG|PROTOKOLL|JAVAONLY&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.

FORM get_tabl_fk_setting_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tmp  TYPE string,
        lv_card TYPE string,
        lv_fkt  TYPE ddtext,
        lv_low  TYPE ddfixvalue-low,
        lv_screen_check TYPE c.
  FIELD-SYMBOLS: &lt;fs_header&gt; LIKE LINE OF is_tabl-foreign_key_header.

  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-foreign_key_header IS NOT INITIAL AND is_tabl-foreign_keys IS NOT INITIAL.

  PERFORM get_small_title_html USING text_tabl-title_fks CHANGING ct_html.
  LOOP AT is_tabl-foreign_key_header ASSIGNING &lt;fs_header&gt;.
    CLEAR: lv_screen_check, lv_card.
    CONCATENATE text_tabl-note_fks &apos;&lt;b&gt;&apos; &lt;fs_header&gt;-fieldname &apos;&lt;/b&gt;&apos; INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_paragraph_html USING lv_tmp CHANGING ct_html.

    APPEND gcv_table_begin TO ct_html.
    PERFORM get_default2column_html CHANGING ct_html.
    PERFORM data2rows USING &lt;fs_header&gt; &apos;S_TABL_FK_DEF&apos; &apos;FIELDNAME|CHECKTABLE|DDTEXT&apos; CHANGING ct_html.
    &quot; foreign key definitions
    PERFORM get_fk_fld_definition_html USING is_tabl-foreign_keys &lt;fs_header&gt;-fieldname CHANGING lv_tmp.
    PERFORM get_2column_right_table_html USING text_tabl-label_fk_flds lv_tmp CHANGING ct_html.
    &quot; screen check attributes: screen check flag differs from checkflag
    lv_screen_check = boolc( &lt;fs_header&gt;-checkflag EQ abap_false ).
    IF lv_screen_check IS NOT INITIAL OR &lt;fs_header&gt;-msgnr IS NOT INITIAL OR &lt;fs_header&gt;-arbgb IS NOT INITIAL.
      CONCATENATE text_tabl-label_check_rq lv_screen_check &apos;&amp;nbsp;&amp;nbsp; &apos; text_tabl-label_msg_no &lt;fs_header&gt;-msgnr &apos;&amp;nbsp;&amp;nbsp; &apos; text_tabl-label_aarea &lt;fs_header&gt;-arbgb
        INTO lv_tmp RESPECTING BLANKS.
      PERFORM get_2column_value_html USING text_tabl-label_screen_check lv_tmp CHANGING ct_html.
      CLEAR lv_tmp.
    ENDIF.
    &quot; semantic attributes
    lv_low = &lt;fs_header&gt;-frkart.
    PERFORM get_value_desc USING &apos;FRKART&apos; lv_low CHANGING lv_fkt.
    IF &lt;fs_header&gt;-cardleft IS NOT INITIAL OR &lt;fs_header&gt;-card IS NOT INITIAL.
      CONCATENATE &apos;&lt;br&gt;&apos; text_tabl-label_card &apos;[&apos; &lt;fs_header&gt;-cardleft &apos;&amp;nbsp;&amp;nbsp;:&amp;nbsp;&amp;nbsp;&apos; &lt;fs_header&gt;-card &apos;]&apos; INTO lv_card RESPECTING BLANKS.
    ENDIF.
    CONCATENATE text_tabl-label_fk_type lv_fkt lv_card INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_2column_value_html USING text_tabl-label_fk_semantic lv_tmp CHANGING ct_html.
    CLEAR lv_tmp.

    APPEND gcv_table_end TO ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDLOOP.
ENDFORM.

FORM get_fk_fld_definition_html USING it_fk_def TYPE t_tabl_fk_def iv_fieldname TYPE fieldname CHANGING cv_html TYPE string.
  DATA: lt_html   TYPE t_string,
        lt_fk_def TYPE t_tabl_fk_def.
  PERFORM get_fk_fld_def_by_name USING it_fk_def iv_fieldname CHANGING lt_fk_def.
  PERFORM convert_table_html USING &apos;&apos; lt_fk_def &apos;S_TABL_FK_DEF&apos;
        &apos;CHECKTABLE|CHECKFIELD|FORTABLE|FORKEY|GENERIC|CONSTANT&apos; abap_true &apos;GENERIC|CONSTANT&apos; abap_true CHANGING lt_html.
  PERFORM join_str USING lt_html CHANGING cv_html.
ENDFORM.

FORM get_fk_fld_def_by_name USING it_fk_def TYPE t_tabl_fk_def iv_fieldname TYPE fieldname CHANGING ct_fld_def TYPE t_tabl_fk_def.
  FIELD-SYMBOLS: &lt;fs_fk_def&gt; TYPE s_tabl_fk_def.
  LOOP AT it_fk_def ASSIGNING &lt;fs_fk_def&gt; WHERE fieldname EQ iv_fieldname.
    APPEND &lt;fs_fk_def&gt; TO ct_fld_def.
  ENDLOOP.
ENDFORM.

FORM get_tabl_namespace_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
* only transparent table with delivery class E need to display namespace maintainance settings
  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-contflag EQ &apos;E&apos; AND is_tabl-namespace IS NOT INITIAL.
  PERFORM table2html USING text_tabl-title_namespace is_tabl-namespace &apos;TRESC&apos; &apos;FIELDNAME|KEYLOW&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.

FORM get_tabl_index_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-index IS NOT INITIAL.
  PERFORM table2html USING text_tabl-title_index is_tabl-index &apos;S_TABL_INDEX&apos; &apos;&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Table Close *****************

***************** Table Definition Begin *****************
FORM getdata_tabd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_tabl_reuse USING is_obj_header.
ENDFORM.

FORM get_special_html_tabd USING is_tabd TYPE s_tabd CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_special_html_tabl USING is_tabd CHANGING ct_html.
ENDFORM.
***************** Table Definition Close *****************
***************** Technical Attributes of a Table Begin *****************
TYPES: BEGIN OF s_tabt.
        INCLUDE TYPE s_obj_header.
TYPES: tech_setting TYPE dd09v.
TYPES: END OF s_tabt.
DATA gt_tabt TYPE TABLE OF s_tabt.                          &quot;#EC NEEDED

FORM getdata_tabt USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tabt  TYPE s_tabt,
        lv_ddobj TYPE ddobjname.

  MOVE-CORRESPONDING is_obj_header TO ls_tabt.
  lv_ddobj = ls_tabt-obj_name.
  CALL FUNCTION &apos;DDIF_TABT_GET&apos;
    EXPORTING
      name          = lv_ddobj
      state         = &apos;A&apos;
    IMPORTING
      dd09l_wa      = ls_tabt-tech_setting
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_tabt-tech_setting IS NOT INITIAL.

  APPEND ls_tabt TO gt_tabt.
ENDFORM.

FORM get_special_html_tabt USING is_tabt TYPE s_tabt CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_techsetting_html USING is_tabt-tech_setting CHANGING ct_html.
ENDFORM.
***************** Technical Attributes of a Table Close *****************

***************** Table Index Begin *****************
TYPES: t_dd17v TYPE STANDARD TABLE OF dd17v WITH DEFAULT KEY.
TYPES: BEGIN OF s_indx.
        INCLUDE TYPE s_obj_header.
TYPES: header TYPE dd12v.
TYPES: fields TYPE string.
TYPES: END OF s_indx.
DATA gt_indx TYPE TABLE OF s_indx.                          &quot;#EC NEEDED

FORM getdata_indx USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_indx     TYPE s_indx,
        lv_table    TYPE ddobjname,
        lt_dd17v    TYPE TABLE OF dd17v,
        lv_index_id TYPE ddobjectid.
  MOVE-CORRESPONDING is_obj_header TO ls_indx.
  CALL FUNCTION &apos;DDIF_INDX_GET&apos;
    EXPORTING
      name          = lv_table
      id            = lv_index_id
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd12v_wa      = ls_indx-header
    TABLES
      dd17v_tab     = lt_dd17v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_indx-header IS NOT INITIAL AND ls_indx-fields IS NOT INITIAL.
  PERFORM collect_tab_fld USING lt_dd17v &apos;FIELDNAME&apos; `, ` CHANGING ls_indx-fields.
  APPEND ls_indx TO gt_indx.
ENDFORM.

FORM get_additional_html_indx USING is_indx TYPE s_indx CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM data2rows_common USING is_indx-header &apos;DD12V&apos; &apos;SQLTAB|INDEXNAME|UNIQUEFLAG|DBINDEX|DBSTATE|FIELDS&apos; abap_false CHANGING ct_html.
  IF is_indx-header-dbstate EQ &apos;D&apos;.
    PERFORM data2rows USING is_indx-header &apos;DD12V&apos; &apos;DBINCLEXCL|DBSYSSEL1|DBSYSSEL2|DBSYSSEL3|DBSYSSEL4&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Table Index Close *****************
***************** View Begin *****************
FORM getdata_view USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_view_reuse USING is_obj_header.
ENDFORM.

FORM getdata_view_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_view  TYPE s_view,
        lv_view_name TYPE ddobjname,
        ls_dd25v TYPE dd25v.

  MOVE-CORRESPONDING is_obj_header TO ls_view.
  lv_view_name = ls_view-obj_name.
  CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
    EXPORTING
      name          = lv_view_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v
      dd09l_wa      = ls_view-tech_setting
    TABLES
      dd26v_tab     = ls_view-table_join
      dd27p_tab     = ls_view-fields
      dd28j_tab     = ls_view-join_condition
      dd28v_tab     = ls_view-selection_condition
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd25v IS NOT INITIAL.

  MOVE-CORRESPONDING ls_dd25v TO ls_view.
  PERFORM get_activity USING ls_dd25v-as4date CHANGING ls_view-activity.
  ls_view-short_text = ls_dd25v-ddtext.

  IF ls_view-object EQ &apos;VIEW&apos;.
    APPEND ls_view TO gt_view.
  ELSEIF ls_view-object EQ &apos;VIED&apos;.
    ls_view-activity = gcv_act_update.
    APPEND ls_view TO gt_vied.
  ENDIF.
ENDFORM.

FORM get_additional_html_view USING ls_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_view &apos;S_VIEW&apos; &apos;VIEWGRANT|CUSTOMAUTH|GLOBALFLAG&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_view USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_jointable_html USING is_view CHANGING ct_html.
  PERFORM get_view_fields_html USING is_view CHANGING ct_html.
  PERFORM get_selcondition_html USING is_view CHANGING ct_html.

  DATA lt_dd09v TYPE TABLE OF dd09v.
  CHECK is_view-tech_setting IS NOT INITIAL.
  APPEND is_view-tech_setting TO lt_dd09v.
  PERFORM table2html USING text_tabl-title_tech lt_dd09v &apos;DD09V&apos; &apos;BUFALLOW|PUFFERUNG&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.

FORM get_jointable_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tmp  TYPE string.
  FIELD-SYMBOLS: &lt;fs_tb&gt; TYPE dd26v.

  LOOP AT is_view-table_join ASSIGNING &lt;fs_tb&gt;.
    CONCATENATE lv_tmp &apos;, &apos; &lt;fs_tb&gt;-tabname INTO lv_tmp RESPECTING BLANKS.
  ENDLOOP.
  SHIFT lv_tmp BY 2 PLACES.
  CONCATENATE text_view-title_tables lv_tmp INTO lv_tmp RESPECTING BLANKS.
  PERFORM get_paragraph_html USING lv_tmp CHANGING ct_html.

  IF is_view-join_condition IS INITIAL.
    PERFORM get_paragraph_html USING text_view-note_join_cond CHANGING ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ELSE.
    PERFORM table2html USING text_view-title_join_conds is_view-join_condition &apos;DD28J&apos; &apos;LTAB|LFIELD|OPERATOR|RTAB|RFIELD&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_view_fields_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM table2html USING text_view-title_fields is_view-fields &apos;DD27P&apos;
          &apos;VIEWFIELD|TABNAME|FIELDNAME|RDONLY|KEYFLAG|ROLLCHANGE&apos; abap_true &apos;RDONLY|ROLLCHANGE&apos; CHANGING ct_html.
ENDFORM.

FORM get_selcondition_html USING is_view TYPE s_view CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_small_title_html USING text_view-title_sel_conds CHANGING ct_html.
  IF is_view-selection_condition IS INITIAL.
    PERFORM get_paragraph_html USING text_view-note_sel_cond CHANGING ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ELSE.
    PERFORM table2html USING &apos;&apos; is_view-selection_condition &apos;DD28V&apos; &apos;TABNAME|FIELDNAME|OPERATOR|CONSTANTS|AND_OR&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** View Close *****************

***************** View Definition Begin *****************
FORM getdata_vied USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  READ TABLE gt_view WITH KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  PERFORM getdata_view_reuse USING is_obj_header.
ENDFORM.

FORM get_special_html_vied USING is_vied TYPE s_vied CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_special_html_view USING is_vied CHANGING ct_html.
ENDFORM.
***************** View Definition Close *****************

TYPES: BEGIN OF s_viet.
        INCLUDE TYPE s_obj_header.
TYPES: tech_setting TYPE dd09v.
TYPES: END OF s_viet.
DATA gt_viet TYPE TABLE OF s_viet.                          &quot;#EC NEEDED

***************** Technical Attributes of a View Begin *****************
FORM getdata_viet USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_viet  TYPE s_viet,
        lv_ddobj TYPE ddobjname.

  READ TABLE gt_view WITH KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  READ TABLE gt_vied WITH KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.

  MOVE-CORRESPONDING is_obj_header TO ls_viet.
  lv_ddobj = ls_viet-obj_name.
  CALL FUNCTION &apos;DDIF_VIET_GET&apos;
    EXPORTING
      name          = lv_ddobj
    IMPORTING
      dd09l_wa      = ls_viet-tech_setting
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_viet-tech_setting IS NOT INITIAL.
  ls_viet-activity = gcv_act_update.
  APPEND ls_viet TO gt_viet.
ENDFORM.

FORM get_special_html_viet USING is_viet TYPE s_viet CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA lt_dd09v TYPE TABLE OF dd09v.
  APPEND is_viet-tech_setting TO lt_dd09v.
  PERFORM table2html USING &apos;&apos; lt_dd09v &apos;DD09V&apos; &apos;TABNAME|BUFALLOW|PUFFERUNG&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Technical Attributes of a View Close *****************
***************** Search Help Begin *****************
FORM getdata_shlp USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_shlp_reuse USING is_obj_header.
ENDFORM.

FORM getdata_shlp_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_shlp TYPE s_shlp,
        lv_shlp_name TYPE ddobjname,
        ls_dd30v TYPE dd30v,
        lt_dd31v TYPE TABLE OF dd31v,
        lt_dd33v TYPE TABLE OF dd33v.

  lv_shlp_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_SHLP_GET&apos;
    EXPORTING
      name          = lv_shlp_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd30v_wa      = ls_dd30v
    TABLES
      dd31v_tab     = lt_dd31v
      dd32p_tab     = ls_shlp-params
      dd33v_tab     = lt_dd33v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd30v IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_shlp.
  MOVE-CORRESPONDING ls_dd30v TO ls_shlp.
  PERFORM get_activity USING ls_dd30v-as4date CHANGING ls_shlp-activity.
  ls_shlp-short_text = ls_dd30v-ddtext.

  IF ls_shlp-object EQ &apos;SHLP&apos;.
    APPEND ls_shlp TO gt_shlp.
  ELSEIF ls_shlp-object EQ &apos;SHLD&apos;.
    ls_shlp-activity = gcv_act_update.
    APPEND ls_shlp TO gt_shld.
  ENDIF.
ENDFORM.

FORM get_additional_html_shlp USING ls_shlp TYPE s_shlp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  DATA: lv_type TYPE string.
  IF ls_shlp-issimple EQ abap_true.
    lv_type = text_shlp-txt_type_ele.
  ELSE.
    lv_type = text_shlp-txt_type_col.
  ENDIF.
  PERFORM get_2column_value_html USING text_shlp-txt_type lv_type CHANGING ct_html.
  PERFORM data2rows USING ls_shlp &apos;DD30V&apos; &apos;SELMETHOD|DIALOGTYPE|HOTKEY|SELMEXIT&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_shlp USING is_shlp TYPE s_shlp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM table2html USING text_enqu-label_params is_shlp-params &apos;DD32P&apos;
          &apos;FIELDNAME|SHLPINPUT|SHLPOUTPUT|SHLPSELPOS|SHLPLISPOS|SHLPSELDIS|ROLLNAME|ROLLCHANGE|DEFAULTVAL&apos; abap_true &apos;DEFAULTVAL&apos; CHANGING ct_html.
ENDFORM.
***************** Search Help Close *****************

***************** Search Help Definition Begin *****************
FORM getdata_shld USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_shlp_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_shld USING is_shld TYPE s_shld CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_shlp USING is_shld CHANGING ct_html.
ENDFORM.

FORM get_special_html_shld USING is_shld TYPE s_shld CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_special_html_shlp USING is_shld CHANGING ct_html.
ENDFORM.
***************** Search Help Definition Close *****************
***************** Lock Object Begin *****************
FORM getdata_enqu USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_enqu_reuse USING is_obj_header.
ENDFORM.

FORM getdata_enqu_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_enqu TYPE s_enqu,
        ls_dd25v     TYPE dd25v,
        lt_dd27p     TYPE TABLE OF dd27p,
        lv_lock_name TYPE ddobjname.

  lv_lock_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
    EXPORTING
      name          = lv_lock_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v            &quot;lock object attributes(similar as that of view)
    TABLES
      dd26e_tab     = ls_enqu-base_tables &quot;base tables
      dd27p_tab     = lt_dd27p            &quot;view fields
      ddena_tab     = ls_enqu-lock_params &quot;lock argument fields
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd25v IS NOT INITIAL.
  MOVE-CORRESPONDING is_obj_header TO ls_enqu.
  ls_enqu-short_text = ls_dd25v-ddtext.
  PERFORM get_activity USING ls_dd25v-as4date CHANGING ls_enqu-activity.

  IF ls_enqu-object EQ &apos;ENQU&apos;.
    APPEND ls_enqu TO gt_enqu.
  ELSEIF ls_enqu-object EQ &apos;ENQD&apos;.
    ls_enqu-activity = gcv_act_update.
    APPEND ls_enqu TO gt_enqd.
  ENDIF.
ENDFORM.

FORM get_additional_html_enqu USING ls_enqu TYPE s_enqu CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_2column_value_html USING text_enqu-label_allow_rfc ls_enqu-rfcenable CHANGING ct_html.
ENDFORM.

FORM get_special_html_enqu USING is_enqu TYPE s_enqu CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM table2html USING text_enqu-label_tables is_enqu-base_tables &apos;DD26E&apos; &apos;TABPOS|TABNAME|ENQMODE&apos; abap_false &apos;&apos; CHANGING ct_html.
  PERFORM table2html USING text_enqu-label_params is_enqu-lock_params &apos;DDENA&apos; &apos;VIEWFIELD|TABNAME|FIELDNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Lock Object Close *****************

***************** Lock Object Definition Begin *****************
FORM getdata_enqd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_enqu_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_enqd USING is_enqd TYPE s_enqd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_enqu USING is_enqd CHANGING ct_html.
ENDFORM.

FORM get_special_html_enqd USING is_enqd TYPE s_enqd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_special_html_enqu USING is_enqd CHANGING ct_html.
ENDFORM.
***************** Lock Object Definition Close *****************
***************** Table Type Begin *****************
FORM getdata_ttyp USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_ttyp_reuse USING is_obj_header.
ENDFORM.

FORM getdata_ttyp_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_ttyp TYPE s_ttyp,
        lv_ttype_name TYPE ddobjname,
        ls_dd40v      TYPE dd40v.

  lv_ttype_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
    EXPORTING
      name          = lv_ttype_name
      langu         = sy-langu
    IMPORTING
      dd40v_wa      = ls_dd40v
    TABLES
      dd42v_tab     = ls_ttyp-primary_key
      dd43v_tab     = ls_ttyp-secondary_key
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd40v IS NOT INITIAL.
  MOVE-CORRESPONDING is_obj_header TO ls_ttyp.

  MOVE-CORRESPONDING ls_dd40v TO ls_ttyp.
  PERFORM get_activity USING ls_dd40v-as4date CHANGING ls_ttyp-activity.
  ls_ttyp-short_text = ls_dd40v-ddtext.

  IF ls_ttyp-object EQ &apos;TTYP&apos;.
    APPEND ls_ttyp TO gt_ttyp.
  ELSEIF ls_ttyp-object EQ &apos;TTYD&apos;.
    ls_ttyp-activity = gcv_act_update.
    APPEND ls_ttyp TO gt_ttyd.
  ENDIF.
ENDFORM.

FORM get_additional_html_ttyp USING is_ttyp TYPE s_ttyp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_2column_value_html USING text_ttyp-label_row_type is_ttyp-rowtype CHANGING ct_html.
ENDFORM.
***************** Table Type Close *****************

***************** Table Type Definition Begin *****************
FORM getdata_ttyd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_ttyp_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_ttyd USING is_ttyd TYPE s_ttyd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_ttyp USING is_ttyd CHANGING ct_html.
ENDFORM.
***************** Table Type Definition Close *****************
***************** Definition of a Maintenance and Transport Object Begin *****************
FORM getdata_tobj USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tobj TYPE s_tobj,
        ls_tvdir TYPE tvdir,
        lv_len   TYPE i,
        ls_tddat TYPE tddat.

  MOVE-CORRESPONDING is_obj_header TO ls_tobj.
  lv_len = strlen( ls_tobj-obj_name ) - 1.
  SELECT SINGLE * FROM tvdir INTO ls_tvdir WHERE tabname = ls_tobj-obj_name(lv_len).
  IF sy-subrc NE 0.
    IF ls_tobj-obj_name+lv_len(1) EQ &apos;C&apos;.
      &quot; maintenance object also exists for view cluster and will be ignored
      PERFORM add_obj_gen_msg USING is_obj_header &apos;W&apos; &apos;&apos;.
    ELSE.
      PERFORM add_obj_gen_msg USING is_obj_header &apos;E&apos; text_tobj-msg_obj_invalid.
    ENDIF.
    RETURN.
  ENDIF.

  MOVE-CORRESPONDING ls_tvdir TO ls_tobj.
  ls_tobj-maint_type = ls_tvdir-type.
  ls_tobj-devclass = ls_tvdir-devclass.
  SELECT SINGLE * FROM tddat INTO ls_tddat WHERE tabname = ls_tvdir-tabname.
  MOVE-CORRESPONDING ls_tddat TO ls_tobj.
  SELECT * FROM tvimf INTO CORRESPONDING FIELDS OF TABLE ls_tobj-events WHERE tabname = ls_tobj-tabname.

  APPEND ls_tobj TO gt_tobj.
ENDFORM.

FORM get_additional_html_tobj USING ls_tobj TYPE s_tobj CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_tobj &apos;S_TOBJ&apos; &apos;TABNAME|CCLASS|AREA|DEVCLASS|MAINT_TYPE|LISTE|DETAIL&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_tobj USING ls_tobj TYPE s_tobj CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  CHECK ls_tobj-events IS NOT INITIAL.
  PERFORM get_small_title_html USING text_tobj-label_events CHANGING ct_html.
  PERFORM get_paragraph_html USING text_tobj-txt_mt_event CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; ls_tobj-events &apos;TVIMF&apos; &apos;EVENT|FORMNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Definition of a Maintenance and Transport Object Close *****************
***************** View cluster Begin *****************
FORM getdata_vcls USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_vcls         TYPE s_vcls.

  PERFORM get_vcls_reuse USING is_obj_header CHANGING ls_vcls.
  CHECK sy-subrc EQ 0.
  APPEND ls_vcls TO gt_vcls.
ENDFORM.

FORM get_vcls_reuse USING is_obj_header TYPE s_obj_header CHANGING cs_vcls TYPE s_vcls.
  DATA: lv_vcls_name TYPE vcl_name,
        ls_vcldir    TYPE v_vcldir.

  CLEAR cs_vcls.
  READ TABLE gt_vcls INTO cs_vcls WITH KEY object = &apos;VCLS&apos; obj_name = is_obj_header-obj_name.
  CHECK sy-subrc NE 0.

  lv_vcls_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;VIEWCLUSTER_GET_DEFINITION&apos;
    EXPORTING
      vclname                = lv_vcls_name
    IMPORTING
      vcldir_entry           = ls_vcldir
    TABLES
      vclstruc_tab           = cs_vcls-object_stru
      vclstrudep_tab         = cs_vcls-field_dep
      vclmf_tab              = cs_vcls-events
    EXCEPTIONS
      viewcluster_not_found  = 1
      incomplete_viewcluster = 2
      OTHERS                 = 3.                           &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.

  CHECK is_obj_header-object EQ &apos;VCLS&apos;.
  MOVE-CORRESPONDING is_obj_header TO cs_vcls.
  PERFORM get_activity USING ls_vcldir-changedate CHANGING cs_vcls-activity.
  cs_vcls-short_text = ls_vcldir-text.
ENDFORM.

FORM get_additional_html_vcls USING ls_vcls TYPE s_vcls CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  DATA: lv_low       TYPE ddfixvalue-low,
        lv_hierarchy TYPE ddtext,
        lv_readtype  TYPE string.

  lv_low = ls_vcls-hieropsoff.
  PERFORM get_value_desc USING &apos;VCLS_HIERARCHY&apos; lv_low CHANGING lv_hierarchy.
  PERFORM get_2column_value_html USING text_vcls-label_hier lv_hierarchy CHANGING ct_html.
  IF ls_vcls-readkind EQ &apos;T&apos;.
    lv_readtype = text_vcls-txt_type_sub.
  ELSE.
    lv_readtype = text_vcls-txt_type_comp.
  ENDIF.
  PERFORM get_2column_value_html USING text_vcls-label_type lv_readtype CHANGING ct_html.
  PERFORM data2rows USING ls_vcls &apos;VCLDIR&apos; &apos;EXITPROG&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_vcls USING is_vcls TYPE s_vcls CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM table2html USING text_vcls-title_obj_stru is_vcls-object_stru &apos;V_VCLSTRUC&apos;
        &apos;OBJECT|OBJECTTEXT|PREDOBJECT|DEPENDENCY|OBJPOS|STARTOBJ|SUPPRESS|CARDINAL|SWITCH_ID&apos; abap_true &apos;SUPPRESS|CARDINAL|SWITCH_ID&apos; CHANGING ct_html.

  PERFORM table2html USING text_vcls-title_fld_dep is_vcls-field_dep &apos;V_VCLSTDEP&apos;
        &apos;OBJECT|OBJFIELD|PREDOBJECT|PREDFIELD|NOKEYFIELD&apos; abap_true &apos;NOKEYFIELD&apos; CHANGING ct_html.

  CHECK is_vcls-events IS NOT INITIAL.
  PERFORM get_small_title_html USING text_vcls-title_events CHANGING ct_html.
  PERFORM get_paragraph_html USING text_vcls-txt_mt_event CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; is_vcls-events &apos;V_VCLMF&apos; &apos;EVENT|FORMNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** View cluster Close *****************
***************** Number Range Objects Begin *****************
FORM getdata_nrob USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_nrob TYPE s_nrob,
        lv_object TYPE tnro-object,
        ls_tnro   TYPE tnro,
        ls_tnrot  TYPE tnrot.

  lv_object = is_obj_header-obj_name.
  CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_READ&apos;
    EXPORTING
      object            = lv_object
    IMPORTING
      object_attributes = ls_tnro
      object_text       = ls_tnrot
    EXCEPTIONS
      object_not_found  = 1
      OTHERS            = 2.                                &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_tnro IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_nrob.
  MOVE-CORRESPONDING ls_tnro TO ls_nrob.
  MOVE-CORRESPONDING ls_tnrot TO ls_nrob.
  ls_nrob-short_text = ls_tnrot-txtshort.
  ls_nrob-object = is_obj_header-object.
  APPEND ls_nrob TO gt_nrob.
ENDFORM.

FORM get_additional_html_nrob USING ls_nrob TYPE s_nrob CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_nrob &apos;S_NROB&apos; &apos;TXT|DTELSOBJ|DOMLEN|PERCENTAGE|YEARIND|NONRSWAP|CODE|BUFFER|NOIVBUFFER&apos; CHANGING ct_html.
ENDFORM.
***************** Number Range Objects Close *****************
***************** Documentation Begin *****************
FORM getdata_docu USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_docu TYPE s_docu,
        lv_docu_name TYPE sobj_name,
        ls_mess_header TYPE s_obj_header,
        ls_dokil TYPE dokil.
  FIELD-SYMBOLS: &lt;fs_objtype_order&gt; TYPE s_objtype_order.

  MOVE-CORRESPONDING is_obj_header TO ls_docu.
  lv_docu_name = ls_docu-obj_name.
  SHIFT lv_docu_name BY 2 PLACES.
  &quot; single message documentation will be transferred to MESS for reusage
  IF ls_docu-obj_name(2) EQ &apos;NA&apos;.
    READ TABLE gt_mess WITH KEY obj_name = lv_docu_name TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    ls_mess_header-pgmid = &apos;LIMU&apos;.
    ls_mess_header-object = &apos;MESS&apos;.
    ls_mess_header-obj_name = lv_docu_name.
    ls_mess_header-activity = gcv_act_create.
    READ TABLE gt_objtype_order ASSIGNING &lt;fs_objtype_order&gt; WITH TABLE KEY object = &apos;MESS&apos;.
    ls_mess_header-primary_sort = &lt;fs_objtype_order&gt;-sort_no.
    PERFORM getdata_mess USING ls_mess_header.
  ELSEIF ls_docu-obj_name(2) EQ &apos;DE&apos;.
    READ TABLE gt_dtel WITH KEY obj_name = lv_docu_name TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    ls_docu-obj_name = lv_docu_name.
    SELECT SINGLE * FROM dokil INTO ls_dokil WHERE id = &apos;DE&apos;
      AND object = ls_docu-obj_name AND langu = sy-langu AND typ = &apos;E&apos;.
    PERFORM read_docu_by_dokil USING ls_dokil CHANGING ls_docu-long_text.
    CHECK ls_docu-long_text IS NOT INITIAL.
    APPEND ls_docu TO gt_docu.
  ENDIF.
ENDFORM.

FORM convert_docu.                                          &quot;#EC CALLED
  DATA: ls_obj_header TYPE s_obj_header,
        lv_cnt TYPE i.
  FIELD-SYMBOLS: &lt;fs_docu&gt; TYPE s_docu.

  CHECK gt_docu IS NOT INITIAL.

  ADD 1 TO gv_header_no.
  lv_cnt = lines( gt_docu ).
  PERFORM add_header_html USING &apos;DOCU&apos; CHANGING gt_html.
  &quot; only data element documentation will be handled
  LOOP AT gt_docu ASSIGNING &lt;fs_docu&gt;.
    &lt;fs_docu&gt;-secondary_sort = sy-tabix.
    PERFORM add_title_html USING &lt;fs_docu&gt; lv_cnt CHANGING gt_html.
    PERFORM append_docu_html USING &lt;fs_docu&gt;-long_text CHANGING gt_html.

    MOVE-CORRESPONDING &lt;fs_docu&gt; TO ls_obj_header.
    PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
  ENDLOOP.
ENDFORM.
***************** Documentation Close *****************
***************** Message Class: Definition and All Short Texts Begin *****************
FORM getdata_msad USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_msad_reuse USING is_obj_header.
ENDFORM.

FORM getdata_msad_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_msg   TYPE s_msad,
        ls_t100a TYPE t100a.

  SELECT SINGLE stext FROM t100t INTO ls_msg-short_text
    WHERE sprsl = sy-langu AND arbgb = is_obj_header-obj_name.
  CHECK sy-subrc EQ 0.
  SELECT * FROM t100 INTO CORRESPONDING FIELDS OF TABLE ls_msg-message_texts ##too_many_itab_fields
    WHERE sprsl = sy-langu AND arbgb = is_obj_header-obj_name ORDER BY msgnr ASCENDING.
  MOVE-CORRESPONDING is_obj_header TO ls_msg.

  DATA: ls_long_txt TYPE s_long_text.
  FIELD-SYMBOLS &lt;fs_msg_txt&gt; TYPE s_msg_txt.
  LOOP AT ls_msg-message_texts ASSIGNING &lt;fs_msg_txt&gt;.
    MOVE-CORRESPONDING &lt;fs_msg_txt&gt; TO ls_long_txt.
    PERFORM read_msg_docu USING &lt;fs_msg_txt&gt; CHANGING &lt;fs_msg_txt&gt;-self_explanatory ls_long_txt-long_text.
    IF &lt;fs_msg_txt&gt;-self_explanatory EQ abap_false.
      APPEND ls_long_txt TO ls_msg-long_texts.
    ENDIF.
  ENDLOOP.

  SELECT SINGLE * FROM t100a INTO ls_t100a WHERE arbgb = ls_msg-obj_name.
  PERFORM get_activity USING ls_t100a-ldate CHANGING ls_msg-activity.

  IF ls_msg-object EQ &apos;MSAG&apos;.
    APPEND ls_msg TO gt_msag.
  ELSEIF ls_msg-object EQ &apos;MSAD&apos;.
    APPEND ls_msg TO gt_msag.
  ENDIF.
ENDFORM.

FORM get_additional_html_msad USING ls_msad TYPE s_msad CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM table2tr USING text_msag-label_messages ls_msad-message_texts &apos;T100&apos; &apos;MSGNR|TEXT|SELF_EXPLANATORY&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_msad USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  DATA: ls_msad TYPE s_msad,
        lv_tmp  TYPE string.
  FIELD-SYMBOLS: &lt;fs_long_txt&gt; TYPE s_long_text.

  MOVE-CORRESPONDING is_obj TO ls_msad.
  LOOP AT ls_msad-long_texts ASSIGNING &lt;fs_long_txt&gt;.
    CONCATENATE text_mess-txt_mt_longtext &lt;fs_long_txt&gt;-arbgb &apos; &apos; &lt;fs_long_txt&gt;-msgnr INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_small_title_html USING lv_tmp CHANGING ct_html.
    PERFORM append_docu_html USING &lt;fs_long_txt&gt;-long_text CHANGING ct_html.
  ENDLOOP.
ENDFORM.
***************** Message Class: Definition and All Short Texts Close *****************

***************** Message Class Begin *****************
FORM getdata_msag USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_msad_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_msag USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_additional_html_msad USING is_obj CHANGING ct_html.
ENDFORM.

FORM get_special_html_msag USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_special_html_msad USING is_obj CHANGING ct_html.
ENDFORM.
***************** Message Class Close *****************
***************** Single Message Begin *****************
FORM getdata_mess USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_mess     TYPE s_mess,
        ls_msg_txt  TYPE s_msg_txt,
        lv_len      TYPE i.
  lv_len = strlen( is_obj_header-obj_name ) - 3.
  ls_mess-arbgb = is_obj_header-obj_name(lv_len).
  ls_mess-msgnr = is_obj_header-obj_name+lv_len(3).

  MOVE-CORRESPONDING is_obj_header TO ls_mess.
  SELECT SINGLE text FROM t100 INTO ls_mess-text WHERE sprsl = sy-langu AND arbgb = ls_mess-arbgb AND msgnr = ls_mess-msgnr.
  CHECK sy-subrc EQ 0.

  MOVE-CORRESPONDING ls_mess TO ls_msg_txt.
  PERFORM read_msg_docu USING ls_msg_txt CHANGING ls_mess-self_explanatory ls_mess-long_text.
  APPEND ls_mess TO gt_mess.
ENDFORM.

FORM read_msg_docu USING is_msg_text TYPE s_msg_txt CHANGING cv_self_expl TYPE c ct_lines TYPE t_tline.
  DATA: ls_dokil  TYPE dokil,
        lv_object TYPE dokil-object.

  CLEAR: cv_self_expl, ct_lines.
  cv_self_expl = abap_true.

  CONCATENATE is_msg_text-arbgb is_msg_text-msgnr INTO lv_object.
  SELECT SINGLE * FROM dokil INTO ls_dokil WHERE id = &apos;NA&apos;
    AND object = lv_object AND langu = is_msg_text-sprsl AND typ = &apos;E&apos; AND txtlines GT 0.

  CHECK sy-subrc EQ 0.
  cv_self_expl = abap_false.
  PERFORM read_docu_by_dokil USING ls_dokil CHANGING ct_lines.
ENDFORM.

FORM convert_mess.                                          &quot;#EC CALLED
  DATA: lv_tmp  TYPE string,
        ls_objh TYPE s_obj_header,
        lt_mess TYPE TABLE OF s_mess.
  FIELD-SYMBOLS: &lt;fs_mess&gt; TYPE s_mess.

  CHECK gt_mess IS NOT INITIAL.
  &quot; ignore single messages if they are already included in message class
  DELETE ADJACENT DUPLICATES FROM gt_mess.
  LOOP AT gt_mess ASSIGNING &lt;fs_mess&gt;.
    READ TABLE gt_msad WITH KEY obj_name = &lt;fs_mess&gt;-arbgb TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    READ TABLE gt_msag WITH KEY obj_name = &lt;fs_mess&gt;-arbgb TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    APPEND &lt;fs_mess&gt; TO lt_mess.
  ENDLOOP.

  CHECK lt_mess IS NOT INITIAL.
  ADD 1 TO gv_header_no.
  PERFORM add_header_html USING &apos;MESS&apos; CHANGING gt_html.
  PERFORM add_object_instruction_html USING &apos;MESS&apos; CHANGING gt_html.

  PERFORM table2html USING text_mess-txt_title lt_mess &apos;T100&apos; &apos;ARBGB|MSGNR|TEXT|SELF_EXPLANATORY&apos; abap_false &apos;&apos; CHANGING gt_html.
  LOOP AT lt_mess ASSIGNING &lt;fs_mess&gt;.
    MOVE-CORRESPONDING &lt;fs_mess&gt; TO ls_objh.
    PERFORM add_obj_gen_msg USING ls_objh &apos;S&apos; &apos;&apos;.
  ENDLOOP.

  LOOP AT lt_mess ASSIGNING &lt;fs_mess&gt; WHERE self_explanatory IS INITIAL.
    CONCATENATE text_mess-txt_mt_longtext &lt;fs_mess&gt;-arbgb &apos; &apos; &lt;fs_mess&gt;-msgnr INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_small_title_html USING lv_tmp CHANGING gt_html.
    PERFORM append_docu_html USING &lt;fs_mess&gt;-long_text CHANGING gt_html.
  ENDLOOP.
ENDFORM.
***************** Single Message Close *****************
***************** Transaction Begin *****************
FORM getdata_tran USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tran     TYPE s_tran,
        lv_tcode    TYPE tcode,
        lt_gui_attr TYPE TABLE OF tstcc.

  MOVE-CORRESPONDING is_obj_header TO ls_tran.
  lv_tcode = ls_tran-obj_name.
* basic attributes, gui, param, authority, uiclass, short text
  SELECT SINGLE * FROM tstcv INTO ls_tran-basic_info WHERE tcode = lv_tcode AND sprsl = sy-langu.
* tstcc may not be retrieved from db directly, call RPY_TRANSACTION_READ
  CALL FUNCTION &apos;RPY_TRANSACTION_READ&apos;
    EXPORTING
      transaction      = lv_tcode
    TABLES
      gui_attributes   = lt_gui_attr
    EXCEPTIONS
      permission_error = 1
      cancelled        = 2
      not_found        = 3
      object_not_found = 4
      OTHERS           = 5.                                 &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0.
  READ TABLE lt_gui_attr INTO ls_tran-gui_attributes INDEX 1.
  ls_tran-gui_attributes-s_webgui = boolc( ls_tran-gui_attributes-s_webgui EQ &apos;1&apos; ).

  SELECT SINGLE param FROM tstcp INTO ls_tran-param WHERE tcode = lv_tcode.
  SELECT * FROM tstca INTO TABLE ls_tran-authority WHERE tcode = lv_tcode.
  SELECT SINGLE * FROM tstcclass INTO ls_tran-uiclass WHERE tcode = lv_tcode.
  ls_tran-short_text = ls_tran-basic_info-ttext.
* determine transaction type
  IF ls_tran-basic_info-cinfo EQ &apos;04&apos;.
    ls_tran-transaction_type = c_trans_type-dialog.
  ELSEIF ls_tran-basic_info-cinfo EQ &apos;80&apos;.
    ls_tran-transaction_type = c_trans_type-report.
  ELSEIF ls_tran-basic_info-cinfo EQ &apos;08&apos;.
    ls_tran-transaction_type = c_trans_type-oo.
  ELSEIF ls_tran-basic_info-cinfo EQ &apos;02&apos; AND ls_tran-param IS NOT INITIAL.
    CALL FUNCTION &apos;RS_TRANSACTION_SINGLE_GET&apos;
      EXPORTING
        parameter_tcode = lv_tcode
      IMPORTING
        tcode           = ls_tran-transaction.
    IF ls_tran-transaction IS NOT INITIAL.
      &quot; OO transaction
      IF ls_tran-transaction EQ &apos;OS_APPLICATION&apos;.
        ls_tran-transaction_type = c_trans_type-oo.
        &quot; transaction with variant
      ELSEIF ls_tran-param(2) EQ &apos;@@&apos;.
        ls_tran-transaction_type = c_trans_type-trans_with_variant.
        &quot; transaction with parameter
      ELSEIF ls_tran-param(2) EQ &apos;/*&apos; OR ls_tran-param(2) EQ &apos;/N&apos;.
        ls_tran-transaction_type = c_trans_type-trans_with_param.
      ENDIF.
    ELSEIF ls_tran-param(1) EQ &apos;\&apos;.
      ls_tran-transaction_type = c_trans_type-oo.
    ENDIF.

    PERFORM split_param2table USING ls_tran-param CHANGING ls_tran-param_values.
  ENDIF.

  APPEND ls_tran TO gt_tran.
ENDFORM.

FORM get_additional_html_tran USING ls_tran TYPE s_tran CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: lv_tp_txt      TYPE ddtext,
        lv_html         TYPE string.

  PERFORM get_value_desc USING &apos;TRANSACTION_TYPE&apos; ls_tran-transaction_type CHANGING lv_tp_txt.
  PERFORM get_2column_value_html USING text_tran-label_type lv_tp_txt CHANGING ct_html.
  CASE ls_tran-transaction_type.
    WHEN c_trans_type-dialog.
      PERFORM get_dialog_value_html USING ls_tran CHANGING ct_html.
    WHEN c_trans_type-report.
      PERFORM get_report_value_html USING ls_tran CHANGING ct_html.
    WHEN c_trans_type-oo.
      PERFORM get_oo_value_html USING ls_tran-param ls_tran-param_values CHANGING ct_html.
    WHEN c_trans_type-trans_with_variant.
      PERFORM get_trans_variant_value_html USING ls_tran-param CHANGING ct_html.
    WHEN c_trans_type-trans_with_param.
      PERFORM get_2column_value_html USING text_tran-label_transaction ls_tran-transaction CHANGING ct_html.
      PERFORM get_2column_value_html USING text_tran-label_skip_init_screen &apos;X&apos; CHANGING ct_html.
      PERFORM table2tr USING text_tran-label_default_values ls_tran-param_values &apos;S_TRAN_DEFAULT_VALUE&apos; &apos;SCREEN_FIELD|VALUE&apos; CHANGING ct_html.
  ENDCASE.

  PERFORM get_classfication_html USING ls_tran CHANGING lv_html.
  PERFORM get_2column_right_table_html USING text_tran-label_classification lv_html CHANGING ct_html.
ENDFORM.

FORM split_param2table USING iv_tcode_param TYPE s_tran-param CHANGING ct_param_values TYPE STANDARD TABLE.
  DATA: lv_dummy      TYPE string,
        lv_fld_values TYPE string,
        lt_dfvalue    TYPE TABLE OF string,
        ls_param      TYPE s_tran_default_value,
        lt_param      TYPE TABLE OF s_tran_default_value.
  FIELD-SYMBOLS: &lt;fs_dfvalue&gt; TYPE string.

  CHECK iv_tcode_param IS NOT INITIAL.
  SPLIT iv_tcode_param AT space INTO lv_dummy lv_fld_values.
  SPLIT lv_fld_values AT &apos;;&apos; INTO TABLE lt_dfvalue.
  CHECK lt_dfvalue IS NOT INITIAL.

  LOOP AT lt_dfvalue ASSIGNING &lt;fs_dfvalue&gt;.
    SPLIT &lt;fs_dfvalue&gt; AT &apos;=&apos; INTO ls_param-screen_field ls_param-value.
    APPEND ls_param TO lt_param.
    CLEAR ls_param.
  ENDLOOP.

  CLEAR ct_param_values.
  ct_param_values = lt_param.
ENDFORM.

FORM get_classfication_html USING is_tran TYPE s_tran CHANGING cv_html TYPE string.
  DATA: lt_html TYPE TABLE OF string.

  APPEND gcv_table_begin TO lt_html.
  &quot; TODO: replace hardcoded values
  PERFORM get_2column_value_html USING text_tran-label_inherit_gui &apos;X&apos; CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_prof_user &apos;X&apos; CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_easy_web &apos;&apos;  CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_service  is_tran-gui_attributes-s_service CHANGING lt_html.
  PERFORM get_2column_value_html USING text_tran-label_pervasive is_tran-gui_attributes-s_pervas CHANGING lt_html.
  PERFORM data2rows_common USING is_tran-gui_attributes &apos;TSTCC&apos; &apos;S_WEBGUI|S_PLATIN|S_WIN32&apos; abap_false CHANGING lt_html.
  APPEND gcv_table_end TO lt_html.

  PERFORM join_str USING lt_html CHANGING cv_html.
ENDFORM.

FORM get_dialog_value_html USING is_tran TYPE s_tran CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_value_html4dialog_report USING c_trans_type-dialog is_tran CHANGING ct_html.
ENDFORM.

FORM get_value_html4dialog_report USING iv_trans_type TYPE c is_tran TYPE s_tran CHANGING ct_html TYPE STANDARD TABLE.
  DATA: ls_tstca TYPE tstca.

  PERFORM data2rows USING is_tran-basic_info &apos;TSTC&apos; &apos;PGMNA|DYPNO&apos; CHANGING ct_html.
  IF is_tran-authority IS NOT INITIAL.
    READ TABLE is_tran-authority INTO ls_tstca INDEX 1.
    PERFORM data2rows USING ls_tstca &apos;TSTCA&apos; &apos;OBJCT&apos; CHANGING ct_html.
    PERFORM table2tr USING text_tran-label_auth_values is_tran-authority &apos;TSTCA&apos; &apos;FIELD|VALUE&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_report_value_html USING is_tran TYPE s_tran CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_value_html4dialog_report USING c_trans_type-report is_tran CHANGING ct_html.
ENDFORM.

FORM get_oo_value_html USING iv_param TYPE s_tran-param it_param_values TYPE t_tran_default_value CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lt_html    TYPE TABLE OF string,
        lv_oo_mode TYPE c,
        lv_text    TYPE ddtext.
  FIELD-SYMBOLS: &lt;fs_pv&gt; TYPE s_tran_default_value.

  APPEND gcv_table_begin TO lt_html.
  lv_oo_mode = boolc( iv_param(1) NE &apos;\&apos; ).
  PERFORM get_2column_value_html USING text_tran-label_oo_mode lv_oo_mode CHANGING lt_html.

  LOOP AT it_param_values ASSIGNING &lt;fs_pv&gt;.
    CASE &lt;fs_pv&gt;-screen_field.
      WHEN &apos;CLASS&apos;.
        PERFORM get_2column_value_html USING text_tran-label_oo_clas &lt;fs_pv&gt;-value CHANGING lt_html.
      WHEN &apos;METHOD&apos;.
        PERFORM get_2column_value_html USING text_tran-label_oo_meth &lt;fs_pv&gt;-value CHANGING lt_html.
      WHEN &apos;PROGRAM&apos;.
        PERFORM get_2column_value_html USING text_tran-label_oo_local_prog &lt;fs_pv&gt;-value CHANGING lt_html.
      WHEN &apos;UPDATE_MODE&apos;.
        PERFORM get_value_desc USING &apos;UPDATE_MODE&apos; &lt;fs_pv&gt;-value CHANGING lv_text.
        PERFORM get_2column_value_html USING text_tran-label_oo_update_mode lv_text CHANGING lt_html.
    ENDCASE.
  ENDLOOP.
  APPEND gcv_table_end TO lt_html.
  APPEND LINES OF lt_html TO ct_html.
ENDFORM.

FORM get_trans_variant_value_html USING iv_param TYPE s_tran-param CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tcode TYPE string,
        lv_vari  TYPE string.
  SPLIT iv_param AT space INTO lv_tcode lv_vari.
  SHIFT lv_tcode BY 2 PLACES.

  PERFORM get_2column_value_html USING text_tran-label_transaction lv_tcode CHANGING ct_html.
  PERFORM get_2column_value_html USING text_tran-label_transaction_variant lv_vari CHANGING ct_html.
ENDFORM.
***************** Transaction Close *****************
***************** View Cluster Maintenance: Data Begin *****************
FORM getdata_cdat USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_cdat TYPE s_cdat,
        ls_vcls TYPE s_vcls,
        ls_vdat TYPE s_vdat.

  MOVE-CORRESPONDING is_obj_header TO ls_cdat.
  PERFORM get_vcls_reuse USING is_obj_header CHANGING ls_vcls.
  CHECK sy-subrc EQ 0 AND ls_vcls IS NOT INITIAL.
  ls_cdat-object_stru = ls_vcls-object_stru.

  PERFORM getdata_tabu_reuse USING is_obj_header CHANGING ls_vdat.
  CHECK sy-subrc EQ 0 AND ls_vdat IS NOT INITIAL.
  ls_cdat-primary_keys = ls_vdat-primary_keys.
  ls_cdat-field_info = ls_vdat-field_info.

  APPEND ls_cdat TO gt_cdat.
ENDFORM.

FORM get_special_html_cdat USING is_cdat TYPE s_cdat CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: ls_vdat_ignore TYPE s_vdat_ignore,
        ls_vdat        TYPE s_vdat,
        ls_objheader   TYPE s_obj_header,
        lv_fields      TYPE string,
        lr_data        TYPE REF TO data,
        lv_msg         TYPE string.
  FIELD-SYMBOLS: &lt;fs_obj_stru&gt; TYPE v_vclstruc,
                 &lt;fs_contents&gt; TYPE STANDARD TABLE.

  LOOP AT is_cdat-object_stru ASSIGNING &lt;fs_obj_stru&gt;.
    CLEAR: lr_data, ls_vdat, ls_objheader, lv_fields, ls_vdat_ignore.
    UNASSIGN &lt;fs_contents&gt;.

    CHECK &lt;fs_obj_stru&gt;-object IS NOT INITIAL.
    TRY.
        CREATE DATA lr_data TYPE TABLE OF (&lt;fs_obj_stru&gt;-object).
        ASSIGN lr_data-&gt;* TO &lt;fs_contents&gt;.
      CATCH cx_sy_create_data_error.
        MESSAGE e208(00) WITH &apos;DDIC &apos; &lt;fs_obj_stru&gt;-object &apos; is invalid, please check it.&apos; INTO lv_msg.
        PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
        RETURN.
    ENDTRY.

    PERFORM get_vdat_info_via_cdat USING &lt;fs_obj_stru&gt;-object is_cdat CHANGING ls_vdat.
    PERFORM get_complete_entries USING ls_vdat CHANGING &lt;fs_contents&gt;.
    CHECK &lt;fs_contents&gt; IS NOT INITIAL.

    MOVE-CORRESPONDING ls_vdat TO ls_objheader.
    PERFORM get_maintable_flds USING ls_objheader CHANGING lv_fields.
    CHECK lv_fields IS NOT INITIAL.

    PERFORM get_vcls_node_title USING &lt;fs_obj_stru&gt;-objecttext CHANGING ct_html.
    PERFORM table2html USING &apos;&apos; &lt;fs_contents&gt; ls_vdat-obj_name lv_fields abap_false &apos;&apos; CHANGING ct_html.

    READ TABLE gt_vdat_ignore WITH TABLE KEY obj_name = &lt;fs_obj_stru&gt;-object TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.
    ls_vdat_ignore-vcls_name = is_cdat-obj_name.
    ls_vdat_ignore-obj_name = &lt;fs_obj_stru&gt;-object.
    INSERT ls_vdat_ignore INTO TABLE gt_vdat_ignore.
  ENDLOOP.
ENDFORM.

FORM get_vcls_node_title USING iv_objtext TYPE v_vclstruc-objecttext CHANGING ct_html TYPE t_string.
  DATA: lv_txt  TYPE string.
  CONCATENATE text_tabu-txt_maint_node &apos;&lt;b&gt;&apos; iv_objtext &apos;&lt;/b&gt;&apos; INTO lv_txt RESPECTING BLANKS.
  PERFORM get_paragraph_html USING lv_txt CHANGING ct_html.
ENDFORM.

FORM get_vdat_info_via_cdat USING iv_objname TYPE vim_name is_cdat TYPE s_cdat CHANGING cs_vdat TYPE s_vdat.
  CLEAR cs_vdat.
  TYPES: BEGIN OF s_e071kf_obj,
          objname TYPE tabname,
         END OF s_e071kf_obj.
  DATA: ls_object TYPE s_e071kf_obj,
        lt_object TYPE HASHED TABLE OF s_e071kf_obj WITH UNIQUE KEY objname.
  FIELD-SYMBOLS: &lt;fs_e071k&gt;  TYPE e071k,
                 &lt;fs_e071kf&gt; TYPE e071kf.

  cs_vdat-obj_name = iv_objname.
  LOOP AT is_cdat-primary_keys ASSIGNING &lt;fs_e071k&gt; WHERE objname EQ iv_objname OR viewname EQ iv_objname.
    APPEND &lt;fs_e071k&gt; TO cs_vdat-primary_keys.
    IF &lt;fs_e071k&gt;-viewname IS INITIAL.
      cs_vdat-object = &apos;TABU&apos;.
    ELSE.
      cs_vdat-object = &apos;VDAT&apos;.
    ENDIF.

    READ TABLE lt_object WITH TABLE KEY objname = &lt;fs_e071k&gt;-objname TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    ls_object-objname = &lt;fs_e071k&gt;-objname.
    INSERT ls_object INTO TABLE lt_object.
  ENDLOOP.

  LOOP AT is_cdat-field_info ASSIGNING &lt;fs_e071kf&gt;.
    READ TABLE lt_object WITH TABLE KEY objname = &lt;fs_e071kf&gt;-objname TRANSPORTING NO FIELDS.
    CHECK sy-subrc EQ 0.
    APPEND &lt;fs_e071kf&gt; TO cs_vdat-field_info.
  ENDLOOP.
ENDFORM.
***************** View Cluster Maintenance: Data Close *****************

***************** View Maintenance: Data Begin *****************
FORM getdata_vdat USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_vdat TYPE s_vdat.
  PERFORM getdata_tabu_reuse USING is_obj_header CHANGING ls_vdat.
  CHECK ls_vdat IS NOT INITIAL.
  APPEND ls_vdat TO gt_vdat.
ENDFORM.

FORM getdata_tabu_reuse USING is_obj_header TYPE s_obj_header CHANGING cs_tabu TYPE s_vdat.
* if vdat/tabu has been included in cdat already, then ignore
  READ TABLE gt_vdat_ignore WITH TABLE KEY obj_name = is_obj_header-obj_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  DATA: lv_ddobj TYPE ddobjname,
        lv_rc    TYPE sy-subrc.
  lv_ddobj = is_obj_header-obj_name.

* filter system level data of view cluster/view maintenance/table contents
  IF is_obj_header-object EQ &apos;VDAT&apos;.
    IF is_obj_header-obj_name EQ &apos;V_TVIMF&apos; OR is_obj_header-obj_name EQ &apos;V_TVDIR&apos;.
      PERFORM add_obj_gen_msg USING is_obj_header &apos;W&apos; &apos;&apos;.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;DB_EXISTS_TABLE&apos;
      EXPORTING
        tabname = lv_ddobj
      IMPORTING
        subrc   = lv_rc.
  ELSEIF is_obj_header-object EQ &apos;TABU&apos;.
    IF is_obj_header-obj_name EQ &apos;TDDAT&apos; OR is_obj_header-obj_name EQ &apos;TRESC&apos; OR
          is_obj_header-obj_name EQ &apos;TVDIR&apos; OR is_obj_header-obj_name EQ &apos;TVIMF&apos;.
      PERFORM add_obj_gen_msg USING is_obj_header &apos;W&apos; &apos;&apos;.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;DB_EXISTS_VIEW&apos;
      EXPORTING
        viewname = lv_ddobj
      IMPORTING
        subrc    = lv_rc.
  ELSEIF is_obj_header-object EQ &apos;CDAT&apos;.
    &quot;TODO
  ENDIF.
* check validity of table/view
  sy-subrc = lv_rc.
  PERFORM handle_rc USING is_obj_header.
  CHECK lv_rc EQ 0.

  MOVE-CORRESPONDING is_obj_header TO cs_tabu.
  SELECT * FROM e071k INTO TABLE cs_tabu-primary_keys
    WHERE trkorr IN so_trans AND mastertype EQ cs_tabu-object AND mastername EQ cs_tabu-obj_name.
* only after change request was released key field info will be filled into table e071kf
  SELECT * FROM e071kf INTO TABLE cs_tabu-field_info
    FOR ALL ENTRIES IN cs_tabu-primary_keys
    WHERE trkorr IN so_trans AND objname EQ cs_tabu-primary_keys-objname.
ENDFORM.

FORM convert_vdat.                                          &quot;#EC CALLED
  PERFORM convert_vdat_reuse USING &apos;VDAT&apos; gt_vdat.
ENDFORM.

FORM convert_vdat_reuse USING iv_object TYPE trobjtype it_tab TYPE t_vdat.
  CHECK it_tab IS NOT INITIAL.
  ADD 1 TO gv_header_no.

  DATA: lv_cnt TYPE i.
  FIELD-SYMBOLS: &lt;fs_vdat&gt; TYPE s_vdat.

  lv_cnt = lines( it_tab ).
  PERFORM add_header_html USING iv_object CHANGING gt_html.
  PERFORM add_object_instruction_html USING iv_object CHANGING gt_html.

  LOOP AT it_tab ASSIGNING &lt;fs_vdat&gt;.
    &lt;fs_vdat&gt;-secondary_sort = sy-tabix.
    PERFORM convert_single_vdat2html USING &lt;fs_vdat&gt; lv_cnt CHANGING gt_html.
  ENDLOOP.
ENDFORM.

FORM convert_single_vdat2html USING is_vdat TYPE s_vdat iv_cnt TYPE i CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lr_view_data  TYPE REF TO data,
        lv_fields     TYPE string,
        ls_obj_header TYPE s_obj_header,
        lv_msg        TYPE string.
  FIELD-SYMBOLS: &lt;fs_view_contents&gt; TYPE STANDARD TABLE.

  MOVE-CORRESPONDING is_vdat TO ls_obj_header.
  PERFORM get_maintable_flds USING ls_obj_header CHANGING lv_fields.
  CHECK lv_fields IS NOT INITIAL.

  TRY .
      CREATE DATA lr_view_data TYPE TABLE OF (is_vdat-obj_name).
      ASSIGN lr_view_data-&gt;* TO &lt;fs_view_contents&gt;.
    CATCH cx_sy_create_data_error.
      MESSAGE e208(00) WITH &apos;DDIC &apos; is_vdat-obj_name &apos; is invalid, please check it.&apos; INTO lv_msg.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
      RETURN.
  ENDTRY.

  PERFORM get_complete_entries USING is_vdat CHANGING &lt;fs_view_contents&gt;.
  PERFORM add_title_html USING is_vdat iv_cnt CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; &lt;fs_view_contents&gt; is_vdat-obj_name lv_fields abap_true &apos;&apos; CHANGING ct_html.
  PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
ENDFORM.

FORM get_complete_entries USING is_vdat TYPE s_vdat CHANGING ct_contents TYPE STANDARD TABLE.
  DATA: lr_view_data  TYPE REF TO data,
        lr_table_data TYPE REF TO data,
        lr_view_row   TYPE REF TO data,
        lt_where      TYPE TABLE OF string,
        lt_e071k      TYPE TABLE OF e071k,
        lv_where      TYPE string,
        lv_result     TYPE string,
        lv_msg        TYPE string,
        lv_index      TYPE i.
  FIELD-SYMBOLS: &lt;fs_e071kf&gt;      TYPE e071kf,
                 &lt;fs_e071k&gt;       TYPE e071k,
                 &lt;fs_tab_conts&gt;   TYPE STANDARD TABLE,
                 &lt;fs_tab_cont&gt;    TYPE any,
                 &lt;fs_view_conts&gt;  TYPE STANDARD TABLE,
                 &lt;fs_view_cont&gt;   TYPE any,
                 &lt;fs_value&gt;       TYPE any.

  TRY.
      CREATE DATA lr_view_data TYPE TABLE OF (is_vdat-obj_name).
      ASSIGN lr_view_data-&gt;* TO &lt;fs_view_conts&gt;.
    CATCH cx_sy_create_data_error.
      MESSAGE e208(00) WITH &apos;DDIC &apos; is_vdat-obj_name &apos; is invalid, please check it.&apos; INTO lv_msg.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
      RETURN.
  ENDTRY.

  lt_e071k = is_vdat-primary_keys.
  SORT lt_e071k BY objname ASCENDING.

  LOOP AT lt_e071k ASSIGNING &lt;fs_e071k&gt;.
    IF &lt;fs_tab_conts&gt; IS NOT ASSIGNED.
      TRY.
          CREATE DATA lr_table_data TYPE TABLE OF (&lt;fs_e071k&gt;-objname).
          ASSIGN lr_table_data-&gt;* TO &lt;fs_tab_conts&gt;.
        CATCH cx_sy_create_data_error.
          CLEAR lv_msg.
          MESSAGE e208(00) WITH &apos;DDIC &apos; &lt;fs_e071k&gt;-objname &apos; is invalid, please check it.&apos; INTO lv_msg.
          PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
          RETURN.
      ENDTRY.
    ENDIF.

    &quot; get table contents
    LOOP AT is_vdat-field_info ASSIGNING &lt;fs_e071kf&gt; WHERE objname EQ &lt;fs_e071k&gt;-objname.
      ASSIGN &lt;fs_e071k&gt;-tabkey+&lt;fs_e071kf&gt;-offset(&lt;fs_e071kf&gt;-dblength) TO &lt;fs_value&gt;.
      CHECK &lt;fs_value&gt; IS ASSIGNED AND &lt;fs_value&gt; IS NOT INITIAL.

      IF &lt;fs_e071kf&gt;-exid NE &apos;C&apos;.
        DATA lo_datadescr TYPE REF TO cl_abap_datadescr.
        lo_datadescr ?= cl_abap_typedescr=&gt;describe_by_data( &lt;fs_value&gt; ).
        CHECK lo_datadescr-&gt;type_kind EQ &lt;fs_e071kf&gt;-exid.
        CLEAR lo_datadescr.
      ENDIF.

      CONCATENATE &lt;fs_e071kf&gt;-fieldname &apos; = &apos;&apos;&apos; &lt;fs_value&gt; &apos;&apos;&apos; &apos; INTO lv_where RESPECTING BLANKS.
      APPEND lv_where TO lt_where.
      UNASSIGN &lt;fs_value&gt;.
    ENDLOOP.
    CONCATENATE LINES OF lt_where INTO lv_result SEPARATED BY &apos; AND &apos; RESPECTING BLANKS.

    SELECT * FROM (&lt;fs_e071k&gt;-objname) APPENDING TABLE &lt;fs_tab_conts&gt; WHERE (lv_result).
    CLEAR: lv_where, lt_where, lv_result.

    AT END OF objname.
      ADD 1 TO lv_index.
      &quot; move table contents to view contents(similar as join)
      LOOP AT &lt;fs_tab_conts&gt; ASSIGNING &lt;fs_tab_cont&gt;.
        CREATE DATA lr_view_row TYPE (is_vdat-obj_name).
        ASSIGN lr_view_row-&gt;* TO &lt;fs_view_cont&gt;.

        MOVE-CORRESPONDING &lt;fs_tab_cont&gt; TO &lt;fs_view_cont&gt;.
        &quot; if current table is primary table, then just insert
        IF lv_index LE 1.
          APPEND &lt;fs_view_cont&gt; TO &lt;fs_view_conts&gt;.
        &quot; if primary table contents has been transferred to view contents, then other table contents should be appended as delta
        ELSE.
          MODIFY &lt;fs_view_conts&gt; FROM &lt;fs_view_cont&gt; INDEX sy-tabix.
        ENDIF.

        CLEAR lr_view_row.
        UNASSIGN &lt;fs_view_cont&gt;.
      ENDLOOP.

      CLEAR: lr_table_data.
      UNASSIGN: &lt;fs_tab_conts&gt;, &lt;fs_tab_cont&gt;.
    ENDAT.
  ENDLOOP.

  CLEAR ct_contents.
  ct_contents = &lt;fs_view_conts&gt;.
ENDFORM.

FORM get_maintable_flds USING is_objheader TYPE s_obj_header CHANGING cv_fldnames TYPE string.
  DATA: lv_ddobjname TYPE ddobjname,
        ls_obj_head  TYPE s_obj_header,
        lt_view_fld  TYPE t_view_fields,
        lt_tabl_fld  TYPE dd03ttyp.
  FIELD-SYMBOLS: &lt;fs_view_fld&gt; TYPE dd27p,
                 &lt;fs_tabl_fld&gt; TYPE dd03p.

  CLEAR cv_fldnames.
  lv_ddobjname = is_objheader-obj_name.

  IF is_objheader-object EQ &apos;VDAT&apos;.
    CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
      EXPORTING
        name          = lv_ddobjname
        state         = &apos;A&apos;
      TABLES
        dd27p_tab     = lt_view_fld
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.                                  &quot;#EC FB_RC
    PERFORM handle_rc USING ls_obj_head.
    CHECK sy-subrc EQ 0 AND lt_view_fld IS NOT INITIAL.
    &quot; only those available fields in maintenance view will be fetched
    LOOP AT lt_view_fld ASSIGNING &lt;fs_view_fld&gt; WHERE rdonly IS INITIAL.
      CONCATENATE cv_fldnames &apos;|&apos; &lt;fs_view_fld&gt;-fieldname INTO cv_fldnames.
    ENDLOOP.
    SHIFT cv_fldnames.
  ELSEIF is_objheader-object EQ &apos;TABU&apos;.
    CALL FUNCTION &apos;DDIF_TABL_GET&apos;
      EXPORTING
        name          = lv_ddobjname
        state         = &apos;A&apos;
      TABLES
        dd03p_tab     = lt_tabl_fld
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.                                  &quot;#EC FB_RC
    PERFORM handle_rc USING ls_obj_head.
    CHECK sy-subrc EQ 0 AND lt_tabl_fld IS NOT INITIAL.

    LOOP AT lt_tabl_fld ASSIGNING &lt;fs_tabl_fld&gt;.
      CONCATENATE cv_fldnames &apos;|&apos; &lt;fs_tabl_fld&gt;-fieldname INTO cv_fldnames.
    ENDLOOP.
    SHIFT cv_fldnames.
  ENDIF.
ENDFORM.
***************** View Maintenance: Data Close *****************

***************** Table Contents Begin *****************
FORM getdata_tabu USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tabu TYPE s_tabu.
  PERFORM getdata_tabu_reuse USING is_obj_header CHANGING ls_tabu.
  CHECK ls_tabu IS NOT INITIAL.
  APPEND ls_tabu TO gt_tabu.
ENDFORM.

FORM convert_tabu.                                          &quot;#EC CALLED
  PERFORM convert_vdat_reuse USING &apos;TABU&apos; gt_tabu.
ENDFORM.
***************** Table Contents Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_BUILD" VARCL="X" SUBC="1" APPL="*" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT Build Tool" LENGTH="29 "/>
   </language>
  </textPool>
  <source>*&amp; --------------------------------------------------------------------*
*&amp; YNOT Build Tool:
*&amp; 1.Read main prorgam and includes, then generate All in one program
*&amp;   YNOT_ALL_IN_ONE local for test and export txt file YNOT_ALL_IN_ONE;
*&amp; 2.Export nugg file for package YNOTE_DOCU_GEN, all objects of project
*&amp;   will be included in except package itself, user can import it via ZSAPLINK;
*&amp; 3.For usage, after create the program YNOT via SE38, select menu as below:
*&amp;   Ultilities -&gt; More Ultilities -&gt; Upload/Download -&gt; Upload, then select
*&amp;   the generate file YNOT_ALL_IN_ONE.txt
*&amp; --------------------------------------------------------------------*
REPORT  ynot_build.
CONSTANTS: c_rep_name TYPE c LENGTH 15 VALUE &apos;YNOT_ALL_IN_ONE&apos;.

SELECTION-SCREEN BEGIN OF BLOCK b0 WITH FRAME TITLE g_title.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) c_dir FOR FIELD p_dir.
PARAMETER: p_dir TYPE string DEFAULT &apos;C:\USERS\JOKER\DESKTOP&apos;.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) c_nugg FOR FIELD p_nugg.
PARAMETER: p_nugg TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b0.

INITIALIZATION.
  g_title = &apos;Build YNOT ALL IN ONE&apos;.
  c_dir = &apos;Select Build Folder Path&apos;.
  c_nugg = &apos;Export Nugg File&apos;.

START-OF-SELECTION.
  PERFORM generate_all_in_one.
  CHECK p_nugg EQ abap_true.
  PERFORM build_nugg_file.

FORM generate_all_in_one.
  DATA: lt_result   TYPE TABLE OF string,
        lv_msg      TYPE string,
        lv_wrd      TYPE string,
        ls_textpool TYPE textpool,
        lt_textpool TYPE STANDARD TABLE OF textpool,
        lv_line     TYPE i.

* read YNOT, combine and perform syntax check
  PERFORM read_ynot_all CHANGING lt_result.
  SYNTAX-CHECK FOR lt_result MESSAGE lv_msg LINE lv_line WORD lv_wrd PROGRAM c_rep_name.
  IF sy-subrc NE 0.
    MESSAGE e208(00) WITH lv_msg lv_line lv_wrd.
    RETURN.
  ENDIF.
* generate all in one prorgam and short text
  INSERT REPORT c_rep_name FROM lt_result STATE &apos;A&apos; PROGRAM TYPE &apos;1&apos;.
  ls_textpool-id = &apos;R&apos;.
  CONCATENATE `YNOT: All In One Version Built at ` sy-datum ` ` sy-uzeit INTO ls_textpool-entry RESPECTING BLANKS.
  ls_textpool-length = strlen( ls_textpool-entry ).
  APPEND ls_textpool TO lt_textpool.
  INSERT TEXTPOOL c_rep_name FROM lt_textpool LANGUAGE sy-langu STATE &apos;A&apos;.

  CALL FUNCTION &apos;WB_TREE_ACTUALIZE&apos;
    EXPORTING
      tree_name = c_rep_name.

  DATA lv_obj_name TYPE e071-obj_name.
  lv_obj_name = c_rep_name.

  CALL FUNCTION &apos;RS_TREE_OBJECT_PLACEMENT&apos;
    EXPORTING
      object    = lv_obj_name
      program   = lv_obj_name
      operation = &apos;INSERT&apos;
      type      = &apos;CP&apos;.

  PERFORM download_txt USING lt_result.
ENDFORM.

FORM download_txt USING ct_result TYPE STANDARD TABLE.
* download txt file for release
  DATA: lv_codepage  TYPE cpcodepage,
        lv_cp_dl     TYPE abap_encod,
        lv_filename   TYPE string.
  CONCATENATE p_dir &apos;\&apos; c_rep_name INTO lv_filename RESPECTING BLANKS.

  CALL FUNCTION &apos;SCP_CODEPAGE_BY_EXTERNAL_NAME&apos;
    EXPORTING
      external_name = &apos;UTF-16LE&apos;
      kind          = &apos;H&apos;
    IMPORTING
      sap_codepage  = lv_codepage
    EXCEPTIONS
      not_found     = 1
      OTHERS        = 2.
  IF sy-subrc NE 0.
    lv_codepage = &apos;4013&apos;.
  ENDIF.
  lv_cp_dl = lv_codepage.

  cl_gui_frontend_services=&gt;gui_download(
    EXPORTING
      filename                  =     lv_filename
      confirm_overwrite         =     abap_false
*      codepage                  =     lv_cp_dl
    CHANGING
      data_tab                  =     ct_result
    EXCEPTIONS
      file_write_error          = 1
      no_batch                  = 2
      gui_refuse_filetransfer   = 3
      invalid_type              = 4
      no_authority              = 5
      unknown_error             = 6
      header_not_allowed        = 7
      separator_not_allowed     = 8
      filesize_not_allowed      = 9
      header_too_long           = 10
      dp_error_create           = 11
      dp_error_send             = 12
      dp_error_write            = 13
      unknown_dp_error          = 14
      access_denied             = 15
      dp_out_of_memory          = 16
      disk_full                 = 17
      dp_timeout                = 18
      file_not_found            = 19
      dataprovider_exception    = 20
      control_flush_error       = 21
      not_supported_by_gui      = 22
      error_no_gui              = 23
      OTHERS                     = 24
    ).
ENDFORM.

FORM insert_title.
* currently this routine is useless, to be enhanced in the future
  DATA: ls_dir      TYPE trdir,
        ls_title    TYPE trdirti.

  ls_dir-name = c_rep_name.
  ls_dir-varcl = &apos;X&apos;.
  ls_dir-subc = &apos;1&apos;.
  ls_dir-idate = sy-datum.
  ls_dir-itime = sy-uzeit.
  ls_dir-cnam  = sy-uname.
  ls_dir-cdat  = sy-datum.
  ls_dir-unam  = sy-uname.
  ls_dir-udat  = sy-datum.
  ls_dir-sdate = sy-datum.

  SELECT SINGLE * FROM trdir INTO ls_dir WHERE name = c_rep_name.
  IF sy-subrc NE 0.
    MODIFY trdir FROM ls_dir.
  ENDIF.

  ls_title-name = c_rep_name.
  ls_title-sprsl = sy-langu.
  CONCATENATE &apos;YNOT: All In One Version Built at &apos; sy-datum sy-uzeit INTO ls_title-text RESPECTING BLANKS.
  MODIFY trdirti FROM ls_title.
ENDFORM.

FORM read_ynot_all CHANGING ct_result TYPE STANDARD TABLE.
  DATA: lt_content  TYPE TABLE OF string,
        lt_result   TYPE TABLE OF string,
        lv_len      TYPE i,
        lv_rep_t    TYPE string,
        lv_tmp      TYPE string.
  FIELD-SYMBOLS: &lt;fs_content&gt; TYPE string.

  READ REPORT &apos;YNOT&apos; INTO lt_content.

  LOOP AT lt_content ASSIGNING &lt;fs_content&gt;.
    lv_tmp = &lt;fs_content&gt;.
    CONDENSE lv_tmp NO-GAPS.
    lv_len = strlen( lv_tmp ).

    IF lv_len GE 7.
      TRANSLATE lv_tmp TO UPPER CASE.
      &quot; append include program codes
      IF lv_tmp(7) EQ &apos;INCLUDE&apos;.
        PERFORM get_include_code USING lv_tmp CHANGING lt_result.
        &quot; replace main program name in declaration code
      ELSEIF lv_len GE 10 AND lv_tmp(10) EQ &apos;REPORTYNOT&apos;.
        CONCATENATE &apos;REPORT &apos; c_rep_name &apos;.&apos; INTO lv_rep_t RESPECTING BLANKS.
        APPEND lv_rep_t TO lt_result.
        CLEAR lv_rep_t.
        &quot; replace main program name in comments
      ELSEIF lv_len GE 12 AND lv_tmp(12) EQ &apos;*&amp;REPORTYNOT&apos;.
        CONCATENATE &apos;*&amp; Report &apos; c_rep_name &apos; built as all-in-one program at &apos; sy-datum ` ` sy-uzeit &apos;&apos; INTO lv_rep_t RESPECTING BLANKS.
        APPEND lv_rep_t TO lt_result.
        CLEAR lv_rep_t.
      ELSE.
        APPEND &lt;fs_content&gt; TO lt_result.
      ENDIF.
    ELSE.
      APPEND &lt;fs_content&gt; TO lt_result.
    ENDIF.
  ENDLOOP.

  ct_result = lt_result.
ENDFORM.

FORM get_include_code USING iv_include_code TYPE string CHANGING ct_codes TYPE STANDARD TABLE.
  DATA: lv_end TYPE i,
        lv_inc TYPE programm,
        lt_codes TYPE TABLE OF string.

  FIND &apos;.&apos; IN iv_include_code MATCH OFFSET lv_end.
* offset begins from 0 while for fetch it begins from 1
  ADD -7 TO lv_end.
  lv_inc = iv_include_code+7(lv_end).

  CONDENSE lv_inc NO-GAPS.
  READ REPORT lv_inc INTO lt_codes.
  APPEND LINES OF lt_codes TO ct_codes.
ENDFORM.

FORM build_nugg_file.
  DATA: lt_rsparam  TYPE TABLE OF rsparams,
        ls_rsparam  TYPE rsparams.

  ls_rsparam-selname = &apos;P_DIR&apos;.
  ls_rsparam-low = p_dir.
  ls_rsparam-sign = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  SUBMIT ynot_export_nugg WITH SELECTION-TABLE lt_rsparam AND RETURN.
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_CODE_HELPER" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Code Helper Routines" LENGTH="26 "/>
   </language>
  </textPool>
  <source>***** Generate Code Template For New Object Type Begin ****
FORM initialize_code_template.
  APPEND &apos;TYPES: BEGIN OF s_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;INCLUDE TYPE s_obj_header.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;TYPES: END OF s_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;DATA gt_$OBJECT TYPE TABLE OF s_$OBJECT.  &quot;#EC NEEDED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;***************** $DESC Begin *****************&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;FORM getdata_$OBJECT USING is_obj_header TYPE s_obj_header.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  DATA: ls_$OBJECT TYPE s_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  MOVE-CORRESPONDING is_obj_header TO ls_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  &quot; add data retrive logic here&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  APPEND ls_$OBJECT TO gt_$OBJECT.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT

  APPEND &apos;FORM get_additional_html_$OBJECT USING is_$OBJECT TYPE s_$OBJECT CHANGING ct_html TYPE t_string.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM data2rows USING is_$OBJECT &apos;&apos;S_$OBJECT&apos;&apos; &apos;&apos;${Field names separated by |}&apos;&apos; CHANGING ct_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT

  APPEND &apos;FORM get_special_html_$OBJECT USING is_$OBJECT TYPE s_$OBJECT CHANGING ct_html TYPE t_string.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM table2html USING &apos;&apos;${TITLE}&apos;&apos; is_$OBJECT-{$TABLE} &apos;&apos;${STRUC}&apos;&apos; &apos;&apos;${Field names separated by |}&apos;&apos; abap_false &apos;&apos;&apos;&apos; CHANGING ct_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT

  APPEND &apos;FORM convert_$OBJECT.     &quot;#EC CALLED&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  CHECK gt_$OBJECT IS NOT INITIAL.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  ADD 1 TO gv_header_no.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM add_header_html USING &apos;&apos;$OBJECT&apos;&apos; CHANGING gt_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM add_object_instruction_html USING &apos;&apos;$OBJECT&apos;&apos; CHANGING gt_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;  PERFORM table2html USING &apos;&apos;${TITLE}&apos;&apos; gt_$OBJECT &apos;&apos;S_$OBJECT&apos;&apos; &apos;&apos;${Field names separated by |}&apos;&apos; abap_false &apos;&apos;&apos;&apos; CHANGING gt_html.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;ENDFORM.&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;***************** $DESC Close *****************&apos; TO gt_code_template. &quot;#EC NOTEXT
  APPEND &apos;&apos; TO gt_code_template. &quot;#EC NOTEXT
ENDFORM.

FORM print_template_codes.
  DATA: lv_objtype  TYPE trobjtype,
        lv_tmp      TYPE char255,
        lv_rc       TYPE i,
        lt_code_tab TYPE TABLE OF char255.

  FIELD-SYMBOLS: &lt;fs_ko100&gt; TYPE ko100,
                 &lt;fs_code&gt;  TYPE char255.

  LOOP AT so_objt.
    READ TABLE gt_ko100 WITH KEY object = so_objt-low ASSIGNING &lt;fs_ko100&gt;.
    IF &lt;fs_ko100&gt; IS ASSIGNED.
      lv_objtype = so_objt-low.
      LOOP AT gt_code_template INTO lv_tmp.
        REPLACE ALL OCCURRENCES OF &apos;$OBJECT&apos; IN lv_tmp WITH lv_objtype.
        REPLACE ALL OCCURRENCES OF &apos;$DESC&apos; IN lv_tmp WITH &lt;fs_ko100&gt;-text.
        APPEND lv_tmp TO lt_code_tab.
      ENDLOOP.
    ENDIF.
    UNASSIGN &lt;fs_ko100&gt;.
  ENDLOOP.

  LOOP AT lt_code_tab ASSIGNING &lt;fs_code&gt;.
    IF &lt;fs_code&gt; IS INITIAL.
      SKIP.
    ENDIF.
    WRITE: / &lt;fs_code&gt;.
  ENDLOOP.

  CALL METHOD cl_gui_frontend_services=&gt;clipboard_export
    IMPORTING
      data                 = lt_code_tab
    CHANGING
      rc                   = lv_rc
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4.

  IF sy-subrc EQ 0 AND lv_rc NE -1.
    MESSAGE s208(00) WITH &apos;Generated Codes exported to clip board also.&apos;.
  ENDIF.
ENDFORM.
***** Generate Code Template For New Object Type Close ****</source>
 </PROG>
 <PROG NAME="YNOT_COMMONS" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Common Used Routines" LENGTH="26 "/>
   </language>
  </textPool>
  <source>FORM collect_objects_header_in_tr CHANGING ct_objheaders TYPE STANDARD TABLE.
  CHECK so_trans IS NOT INITIAL.
  CLEAR ct_objheaders.

* since tadir is buffered by primary key, join e071 and tadir to get devclass is not necessary
  SELECT DISTINCT pgmid object obj_name FROM e071              ##too_many_itab_fields
    INTO CORRESPONDING FIELDS OF TABLE ct_objheaders FOR ALL ENTRIES IN gt_objtype_order
* object function marked as deletion is out of scope
    WHERE trkorr IN so_trans AND objfunc NE &apos;D&apos; AND object = gt_objtype_order-object.
ENDFORM.

FORM initialize_buffer.
  PERFORM init_objectype_config.
  PERFORM init_objectype_desc.
  PERFORM init_trans_dir.
  PERFORM init_texts_of_value.
  PERFORM get_user_info.
  CALL METHOD cl_gui_frontend_services=&gt;get_file_separator
    CHANGING
      file_separator       = gv_slash
    EXCEPTIONS
      cntl_error           = 1
      error_no_gui         = 2
      not_supported_by_gui = 3
      OTHERS               = 4.
  IF sy-subrc &lt;&gt; 0.
    gv_slash = &apos;\&apos;.
  ENDIF.
ENDFORM.

FORM add_objectype_config_entry USING iv_object TYPE trobjtype iv_sort_no TYPE i iv_show_basic_attr TYPE abap_bool
                                CHANGING ct_object_config TYPE ht_objtype_order.
  DATA ls_object_config TYPE s_objtype_order.

  ls_object_config-object = iv_object.
  CONDENSE ls_object_config-object NO-GAPS.

  ls_object_config-sort_no = iv_sort_no.
  ls_object_config-show_basic_attr = iv_show_basic_attr.

  READ TABLE gt_objtype_order WITH TABLE KEY object = iv_object TRANSPORTING NO FIELDS.
  IF sy-subrc NE 0.
    INSERT ls_object_config INTO TABLE ct_object_config.
  ENDIF.
ENDFORM.

FORM init_objectype_config.
  PERFORM add_objectype_config_entry USING :  &apos;DEVC&apos; 0010 abap_true  CHANGING gt_objtype_order,
                                              &apos;DEVP&apos; 0020 abap_false CHANGING gt_objtype_order,
                                              &apos;PINF&apos; 0021 abap_false CHANGING gt_objtype_order,
                                              &apos;FUGR&apos; 0030 abap_true  CHANGING gt_objtype_order,
                                              &apos;FUGT&apos; 0040 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOMA&apos; 0050 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOMD&apos; 0051 abap_true  CHANGING gt_objtype_order,
                                              &apos;DTEL&apos; 0060 abap_true  CHANGING gt_objtype_order,
                                              &apos;DTED&apos; 0061 abap_true  CHANGING gt_objtype_order,
                                              &apos;TABL&apos; 0070 abap_true  CHANGING gt_objtype_order,
                                              &apos;TABD&apos; 0080 abap_false CHANGING gt_objtype_order,
                                              &apos;TABT&apos; 0081 abap_false CHANGING gt_objtype_order,
                                              &apos;INDX&apos; 0082 abap_false CHANGING gt_objtype_order,
                                              &apos;VIEW&apos; 0090 abap_true  CHANGING gt_objtype_order,
                                              &apos;VIED&apos; 0091 abap_false CHANGING gt_objtype_order,
                                              &apos;VIET&apos; 0092 abap_false CHANGING gt_objtype_order,
                                              &apos;SHLP&apos; 0100 abap_true  CHANGING gt_objtype_order,
                                              &apos;SHLD&apos; 0101 abap_true  CHANGING gt_objtype_order,
                                              &apos;ENQU&apos; 0110 abap_true  CHANGING gt_objtype_order,
                                              &apos;ENQD&apos; 0111 abap_true  CHANGING gt_objtype_order,
                                              &apos;TTYP&apos; 0120 abap_true  CHANGING gt_objtype_order,
                                              &apos;TTYD&apos; 0121 abap_true  CHANGING gt_objtype_order,
                                              &apos;TOBJ&apos; 0130 abap_true  CHANGING gt_objtype_order,
                                              &apos;VCLS&apos; 0140 abap_true  CHANGING gt_objtype_order,
                                              &apos;NROB&apos; 0150 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOCU&apos; 0160 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOCT&apos; 0161 abap_true  CHANGING gt_objtype_order,
                                              &apos;DOCV&apos; 0162 abap_true  CHANGING gt_objtype_order,
                                              &apos;MSAD&apos; 0170 abap_true  CHANGING gt_objtype_order,
                                              &apos;MSAG&apos; 0180 abap_true  CHANGING gt_objtype_order,
                                              &apos;MESS&apos; 0190 abap_true  CHANGING gt_objtype_order,
                                              &apos;TRAN&apos; 0200 abap_true  CHANGING gt_objtype_order,
                                              &apos;CDAT&apos; 0201 abap_false CHANGING gt_objtype_order,
                                              &apos;VDAT&apos; 0210 abap_false CHANGING gt_objtype_order,
                                              &apos;TABU&apos; 0220 abap_false CHANGING gt_objtype_order.
ENDFORM.

FORM init_objectype_desc.
  DATA: lt_ko100 TYPE TABLE OF ko100.
  FIELD-SYMBOLS &lt;fs_ko100&gt; TYPE ko100.

  CALL FUNCTION &apos;TR_OBJECT_TABLE&apos;
    TABLES
      wt_object_text = lt_ko100.
  MOVE lt_ko100 TO gt_ko100.

  LOOP AT gt_ko100 ASSIGNING &lt;fs_ko100&gt;.
    READ TABLE gt_objtype_order WITH TABLE KEY object = &lt;fs_ko100&gt;-object TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      INSERT &lt;fs_ko100&gt; INTO TABLE gt_objtype_desc.
    ENDIF.
  ENDLOOP.
ENDFORM.

FORM init_trans_dir.
  DATA: lv_trans_dir     TYPE trtppvalue,
        lv_len           TYPE i.

  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos; FIELD &apos;DIR_TRANS&apos; ID &apos;VALUE&apos; FIELD lv_trans_dir.
  lv_len = strlen( lv_trans_dir ).
  gv_trans_dir = lv_trans_dir(lv_len).
ENDFORM.

FORM init_texts_of_value.
  PERFORM add_value_desc USING &apos;DD02L&apos;   &apos;TABCLASS&apos;   &apos;TABCLASS&apos;.
  PERFORM add_value_desc USING &apos;DD02L&apos;   &apos;MAINFLAG&apos;   &apos;MAINFLAG&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos;   &apos;GLOBALFLAG&apos; &apos;GLOBALFLAG&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos;   &apos;VIEWCLASS&apos;  &apos;VIEWCLASS&apos;.
  PERFORM add_value_desc USING &apos;DD25L&apos;   &apos;VIEWGRANT&apos;  &apos;VIEWGRANT&apos;.
  PERFORM add_value_desc USING &apos;DD09L&apos;   &apos;BUFALLOW&apos;   &apos;BUFALLOW&apos;.
  PERFORM add_value_desc USING &apos;DD03P_D&apos; &apos;F_REFTYPE&apos;  &apos;F_REFTYPE&apos;.
  PERFORM manual_add_value_desc.
ENDFORM.

FORM add_value_desc USING iv_tabname TYPE ddobjname iv_fieldname TYPE fieldname iv_lfield_name TYPE dfies-lfieldname.
  DATA: ls_value_desc  TYPE s_value_desc.

  ls_value_desc-fieldname = iv_fieldname.
  CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
    EXPORTING
      tabname      = iv_tabname
      fieldname    = iv_fieldname
      lfieldname   = iv_lfield_name
      langu        = sy-langu
    TABLES
      fixed_values = ls_value_desc-ddfixvalues.

  READ TABLE gt_value_desc WITH TABLE KEY fieldname = iv_fieldname TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  INSERT ls_value_desc INTO TABLE gt_value_desc.
ENDFORM.

FORM manual_add_value_desc.
  DATA: ls_vd TYPE s_value_desc.

  ls_vd-fieldname = &apos;PUFFERUNG&apos;.
  PERFORM add_ddfixvalue USING: &apos;P&apos;  &apos;Single records buff.&apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;G&apos;  &apos;Generic Area Buffered&apos; CHANGING ls_vd-ddfixvalues,
                                &apos;X&apos;  &apos;Fully Buffered&apos;        CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;FRKART&apos;.
  PERFORM add_ddfixvalue USING: &apos;&apos;      &apos;Not Specified&apos;              CHANGING ls_vd-ddfixvalues,
                                &apos;OPT&apos;   &apos;Optional foreign key&apos;       CHANGING ls_vd-ddfixvalues,
                                &apos;OBL&apos;   &apos;Mandatory foreign key&apos;      CHANGING ls_vd-ddfixvalues,
                                &apos;ID&apos;    &apos;Identifying foreign key&apos;    CHANGING ls_vd-ddfixvalues,
                                &apos;TEXT&apos;  &apos;Key fields of a text table&apos; CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;TRANSACTION_TYPE&apos;.
  PERFORM add_ddfixvalue USING: c_trans_type-dialog &apos;Program and screen (dialog transaction)&apos;           CHANGING ls_vd-ddfixvalues,
                                c_trans_type-report &apos;Program and selection screen (report transaction)&apos; CHANGING ls_vd-ddfixvalues,
                                c_trans_type-oo &apos;Method of a class (OO transaction) &apos; CHANGING ls_vd-ddfixvalues,
                                c_trans_type-trans_with_variant &apos;Transaction with variant (variant transaction)&apos;    CHANGING ls_vd-ddfixvalues,
                                c_trans_type-trans_with_param &apos;Transaction with parameters (parameter transaction)&apos; CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;UPDATE_MODE&apos;.
  PERFORM add_ddfixvalue USING: &apos;U&apos; &apos;Asynchronous Update&apos; CHANGING ls_vd-ddfixvalues,
                                &apos;S&apos; &apos;Synchronous Update&apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;L&apos; &apos;LocalUpdate&apos;         CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;VCLS_HIERARCHY&apos;.
  PERFORM add_ddfixvalue USING: &apos;&apos;  &apos;Use in Hierarchy (Popup) &apos;      CHANGING ls_vd-ddfixvalues,
                                &apos;A&apos; &apos;Use in Hierarchy (Mandatory) &apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;X&apos; &apos;Limit to One Step&apos;              CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.

  CLEAR ls_vd.
  ls_vd-fieldname = &apos;MAINT_TYPE&apos;.
  PERFORM add_ddfixvalue USING: &apos;1&apos;  &apos;One Step&apos;  CHANGING ls_vd-ddfixvalues,
                                &apos;2&apos;  &apos;Two Step&apos;  CHANGING ls_vd-ddfixvalues.
  INSERT ls_vd INTO TABLE gt_value_desc.
ENDFORM.

FORM add_ddfixvalue USING iv_value TYPE c iv_text TYPE ddtext CHANGING ct_ddfixvalue TYPE ddfixvalues.
  DATA ls_ddfixvalue TYPE ddfixvalue.
  ls_ddfixvalue-low = iv_value.
  ls_ddfixvalue-ddtext = iv_text.

  APPEND ls_ddfixvalue TO ct_ddfixvalue.
ENDFORM.

FORM get_value_desc USING iv_fieldname TYPE fieldname iv_value TYPE any CHANGING cv_desc TYPE ddtext.
  DATA: ls_value_desc  TYPE s_value_desc,
        lv_low  TYPE ddfixvalue-low.
  FIELD-SYMBOLS: &lt;fs_ddfixvalue&gt; TYPE ddfixvalue.

  CLEAR cv_desc.
  READ TABLE gt_value_desc INTO ls_value_desc WITH TABLE KEY fieldname = iv_fieldname.
  CHECK sy-subrc EQ 0.

  lv_low = iv_value.
  READ TABLE ls_value_desc-ddfixvalues ASSIGNING &lt;fs_ddfixvalue&gt; WITH KEY low = iv_value.
  IF sy-subrc EQ 0 AND &lt;fs_ddfixvalue&gt; IS ASSIGNED.
    cv_desc = &lt;fs_ddfixvalue&gt;-ddtext.
  ENDIF.
ENDFORM.

FORM get_user_info.
  DATA: ls_user_addr  TYPE bapiaddr3,
        lv_len        TYPE i,
        lv_title      TYPE string,
        lt_return_tab TYPE TABLE OF bapiret2.

  CALL FUNCTION &apos;BAPI_USER_GET_DETAIL&apos;
    EXPORTING
      username      = sy-uname
      cache_results = &apos;X&apos;
    IMPORTING
      address       = ls_user_addr
    TABLES
      return        = lt_return_tab.

  IF ls_user_addr-title_p IS NOT INITIAL.
    lv_title = ls_user_addr-title_p.
    CONDENSE lv_title NO-GAPS.
  ENDIF.

  lv_len = strlen( ls_user_addr-fullname ).
  CONCATENATE lv_title &apos; &apos; ls_user_addr-fullname(lv_len) INTO gv_username RESPECTING BLANKS.
ENDFORM.

FORM download_file USING iv_filetype TYPE char10 iv_filename TYPE string CHANGING cv_msg TYPE string ct_tab TYPE STANDARD TABLE .
  cl_gui_frontend_services=&gt;gui_download(
    EXPORTING
      filetype                  = iv_filetype
      filename                  = iv_filename
      confirm_overwrite         = boolc( p_test NE abap_true )
    CHANGING
      data_tab                  = ct_tab
    EXCEPTIONS
      file_write_error          = 1
      no_batch                  = 2
      gui_refuse_filetransfer   = 3
      invalid_type              = 4
      no_authority              = 5
      unknown_error             = 6
      header_not_allowed        = 7
      separator_not_allowed     = 8
      filesize_not_allowed      = 9
      header_too_long           = 10
      dp_error_create           = 11
      dp_error_send             = 12
      dp_error_write            = 13
      unknown_dp_error          = 14
      access_denied             = 15
      dp_out_of_memory          = 16
      disk_full                 = 17
      dp_timeout                = 18
      file_not_found            = 19
      dataprovider_exception    = 20
      control_flush_error       = 21
      not_supported_by_gui      = 22
      error_no_gui              = 23
      OTHERS                    = 24
    ).

  IF sy-subrc NE 0.
    PERFORM get_sys_error_msg CHANGING cv_msg.
    PERFORM append_common_msg USING &apos;E&apos; cv_msg CHANGING gt_sys_msg.
  ENDIF.
ENDFORM.

FORM get_sys_error_msg CHANGING cv_msg TYPE string.
  CLEAR cv_msg.
  IF sy-msgid IS NOT INITIAL AND sy-msgty IS NOT INITIAL AND sy-msgno IS NOT INITIAL.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
  ELSE.
    cv_msg = gcv_text_unexpected_error.                     &quot;#EC NOTEXT
  ENDIF.
ENDFORM.

FORM handle_rc USING is_obj_header TYPE s_obj_header.
  DATA lv_rc TYPE sy-subrc.
  IF sy-subrc NE 0.
    DATA: lv_msgty TYPE sy-msgty,
          lv_msg   TYPE string.

    lv_rc = sy-subrc.
    IF sy-msgid IS NOT INITIAL AND sy-msgty IS NOT INITIAL AND sy-msgno IS NOT INITIAL.
      lv_msgty = sy-msgty.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO lv_msg.
    ELSE.
      lv_msgty = &apos;E&apos;.
      lv_msg = gcv_text_unexpected_error.
    ENDIF.
    PERFORM add_obj_gen_msg USING is_obj_header lv_msgty lv_msg.

    sy-subrc = lv_rc.
  ENDIF.
ENDFORM.

FORM add_obj_gen_msg USING is_obj_header TYPE s_obj_header iv_msgty TYPE sy-msgty iv_msg TYPE string.
  DATA: ls_gen_msg TYPE s_obj_gen_msg,
        lv_desc TYPE string,
        lv_len TYPE i.

  MOVE-CORRESPONDING is_obj_header TO ls_gen_msg.
  ls_gen_msg-msgty = iv_msgty.

  lv_len = strlen( ls_gen_msg-obj_name ).
  PERFORM get_objtype_desc_deep USING is_obj_header CHANGING lv_desc.
  IF iv_msgty EQ &apos;S&apos;.
    CONCATENATE lv_desc &apos; &apos; ls_gen_msg-obj_name(lv_len) &apos; : &apos; text_common-msg_success
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ELSEIF iv_msgty EQ &apos;W&apos;.
    CONCATENATE lv_desc &apos; &apos; ls_gen_msg-obj_name(lv_len) &apos; : &apos; text_common-msg_ignore
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ELSEIF iv_msgty EQ &apos;E&apos;.
    CONCATENATE lv_desc &apos; &apos; ls_gen_msg-obj_name(lv_len) &apos; : &apos; text_common-msg_error
      INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.

    CLEAR ls_gen_msg-msg.
    CONCATENATE &apos;  &apos; text_common-msg_error_msg &apos;: &apos; iv_msg INTO ls_gen_msg-msg RESPECTING BLANKS.
    APPEND ls_gen_msg TO gt_obj_gen_msg.
  ENDIF.
ENDFORM.

FORM display_result.
  DATA: lv_msg TYPE string.
  FIELD-SYMBOLS: &lt;fs_gen_msg&gt; TYPE s_obj_gen_msg,
                 &lt;fs_sys_msg&gt; TYPE s_common_msg.

  IF gt_obj_gen_msg IS INITIAL AND gt_sys_msg IS INITIAL.
    lv_msg = text_common-rep_none.
    REPLACE FIRST OCCURRENCE OF &apos;$USERNAME&apos; IN lv_msg WITH gv_username.
    WRITE: / icon_led_green AS ICON, lv_msg.
  ELSE.
    lv_msg = text_common-rep_docu.
    REPLACE FIRST OCCURRENCE OF &apos;$USERNAME&apos; IN lv_msg WITH gv_username.
    WRITE: / icon_led_green AS ICON, lv_msg.

    LOOP AT gt_obj_gen_msg ASSIGNING &lt;fs_gen_msg&gt;.
      PERFORM print_msg USING &lt;fs_gen_msg&gt;-msgty &lt;fs_gen_msg&gt;-msg.
    ENDLOOP.

    LOOP AT gt_sys_msg ASSIGNING &lt;fs_sys_msg&gt;.
      PERFORM print_msg USING &lt;fs_sys_msg&gt;-msgty &lt;fs_sys_msg&gt;-msg.
    ENDLOOP.

    SKIP.
    WRITE: / icon_information AS ICON, text_common-action_en.
    WRITE: / icon_information AS ICON, text_common-action2_en.
  ENDIF.
  WRITE: / icon_tools AS ICON, text_common-thanks.
ENDFORM.

FORM print_msg USING iv_msgty TYPE sy-msgty iv_msg TYPE string.
  CASE iv_msgty.
    WHEN &apos;E&apos; OR &apos;A&apos; OR &apos;X&apos;.
      WRITE / icon_led_red AS ICON.
    WHEN &apos;W&apos;.
      WRITE / icon_led_yellow AS ICON.
    WHEN OTHERS.
      WRITE / icon_led_green AS ICON.
  ENDCASE.

  WRITE iv_msg.
ENDFORM.

FORM get_activity USING iv_obj_create_date TYPE as4date CHANGING cv_activity TYPE s_obj_header-activity.
  &quot;TODO: it seems not reliable via compare object create/last change date with request create date
  RETURN.

  IF iv_obj_create_date LT gv_tr_date.
    cv_activity = gcv_act_update.
  ELSE.
    cv_activity = gcv_act_create.
  ENDIF.
ENDFORM.

FORM format_numc USING iv_num TYPE n CHANGING cv_oput TYPE string.
  CLEAR cv_oput.
  CALL FUNCTION &apos;CONVERSION_EXIT_ALPHA_OUTPUT&apos;
    EXPORTING
      input  = iv_num
    IMPORTING
      output = cv_oput.
ENDFORM.

FORM collect_tab_fld USING it_tab TYPE STANDARD TABLE iv_fld TYPE fieldname iv_sep TYPE string CHANGING cv_result TYPE string.
  CHECK it_tab IS NOT INITIAL AND iv_fld IS NOT INITIAL.
  CLEAR cv_result.

  FIELD-SYMBOLS: &lt;fs_row&gt; TYPE any,
                 &lt;fs_value&gt; TYPE any.
  LOOP AT it_tab ASSIGNING &lt;fs_row&gt;.
    ASSIGN COMPONENT iv_fld OF STRUCTURE &lt;fs_row&gt; TO &lt;fs_value&gt;.
    CHECK &lt;fs_value&gt; IS ASSIGNED.
    CONCATENATE cv_result iv_sep &lt;fs_value&gt; INTO cv_result RESPECTING BLANKS.
  ENDLOOP.

  IF iv_sep IS NOT INITIAL.
    DATA lv_len TYPE i.
    lv_len = strlen( iv_sep ).
    SHIFT cv_result BY lv_len PLACES.
  ENDIF.
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_CONSTANTS" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Constants" LENGTH="15 "/>
   </language>
  </textPool>
  <source>*&amp;-------------------------Constants/Global Data Definition-------------------------*
CONSTANTS: gcv_act_update TYPE char6 VALUE &apos;Update&apos;,
           gcv_act_create TYPE char6 VALUE &apos;Create&apos;,
* Html template definition, place holder like $XXX will be replaced by content
           gcv_header_html TYPE string VALUE &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                             &apos;&lt;b&gt;&lt;span style=&quot;font-size:20.0pt;line-height:115%&quot;&gt;$HEADER_NO.$OBJECT_DESC&lt;/span&gt;&lt;/b&gt;&apos; &amp;
                                             &apos;&lt;/p&gt;&apos;,
           gcv_title_html  TYPE string VALUE
                                   &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                   &apos;&lt;span style=&quot;font-size:16.0pt;line-height:115%&quot;&gt;$TITLE_NO $ACTIVITY $OBJECT_DESC $OBJ_NAME&lt;/span&gt;&apos; &amp;
                                   &apos;&lt;/p&gt;&apos;,
           gcv_small_title_html  TYPE string VALUE
                                   &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                   &apos;&lt;span style=&quot;font-size:14.0pt;line-height:115%&quot;&gt;$TITLE&lt;/span&gt;&apos; &amp;
                                   &apos;&lt;/p&gt;&apos;,
           gcv_paragraph_html  TYPE string VALUE
                                    &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;$PARAGRAPH&apos; &amp;
                                    &apos;&lt;/p&gt;&apos;,
           gcv_td_label  TYPE string VALUE
                                &apos;&lt;td valign=&quot;top&quot; style=&quot;border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt&quot;&gt;&apos; &amp;
                                  &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;&lt;b&gt;$LABEL&lt;/b&gt;&apos; &amp;
                                  &apos;&lt;/p&gt;&apos; &amp;
                                &apos;&lt;/td&gt;&apos;,
           gcv_td_content TYPE string VALUE
                                &apos;&lt;td valign=&quot;top&quot; style=&quot;border:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt&quot;&gt;&apos; &amp;
                                  &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&apos; &amp;
                                    &apos;$VALUE&apos; &amp;
                                  &apos;&lt;/p&gt;&apos; &amp;
                                &apos;&lt;/td&gt;&apos;,
           gcv_td_inner_table TYPE string VALUE &apos;&lt;td&gt;$VALUE&lt;/td&gt;&apos;,
           gcv_img_content TYPE string VALUE &apos;&lt;p&gt;&lt;img width=600 height=450 src=&quot;$IMAGE.jpg&quot;&gt;&lt;/p&gt;&apos;,  &quot;#EC NEEDED
           gcv_table_begin TYPE string VALUE &apos;&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot; style=&quot;100.0%;border-collapse:collapse;border:none&quot;&gt;&apos;,
           gcv_table_end   TYPE string VALUE &apos;&lt;/table&gt;&apos;.

CONSTANTS: BEGIN OF c_trans_type,
            dialog TYPE c VALUE &apos;1&apos;,
            report TYPE c VALUE &apos;2&apos;,
            oo     TYPE c VALUE &apos;3&apos;,
            trans_with_variant TYPE c VALUE &apos;4&apos;,
            trans_with_param   TYPE c VALUE &apos;5&apos;,
           END OF c_trans_type.</source>
 </PROG>
 <PROG NAME="YNOT_DEVC" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Package Data Retrive &amp; HTML Conversion Routines" LENGTH="53 "/>
   </language>
  </textPool>
  <source>***************** Package Begin *****************
FORM getdata_devc USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_devc_reuse USING is_obj_header.
ENDFORM.

FORM getdata_devc_reuse USING is_obj_header TYPE s_obj_header.
  DATA: lv_devclass     TYPE devclass,
        lo_package      TYPE REF TO if_package,
        lt_permission   TYPE tpak_permission_to_use_list,
        lo_permission   TYPE REF TO if_package_permission_to_use,
        ls_use_access   TYPE permission,
        lt_interface    TYPE tpak_package_interface_list,
        lo_interface    TYPE REF TO if_package_interface,
        ls_interface    TYPE vintf,
        ls_devc         TYPE s_devc.

  IF is_obj_header-object EQ &apos;DEVP&apos;.
    READ TABLE gt_devc WITH KEY obj_name = ls_devc-obj_name TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.
  ENDIF.

  lv_devclass = is_obj_header-obj_name.
  cl_package_factory=&gt;load_package(
    EXPORTING
      i_package_name             = lv_devclass
    IMPORTING
      e_package                  = lo_package
    EXCEPTIONS
      object_not_existing        = 1
      unexpected_error           = 2
      intern_err                 = 3
      no_access                  = 4
      object_locked_and_modified = 5
      OTHERS                     = 6
    ).
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND lo_package IS BOUND.
  MOVE-CORRESPONDING is_obj_header TO ls_devc.
* basic attributes
  ls_devc-devclass = lo_package-&gt;package_name.
  ls_devc-short_text = lo_package-&gt;short_text.
  ls_devc-parentcl = lo_package-&gt;super_package_name.
  ls_devc-dlvunit = lo_package-&gt;software_component.
  ls_devc-applicat = lo_package-&gt;application_component_abbrev.
  ls_devc-project_id = lo_package-&gt;project_id.
  ls_devc-translation_relevance = lo_package-&gt;translation_depth_text.
  ls_devc-mainpack =  lo_package-&gt;main_package.
  ls_devc-korrflag = lo_package-&gt;wbo_korr_flag.
  ls_devc-pdevclass = lo_package-&gt;transport_layer.
  PERFORM get_activity USING lo_package-&gt;created_on CHANGING ls_devc-activity.
* use accesses
  lo_package-&gt;get_permissions_to_use(
    IMPORTING
      e_permissions    = lt_permission
    EXCEPTIONS
      object_invalid   = 1
      unexpected_error = 2
      OTHERS           = 3
    ).
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0.

  LOOP AT lt_permission INTO lo_permission.
    ls_use_access-intf_name = lo_permission-&gt;package_interface_name.
    ls_use_access-client_pak = lo_permission-&gt;publisher_package_name.
    ls_use_access-err_sever = lo_permission-&gt;error_severity.
    APPEND ls_use_access TO ls_devc-use_accesses.
  ENDLOOP.
* interfaces published
  IF is_obj_header-object EQ &apos;DEVC&apos;.
    lo_package-&gt;get_interfaces(
      IMPORTING
        e_package_interfaces = lt_interface
      EXCEPTIONS
        object_invalid       = 1
        unexpected_error     = 2
        intern_err           = 3
        OTHERS               = 4
    ).
    PERFORM handle_rc USING is_obj_header.
    CHECK sy-subrc EQ 0.

    LOOP AT lt_interface INTO lo_interface.
      ls_interface-intf_name = lo_interface-&gt;interface_name.
      ls_interface-descript = lo_interface-&gt;short_text.
      ls_interface-pack_name = lo_interface-&gt;publisher_package_name.
      APPEND ls_interface TO ls_devc-interfaces.
    ENDLOOP.
  ENDIF.

  IF ls_devc-object EQ &apos;DEVC&apos;.
    APPEND ls_devc TO gt_devc.
  ELSEIF ls_devc-object EQ &apos;DEVP&apos;.
    ls_devc-activity = gcv_act_update.
    APPEND ls_devc TO gt_devp.
  ENDIF.
ENDFORM.

FORM get_additional_html_devc USING ls_devc TYPE s_devc CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_devc &apos;S_DEVC&apos; &apos;APPLICAT|TRANSLATION_RELEVANCE|PARENTCL|DLVUNIT|KORRFLAG&apos; CHANGING ct_html.
  PERFORM get_2column_value_html USING text_devc-label_tp_layer text_devc-txt_tp_note CHANGING ct_html.
ENDFORM.

FORM get_special_html_devc USING ls_devc TYPE s_devc CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  IF ls_devc-use_accesses IS NOT INITIAL.
    PERFORM get_small_title_html USING text_devc-title_access CHANGING ct_html.
    PERFORM get_paragraph_html USING text_devc-inst_devp_sub CHANGING ct_html.
    PERFORM table2html USING &apos;&apos; ls_devc-use_accesses &apos;PERMISSION&apos; &apos;INTF_NAME|CLIENT_PAK|ERR_SEVER&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.

  IF ls_devc-interfaces IS NOT INITIAL.
    PERFORM get_small_title_html USING text_devc-title_interface CHANGING ct_html.
    PERFORM get_paragraph_html USING text_devc-inst_pinf_sub CHANGING ct_html.
    PERFORM table2html USING &apos;&apos; ls_devc-interfaces &apos;VINTF&apos; &apos;INTF_NAME|DESCRIPT&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Package Close *****************

***************** Package: Usage Begin *****************
FORM getdata_devp USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_devc_reuse USING is_obj_header.
ENDFORM.

FORM get_special_html_devp USING is_devp TYPE s_devp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_small_title_html USING text_devc-title_access CHANGING ct_html.
  PERFORM get_paragraph_html USING text_devc-inst_devp CHANGING ct_html.
  PERFORM table2html USING &apos;&apos; is_devp-use_accesses &apos;PERMISSION&apos; &apos;INTF_NAME|CLIENT_PAK|ERR_SEVER&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Package: Usage Close *****************

***************** Package: Interface Begin *****************
FORM getdata_pinf USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_pinf TYPE s_pinf.
  MOVE-CORRESPONDING is_obj_header TO ls_pinf.
  SELECT SINGLE * FROM vintf INTO CORRESPONDING FIELDS OF ls_pinf WHERE intf_name = ls_pinf-obj_name AND langu = sy-langu.
* check whether package interface is valid
  CHECK ls_pinf IS NOT INITIAL AND ls_pinf-pack_name IS NOT INITIAL.

  READ TABLE gt_devc WITH KEY obj_name = ls_pinf-pack_name TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  APPEND ls_pinf TO gt_pinf.
ENDFORM.

FORM convert_pinf.                                          &quot;#EC CALLED
  CHECK gt_pinf IS NOT INITIAL.
  SORT gt_pinf BY pack_name ASCENDING.
  ADD 1 TO gv_header_no.
  PERFORM add_header_html USING &apos;PINF&apos; CHANGING gt_html.
  PERFORM add_object_instruction_html USING &apos;PINF&apos; CHANGING gt_html.
  PERFORM table2html USING &apos;&apos; gt_pinf &apos;VINTF&apos; &apos;PACK_NAME|INTF_NAME|DESCRIPT&apos; abap_false &apos;&apos; CHANGING gt_html.
ENDFORM.
***************** Package: Interface Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_DOCU" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Documentation - Data Retrive &amp; HTML Conversion Routines" LENGTH="61 "/>
   </language>
  </textPool>
  <source>***************** Documentation Begin *****************
FORM getdata_docu USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_docu TYPE s_docu,
        lv_docu_name TYPE sobj_name,
        ls_mess_header TYPE s_obj_header,
        ls_dokil TYPE dokil.
  FIELD-SYMBOLS: &lt;fs_objtype_order&gt; TYPE s_objtype_order.

  MOVE-CORRESPONDING is_obj_header TO ls_docu.
  lv_docu_name = ls_docu-obj_name.
  SHIFT lv_docu_name BY 2 PLACES.
  &quot; single message documentation will be transferred to MESS for reusage
  IF ls_docu-obj_name(2) EQ &apos;NA&apos;.
    READ TABLE gt_mess WITH KEY obj_name = lv_docu_name TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    ls_mess_header-pgmid = &apos;LIMU&apos;.
    ls_mess_header-object = &apos;MESS&apos;.
    ls_mess_header-obj_name = lv_docu_name.
    ls_mess_header-activity = gcv_act_create.
    READ TABLE gt_objtype_order ASSIGNING &lt;fs_objtype_order&gt; WITH TABLE KEY object = &apos;MESS&apos;.
    ls_mess_header-primary_sort = &lt;fs_objtype_order&gt;-sort_no.
    PERFORM getdata_mess USING ls_mess_header.
  ELSEIF ls_docu-obj_name(2) EQ &apos;DE&apos;.
    READ TABLE gt_dtel WITH KEY obj_name = lv_docu_name TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    ls_docu-obj_name = lv_docu_name.
    SELECT SINGLE * FROM dokil INTO ls_dokil WHERE id = &apos;DE&apos;
      AND object = ls_docu-obj_name AND langu = sy-langu AND typ = &apos;E&apos;.
    PERFORM read_docu_by_dokil USING ls_dokil CHANGING ls_docu-long_text.
    CHECK ls_docu-long_text IS NOT INITIAL.
    APPEND ls_docu TO gt_docu.
  ENDIF.
ENDFORM.

FORM convert_docu.                                          &quot;#EC CALLED
  DATA: ls_obj_header TYPE s_obj_header,
        lv_cnt TYPE i.
  FIELD-SYMBOLS: &lt;fs_docu&gt; TYPE s_docu.

  CHECK gt_docu IS NOT INITIAL.

  ADD 1 TO gv_header_no.
  lv_cnt = lines( gt_docu ).
  PERFORM add_header_html USING &apos;DOCU&apos; CHANGING gt_html.
  &quot; only data element documentation will be handled
  LOOP AT gt_docu ASSIGNING &lt;fs_docu&gt;.
    &lt;fs_docu&gt;-secondary_sort = sy-tabix.
    PERFORM add_title_html USING &lt;fs_docu&gt; lv_cnt CHANGING gt_html.
    PERFORM append_docu_html USING &lt;fs_docu&gt;-long_text CHANGING gt_html.

    MOVE-CORRESPONDING &lt;fs_docu&gt; TO ls_obj_header.
    PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
  ENDLOOP.
ENDFORM.
***************** Documentation Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_DOMA" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Domain - Data Retrive &amp; HTML Conversion Routines" LENGTH="54 "/>
   </language>
  </textPool>
  <source>***************** Domain Begin *****************
FORM getdata_doma USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_doma_reuse USING is_obj_header.
ENDFORM.

FORM getdata_doma_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_doma        TYPE s_doma,
        lv_dm_name     TYPE ddobjname,
        ls_dd01v       TYPE dd01v.
  lv_dm_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
    EXPORTING
      name          = lv_dm_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd01v_wa      = ls_dd01v
    TABLES
      dd07v_tab     = ls_doma-value_range
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd01v IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_doma.
  MOVE-CORRESPONDING ls_dd01v TO ls_doma.
  PERFORM get_activity USING ls_dd01v-as4date CHANGING ls_doma-activity.
  ls_doma-short_text = ls_dd01v-ddtext.

  IF ls_doma-object EQ &apos;DOMA&apos;.
    APPEND ls_doma TO gt_doma.
  ELSEIF ls_doma-object EQ &apos;DOMD&apos;.
    ls_doma-activity = gcv_act_update.
    APPEND ls_doma TO gt_doma.
  ENDIF.
ENDFORM.

FORM get_additional_html_doma USING is_doma TYPE s_doma CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING is_doma &apos;S_DOMA&apos; &apos;DATATYPE|LENG|OUTPUTLEN|DECIMALS|LOWERCASE|SIGNFLAG|ENTITYTAB&apos; CHANGING ct_html.
  IF is_doma-valexi EQ abap_true.
    PERFORM table2tr USING text_doma-label_value_range is_doma-value_range &apos;DD07V&apos; &apos;DOMVALUE_L|DDTEXT&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Domain Close *****************

***************** Domain Definition: Begin *****************
FORM getdata_domd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_doma_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_domd USING is_domd TYPE s_domd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM data2rows USING is_domd &apos;S_DOMA&apos; &apos;DATATYPE|LENG|OUTPUTLEN|DECIMALS|LOWERCASE|SIGNFLAG|ENTITYTAB&apos; CHANGING ct_html.
  IF is_domd-valexi EQ abap_true.
    PERFORM table2tr USING text_doma-label_value_range is_domd-value_range &apos;DD07V&apos; &apos;DOMVALUE_L|DDTEXT&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Domain Definition: Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_DTEL" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Data Element - Data Retrive &amp; HTML Conversion Routines" LENGTH="60 "/>
   </language>
  </textPool>
  <source>***************** Data Element Begin *****************
FORM getdata_dtel USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_dtel_reuse USING is_obj_header.
ENDFORM.

FORM getdata_dtel_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_dtel    TYPE s_dtel,
        lv_de_name TYPE ddobjname,
        ls_dd04v   TYPE dd04v.

  lv_de_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
    EXPORTING
      name          = lv_de_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd04v_wa      = ls_dd04v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd04v IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_dtel.
  MOVE-CORRESPONDING ls_dd04v TO ls_dtel.
  PERFORM get_activity USING ls_dd04v-as4date CHANGING ls_dtel-activity.
  ls_dtel-short_text = ls_dd04v-ddtext.

  IF ls_dtel-object EQ &apos;DTEL&apos;.
    APPEND ls_dtel TO gt_dtel.
  ELSE.
    ls_dtel-activity = gcv_act_update.
    APPEND ls_dtel TO gt_dted.
  ENDIF.
ENDFORM.

FORM get_additional_html_dtel USING ls_dtel TYPE s_dtel CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: lv_tr   TYPE string,
        lv_td1  TYPE string,
        lv_td2  TYPE string,
        lv_td3  TYPE string,
        lv_tmp  TYPE string,
        lv_numc TYPE string,
        lt_tab  TYPE TABLE OF string,
        lv_labels  TYPE string.

  IF ls_dtel-domname IS NOT INITIAL.
    PERFORM get_2column_value_html USING text_dtel-label_domain ls_dtel-domname  CHANGING ct_html.
  ELSE.
    PERFORM format_numc USING ls_dtel-leng CHANGING lv_numc.
    CONCATENATE text_dtel-label_domain &apos;: &apos; ls_dtel-datatype &apos;&lt;br&gt;&apos; text_dtel-label_length &apos;: &apos; lv_numc INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_2column_value_html USING text_dtel-label_predf_type lv_tmp CHANGING ct_html.
  ENDIF.
  PERFORM get_column_value_html USING text_dtel-label_fld_lab CHANGING lv_td1.
  CONCATENATE &apos;&lt;tr&gt;&apos; lv_td1 &apos;&lt;td&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  APPEND gcv_table_begin TO lt_tab.
  CONCATENATE &apos; |&apos; text_dtel-label_length &apos;|&apos; text_dtel-label_fld_lab INTO lv_labels RESPECTING BLANKS.
  PERFORM get_tr_label_html USING lv_labels CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_short CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen1 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_s CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_medium CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen2 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_m CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_long CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-scrlen3 CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-scrtext_l CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  PERFORM get_column_value_html USING text_dtel-label_heading CHANGING lv_td1.
  PERFORM get_column_value_html USING ls_dtel-headlen CHANGING lv_td2.
  PERFORM get_column_value_html USING ls_dtel-reptext CHANGING lv_td3.
  PERFORM combine3td USING lv_td1 lv_td2 lv_td3 CHANGING lt_tab.

  APPEND gcv_table_end TO lt_tab.
  PERFORM join_str USING lt_tab CHANGING lv_tmp.
  CONCATENATE lv_tr lv_tmp &apos;&lt;/td&gt;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
ENDFORM.

FORM get_special_html_dtel USING ls_dtel TYPE s_dtel CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  DATA: ls_dokil TYPE dokil,
        lt_lines TYPE t_tline.

  SELECT SINGLE * FROM dokil INTO ls_dokil WHERE id = &apos;DE&apos;
    AND object = ls_dtel-obj_name AND langu = sy-langu AND typ = &apos;E&apos;.
  PERFORM read_docu_by_dokil USING ls_dokil CHANGING lt_lines.
  CHECK lt_lines IS NOT INITIAL.

  PERFORM get_small_title_html USING text_dtel-txt_mt_docu_title CHANGING ct_html.
  PERFORM get_paragraph_html USING text_dtel-txt_mt_docu_para CHANGING ct_html.
  PERFORM append_docu_html USING lt_lines CHANGING ct_html.
ENDFORM.

FORM read_docu_by_dokil USING is_dokil TYPE dokil CHANGING ct_lines TYPE t_tline.
  CHECK is_dokil IS NOT INITIAL.

  CALL FUNCTION &apos;DOCU_READ&apos;
    EXPORTING
      id      = is_dokil-id
      langu   = is_dokil-langu
      object  = is_dokil-object
      typ     = is_dokil-typ
      version = is_dokil-version
    TABLES
      line    = ct_lines.
ENDFORM.

FORM append_docu_html USING it_lines TYPE t_tline CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM table2html USING &apos;&apos; it_lines &apos;TLINE&apos; &apos;TDFORMAT|TDLINE&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Data Element Close *****************

***************** Data Element Definition Begin *****************
FORM getdata_dted USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_dtel_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_dted USING is_dted TYPE s_dted CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_dtel USING is_dted CHANGING ct_html.
ENDFORM.

FORM get_special_html_dted USING is_dted TYPE s_dted CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_special_html_dtel USING is_dted CHANGING ct_html.
ENDFORM.
***************** Data Element Definition Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_ENQU" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Lock Object - Data Retrive &amp; HTML Conversion Routines" LENGTH="59 "/>
   </language>
  </textPool>
  <source>***************** Lock Object Begin *****************
FORM getdata_enqu USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_enqu_reuse USING is_obj_header.
ENDFORM.

FORM getdata_enqu_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_enqu TYPE s_enqu,
        ls_dd25v     TYPE dd25v,
        lt_dd27p     TYPE TABLE OF dd27p,
        lv_lock_name TYPE ddobjname.

  lv_lock_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
    EXPORTING
      name          = lv_lock_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd25v_wa      = ls_dd25v            &quot;lock object attributes(similar as that of view)
    TABLES
      dd26e_tab     = ls_enqu-base_tables &quot;base tables
      dd27p_tab     = lt_dd27p            &quot;view fields
      ddena_tab     = ls_enqu-lock_params &quot;lock argument fields
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd25v IS NOT INITIAL.
  MOVE-CORRESPONDING is_obj_header TO ls_enqu.
  ls_enqu-short_text = ls_dd25v-ddtext.
  PERFORM get_activity USING ls_dd25v-as4date CHANGING ls_enqu-activity.

  IF ls_enqu-object EQ &apos;ENQU&apos;.
    APPEND ls_enqu TO gt_enqu.
  ELSEIF ls_enqu-object EQ &apos;ENQD&apos;.
    ls_enqu-activity = gcv_act_update.
    APPEND ls_enqu TO gt_enqd.
  ENDIF.
ENDFORM.

FORM get_additional_html_enqu USING ls_enqu TYPE s_enqu CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_2column_value_html USING text_enqu-label_allow_rfc ls_enqu-rfcenable CHANGING ct_html.
ENDFORM.

FORM get_special_html_enqu USING is_enqu TYPE s_enqu CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM table2html USING text_enqu-label_tables is_enqu-base_tables &apos;DD26E&apos; &apos;TABPOS|TABNAME|ENQMODE&apos; abap_false &apos;&apos; CHANGING ct_html.
  PERFORM table2html USING text_enqu-label_params is_enqu-lock_params &apos;DDENA&apos; &apos;VIEWFIELD|TABNAME|FIELDNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Lock Object Close *****************

***************** Lock Object Definition Begin *****************
FORM getdata_enqd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_enqu_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_enqd USING is_enqd TYPE s_enqd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_enqu USING is_enqd CHANGING ct_html.
ENDFORM.

FORM get_special_html_enqd USING is_enqd TYPE s_enqd CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_special_html_enqu USING is_enqd CHANGING ct_html.
ENDFORM.
***************** Lock Object Definition Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_EXPORT_NUGG" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT Nugg File Export Via/For ZSAPLINK" LENGTH="43 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  YNOT_EXPORT_NUGG
*&amp;---------------------------------------------------------------------*
*&amp; build nugg file via zsaplink
*&amp; integrated to release process
*&amp;---------------------------------------------------------------------*
REPORT  ynot_export_nugg.
CONSTANTS: c_nugg_name TYPE rsparams-low VALUE &apos;YNOT&apos;,
           c_ynot_pack TYPE rsparams-low VALUE &apos;YNOTE_DOCU_GEN&apos;.

SELECTION-SCREEN BEGIN OF BLOCK b0 WITH FRAME TITLE g_title.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(35) c_dir FOR FIELD p_dir.
PARAMETER: p_dir TYPE string DEFAULT &apos;C:\USERS\JOKER\DESKTOP&apos;.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b0.

INITIALIZATION.
  g_title = &apos;Build YNOT Nugg File&apos;.
  c_dir = &apos;Select Build Folder Path&apos;.

START-OF-SELECTION.
  PERFORM create_nugg_file.
  PERFORM add_objects_into_nugg_file.

FORM create_nugg_file.
  DATA: lt_rsparam  TYPE TABLE OF rsparams,
        ls_rsparam  TYPE rsparams.
* import nugget was chosen defautly, reset it
  ls_rsparam-selname = &apos;NUGI&apos;.
  ls_rsparam-low = &apos;&apos;.
  ls_rsparam-SIGN = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  ls_rsparam-selname = &apos;NUGC&apos;.
  ls_rsparam-low = &apos;X&apos;.
  ls_rsparam-sign = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  ls_rsparam-selname = &apos;NUGGNAM&apos;.
  ls_rsparam-low = c_nugg_name.
  ls_rsparam-sign = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  SUBMIT zsaplink WITH SELECTION-TABLE lt_rsparam AND RETURN.
ENDFORM.

FORM add_objects_into_nugg_file.
  DATA: lt_rsparam  TYPE TABLE OF rsparams,
        ls_rsparam  TYPE rsparams.
* import nugget was chosen defautly, reset it
  ls_rsparam-selname = &apos;NUGI&apos;.
  ls_rsparam-low = &apos;&apos;.
  ls_rsparam-SIGN = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  ls_rsparam-selname = &apos;NUGP&apos;.
  ls_rsparam-low = &apos;X&apos;.
  ls_rsparam-sign = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  ls_rsparam-selname = &apos;PACKAGE&apos;.
  ls_rsparam-low = c_ynot_pack.
  ls_rsparam-SIGN = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  ls_rsparam-selname = &apos;NUGFILE&apos;.
  CONCATENATE p_dir &apos;\NUGG_YNOT.nugg&apos; INTO ls_rsparam-low RESPECTING BLANKS.
  ls_rsparam-SIGN = &apos;I&apos;.
  ls_rsparam-option = &apos;EQ&apos;.
  APPEND ls_rsparam TO lt_rsparam.
  CLEAR ls_rsparam.

  SUBMIT zsaplink WITH SELECTION-TABLE lt_rsparam AND RETURN.
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_EXPORT_TR" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Export Transport Files" LENGTH="53 "/>
   </language>
  </textPool>
  <source>FORM export_transport_files.
  DATA: lv_zip TYPE xstring,
        lt_str TYPE solix_tab,
        lv_msg TYPE string,
        lv_err_cnt     TYPE i,
        lv_zipfilename TYPE string.

  IF go_zip IS NOT BOUND.
    CREATE OBJECT go_zip.
  ENDIF.

  LOOP AT so_trans.
    PERFORM add_single_transport USING so_trans-low CHANGING lv_msg.
    IF lv_msg IS NOT INITIAL.
      PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
      ADD 1 TO lv_err_cnt.
    ENDIF.
    CONCATENATE lv_zipfilename &apos;_&apos; so_trans-low INTO lv_zipfilename.
  ENDLOOP.

  IF lv_err_cnt GT 0.
    RETURN.
  ENDIF.
  SHIFT lv_zipfilename.
  CONCATENATE p_dir gv_slash lv_zipfilename &apos;.zip&apos; INTO lv_zipfilename RESPECTING BLANKS.

  lv_zip = go_zip-&gt;save( ).
  lt_str = cl_bcs_convert=&gt;xstring_to_solix( iv_xstring  = lv_zip ).
  PERFORM download_file USING &apos;BIN&apos; lv_zipfilename CHANGING lv_msg lt_str.
  IF lv_msg IS NOT INITIAL.
    PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
  ENDIF.
ENDFORM.

FORM add_single_transport USING iv_tr TYPE e070-trkorr CHANGING cv_msg TYPE string.
  DATA: server_file_k TYPE rlgrap-filename,
        server_file_r TYPE rlgrap-filename,
        lv_tr_no      TYPE e070-trkorr,
        lv_filename   TYPE string,
        lv_slah       TYPE c.

  CLEAR cv_msg.
  lv_slah = gv_trans_dir(1).
  lv_tr_no = iv_tr.
  SHIFT lv_tr_no BY 4 PLACES LEFT.

  &quot; SI3K017810-&gt; K017810.SI3 &amp; R017810.SI3
  CONCATENATE &apos;K&apos; lv_tr_no &apos;.&apos; so_trans-low(3) INTO lv_filename.
  CONCATENATE gv_trans_dir lv_slah &apos;cofiles&apos; lv_slah  lv_filename INTO server_file_k. &quot;#EC NOTEXT
  PERFORM add2zip USING lv_filename server_file_k CHANGING cv_msg.
  CLEAR lv_filename.
  IF cv_msg IS NOT INITIAL.
    EXIT.
  ENDIF.

  CONCATENATE &apos;R&apos; lv_tr_no &apos;.&apos; so_trans-low(3) INTO lv_filename.
  CONCATENATE gv_trans_dir lv_slah &apos;data&apos; lv_slah lv_filename INTO server_file_r. &quot;#EC NOTEXT
  PERFORM add2zip USING lv_filename server_file_r CHANGING cv_msg.
  IF cv_msg IS NOT INITIAL.
    RETURN.
  ENDIF.
ENDFORM.

FORM add2zip USING iv_filename TYPE string iv_server_file TYPE rlgrap-filename CHANGING cv_msg TYPE string.
  DATA: l_data     TYPE STANDARD TABLE OF tbl1024,
        l_size     TYPE i,
        lv_xstr    TYPE xstring.

  CALL FUNCTION &apos;SCMS_UPLOAD&apos;
    EXPORTING
      filename = iv_server_file
      binary   = &apos;X&apos;
      frontend = &apos; &apos;
    IMPORTING
      filesize = l_size
    TABLES
      data     = l_data
    EXCEPTIONS
      error    = 1
      OTHERS   = 2.
  IF sy-subrc NE 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO cv_msg.
    PERFORM append_common_msg USING &apos;E&apos; cv_msg CHANGING gt_sys_msg.
    RETURN.
  ENDIF.

  CALL FUNCTION &apos;SCMS_BINARY_TO_XSTRING&apos;
    EXPORTING
      input_length = l_size
    IMPORTING
      buffer       = lv_xstr
    TABLES
      binary_tab   = l_data
    EXCEPTIONS
      failed       = 1
      OTHERS       = 2.

  go_zip-&gt;add( name = iv_filename content = lv_xstr ).
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_FUGR" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Function Group - Data Retrive &amp; HTML Conversion Routines" LENGTH="62 "/>
   </language>
  </textPool>
  <source>***************** Function Group Begin *****************
FORM getdata_fugr USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_fugr TYPE s_fugr.

  MOVE-CORRESPONDING is_obj_header TO ls_fugr.
  SELECT SINGLE areat FROM tlibt INTO ls_fugr-short_text WHERE spras = sy-langu AND area = ls_fugr-obj_name.
  CHECK sy-subrc EQ 0.
  APPEND ls_fugr TO gt_fugr.
ENDFORM.
***************** Function Group Close *****************

***************** Function Group(Texts) Begin *****************
FORM getdata_fugt USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_fugt TYPE s_fugt.

  MOVE-CORRESPONDING is_obj_header TO ls_fugt.
  SELECT SINGLE areat FROM tlibt INTO ls_fugt-short_text WHERE spras = sy-langu AND area = ls_fugt-obj_name.
  CHECK sy-subrc EQ 0.
  ls_fugt-activity = gcv_act_update.
  APPEND ls_fugt TO gt_fugt.
ENDFORM.
***************** Function Group(Texts) Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_GLOBAL_DATA" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Global Data Definition" LENGTH="28 "/>
   </language>
  </textPool>
  <source>DATA: gt_ko100         TYPE HASHED TABLE OF ko100 WITH UNIQUE KEY object,
      gt_objtype_desc  TYPE HASHED TABLE OF ko100 WITH UNIQUE KEY object,
      gt_objtype_order TYPE ht_objtype_order,
      gt_value_desc    TYPE HASHED TABLE OF s_value_desc WITH UNIQUE KEY fieldname,
      gv_trans_dir     TYPE string,
      &quot; global internal data table for each kind of object, name convention: gt_{objtype}
      gt_devc TYPE TABLE OF s_devc,                         &quot;#EC NEEDED
      gt_devp TYPE TABLE OF s_devp,                         &quot;#EC NEEDED
      gt_pinf TYPE TABLE OF s_pinf,                         &quot;#EC NEEDED
      gt_fugr TYPE TABLE OF s_fugr,                         &quot;#EC NEEDED
      gt_fugt TYPE TABLE OF s_fugt,                         &quot;#EC NEEDED
      gt_doma TYPE TABLE OF s_doma,                         &quot;#EC NEEDED
      gt_domd TYPE TABLE OF s_domd,                         &quot;#EC NEEDED
      gt_dtel TYPE TABLE OF s_dtel,                         &quot;#EC NEEDED
      gt_dted TYPE TABLE OF s_dted,                         &quot;#EC NEEDED
      gt_tabl TYPE TABLE OF s_tabl,                         &quot;#EC NEEDED
      gt_tabd TYPE TABLE OF s_tabd,                         &quot;#EC NEEDED
      gt_view TYPE TABLE OF s_view,                         &quot;#EC NEEDED
      gt_vied TYPE TABLE OF s_vied,                         &quot;#EC NEEDED
      gt_vcls TYPE TABLE OF s_vcls,                         &quot;#EC NEEDED
      gt_tobj TYPE TABLE OF s_tobj,                         &quot;#EC NEEDED
      gt_shlp TYPE TABLE OF s_shlp,                         &quot;#EC NEEDED
      gt_shld TYPE TABLE OF s_shld,                         &quot;#EC NEEDED
      gt_enqu TYPE TABLE OF s_enqu,                         &quot;#EC NEEDED
      gt_enqd TYPE TABLE OF s_enqd,                         &quot;#EC NEEDED
      gt_ttyp TYPE TABLE OF s_ttyp,                         &quot;#EC NEEDED
      gt_ttyd TYPE TABLE OF s_ttyd,                         &quot;#EC NEEDED
      gt_nrob TYPE TABLE OF s_nrob,                         &quot;#EC NEEDED
      gt_msad TYPE TABLE OF s_msad,                         &quot;#EC NEEDED
      gt_msag TYPE TABLE OF s_msag,                         &quot;#EC NEEDED
      gt_mess TYPE TABLE OF s_mess,                         &quot;#EC NEEDED
      gt_docu TYPE TABLE OF s_docu,                         &quot;#EC NEEDED
      gt_tran TYPE TABLE OF s_tran,                         &quot;#EC NEEDED
      gt_cdat TYPE TABLE OF s_cdat,                         &quot;#EC NEEDED
      gt_vdat TYPE t_vdat,                                  &quot;#EC NEEDED
      gt_tabu TYPE t_vdat,                                  &quot;#EC NEEDED

      gt_vdat_ignore   TYPE HASHED TABLE OF s_vdat_ignore WITH UNIQUE KEY obj_name,
      gv_tr_date       TYPE as4date,
      gv_header_no     TYPE numc2,
      &quot; screen shot folder, however currently this feature is not available
      gv_img_folder    TYPE string,                         &quot;#EC NEEDED
      gt_object_instruction TYPE ht_object_instruction,
      gt_html          TYPE TABLE OF string,
      gt_html_all      TYPE TABLE OF string,
      &quot; template code: a helper when add support for new object types
      gt_code_template TYPE TABLE OF char255,
      gt_objtype2codes TYPE TABLE OF trobjtype,
      gt_obj_gen_msg   TYPE TABLE OF s_obj_gen_msg,
      gt_sys_msg       TYPE TABLE OF s_common_msg,
      gv_username      TYPE string,
      go_zip           TYPE REF TO cl_abap_zip,
      gv_slash         TYPE c.

DATA: gcv_text_unexpected_error TYPE string,
      BEGIN OF text_common,
        label_col_attr  TYPE string,
        label_col_value TYPE string,
        title_tobj      TYPE string,
        txt_notice      TYPE string,
        title_html      TYPE string,
        msg_success     TYPE string,
        msg_ignore      TYPE string,
        msg_error       TYPE string,
        msg_error_msg   TYPE string,
        rep_none        TYPE string,
        rep_docu        TYPE string,
        action_en       TYPE string,
        action2_en      TYPE string,
        action_de       TYPE string,
        thanks          TYPE string,
        time_cost       TYPE string,
      END OF text_common,
      BEGIN OF text_devc,
        label_tp_layer    TYPE string,
        txt_tp_note       TYPE string,
        title_access      TYPE string,
        title_interface   TYPE string,
        inst_devc         TYPE string,
        inst_devp         TYPE string,
        inst_devp_sub     TYPE string,
        inst_pinf         TYPE string,
        inst_pinf_sub     TYPE string,
      END OF text_devc,
      BEGIN OF text_fugr,
        inst_fugr TYPE string,
        inst_fugt TYPE string,
      END OF text_fugr,
      BEGIN OF text_doma,
        label_value_range TYPE string,
        inst_doma         TYPE string,
        inst_domd         TYPE string,
      END OF text_doma,
      BEGIN OF text_dtel,
        label_domain     TYPE string,
        label_data_type  TYPE string,
        label_predf_type TYPE string,
        label_fld_lab    TYPE string,
        label_length     TYPE string,
        label_short      TYPE string,
        label_medium     TYPE string,
        label_long       TYPE string,
        label_heading    TYPE string,
        txt_mt_docu_title TYPE string,
        txt_mt_docu_para  TYPE string,
        inst_dtel         TYPE string,
        inst_dted         TYPE string,
      END OF text_dtel,
      BEGIN OF text_tabl,
        title_tech  TYPE string,
        title_flds  TYPE string,
        title_comps TYPE string,
        title_fks   TYPE string,
        title_namespace TYPE string,
        title_index     TYPE string,
        note_flds  TYPE string,
        note_comps TYPE string,
        note_fks   TYPE string,
        inst_tabl  TYPE string,
        inst_tabd  TYPE string,
        inst_tabt  TYPE string,
        inst_indx  TYPE string,
        label_fk_flds  TYPE string,
        label_check_rq TYPE string,
        label_msg_no   TYPE string,
        label_aarea    TYPE string,
        label_screen_check TYPE string,
        label_card     TYPE string,
        label_fk_type  TYPE string,
        label_fk_semantic  TYPE string,
      END OF text_tabl,
      BEGIN OF text_view,
        inst_view TYPE string,
        inst_vied TYPE string,
        inst_viet TYPE string,
        title_tables TYPE string,
        title_fields TYPE string,
        title_join_conds TYPE string,
        title_sel_conds  TYPE string,
        note_join_cond   TYPE string,
        note_sel_cond    TYPE string,
      END OF text_view,
      BEGIN OF text_shlp,
        txt_type_ele  TYPE string,
        txt_type_col  TYPE string,
        txt_type      TYPE string,
        inst_shlp     TYPE string,
        inst_shld     TYPE string,
      END OF text_shlp,
      BEGIN OF text_enqu,
        label_allow_rfc TYPE string,
        label_tables    TYPE string,
        label_params    TYPE string,
        inst_enqu       TYPE string,
        inst_enqd       TYPE string,
      END OF text_enqu,
      BEGIN OF text_nrob,
        inst_nrob TYPE string,
      END OF text_nrob,
      BEGIN OF text_docu,
        inst_docu TYPE string,
        inst_doct TYPE string,
        inst_docv TYPE string,
      END OF text_docu,
      BEGIN OF text_mess,
        txt_title       TYPE string,
        txt_mt_longtext TYPE string,
        inst_mess       TYPE string,
      END OF text_mess,
      BEGIN OF text_msag,
        label_messages  TYPE string,
        inst_msag       TYPE string,
        inst_msad       TYPE string,
        inst_mess       TYPE string,
      END OF text_msag,
      BEGIN OF text_tobj,
        msg_obj_invalid TYPE string,
        label_events    TYPE string,
        inst_tobj       TYPE string,
        txt_mt_event   TYPE string,
      END OF text_tobj,
      BEGIN OF text_vcls,
        title_obj_stru TYPE string,
        title_fld_dep  TYPE string,
        title_events   TYPE string,
        label_hier     TYPE string,
        label_type     TYPE string,
        txt_type_comp  TYPE string,
        txt_type_sub   TYPE string,
        txt_mt_event   TYPE string,
      END OF text_vcls,
      BEGIN OF text_ttyp,
        label_row_type  TYPE string,
        inst_ttyp       TYPE string,
        inst_ttyd       TYPE string,
      END OF text_ttyp,
      BEGIN OF text_tran,
        inst_tran            TYPE string,
        label_type           TYPE string,
        label_default_values TYPE string,
        label_classification TYPE string,
        label_inherit_gui    TYPE string,
        label_prof_user      TYPE string,
        label_easy_web       TYPE string,
        label_service        TYPE string,
        label_pervasive      TYPE string,
        label_auth_values    TYPE string,
        label_oo_mode        TYPE string,
        label_oo_clas        TYPE string,
        label_oo_meth        TYPE string,
        label_oo_local_prog  TYPE string,
        label_oo_update_mode TYPE string,
        label_transaction    TYPE string,
        label_transaction_variant TYPE string,
        label_skip_init_screen    TYPE string,
      END OF text_tran,
      BEGIN OF text_tabu,
        inst_cdat  TYPE string,
        inst_vdat  TYPE string,
        inst_tabu  TYPE string,
        txt_maint_node TYPE string,
      END OF text_tabu.</source>
 </PROG>
 <PROG NAME="YNOT_HTML" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: HTML Ultility Routines" LENGTH="28 "/>
   </language>
  </textPool>
  <source>FORM prepare_html_body.
  DATA: lt_object_header TYPE TABLE OF s_obj_header,
        ls_tadir         TYPE tadir,
        lv_subroutine    TYPE string.

  FIELD-SYMBOLS: &lt;fs_object_header&gt; TYPE s_obj_header,
                 &lt;fs_objtype_order&gt; TYPE s_objtype_order.

  PERFORM collect_objects_header_in_tr CHANGING lt_object_header.
  LOOP AT lt_object_header ASSIGNING &lt;fs_object_header&gt;.
    READ TABLE so_exclu WITH KEY low = &lt;fs_object_header&gt;-obj_name TRANSPORTING NO FIELDS.
    IF sy-subrc EQ 0.
      DELETE lt_object_header.
      CONTINUE.
    ENDIF.

    READ TABLE gt_objtype_order WITH TABLE KEY object = &lt;fs_object_header&gt;-object ASSIGNING &lt;fs_objtype_order&gt;.
    &lt;fs_object_header&gt;-primary_sort = &lt;fs_objtype_order&gt;-sort_no.
  ENDLOOP.
  CHECK lt_object_header IS NOT INITIAL.

  SORT lt_object_header BY primary_sort obj_name.

  LOOP AT lt_object_header ASSIGNING &lt;fs_object_header&gt;.
    SELECT SINGLE * FROM tadir INTO ls_tadir WHERE pgmid = &lt;fs_object_header&gt;-pgmid
      AND object = &lt;fs_object_header&gt;-object AND obj_name = &lt;fs_object_header&gt;-obj_name.
    IF sy-subrc EQ 0.
      &lt;fs_object_header&gt;-devclass = ls_tadir-devclass.
    ENDIF.
    &quot; set activity &apos;Create&apos; as default value, change mode will be detected in routine GETDATA_{objtype} if possible
    &lt;fs_object_header&gt;-activity = gcv_act_create.
    CONCATENATE &apos;GETDATA_&apos; &lt;fs_object_header&gt;-object INTO lv_subroutine. &quot;#EC NOTEXT
    PERFORM (lv_subroutine) IN PROGRAM (sy-repid) USING &lt;fs_object_header&gt; IF FOUND.
    CLEAR lv_subroutine.

    AT END OF object.
      &quot; usually abstract routine can cover 80% of the case, however 20% are special and need to handle separately
      &quot; so we will try to call subroutine of special case first and then fall back to common mode
      TRY.
          CONCATENATE &apos;CONVERT_&apos; &lt;fs_object_header&gt;-object INTO lv_subroutine. &quot;#EC NOTEXT
          PERFORM (lv_subroutine) IN PROGRAM (sy-repid).
        CATCH cx_sy_dyn_call_illegal_form.
          PERFORM convert_obj_abstract USING &lt;fs_object_header&gt;-object.
      ENDTRY.
    ENDAT.
  ENDLOOP.
ENDFORM.

* abstract subroutine for all kinds of objects
* for a collection of objects with same kind, the rendering html should be build in the steps below:
* 1.get header html
* 2.render each object in same format
FORM convert_obj_abstract USING iv_objtype TYPE trobjtype.
  DATA: lv_cnt  TYPE i,
        lv_tab  TYPE string,
        lt_html TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_t_obj&gt;       TYPE STANDARD TABLE,
                 &lt;fs_obj&gt;         TYPE any,
                 &lt;fs_sec_sort&gt;    TYPE any.

  CONCATENATE &apos;(&apos; sy-repid &apos;)GT_&apos; iv_objtype INTO lv_tab.
  ASSIGN (lv_tab) TO &lt;fs_t_obj&gt;.
  CHECK &lt;fs_t_obj&gt; IS ASSIGNED AND &lt;fs_t_obj&gt; IS NOT INITIAL.

  ADD 1 TO gv_header_no.
  lv_cnt  = lines( &lt;fs_t_obj&gt; ).
  PERFORM add_header_html USING iv_objtype CHANGING lt_html.
  PERFORM add_object_instruction_html USING iv_objtype CHANGING lt_html.

  LOOP AT &lt;fs_t_obj&gt; ASSIGNING &lt;fs_obj&gt;.
    ASSIGN COMPONENT &apos;SECONDARY_SORT&apos; OF STRUCTURE &lt;fs_obj&gt; TO &lt;fs_sec_sort&gt;.
    IF &lt;fs_sec_sort&gt; IS ASSIGNED.
      &lt;fs_sec_sort&gt; = sy-tabix.
    ENDIF.
    PERFORM get_single_obj_html_abstract USING &lt;fs_obj&gt; lv_cnt CHANGING lt_html.

    UNASSIGN &lt;fs_sec_sort&gt;.
  ENDLOOP.
  UNASSIGN &lt;fs_obj&gt;.
  APPEND LINES OF lt_html TO gt_html.
ENDFORM.

FORM add_object_instruction_html USING iv_object TYPE trobjtype CHANGING ct_html TYPE t_string.
  FIELD-SYMBOLS &lt;fs_instruction&gt; TYPE s_object_instruction.

  READ TABLE gt_object_instruction ASSIGNING &lt;fs_instruction&gt; WITH TABLE KEY object = iv_object.
  IF &lt;fs_instruction&gt; IS ASSIGNED AND &lt;fs_instruction&gt;-instruction IS NOT INITIAL.
    PERFORM get_paragraph_html USING &lt;fs_instruction&gt;-instruction CHANGING ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDIF.
ENDFORM.

* abstract subroutine as a template pattern for all kinds of objects to implement
* for a single object, the rendering html should be built in the steps below:
* 1.get title html
* 2.get basic attributes and always are obj_name, devclass, short_text
* 3.get additional attributes, for example, for package, its application component, software component and etc
* 4.get special attributes, for example, for table, its fields, technical settings, foreign key settings and etc
* To keep things simple, name convention should be followed like this:
* GET_ADDITIONAL_HTML_{objtype}
* GET_SPECIAL_HTML_{objtype}
FORM get_single_obj_html_abstract USING is_obj TYPE any iv_cnt TYPE i CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_form_addi  TYPE string,
        lv_form_spec  TYPE string,
        ls_obj_header TYPE s_obj_header.
  FIELD-SYMBOLS &lt;fs_objtype_order&gt; TYPE s_objtype_order.

  MOVE-CORRESPONDING is_obj TO ls_obj_header.
  CONCATENATE &apos;GET_ADDITIONAL_HTML_&apos; ls_obj_header-object INTO lv_form_addi.
  CONCATENATE &apos;GET_SPECIAL_HTML_&apos; ls_obj_header-object INTO lv_form_spec.

  PERFORM add_title_html USING is_obj iv_cnt CHANGING ct_html.
  READ TABLE gt_objtype_order WITH TABLE KEY object = ls_obj_header-object ASSIGNING &lt;fs_objtype_order&gt;.
  IF &lt;fs_objtype_order&gt;-show_basic_attr EQ abap_true.
    APPEND gcv_table_begin TO ct_html.
    PERFORM get_basic_attr_html USING ls_obj_header CHANGING ct_html.
    PERFORM (lv_form_addi) IN PROGRAM (sy-repid) USING is_obj CHANGING ct_html IF FOUND.
    APPEND gcv_table_end TO ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDIF.

  PERFORM (lv_form_spec) IN PROGRAM (sy-repid) USING is_obj CHANGING ct_html IF FOUND.
  PERFORM add_obj_gen_msg USING ls_obj_header &apos;S&apos; &apos;&apos;.
ENDFORM.

FORM get_basic_attr_html USING is_obj_header TYPE s_obj_header CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_default2column_html CHANGING ct_html.
  &quot; basic attributes of maintenance object is of little value
  CHECK is_obj_header-object NE &apos;TOBJ&apos;.
  DATA lv_fields TYPE string VALUE &apos;OBJ_NAME|SHORT_TEXT&apos;.
  IF is_obj_header-object NE &apos;DEVC&apos; AND is_obj_header-object NE &apos;FUGT&apos;.
    CONCATENATE lv_fields &apos;|&apos; &apos;DEVCLASS&apos; INTO lv_fields.
  ENDIF.
  PERFORM data2rows USING is_obj_header &apos;S_OBJ_HEADER&apos; lv_fields CHANGING ct_html.
ENDFORM.

FORM get_objtype_desc USING iv_objtype TYPE trobjtype CHANGING cv_str TYPE ko100-text.
  DATA: ls_ko100 TYPE ko100.
  READ TABLE gt_objtype_desc INTO ls_ko100 WITH TABLE KEY object = iv_objtype.
  CLEAR cv_str.
  &quot; TOBJ: Definition of a Maintenance and Transport Object -&gt; might be confusing to customer
  IF iv_objtype EQ &apos;TOBJ&apos;.
    cv_str = text_common-title_tobj.
  ELSE.
    cv_str = ls_ko100-text.
  ENDIF.
ENDFORM.

FORM add_header_html USING iv_objtype TYPE trobjtype CHANGING ct_html TYPE t_string.
  DATA: lv_html   TYPE string,
        lv_desc   TYPE ddtext,
        lv_no_str TYPE string.

  lv_html = gcv_header_html.
  PERFORM format_numc USING gv_header_no CHANGING lv_no_str.
  REPLACE FIRST OCCURRENCE OF &apos;$HEADER_NO&apos; IN lv_html WITH lv_no_str.
  PERFORM get_objtype_desc USING iv_objtype CHANGING lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJECT_DESC&apos; IN lv_html WITH lv_desc.

  APPEND lv_html TO ct_html.
ENDFORM.

FORM add_title_html USING is_obj TYPE any iv_cnt TYPE i CHANGING ct_html TYPE t_string.
  DATA: lv_no1 TYPE string,
        lv_no2 TYPE string,
        lv_desc TYPE ddtext,
        ls_obj_header TYPE s_obj_header,
        lv_title_no TYPE string,
        lv_html TYPE string VALUE gcv_title_html.

  MOVE-CORRESPONDING is_obj TO ls_obj_header.
  IF iv_cnt EQ 1.
    REPLACE FIRST OCCURRENCE OF &apos;$TITLE_NO&apos; IN lv_html WITH &apos;&apos;.
  ELSE.
    PERFORM format_numc USING gv_header_no CHANGING lv_no1.
    PERFORM format_numc USING ls_obj_header-secondary_sort CHANGING lv_no2.
    CONCATENATE lv_no1 &apos;.&apos; lv_no2 &apos; &apos; INTO lv_title_no RESPECTING BLANKS.
    REPLACE FIRST OCCURRENCE OF &apos;$TITLE_NO&apos; IN lv_html WITH lv_title_no.
  ENDIF.

  PERFORM get_title_objtype_desc USING ls_obj_header-object is_obj CHANGING lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$ACTIVITY&apos; IN lv_html WITH ls_obj_header-activity.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJECT_DESC&apos; IN lv_html WITH lv_desc.
  REPLACE FIRST OCCURRENCE OF &apos;$OBJ_NAME&apos; IN lv_html WITH ls_obj_header-obj_name.
  APPEND lv_html TO ct_html.
ENDFORM.

* some object type has sub category and we need to get that
FORM get_objtype_desc_deep USING is_obj_header TYPE s_obj_header CHANGING cv_desc TYPE string.
  DATA: lv_desc TYPE ddtext,
        lv_len  TYPE i.

  CASE is_obj_header-object.
    WHEN &apos;TABL&apos;.
      DATA ls_tabl TYPE s_tabl.
      READ TABLE gt_tabl INTO ls_tabl WITH KEY obj_name = is_obj_header-obj_name BINARY SEARCH.
      PERFORM get_title_objtype_desc USING is_obj_header-object ls_tabl CHANGING lv_desc.
    WHEN &apos;VIEW&apos;.
      DATA ls_view TYPE s_view.
      READ TABLE gt_view INTO ls_view WITH KEY obj_name = is_obj_header-obj_name BINARY SEARCH.
      PERFORM get_title_objtype_desc USING is_obj_header-object ls_view CHANGING lv_desc.
    WHEN OTHERS.
      PERFORM get_objtype_desc USING is_obj_header-object CHANGING lv_desc.
  ENDCASE.

  CLEAR cv_desc.
  CHECK lv_desc IS NOT INITIAL.
  lv_len = strlen( lv_desc ).
  cv_desc = lv_desc(lv_len).
ENDFORM.

FORM get_title_objtype_desc USING iv_objtype TYPE trobjtype is_obj TYPE any CHANGING cv_desc TYPE ddtext.
  DATA: lv_low TYPE ddfixvalue-low.
  FIELD-SYMBOLS &lt;fs_value&gt; TYPE any.

  CLEAR cv_desc.
  IF iv_objtype EQ &apos;TABL&apos;.
    ASSIGN COMPONENT &apos;TABCLASS&apos; OF STRUCTURE is_obj TO &lt;fs_value&gt;.
    IF &lt;fs_value&gt; IS ASSIGNED.
      lv_low = &lt;fs_value&gt;.
      PERFORM get_value_desc USING &apos;TABCLASS&apos; lv_low CHANGING cv_desc.
    ENDIF.
  ELSEIF iv_objtype EQ &apos;VIEW&apos;.
    ASSIGN COMPONENT &apos;VIEWCLASS&apos; OF STRUCTURE is_obj TO &lt;fs_value&gt;.
    IF &lt;fs_value&gt; IS ASSIGNED.
      lv_low = &lt;fs_value&gt;.
      PERFORM get_value_desc USING &apos;VIEWCLASS&apos; lv_low CHANGING cv_desc.
    ENDIF.
  ELSE.
    PERFORM get_objtype_desc USING iv_objtype CHANGING cv_desc.
  ENDIF.
ENDFORM.

FORM get_small_title_html USING iv_small_title TYPE string CHANGING ct_html TYPE t_string.
  DATA lv_html TYPE string VALUE gcv_small_title_html.
  REPLACE FIRST OCCURRENCE OF &apos;$TITLE&apos; IN lv_html WITH iv_small_title.
  APPEND lv_html TO ct_html.
ENDFORM.

FORM get_paragraph_html  USING iv_para TYPE string CHANGING ct_html TYPE t_string.
  DATA lv_html TYPE string VALUE gcv_paragraph_html.
  REPLACE FIRST OCCURRENCE OF &apos;$PARAGRAPH&apos; IN lv_html WITH iv_para.
  APPEND lv_html TO ct_html.
ENDFORM.

FORM get_column_label_html USING iv_label TYPE any CHANGING cv_td TYPE string.
  CLEAR cv_td.
  cv_td = gcv_td_label.
  REPLACE FIRST OCCURRENCE OF &apos;$LABEL&apos; IN cv_td WITH iv_label.
ENDFORM.

FORM get_tr_label_html USING iv_labels TYPE string CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td TYPE string,
        lv_tr TYPE string,
        lt_labels TYPE TABLE OF string.
  FIELD-SYMBOLS: &lt;fs_label&gt; TYPE string.

  SPLIT iv_labels AT &apos;|&apos; INTO TABLE lt_labels.

  lv_tr = &apos;&lt;tr&gt;&apos;.
  LOOP AT lt_labels ASSIGNING &lt;fs_label&gt;.
    CHECK &lt;fs_label&gt; IS NOT INITIAL.
    CONDENSE &lt;fs_label&gt;.
    PERFORM get_column_label_html USING &lt;fs_label&gt; CHANGING lv_td.
    CONCATENATE lv_tr lv_td INTO lv_tr RESPECTING BLANKS.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
ENDFORM.

FORM get_column_value_html USING iv_value TYPE any CHANGING cv_td TYPE string.
  DATA: lv_str   TYPE string,
        lo_descr TYPE REF TO cl_abap_datadescr.

  lo_descr ?= cl_abap_typedescr=&gt;describe_by_data( iv_value ).
  IF lo_descr IS BOUND AND lo_descr-&gt;type_kind EQ &apos;N&apos;.
    PERFORM format_numc USING iv_value CHANGING lv_str.
  ELSE.
    lv_str = iv_value.
  ENDIF.

  CLEAR cv_td.
  cv_td = gcv_td_content.
  REPLACE FIRST OCCURRENCE OF &apos;$VALUE&apos; IN cv_td WITH lv_str.
ENDFORM.

FORM get_column_innertable_html USING iv_value TYPE any CHANGING cv_td TYPE string.
  DATA lv_str TYPE string.
  lv_str = iv_value.

  CLEAR cv_td.
  cv_td = gcv_td_inner_table.
  REPLACE FIRST OCCURRENCE OF &apos;$VALUE&apos; IN cv_td WITH lv_str.
ENDFORM.

FORM get_default2column_html CHANGING ct_html TYPE STANDARD TABLE.
  PERFORM get_2column_label_html USING text_common-label_col_attr text_common-label_col_value CHANGING ct_html.
ENDFORM.

FORM get_2column_label_html USING iv_label1 TYPE string iv_label2 TYPE string CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_label_html USING iv_label1 CHANGING lv_td1.
  PERFORM get_column_label_html USING iv_label2 CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM get_2column_right_table_html USING iv_label1 TYPE string iv_inner_table_html TYPE string CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_value_html USING iv_label1 CHANGING lv_td1.
  PERFORM get_column_innertable_html USING iv_inner_table_html CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM get_2column_value_html USING iv_label TYPE any iv_value TYPE any CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string.

  PERFORM get_column_value_html USING iv_label CHANGING lv_td1.
  PERFORM get_column_value_html USING iv_value CHANGING lv_td2.
  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM combine2td USING iv_td1 TYPE string iv_td2 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM combine3td USING iv_td1 TYPE string iv_td2 TYPE string iv_td3 TYPE string  CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tr TYPE string.
  CONCATENATE &apos;&lt;tr&gt;&apos; iv_td1 iv_td2 iv_td3  &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
  APPEND lv_tr TO ct_html.
  CLEAR lv_tr.
ENDFORM.

FORM join_str USING it_tab TYPE t_string CHANGING cv_str TYPE string.
  CLEAR cv_str.

  FIELD-SYMBOLS: &lt;fs_str&gt; TYPE string.
  LOOP AT it_tab ASSIGNING &lt;fs_str&gt;.
    CONCATENATE cv_str &lt;fs_str&gt; INTO cv_str RESPECTING BLANKS.
  ENDLOOP.
ENDFORM.

FORM table2tr USING iv_label TYPE string it_tab TYPE STANDARD TABLE iv_stru TYPE any iv_fldnames TYPE string CHANGING ct_html TYPE t_string.
  DATA: lv_td1 TYPE string,
        lv_td2 TYPE string,
        lv_tmp TYPE string,
        lt_tab TYPE TABLE OF string.

  PERFORM get_column_value_html USING iv_label CHANGING lv_td1.
  PERFORM convert_table_html USING &apos;&apos; it_tab iv_stru iv_fldnames abap_false &apos;&apos; abap_true CHANGING lt_tab.
  PERFORM join_str USING lt_tab CHANGING lv_tmp.
  PERFORM get_column_innertable_html USING lv_tmp CHANGING lv_td2.

  PERFORM combine2td USING lv_td1 lv_td2 CHANGING ct_html.
ENDFORM.

FORM convert_table_html USING iv_title TYPE string it_tab TYPE STANDARD TABLE iv_stru TYPE any
                              iv_fldnames TYPE string iv_remove TYPE abap_bool iv_remove_flds TYPE string
                              iv_innertable  TYPE abap_bool
                        CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lt_used_ddic TYPE ddfields,
        lv_tr        TYPE string,
        lv_td        TYPE string,
        lv_txt       TYPE ddtext.
  FIELD-SYMBOLS: &lt;fs_ddic&gt;  TYPE dfies,
                 &lt;fs_row&gt;   TYPE any,
                 &lt;fs_value&gt; TYPE any.

  CHECK it_tab IS NOT INITIAL.
  PERFORM get_used_ddfields USING iv_stru iv_fldnames CHANGING lt_used_ddic.
  CHECK sy-subrc EQ 0.

  IF iv_remove EQ abap_true.
    PERFORM remove_no_need_fields USING it_tab iv_remove_flds CHANGING lt_used_ddic.
  ENDIF.

  IF iv_title IS NOT INITIAL.
    PERFORM get_small_title_html USING iv_title CHANGING ct_html.
  ENDIF.

  APPEND gcv_table_begin TO ct_html.
  PERFORM get_table_head_html USING lt_used_ddic CHANGING lv_tr.
  APPEND lv_tr TO ct_html.

  LOOP AT it_tab ASSIGNING &lt;fs_row&gt;.
    lv_tr = &apos;&lt;tr&gt;&apos;.

    LOOP AT lt_used_ddic ASSIGNING &lt;fs_ddic&gt;.
      ASSIGN COMPONENT &lt;fs_ddic&gt;-fieldname OF STRUCTURE &lt;fs_row&gt; TO &lt;fs_value&gt;.
      CHECK &lt;fs_value&gt; IS ASSIGNED.

      PERFORM get_value_desc USING &lt;fs_ddic&gt;-fieldname &lt;fs_value&gt; CHANGING lv_txt.
      IF lv_txt IS NOT INITIAL.
        lv_txt = escape( val = lv_txt format = cl_abap_format=&gt;e_html_text ).
        PERFORM get_column_value_html USING lv_txt CHANGING lv_td.
      ELSE.
        PERFORM get_column_value_html USING &lt;fs_value&gt; CHANGING lv_td.
      ENDIF.
      CONCATENATE lv_tr lv_td INTO lv_tr RESPECTING BLANKS.

      CLEAR: lv_txt.
      UNASSIGN &lt;fs_value&gt;.
    ENDLOOP.

    CONCATENATE lv_tr &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.
    APPEND lv_tr TO ct_html.
  ENDLOOP.
  APPEND gcv_table_end TO ct_html.

  IF iv_innertable EQ abap_false.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDIF.
ENDFORM.

FORM remove_no_need_fields USING it_tab TYPE STANDARD TABLE iv_remove_flds TYPE string CHANGING ct_ddfields TYPE ddfields.
  TYPES: BEGIN OF s_field_remain,
         fieldname TYPE fieldname,
         remain    TYPE abap_bool,
         END OF s_field_remain.
  TYPES: BEGIN OF s_field_to_check,
         fieldname TYPE fieldname,
         END OF s_field_to_check.

  DATA: lt_fld_remain TYPE HASHED TABLE OF s_field_remain WITH UNIQUE KEY fieldname,
        ls_fld_remain TYPE s_field_remain,
        lt_fldnames   TYPE TABLE OF s_field_to_check,
        lt_fld2check  TYPE HASHED TABLE OF s_field_to_check WITH UNIQUE KEY fieldname.
  FIELD-SYMBOLS: &lt;fs_ddic&gt;  TYPE dfies,
                 &lt;fs_fld&gt;   TYPE s_field_to_check,
                 &lt;fs_row&gt;   TYPE any,
                 &lt;fs_value&gt; TYPE any.

  IF iv_remove_flds IS NOT INITIAL.
    SPLIT iv_remove_flds AT &apos;|&apos; INTO TABLE lt_fldnames.
  ELSE.
    LOOP AT ct_ddfields ASSIGNING &lt;fs_ddic&gt;.
      APPEND &lt;fs_ddic&gt;-fieldname TO lt_fldnames.
    ENDLOOP.
  ENDIF.
  MOVE lt_fldnames TO lt_fld2check.

  LOOP AT it_tab ASSIGNING &lt;fs_row&gt;.
    LOOP AT lt_fldnames ASSIGNING &lt;fs_fld&gt;.
      ASSIGN COMPONENT &lt;fs_fld&gt;-fieldname OF STRUCTURE &lt;fs_row&gt; TO &lt;fs_value&gt;.
      IF &lt;fs_value&gt; IS ASSIGNED AND &lt;fs_value&gt; IS NOT INITIAL.
        READ TABLE lt_fld_remain WITH TABLE KEY fieldname = &lt;fs_fld&gt;-fieldname TRANSPORTING NO FIELDS.
        CHECK sy-subrc NE 0.

        ls_fld_remain-fieldname = &lt;fs_fld&gt;-fieldname.
        ls_fld_remain-remain = abap_true.
        INSERT ls_fld_remain INTO TABLE lt_fld_remain.
      ENDIF.
    ENDLOOP.
  ENDLOOP.

  LOOP AT ct_ddfields ASSIGNING &lt;fs_ddic&gt;.
    READ TABLE lt_fld2check WITH KEY fieldname = &lt;fs_ddic&gt;-fieldname TRANSPORTING NO FIELDS.
    CHECK sy-subrc EQ 0.

    READ TABLE lt_fld_remain WITH TABLE KEY fieldname = &lt;fs_ddic&gt;-fieldname TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.
    DELETE ct_ddfields.
  ENDLOOP.
ENDFORM.

FORM table2html USING iv_title TYPE string
                      it_tab   TYPE STANDARD TABLE
                      iv_stru  TYPE any
                      iv_fldnames    TYPE string
                      iv_remove      TYPE abap_bool
                      iv_remove_flds TYPE string
                CHANGING ct_html     TYPE STANDARD TABLE.
  PERFORM convert_table_html USING iv_title it_tab iv_stru iv_fldnames iv_remove iv_remove_flds abap_false CHANGING ct_html.
ENDFORM.

FORM data2rows_common USING iv_data TYPE any  iv_stru TYPE any iv_fldnames TYPE any iv_filter TYPE abap_bool CHANGING ct_html TYPE t_string.
  DATA: lt_ddfields TYPE ddfields,
        lv_label    TYPE string,
        lv_txt      TYPE ddtext.
  FIELD-SYMBOLS: &lt;fs_dfies&gt; TYPE dfies,
                 &lt;fs_value&gt; TYPE any.

  PERFORM get_used_ddfields USING iv_stru iv_fldnames CHANGING lt_ddfields.
  LOOP AT lt_ddfields ASSIGNING &lt;fs_dfies&gt;.
    ASSIGN COMPONENT &lt;fs_dfies&gt;-fieldname OF STRUCTURE iv_data TO &lt;fs_value&gt;.
    CHECK &lt;fs_value&gt; IS ASSIGNED.

    PERFORM get_value_desc USING &lt;fs_dfies&gt;-fieldname &lt;fs_value&gt; CHANGING lv_txt.
    IF iv_filter EQ abap_true.
      CHECK &lt;fs_value&gt; IS NOT INITIAL OR lv_txt IS NOT INITIAL.
    ENDIF.

    PERFORM get_field_label USING &lt;fs_dfies&gt; CHANGING lv_label.
    IF lv_txt IS NOT INITIAL.
      lv_txt = escape( val = lv_txt format = cl_abap_format=&gt;e_html_text ).
      PERFORM get_2column_value_html USING lv_label lv_txt CHANGING ct_html.
    ELSE.
      PERFORM get_2column_value_html USING lv_label &lt;fs_value&gt; CHANGING ct_html.
    ENDIF.

    UNASSIGN &lt;fs_value&gt;.
    CLEAR: lv_txt.
  ENDLOOP.
ENDFORM.

FORM data2rows USING iv_data TYPE any  iv_stru TYPE any iv_fldnames TYPE any CHANGING ct_html TYPE t_string.
  PERFORM data2rows_common USING iv_data iv_stru iv_fldnames abap_true CHANGING ct_html.
ENDFORM.

FORM get_used_ddfields USING iv_stru TYPE any iv_fldnames TYPE string CHANGING ct_ddfields TYPE ddfields.
  DATA: lo_stru      TYPE REF TO cl_abap_structdescr,
        lo_type      TYPE REF TO cl_abap_typedescr,
        lt_ddic      TYPE ddfields,
        lt_hash_ddic TYPE HASHED TABLE OF dfies WITH UNIQUE KEY fieldname,
        lt_used_ddic TYPE ddfields,
        lt_fldnames  TYPE TABLE OF fieldname,
        ls_ddic      TYPE dfies,
        lt_components TYPE abap_component_tab,
        lo_ele_descr  TYPE REF TO cl_abap_elemdescr,
        lv_msg       TYPE string.

  FIELD-SYMBOLS: &lt;fs_ddic&gt;  TYPE dfies,
                 &lt;fs_fld&gt;   TYPE fieldname,
                 &lt;fs_comp&gt;  TYPE abap_componentdescr.

  CHECK iv_stru IS NOT INITIAL.
  CALL METHOD cl_abap_typedescr=&gt;describe_by_name
    EXPORTING
      p_name         = iv_stru
    RECEIVING
      p_descr_ref    = lo_type
    EXCEPTIONS
      type_not_found = 1
      OTHERS         = 2.

  IF sy-subrc EQ 0.
    lo_stru ?= lo_type.
    IF lo_stru-&gt;is_ddic_type( ) EQ abap_true.
      lt_ddic = lo_stru-&gt;get_ddic_field_list( ).
    ELSE.
      lt_components = lo_stru-&gt;get_components( ).

      LOOP AT lt_components ASSIGNING &lt;fs_comp&gt; WHERE as_include EQ abap_false.
        &quot; include/table/structure is out of scope, only fields will be fetched
        CHECK &lt;fs_comp&gt;-type-&gt;type_kind NE cl_abap_typedescr=&gt;typekind_table AND
              &lt;fs_comp&gt;-type-&gt;type_kind NE cl_abap_typedescr=&gt;typekind_struct1 AND
              &lt;fs_comp&gt;-type-&gt;type_kind NE cl_abap_typedescr=&gt;typekind_struct2.

        lo_ele_descr ?= &lt;fs_comp&gt;-type.
        IF lo_ele_descr-&gt;is_ddic_type( ) EQ abap_true.
          ls_ddic = lo_ele_descr-&gt;get_ddic_field( ).
          ls_ddic-fieldname = &lt;fs_comp&gt;-name.
        ELSE.
          &quot; if component is not ddic type, then fall back to its field name
          ls_ddic-fieldname = &lt;fs_comp&gt;-name.
        ENDIF.
        APPEND ls_ddic TO lt_ddic.
        CLEAR ls_ddic.
      ENDLOOP.
    ENDIF.
  ELSE.
    CONCATENATE &apos;Type &apos; iv_stru &apos; not found.&apos; INTO lv_msg RESPECTING BLANKS.
    PERFORM append_common_msg USING &apos;E&apos; lv_msg CHANGING gt_sys_msg.
    RETURN.
  ENDIF.

  IF iv_fldnames IS NOT INITIAL.
    MOVE lt_ddic TO lt_hash_ddic.

    SPLIT iv_fldnames AT &apos;|&apos; INTO TABLE lt_fldnames.
    LOOP AT lt_fldnames ASSIGNING &lt;fs_fld&gt;.
      CONDENSE &lt;fs_fld&gt; NO-GAPS.
      CHECK &lt;fs_fld&gt; IS NOT INITIAL.

      READ TABLE lt_hash_ddic WITH TABLE KEY fieldname = &lt;fs_fld&gt; ASSIGNING &lt;fs_ddic&gt;.
      IF &lt;fs_ddic&gt; IS ASSIGNED.
        APPEND &lt;fs_ddic&gt; TO lt_used_ddic.
        UNASSIGN &lt;fs_ddic&gt;.
      ELSE.
        ls_ddic-fieldname = &lt;fs_fld&gt;.
        APPEND ls_ddic TO lt_used_ddic.
      ENDIF.
    ENDLOOP.
  ELSE.
    lt_used_ddic = lt_ddic.
  ENDIF.

  CLEAR ct_ddfields.
  ct_ddfields = lt_used_ddic.
ENDFORM.

TYPES: BEGIN OF s_label,
       len TYPE headlen,
       txt TYPE string,
       END OF s_label.
TYPES: t_label TYPE STANDARD TABLE OF s_label.

FORM append_fld_label USING iv_txt TYPE c CHANGING ct_label TYPE t_label.
  DATA ls_label TYPE s_label.

  ls_label-len = strlen( iv_txt ).
  ls_label-txt = iv_txt.
  APPEND ls_label TO ct_label.
ENDFORM.

FORM get_field_label USING iv_dfies TYPE dfies CHANGING cv_label TYPE string.
  CHECK iv_dfies IS NOT INITIAL.
  CLEAR cv_label.

  DATA lt_table TYPE t_label.
  FIELD-SYMBOLS &lt;fs_label&gt; TYPE s_label.

  PERFORM append_fld_label USING iv_dfies-scrtext_s CHANGING lt_table.
  PERFORM append_fld_label USING iv_dfies-scrtext_m CHANGING lt_table.
  PERFORM append_fld_label USING iv_dfies-scrtext_l CHANGING lt_table.
  PERFORM append_fld_label USING iv_dfies-reptext   CHANGING lt_table.

  SORT lt_table BY len DESCENDING.
  READ TABLE lt_table ASSIGNING &lt;fs_label&gt; INDEX 1.
  IF &lt;fs_label&gt;-txt IS INITIAL.
    PERFORM format_fldname USING iv_dfies-fieldname CHANGING cv_label.
  ELSE.
    cv_label = &lt;fs_label&gt;-txt.
  ENDIF.
ENDFORM.

FORM format_fldname USING iv_fldname TYPE fieldname CHANGING cv_label TYPE string.
  DATA: lt_word TYPE TABLE OF fieldname,
        lv_char TYPE c.
  FIELD-SYMBOLS &lt;fs_word&gt; TYPE fieldname.
  SPLIT iv_fldname AT &apos;_&apos; INTO TABLE lt_word.
  LOOP AT lt_word ASSIGNING &lt;fs_word&gt;.
    lv_char = &lt;fs_word&gt;(1).
    TRANSLATE &lt;fs_word&gt; TO LOWER CASE.
    &lt;fs_word&gt;(1) = lv_char.
  ENDLOOP.

  CONCATENATE LINES OF lt_word INTO cv_label SEPARATED BY space.
ENDFORM.

FORM get_table_head_html USING it_dfies TYPE ddfields CHANGING cv_tr TYPE string.
  DATA: lv_tr    TYPE string VALUE &apos;&lt;tr&gt;&apos;,
        lv_td    TYPE string,
        lv_label TYPE string.

  FIELD-SYMBOLS: &lt;fs_ddic&gt; TYPE dfies.

  LOOP AT it_dfies ASSIGNING &lt;fs_ddic&gt;.
    PERFORM get_field_label USING &lt;fs_ddic&gt; CHANGING lv_label.
    PERFORM get_column_label_html USING lv_label CHANGING lv_td.
    CONCATENATE lv_tr lv_td INTO lv_tr RESPECTING BLANKS.

    CLEAR: lv_label, lv_td.
  ENDLOOP.
  CONCATENATE lv_tr &apos;&lt;/tr&gt;&apos; INTO lv_tr RESPECTING BLANKS.

  CLEAR cv_tr.
  cv_tr = lv_tr.
ENDFORM.

FORM prepare_html_head.
  APPEND &apos;&lt;html&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;head&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;meta name=&quot;Generator&quot; content=&quot;Microsoft Word 14 (filtered)&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;style type=&quot;text/css&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;!--&apos; TO gt_html_all.
  APPEND &apos;/* Font Definitions */&apos; TO gt_html_all.
  APPEND &apos;@font-face&apos; TO gt_html_all.
  APPEND &apos;{font-family:Calibri;&apos; TO gt_html_all.
  APPEND &apos;panose-1:2 15 5 2 2 2 4 3 2 4;}&apos; TO gt_html_all.
  APPEND &apos;@font-face&apos; TO gt_html_all.
  APPEND &apos;{font-family:Tahoma;&apos; TO gt_html_all.
  APPEND &apos;panose-1:2 11 6 4 3 5 4 4 2 4;}&apos; TO gt_html_all.
  APPEND &apos;/* Style Definitions */&apos; TO gt_html_all.
  APPEND &apos;p.MsoNormal, li.MsoNormal, div.MsoNormal&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;margin-left:0in;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoAcetate, li.MsoAcetate, div.MsoAcetate&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:.0001pt;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:.0001pt;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast&apos; TO gt_html_all.
  APPEND &apos;{margin-top:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-right:0in;&apos; TO gt_html_all.
  APPEND &apos;margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;margin-left:.5in;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;&apos; TO gt_html_all.
  APPEND &apos;font-size:11.0pt;&apos; TO gt_html_all.
  APPEND &apos;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;.MsoChpDefault&apos; TO gt_html_all.
  APPEND &apos;{font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;}&apos; TO gt_html_all.
  APPEND &apos;.MsoPapDefault&apos; TO gt_html_all.
  APPEND &apos;{margin-bottom:10.0pt;&apos; TO gt_html_all.
  APPEND &apos;line-height:115%;}&apos; TO gt_html_all.
  APPEND &apos;/* Page Definitions */&apos; TO gt_html_all.
  APPEND &apos;@page WordSection1&apos; TO gt_html_all.
  APPEND &apos;{size:8.5in 11.0in;&apos; TO gt_html_all.
  APPEND &apos;margin:1.0in 1.0in 1.0in 1.0in;}&apos; TO gt_html_all.
  APPEND &apos;div.WordSection1&apos; TO gt_html_all.
  APPEND &apos;{page:WordSection1;}&apos; TO gt_html_all.
  APPEND &apos;/* List Definitions */&apos; TO gt_html_all.
  APPEND &apos;ol&apos; TO gt_html_all.
  APPEND &apos;{margin-bottom:0in;}&apos; TO gt_html_all.
  APPEND &apos;ul&apos; TO gt_html_all.
  APPEND &apos;{margin-bottom:0in;}&apos; TO gt_html_all.
  APPEND &apos;--&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;/style&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;title&gt;&apos; TO gt_html_all.
  APPEND text_common-title_html TO gt_html_all.
  APPEND &apos;&lt;/title&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;/head&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;body lang=&quot;EN-US&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;div class=&quot;WordSection1&quot;&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;p class=&quot;MsoNormal&quot; style=&quot;margin-bottom:0in;margin-bottom:.0001pt;line-height: normal&quot;&gt;&lt;span syle=&quot;font-size:14.0pt;line-height:115%&quot;&gt;&apos; TO gt_html_all.
  APPEND text_common-txt_notice TO gt_html_all.
  APPEND &apos;&lt;/span&gt;&lt;/p&gt;&lt;br&gt;&apos; TO gt_html_all.
ENDFORM.

FORM prepare_html_tail.
  APPEND &apos;&lt;/div&gt;&apos;  TO gt_html_all.
  APPEND &apos;&lt;/body&gt;&apos; TO gt_html_all.
  APPEND &apos;&lt;/html&gt;&apos; TO gt_html_all.
ENDFORM.

FORM export_docu CHANGING cv_file_name TYPE string.
  DATA: lv_html_file TYPE string,
        lv_msg       TYPE string,
        lv_len       TYPE i,
        lv_codepage  TYPE cpcodepage,
        lv_cp_dl     TYPE abap_encod.

  lv_len = strlen( p_doc ).
  CONCATENATE p_dir gv_slash p_doc(lv_len) &apos;.html&apos; INTO  lv_html_file RESPECTING BLANKS.
  cv_file_name = lv_html_file.
  IF sy-langu EQ &apos;E&apos;.
    PERFORM download_file USING &apos;ASC&apos; lv_html_file CHANGING lv_msg gt_html_all.
  ELSE.
    CALL FUNCTION &apos;SCP_CODEPAGE_BY_EXTERNAL_NAME&apos;
      EXPORTING
        external_name = &apos;UTF-16LE&apos;
        kind          = &apos;H&apos;
      IMPORTING
        sap_codepage  = lv_codepage
      EXCEPTIONS
        not_found     = 1
        OTHERS        = 2.
    IF sy-subrc NE 0.
      lv_codepage = &apos;4013&apos;.
    ENDIF.
    lv_cp_dl = lv_codepage.

    CALL METHOD cl_gui_frontend_services=&gt;gui_download
      EXPORTING
        filename                = lv_html_file
        confirm_overwrite       = boolc( p_test NE abap_true )
        codepage                = lv_cp_dl
      CHANGING
        data_tab                = gt_html_all
      EXCEPTIONS
        file_write_error        = 1
        no_batch                = 2
        gui_refuse_filetransfer = 3
        invalid_type            = 4
        no_authority            = 5
        unknown_error           = 6
        header_not_allowed      = 7
        separator_not_allowed   = 8
        filesize_not_allowed    = 9
        header_too_long         = 10
        dp_error_create         = 11
        dp_error_send           = 12
        dp_error_write          = 13
        unknown_dp_error        = 14
        access_denied           = 15
        dp_out_of_memory        = 16
        disk_full               = 17
        dp_timeout              = 18
        file_not_found          = 19
        dataprovider_exception  = 20
        control_flush_error     = 21
        not_supported_by_gui    = 22
        error_no_gui            = 23
        OTHERS                  = 24.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
ENDFORM.

FORM open_html_in_msword USING iv_filename TYPE string.
* German should be open by IE browser directly, MS WORD won&apos;t work
  CHECK sy-langu EQ &apos;E&apos; AND p_open EQ abap_true.

  DATA: lt_paths      TYPE TABLE OF string,
        lv_path_used  TYPE string,
        lv_params     TYPE string,
        lv_result     TYPE abap_bool.
  FIELD-SYMBOLS &lt;fs_path&gt; TYPE string.

  APPEND &apos;C:\Program Files (x86)\Microsoft Office\Office12\WINWORD.exe&apos; TO lt_paths.
  APPEND &apos;C:\Program Files (x86)\Microsoft Office\Office14\winword.exe&apos; TO lt_paths.

  LOOP AT lt_paths ASSIGNING &lt;fs_path&gt;.
    CALL METHOD cl_gui_frontend_services=&gt;file_exist
      EXPORTING
        file                 = &lt;fs_path&gt;
      RECEIVING
        result               = lv_result
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        wrong_parameter      = 3
        not_supported_by_gui = 4
        OTHERS               = 5.

    IF sy-subrc EQ 0 AND lv_result EQ abap_true.
      lv_path_used = &lt;fs_path&gt;.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF lv_path_used IS INITIAL.
    &quot;TODO read registry to get the installation path of MS Word
  ENDIF.
  CHECK lv_path_used IS NOT INITIAL.

  CONCATENATE &apos;/f &apos; iv_filename INTO lv_params RESPECTING BLANKS.
  CALL METHOD cl_gui_frontend_services=&gt;execute
    EXPORTING
      application            = lv_path_used
      parameter              = lv_params
      maximized              = &apos;X&apos;
    EXCEPTIONS
      cntl_error             = 1
      error_no_gui           = 2
      bad_parameter          = 3
      file_not_found         = 4
      path_not_found         = 5
      file_extension_unknown = 6
      error_execute_failed   = 7
      synchronous_failed     = 8
      not_supported_by_gui   = 9
      OTHERS                 = 10.
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_MESS" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Single Message - Data Retrive &amp; HTML Conversion Routines" LENGTH="62 "/>
   </language>
  </textPool>
  <source>***************** Single Message Begin *****************
FORM getdata_mess USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_mess     TYPE s_mess,
        ls_msg_txt  TYPE s_msg_txt,
        lv_len      TYPE i.
  lv_len = strlen( is_obj_header-obj_name ) - 3.
  ls_mess-arbgb = is_obj_header-obj_name(lv_len).
  ls_mess-msgnr = is_obj_header-obj_name+lv_len(3).

  MOVE-CORRESPONDING is_obj_header TO ls_mess.
  SELECT SINGLE text FROM t100 INTO ls_mess-text WHERE sprsl = sy-langu AND arbgb = ls_mess-arbgb AND msgnr = ls_mess-msgnr.
  CHECK sy-subrc EQ 0.

  MOVE-CORRESPONDING ls_mess TO ls_msg_txt.
  PERFORM read_msg_docu USING ls_msg_txt CHANGING ls_mess-self_explanatory ls_mess-long_text.
  APPEND ls_mess TO gt_mess.
ENDFORM.

FORM read_msg_docu USING is_msg_text TYPE s_msg_txt CHANGING cv_self_expl TYPE c ct_lines TYPE t_tline.
  DATA: ls_dokil  TYPE dokil,
        lv_object TYPE dokil-object.

  CLEAR: cv_self_expl, ct_lines.
  cv_self_expl = abap_true.

  CONCATENATE is_msg_text-arbgb is_msg_text-msgnr INTO lv_object.
  SELECT SINGLE * FROM dokil INTO ls_dokil WHERE id = &apos;NA&apos;
    AND object = lv_object AND langu = is_msg_text-sprsl AND typ = &apos;E&apos; AND txtlines GT 0.

  CHECK sy-subrc EQ 0.
  cv_self_expl = abap_false.
  PERFORM read_docu_by_dokil USING ls_dokil CHANGING ct_lines.
ENDFORM.

FORM convert_mess.                                          &quot;#EC CALLED
  DATA: lv_tmp  TYPE string,
        ls_objh TYPE s_obj_header,
        lt_mess TYPE TABLE OF s_mess.
  FIELD-SYMBOLS: &lt;fs_mess&gt; TYPE s_mess.

  CHECK gt_mess IS NOT INITIAL.
  &quot; ignore single messages if they are already included in message class
  DELETE ADJACENT DUPLICATES FROM gt_mess.
  LOOP AT gt_mess ASSIGNING &lt;fs_mess&gt;.
    READ TABLE gt_msad WITH KEY obj_name = &lt;fs_mess&gt;-arbgb TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    READ TABLE gt_msag WITH KEY obj_name = &lt;fs_mess&gt;-arbgb TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.

    APPEND &lt;fs_mess&gt; TO lt_mess.
  ENDLOOP.

  CHECK lt_mess IS NOT INITIAL.
  ADD 1 TO gv_header_no.
  PERFORM add_header_html USING &apos;MESS&apos; CHANGING gt_html.
  PERFORM add_object_instruction_html USING &apos;MESS&apos; CHANGING gt_html.

  PERFORM table2html USING text_mess-txt_title lt_mess &apos;T100&apos; &apos;ARBGB|MSGNR|TEXT|SELF_EXPLANATORY&apos; abap_false &apos;&apos; CHANGING gt_html.
  LOOP AT lt_mess ASSIGNING &lt;fs_mess&gt;.
    MOVE-CORRESPONDING &lt;fs_mess&gt; TO ls_objh.
    PERFORM add_obj_gen_msg USING ls_objh &apos;S&apos; &apos;&apos;.
  ENDLOOP.

  LOOP AT lt_mess ASSIGNING &lt;fs_mess&gt; WHERE self_explanatory IS INITIAL.
    CONCATENATE text_mess-txt_mt_longtext &lt;fs_mess&gt;-arbgb &apos; &apos; &lt;fs_mess&gt;-msgnr INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_small_title_html USING lv_tmp CHANGING gt_html.
    PERFORM append_docu_html USING &lt;fs_mess&gt;-long_text CHANGING gt_html.
  ENDLOOP.
ENDFORM.
***************** Single Message Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_MSAD" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Message Class - Data Retrive &amp; HTML Conversion Routines" LENGTH="66 "/>
   </language>
  </textPool>
  <source>***************** Message Class: Definition and All Short Texts Begin *****************
FORM getdata_msad USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_msad_reuse USING is_obj_header.
ENDFORM.

FORM getdata_msad_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_msg   TYPE s_msad,
        ls_t100a TYPE t100a.

  SELECT SINGLE stext FROM t100t INTO ls_msg-short_text
    WHERE sprsl = sy-langu AND arbgb = is_obj_header-obj_name.
  CHECK sy-subrc EQ 0.
  SELECT * FROM t100 INTO CORRESPONDING FIELDS OF TABLE ls_msg-message_texts ##too_many_itab_fields
    WHERE sprsl = sy-langu AND arbgb = is_obj_header-obj_name ORDER BY msgnr ASCENDING.
  MOVE-CORRESPONDING is_obj_header TO ls_msg.

  DATA: ls_long_txt TYPE s_long_text.
  FIELD-SYMBOLS &lt;fs_msg_txt&gt; TYPE s_msg_txt.
  LOOP AT ls_msg-message_texts ASSIGNING &lt;fs_msg_txt&gt;.
    MOVE-CORRESPONDING &lt;fs_msg_txt&gt; TO ls_long_txt.
    PERFORM read_msg_docu USING &lt;fs_msg_txt&gt; CHANGING &lt;fs_msg_txt&gt;-self_explanatory ls_long_txt-long_text.
    IF &lt;fs_msg_txt&gt;-self_explanatory EQ abap_false.
      APPEND ls_long_txt TO ls_msg-long_texts.
    ENDIF.
  ENDLOOP.

  SELECT SINGLE * FROM t100a INTO ls_t100a WHERE arbgb = ls_msg-obj_name.
  PERFORM get_activity USING ls_t100a-ldate CHANGING ls_msg-activity.

  IF ls_msg-object EQ &apos;MSAG&apos;.
    APPEND ls_msg TO gt_msag.
  ELSEIF ls_msg-object EQ &apos;MSAD&apos;.
    APPEND ls_msg TO gt_msag.
  ENDIF.
ENDFORM.

FORM get_additional_html_msad USING ls_msad TYPE s_msad CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM table2tr USING text_msag-label_messages ls_msad-message_texts &apos;T100&apos; &apos;MSGNR|TEXT|SELF_EXPLANATORY&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_msad USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  DATA: ls_msad TYPE s_msad,
        lv_tmp  TYPE string.
  FIELD-SYMBOLS: &lt;fs_long_txt&gt; TYPE s_long_text.

  MOVE-CORRESPONDING is_obj TO ls_msad.
  LOOP AT ls_msad-long_texts ASSIGNING &lt;fs_long_txt&gt;.
    CONCATENATE text_mess-txt_mt_longtext &lt;fs_long_txt&gt;-arbgb &apos; &apos; &lt;fs_long_txt&gt;-msgnr INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_small_title_html USING lv_tmp CHANGING ct_html.
    PERFORM append_docu_html USING &lt;fs_long_txt&gt;-long_text CHANGING ct_html.
  ENDLOOP.
ENDFORM.
***************** Message Class: Definition and All Short Texts Close *****************

***************** Message Class Begin *****************
FORM getdata_msag USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_msad_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_msag USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_additional_html_msad USING is_obj CHANGING ct_html.
ENDFORM.

FORM get_special_html_msag USING is_obj TYPE any CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_special_html_msad USING is_obj CHANGING ct_html.
ENDFORM.
***************** Message Class Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_NROB" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Number Range Object - Data Retrive &amp; HTML Conversion Routines" LENGTH="67 "/>
   </language>
  </textPool>
  <source>***************** Number Range Objects Begin *****************
FORM getdata_nrob USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_nrob TYPE s_nrob,
        lv_object TYPE tnro-object,
        ls_tnro   TYPE tnro,
        ls_tnrot  TYPE tnrot.

  lv_object = is_obj_header-obj_name.
  CALL FUNCTION &apos;NUMBER_RANGE_OBJECT_READ&apos;
    EXPORTING
      object            = lv_object
    IMPORTING
      object_attributes = ls_tnro
      object_text       = ls_tnrot
    EXCEPTIONS
      object_not_found  = 1
      OTHERS            = 2.                                &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_tnro IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_nrob.
  MOVE-CORRESPONDING ls_tnro TO ls_nrob.
  MOVE-CORRESPONDING ls_tnrot TO ls_nrob.
  ls_nrob-short_text = ls_tnrot-txtshort.
  ls_nrob-object = is_obj_header-object.
  APPEND ls_nrob TO gt_nrob.
ENDFORM.

FORM get_additional_html_nrob USING ls_nrob TYPE s_nrob CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM data2rows USING ls_nrob &apos;S_NROB&apos; &apos;TXT|DTELSOBJ|DOMLEN|PERCENTAGE|YEARIND|NONRSWAP|CODE|BUFFER|NOIVBUFFER&apos; CHANGING ct_html.
ENDFORM.
***************** Number Range Objects Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_SHLP" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Search Help - Data Retrive &amp; HTML Conversion Routines" LENGTH="59 "/>
   </language>
  </textPool>
  <source>***************** Search Help Begin *****************
FORM getdata_shlp USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_shlp_reuse USING is_obj_header.
ENDFORM.

FORM getdata_shlp_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_shlp TYPE s_shlp,
        lv_shlp_name TYPE ddobjname,
        ls_dd30v TYPE dd30v,
        lt_dd31v TYPE TABLE OF dd31v,
        lt_dd33v TYPE TABLE OF dd33v.

  lv_shlp_name = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_SHLP_GET&apos;
    EXPORTING
      name          = lv_shlp_name
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd30v_wa      = ls_dd30v
    TABLES
      dd31v_tab     = lt_dd31v
      dd32p_tab     = ls_shlp-params
      dd33v_tab     = lt_dd33v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd30v IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_shlp.
  MOVE-CORRESPONDING ls_dd30v TO ls_shlp.
  PERFORM get_activity USING ls_dd30v-as4date CHANGING ls_shlp-activity.
  ls_shlp-short_text = ls_dd30v-ddtext.

  IF ls_shlp-object EQ &apos;SHLP&apos;.
    APPEND ls_shlp TO gt_shlp.
  ELSEIF ls_shlp-object EQ &apos;SHLD&apos;.
    ls_shlp-activity = gcv_act_update.
    APPEND ls_shlp TO gt_shld.
  ENDIF.
ENDFORM.

FORM get_additional_html_shlp USING ls_shlp TYPE s_shlp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  DATA: lv_type TYPE string.
  IF ls_shlp-issimple EQ abap_true.
    lv_type = text_shlp-txt_type_ele.
  ELSE.
    lv_type = text_shlp-txt_type_col.
  ENDIF.
  PERFORM get_2column_value_html USING text_shlp-txt_type lv_type CHANGING ct_html.
  PERFORM data2rows USING ls_shlp &apos;DD30V&apos; &apos;SELMETHOD|DIALOGTYPE|HOTKEY|SELMEXIT&apos; CHANGING ct_html.
ENDFORM.

FORM get_special_html_shlp USING is_shlp TYPE s_shlp CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM table2html USING text_enqu-label_params is_shlp-params &apos;DD32P&apos;
          &apos;FIELDNAME|SHLPINPUT|SHLPOUTPUT|SHLPSELPOS|SHLPLISPOS|SHLPSELDIS|ROLLNAME|ROLLCHANGE|DEFAULTVAL&apos; abap_true &apos;DEFAULTVAL&apos; CHANGING ct_html.
ENDFORM.
***************** Search Help Close *****************

***************** Search Help Definition Begin *****************
FORM getdata_shld USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_shlp_reuse USING is_obj_header.
ENDFORM.

FORM get_additional_html_shld USING is_shld TYPE s_shld CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_additional_html_shlp USING is_shld CHANGING ct_html.
ENDFORM.

FORM get_special_html_shld USING is_shld TYPE s_shld CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_special_html_shlp USING is_shld CHANGING ct_html.
ENDFORM.
***************** Search Help Definition Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_TABL" VARCL="X" SUBC="I" LEVL="702" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Table - Data Retrive &amp; HTML Conversion Routines" LENGTH="53 "/>
   </language>
  </textPool>
  <source>***************** Table Begin *****************
FORM getdata_tabl USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_tabl_reuse USING is_obj_header.
ENDFORM.

FORM getdata_tabl_reuse USING is_obj_header TYPE s_obj_header.
  DATA: ls_tabl    TYPE s_tabl,
        lv_tabname TYPE ddobjname,
        ls_dd02v   TYPE dd02v,
        lt_dd36m   TYPE dd36mttyp,
        lt_dd05m   TYPE dd05mttyp,
        lt_dd03p   TYPE dd03ttyp,
        lt_dd12v   TYPE dd12vtab,
        lt_dd17v   TYPE dd17vtab,
        ls_fk_def     TYPE s_tabl_fk_def,
        ls_tabl_fld   TYPE s_tabl_field,
        ls_tabl_index TYPE s_tabl_index.
  FIELD-SYMBOLS: &lt;fs_dd05m&gt; TYPE dd05m,
                 &lt;fs_dd03p&gt; TYPE dd03p,
                 &lt;fs_dd12v&gt; TYPE dd12v,
                 &lt;fs_dd17v&gt; TYPE dd17v.

  lv_tabname = is_obj_header-obj_name.
  CALL FUNCTION &apos;DDIF_TABL_GET&apos;
    EXPORTING
      name          = lv_tabname
      langu         = sy-langu
    IMPORTING
      dd02v_wa      = ls_dd02v                      &quot; table header information
      dd09l_wa      = ls_tabl-tech_setting          &quot; technical setting
    TABLES
      dd03p_tab     = lt_dd03p                      &quot; fields
      dd05m_tab     = lt_dd05m                      &quot; foreign key
      dd08v_tab     = ls_tabl-foreign_key_header    &quot; foreign key headers and texts
      dd12v_tab     = lt_dd12v                      &quot; indexes with text
      dd17v_tab     = lt_dd17v                      &quot; secondary indexes
      dd35v_tab     = ls_tabl-assignments           &quot; assignment of structure fields and search helps
      dd36m_tab     = lt_dd36m                      &quot; interface structure for field assignments table-search help
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_dd02v IS NOT INITIAL AND lt_dd03p IS NOT INITIAL.

  MOVE-CORRESPONDING is_obj_header TO ls_tabl.
  MOVE-CORRESPONDING ls_dd02v TO ls_tabl.
  ls_tabl-short_text = ls_dd02v-ddtext.
* convert table/structure fields
  LOOP AT lt_dd03p ASSIGNING &lt;fs_dd03p&gt;.
    MOVE-CORRESPONDING &lt;fs_dd03p&gt; TO ls_tabl_fld.
    IF &lt;fs_dd03p&gt;-fieldname EQ &apos;.INCLUDE&apos;.
      ls_tabl_fld-rollname = &lt;fs_dd03p&gt;-precfield.
    ENDIF.

    IF &lt;fs_dd03p&gt;-adminfield NE 0.
      CLEAR ls_tabl_fld-fieldname.
      CONCATENATE &apos;&lt;i&gt;&apos; &lt;fs_dd03p&gt;-fieldname &apos;&lt;/i&gt;&apos; INTO ls_tabl_fld-fieldname RESPECTING BLANKS.
    ENDIF.

    IF ls_tabl-tabclass EQ &apos;INTTAB&apos;.
      PERFORM get_tabl_comp_typing_method USING &lt;fs_dd03p&gt; CHANGING ls_tabl_fld-typing_method.
    ENDIF.
    APPEND ls_tabl_fld TO ls_tabl-fields.
    CLEAR ls_tabl_fld.
  ENDLOOP.
* convert foreign key definition
  LOOP AT lt_dd05m ASSIGNING &lt;fs_dd05m&gt;.
    MOVE-CORRESPONDING &lt;fs_dd05m&gt; TO ls_fk_def.
    IF &lt;fs_dd05m&gt;-forkey IS INITIAL.
      ls_fk_def-fortable = abap_false.
    ENDIF.

    IF &lt;fs_dd05m&gt;-fortable EQ &apos;*&apos;.
      ls_fk_def-generic = abap_true.
    ENDIF.

    IF &lt;fs_dd05m&gt;-forkey IS INITIAL AND &lt;fs_dd05m&gt;-fortable NE &apos;*&apos;.
      ls_fk_def-constant = &lt;fs_dd05m&gt;-fortable.
    ENDIF.
    APPEND ls_fk_def TO ls_tabl-foreign_keys.
    CLEAR ls_fk_def.
  ENDLOOP.
* convert table index
  LOOP AT lt_dd12v ASSIGNING &lt;fs_dd12v&gt;.
    MOVE-CORRESPONDING &lt;fs_dd12v&gt; TO ls_tabl_index.
    LOOP AT lt_dd17v ASSIGNING &lt;fs_dd17v&gt; WHERE indexname EQ &lt;fs_dd12v&gt;-indexname.
      CONCATENATE ls_tabl_index-index_fields &apos;&lt;br&gt;&apos; &lt;fs_dd17v&gt;-fieldname INTO ls_tabl_index-index_fields.
    ENDLOOP.

    SHIFT ls_tabl_index-index_fields BY 4 PLACES.
    APPEND ls_tabl_index TO ls_tabl-index.
    CLEAR ls_tabl_index.
  ENDLOOP.
* namespace reservation
  SELECT * FROM tresc INTO TABLE ls_tabl-namespace WHERE tabname = ls_tabl-obj_name.
  PERFORM get_activity USING ls_dd02v-as4date CHANGING ls_tabl-activity.

  IF ls_tabl-object EQ &apos;TABL&apos;.
    APPEND ls_tabl TO gt_tabl.
  ELSEIF ls_tabl-object EQ &apos;TABL&apos;.
    ls_tabl-activity = gcv_act_update.
    APPEND ls_tabl TO gt_tabd.
  ENDIF.
ENDFORM.

FORM get_additional_html_tabl USING ls_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  IF ls_tabl-tabclass EQ &apos;TRANSP&apos;.
    PERFORM data2rows USING ls_tabl &apos;S_TABL&apos; &apos;CONTFLAG|MAINFLAG&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_special_html_tabl USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_tabl_fields_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_fk_setting_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_techsetting_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_namespace_html USING is_tabl CHANGING ct_html.
  PERFORM get_tabl_index_html USING is_tabl CHANGING ct_html.
ENDFORM.

FORM get_tabl_fields_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA lv_show_note_flds TYPE abap_bool.
  FIELD-SYMBOLS &lt;fs_fld&gt; TYPE s_tabl_field.

  LOOP AT is_tabl-fields ASSIGNING &lt;fs_fld&gt; WHERE fieldname EQ &apos;.INCLUDE&apos;.
    lv_show_note_flds = abap_true.
  ENDLOOP.
  &quot; we will handle transparent table and structure currently
  IF is_tabl-tabclass EQ &apos;TRANSP&apos;.
    PERFORM get_small_title_html USING text_tabl-title_flds CHANGING ct_html.
    IF lv_show_note_flds EQ abap_true.
      PERFORM get_paragraph_html USING text_tabl-note_flds CHANGING ct_html.
    ENDIF.
    PERFORM table2html USING &apos;&apos; is_tabl-fields &apos;S_TABL_FIELD&apos; &apos;FIELDNAME|KEYFLAG|ROLLNAME|CHECKTABLE|SHLPNAME&apos; abap_true &apos;CHECKTABLE|SHLPNAME&apos; CHANGING ct_html.
  ELSEIF is_tabl-tabclass EQ &apos;INTTAB&apos;.
    PERFORM get_small_title_html USING text_tabl-title_comps CHANGING ct_html.
    IF lv_show_note_flds EQ abap_true.
      PERFORM get_paragraph_html USING text_tabl-note_comps CHANGING ct_html.
    ENDIF.
    PERFORM table2html USING &apos;&apos; is_tabl-fields &apos;S_TABL_FIELD&apos; &apos;FIELDNAME|TYPING_METHOD|ROLLNAME&apos; abap_false &apos;&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.

FORM get_tabl_comp_typing_method USING is_fld TYPE dd03p CHANGING cv_typing_method TYPE string.
  CONSTANTS: c_t_ref       VALUE &apos;R&apos;,
             c_t_boxed     VALUE &apos;J&apos;,
             c_type        TYPE f_reftype VALUE &apos;1&apos;,     &quot; type
             c_type_ref_to TYPE f_reftype VALUE &apos;3&apos;,     &quot; type ref to
             c_type_boxed  TYPE f_reftype VALUE &apos;5&apos;.     &quot; type ... boxed
  DATA: lv_txt TYPE ddtext,
        lv_low TYPE ddfixvalue-low,
        lv_f_reftype TYPE f_reftype.

  CLEAR cv_typing_method.

  IF is_fld-comptype EQ c_t_ref.
    IF is_fld-reftype = c_t_boxed.
      lv_f_reftype = c_type_boxed.
    ELSE.
      lv_f_reftype = c_type_ref_to.
    ENDIF.
  ELSE.
    lv_f_reftype = c_type.
  ENDIF.

  lv_low = lv_f_reftype.
  PERFORM get_value_desc USING &apos;F_REFTYPE&apos; lv_low CHANGING lv_txt.
  CONCATENATE lv_f_reftype &apos; &apos; lv_txt INTO cv_typing_method RESPECTING BLANKS.
ENDFORM.

FORM get_tabl_techsetting_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE t_string.
  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos;.
  PERFORM get_techsetting_html USING is_tabl-tech_setting CHANGING ct_html.
ENDFORM.

FORM get_techsetting_html USING is_dd09v TYPE dd09v CHANGING ct_html TYPE t_string.
  DATA lt_dd09v TYPE TABLE OF dd09v.
  APPEND is_dd09v TO lt_dd09v.
  PERFORM table2html USING text_tabl-title_tech lt_dd09v &apos;DD09V&apos; &apos;TABART|TABKAT|BUFALLOW|PUFFERUNG|PROTOKOLL|JAVAONLY&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.

FORM get_tabl_fk_setting_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  DATA: lv_tmp  TYPE string,
        lv_card TYPE string,
        lv_fkt  TYPE ddtext,
        lv_low  TYPE ddfixvalue-low,
        lv_screen_check TYPE c.
  FIELD-SYMBOLS: &lt;fs_header&gt; LIKE LINE OF is_tabl-foreign_key_header.

  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-foreign_key_header IS NOT INITIAL AND is_tabl-foreign_keys IS NOT INITIAL.

  PERFORM get_small_title_html USING text_tabl-title_fks CHANGING ct_html.
  LOOP AT is_tabl-foreign_key_header ASSIGNING &lt;fs_header&gt;.
    CLEAR: lv_screen_check, lv_card.
    CONCATENATE text_tabl-note_fks &apos;&lt;b&gt;&apos; &lt;fs_header&gt;-fieldname &apos;&lt;/b&gt;&apos; INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_paragraph_html USING lv_tmp CHANGING ct_html.

    APPEND gcv_table_begin TO ct_html.
    PERFORM get_default2column_html CHANGING ct_html.
    PERFORM data2rows USING &lt;fs_header&gt; &apos;S_TABL_FK_DEF&apos; &apos;FIELDNAME|CHECKTABLE|DDTEXT&apos; CHANGING ct_html.
    &quot; foreign key definitions
    PERFORM get_fk_fld_definition_html USING is_tabl-foreign_keys &lt;fs_header&gt;-fieldname CHANGING lv_tmp.
    PERFORM get_2column_right_table_html USING text_tabl-label_fk_flds lv_tmp CHANGING ct_html.
    &quot; screen check attributes: screen check flag differs from checkflag
    lv_screen_check = boolc( &lt;fs_header&gt;-checkflag EQ abap_false ).
    IF lv_screen_check IS NOT INITIAL OR &lt;fs_header&gt;-msgnr IS NOT INITIAL OR &lt;fs_header&gt;-arbgb IS NOT INITIAL.
      CONCATENATE text_tabl-label_check_rq lv_screen_check &apos;&amp;nbsp;&amp;nbsp; &apos; text_tabl-label_msg_no &lt;fs_header&gt;-msgnr &apos;&amp;nbsp;&amp;nbsp; &apos; text_tabl-label_aarea &lt;fs_header&gt;-arbgb
        INTO lv_tmp RESPECTING BLANKS.
      PERFORM get_2column_value_html USING text_tabl-label_screen_check lv_tmp CHANGING ct_html.
      CLEAR lv_tmp.
    ENDIF.
    &quot; semantic attributes
    lv_low = &lt;fs_header&gt;-frkart.
    PERFORM get_value_desc USING &apos;FRKART&apos; lv_low CHANGING lv_fkt.
    IF &lt;fs_header&gt;-cardleft IS NOT INITIAL OR &lt;fs_header&gt;-card IS NOT INITIAL.
      CONCATENATE &apos;&lt;br&gt;&apos; text_tabl-label_card &apos;[&apos; &lt;fs_header&gt;-cardleft &apos;&amp;nbsp;&amp;nbsp;:&amp;nbsp;&amp;nbsp;&apos; &lt;fs_header&gt;-card &apos;]&apos; INTO lv_card RESPECTING BLANKS.
    ENDIF.
    CONCATENATE text_tabl-label_fk_type lv_fkt lv_card INTO lv_tmp RESPECTING BLANKS.
    PERFORM get_2column_value_html USING text_tabl-label_fk_semantic lv_tmp CHANGING ct_html.
    CLEAR lv_tmp.

    APPEND gcv_table_end TO ct_html.
    APPEND &apos;&lt;br&gt;&apos; TO ct_html.
  ENDLOOP.
ENDFORM.

FORM get_fk_fld_definition_html USING it_fk_def TYPE t_tabl_fk_def iv_fieldname TYPE fieldname CHANGING cv_html TYPE string.
  DATA: lt_html   TYPE t_string,
        lt_fk_def TYPE t_tabl_fk_def.
  PERFORM get_fk_fld_def_by_name USING it_fk_def iv_fieldname CHANGING lt_fk_def.
  PERFORM convert_table_html USING &apos;&apos; lt_fk_def &apos;S_TABL_FK_DEF&apos;
        &apos;CHECKTABLE|CHECKFIELD|FORTABLE|FORKEY|GENERIC|CONSTANT&apos; abap_true &apos;GENERIC|CONSTANT&apos; abap_true CHANGING lt_html.
  PERFORM join_str USING lt_html CHANGING cv_html.
ENDFORM.

FORM get_fk_fld_def_by_name USING it_fk_def TYPE t_tabl_fk_def iv_fieldname TYPE fieldname CHANGING ct_fld_def TYPE t_tabl_fk_def.
  FIELD-SYMBOLS: &lt;fs_fk_def&gt; TYPE s_tabl_fk_def.
  LOOP AT it_fk_def ASSIGNING &lt;fs_fk_def&gt; WHERE fieldname EQ iv_fieldname.
    APPEND &lt;fs_fk_def&gt; TO ct_fld_def.
  ENDLOOP.
ENDFORM.

FORM get_tabl_namespace_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
* only transparent table with delivery class E need to display namespace maintainance settings
  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-contflag EQ &apos;E&apos; AND is_tabl-namespace IS NOT INITIAL.
  PERFORM table2html USING text_tabl-title_namespace is_tabl-namespace &apos;TRESC&apos; &apos;FIELDNAME|KEYLOW&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.

FORM get_tabl_index_html USING is_tabl TYPE s_tabl CHANGING ct_html TYPE STANDARD TABLE.
  CHECK is_tabl-tabclass EQ &apos;TRANSP&apos; AND is_tabl-index IS NOT INITIAL.
  PERFORM table2html USING text_tabl-title_index is_tabl-index &apos;S_TABL_INDEX&apos; &apos;&apos; abap_false &apos;&apos; CHANGING ct_html.
ENDFORM.
***************** Table Close *****************

***************** Table Definition Begin *****************
FORM getdata_tabd USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  PERFORM getdata_tabl_reuse USING is_obj_header.
ENDFORM.

FORM get_special_html_tabd USING is_tabd TYPE s_tabd CHANGING ct_html TYPE STANDARD TABLE. &quot;#EC CALLED
  PERFORM get_special_html_tabl USING is_tabd CHANGING ct_html.
ENDFORM.
***************** Table Definition Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_TABT" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Table Technical Setting - Data Retrive &amp; HTML Conversion Routine" LENGTH="70 "/>
   </language>
  </textPool>
  <source>***************** Technical Attributes of a Table Begin *****************
TYPES: BEGIN OF s_tabt.
        INCLUDE TYPE s_obj_header.
TYPES: tech_setting TYPE dd09v.
TYPES: END OF s_tabt.
DATA gt_tabt TYPE TABLE OF s_tabt.                          &quot;#EC NEEDED

FORM getdata_tabt USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_tabt  TYPE s_tabt,
        lv_ddobj TYPE ddobjname.

  MOVE-CORRESPONDING is_obj_header TO ls_tabt.
  lv_ddobj = ls_tabt-obj_name.
  CALL FUNCTION &apos;DDIF_TABT_GET&apos;
    EXPORTING
      name          = lv_ddobj
      state         = &apos;A&apos;
    IMPORTING
      dd09l_wa      = ls_tabt-tech_setting
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_tabt-tech_setting IS NOT INITIAL.

  APPEND ls_tabt TO gt_tabt.
ENDFORM.

FORM get_special_html_tabt USING is_tabt TYPE s_tabt CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM get_techsetting_html USING is_tabt-tech_setting CHANGING ct_html.
ENDFORM.
***************** Technical Attributes of a Table Close *****************

***************** Table Index Begin *****************
TYPES: t_dd17v TYPE STANDARD TABLE OF dd17v WITH DEFAULT KEY.
TYPES: BEGIN OF s_indx.
        INCLUDE TYPE s_obj_header.
TYPES: header TYPE dd12v.
TYPES: fields TYPE string.
TYPES: END OF s_indx.
DATA gt_indx TYPE TABLE OF s_indx.                          &quot;#EC NEEDED

FORM getdata_indx USING is_obj_header TYPE s_obj_header.    &quot;#EC CALLED
  DATA: ls_indx     TYPE s_indx,
        lv_table    TYPE ddobjname,
        lt_dd17v    TYPE TABLE OF dd17v,
        lv_index_id TYPE ddobjectid.
  MOVE-CORRESPONDING is_obj_header TO ls_indx.
  CALL FUNCTION &apos;DDIF_INDX_GET&apos;
    EXPORTING
      name          = lv_table
      id            = lv_index_id
      state         = &apos;A&apos;
      langu         = sy-langu
    IMPORTING
      dd12v_wa      = ls_indx-header
    TABLES
      dd17v_tab     = lt_dd17v
    EXCEPTIONS
      illegal_input = 1
      OTHERS        = 2.                                    &quot;#EC FB_RC
  PERFORM handle_rc USING is_obj_header.
  CHECK sy-subrc EQ 0 AND ls_indx-header IS NOT INITIAL AND ls_indx-fields IS NOT INITIAL.
  PERFORM collect_tab_fld USING lt_dd17v &apos;FIELDNAME&apos; `, ` CHANGING ls_indx-fields.
  APPEND ls_indx TO gt_indx.
ENDFORM.

FORM get_additional_html_indx USING is_indx TYPE s_indx CHANGING ct_html TYPE t_string. &quot;#EC CALLED
  PERFORM data2rows_common USING is_indx-header &apos;DD12V&apos; &apos;SQLTAB|INDEXNAME|UNIQUEFLAG|DBINDEX|DBSTATE|FIELDS&apos; abap_false CHANGING ct_html.
  IF is_indx-header-dbstate EQ &apos;D&apos;.
    PERFORM data2rows USING is_indx-header &apos;DD12V&apos; &apos;DBINCLEXCL|DBSYSSEL1|DBSYSSEL2|DBSYSSEL3|DBSYSSEL4&apos; CHANGING ct_html.
  ENDIF.
ENDFORM.
***************** Table Index Close *****************</source>
 </PROG>
 <PROG NAME="YNOT_TEST" VARCL="X" SUBC="1" RSTAT="T" RMAND="002" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT Robusty Test Tool" LENGTH="58 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  YNOT_TEST
*&amp;---------------------------------------------------------------------*
*&amp; To ensure YNOT works well for any transport request
*&amp; we need to test it via input hundreds of them
*&amp;---------------------------------------------------------------------*

REPORT  ynot_test.
SELECTION-SCREEN BEGIN OF BLOCK b0 WITH FRAME TITLE gc_test.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_cnt FOR FIELD p_cnt.
PARAMETERS: p_cnt TYPE i AS LISTBOX VISIBLE LENGTH 20.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(31) gc_dir FOR FIELD p_dir.
PARAMETERS: p_dir TYPE string DEFAULT &apos;C:\TMP\YNOT_TEST&apos;.
SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK b0.

INITIALIZATION.
  gc_test = &apos;YNOT Test Tool&apos;.
  gc_cnt = &apos;Select Transport Request Maxmum Count&apos;.
  gc_dir = &apos;Select Export Folder&apos;.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_dir.
  PERFORM select_download_dir IN PROGRAM ynot_all_in_one CHANGING p_dir.

AT SELECTION-SCREEN.
  IF p_cnt IS INITIAL OR p_cnt LT 0.
    MESSAGE &apos;Please input request maxmum count number.&apos; TYPE &apos;E&apos;.
  ENDIF.
  IF p_dir IS INITIAL.
    MESSAGE &apos;Please select export folder.&apos; TYPE &apos;E&apos;.
  ENDIF.

AT SELECTION-SCREEN OUTPUT.
  PERFORM count_dropdown.

START-OF-SELECTION.
  TYPES: t_string TYPE TABLE OF string WITH DEFAULT KEY.
  TYPES: BEGIN OF tr_msg,
         trkorr TYPE e070-trkorr,
         err_msgs TYPE t_string,
         END OF tr_msg.

  DATA: lt_e070     TYPE TABLE OF e070,
        lt_msg      TYPE t_string,
        ls_tr_msg   TYPE tr_msg,
        lt_tr_msg   TYPE TABLE OF tr_msg,
        lt_rsparam  TYPE TABLE OF rsparams,
        ls_rsparam  TYPE rsparams,
        lv_trlike   TYPE string,
        lv_begin    TYPE i,
        lv_end      TYPE i,
        lv_cost     TYPE i.
  FIELD-SYMBOLS &lt;fs_e070&gt; TYPE e070.
* only fetch change request under current system
  CONCATENATE sy-sysid &apos;%&apos; INTO lv_trlike.
  SELECT * FROM e070 INTO TABLE lt_e070
    UP TO p_cnt ROWS
    WHERE trstatus EQ &apos;R&apos; AND trfunction EQ &apos;K&apos; AND strkorr EQ &apos;&apos;
    AND trkorr LIKE lv_trlike ORDER BY as4date DESCENDING.

  GET RUN TIME FIELD lv_begin.
  LOOP AT lt_e070 ASSIGNING &lt;fs_e070&gt;.
    ls_rsparam-selname = &apos;SO_TRANS&apos;.
    ls_rsparam-low = &lt;fs_e070&gt;-trkorr.
    ls_rsparam-sign = &apos;I&apos;.
    ls_rsparam-option = &apos;EQ&apos;.
    APPEND ls_rsparam TO lt_rsparam.
    CLEAR ls_rsparam.

    ls_rsparam-selname = &apos;P_DIR&apos;.
    ls_rsparam-low = p_dir.
    ls_rsparam-sign = &apos;I&apos;.
    ls_rsparam-option = &apos;EQ&apos;.
    APPEND ls_rsparam TO lt_rsparam.
    CLEAR ls_rsparam.

    ls_rsparam-selname = &apos;P_DOC&apos;.
    ls_rsparam-low = &lt;fs_e070&gt;-trkorr.
    ls_rsparam-sign = &apos;I&apos;.
    ls_rsparam-option = &apos;EQ&apos;.
    APPEND ls_rsparam TO lt_rsparam.
    CLEAR ls_rsparam.

    ls_rsparam-selname = &apos;P_BIN&apos;.
    ls_rsparam-low = abap_true.
*   switch whether download transport files here
    ls_rsparam-low = abap_false.
    ls_rsparam-sign = &apos;I&apos;.
    ls_rsparam-option = &apos;EQ&apos;.
    APPEND ls_rsparam TO lt_rsparam.
    CLEAR ls_rsparam.

    ls_rsparam-selname = &apos;EXPORT&apos;.
    ls_rsparam-low = abap_true.
    ls_rsparam-sign = &apos;I&apos;.
    ls_rsparam-option = &apos;EQ&apos;.
    APPEND ls_rsparam TO lt_rsparam.
    CLEAR ls_rsparam.

* in test mode, we won&apos;t write result and always overwrite
    ls_rsparam-selname = &apos;P_TEST&apos;.
    ls_rsparam-low = abap_true.
    ls_rsparam-sign = &apos;I&apos;.
    ls_rsparam-option = &apos;EQ&apos;.
    APPEND ls_rsparam TO lt_rsparam.
    CLEAR ls_rsparam.

    SUBMIT ynot_all_in_one WITH SELECTION-TABLE lt_rsparam AND RETURN.

    CLEAR lt_rsparam.
  ENDLOOP.

  GET RUN TIME FIELD lv_end.
  lv_cost = ( lv_end - lv_begin ) / ( 1000 * 1000 ).
  DATA: lv_numc TYPE n LENGTH 6,
        lv_msg  TYPE string.
  lv_numc = lv_cost.
  CONCATENATE &apos;Finished in &apos; lv_numc &apos; Seconds.&apos; INTO lv_msg RESPECTING BLANKS.
  MESSAGE s208(00) WITH lv_msg.

FORM count_dropdown.
  DATA: lt_cnt  TYPE vrm_values,
        ls_cnt  TYPE vrm_value.

  ls_cnt-key = 10.
  ls_cnt-text = &apos;Up To 10 Requests&apos;.
  APPEND ls_cnt TO lt_cnt.

  ls_cnt-key = 50.
  ls_cnt-text = &apos;Up To 50 Requests&apos;.
  APPEND ls_cnt TO lt_cnt.

  ls_cnt-key = 100.
  ls_cnt-text = &apos;Up To 100 Requests&apos;.
  APPEND ls_cnt TO lt_cnt.

  ls_cnt-key = 500.
  ls_cnt-text = &apos;Up To 500 Requests&apos;.
  APPEND ls_cnt TO lt_cnt.

  ls_cnt-key = 1000.
  ls_cnt-text = &apos;Up To 1000 Requests&apos;.
  APPEND ls_cnt TO lt_cnt.

  ls_cnt-key = 5000.
  ls_cnt-text = &apos;Up To 5000 Requests&apos;.
  APPEND ls_cnt TO lt_cnt.

  ls_cnt-key = 10000.
  ls_cnt-text = &apos;Up To 10000 Requests&apos;.
  APPEND ls_cnt TO lt_cnt.

  CALL FUNCTION &apos;VRM_SET_VALUES&apos;
    EXPORTING
      id              = &apos;P_CNT&apos;
      values          = lt_cnt
    EXCEPTIONS
      id_illegal_name = 1
      OTHERS          = 2.
ENDFORM.</source>
 </PROG>
 <PROG NAME="YNOT_TEXTS" VARCL="X" SUBC="I" RSTAT="T" RMAND="002" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="YNOT: Texts i18n Handling" LENGTH="53 "/>
   </language>
  </textPool>
  <source>***************** i18n Begin *****************
FORM init_texts USING iv_langu TYPE sy-langu.
  IF iv_langu EQ &apos;D&apos;.
    PERFORM init_german_texts.
  ELSE.
    PERFORM init_english_texts.
  ENDIF.
  PERFORM init_object_instructions.
ENDFORM.

FORM init_english_texts.
* selection screen texts
  gc_case   = &apos;Scenario Selection&apos;.
  gc_exp    = &apos;Generate Note Pre-Impl Documentation&apos;.
  gc_imp    = &apos;Upload Transport Files&apos;.
  gc_code   = &apos;Code Helper For New Object Type&apos;.
  gc_opt    = &apos;Options&apos;.
  gc_trans  = &apos;Transport Request&apos;.
  gc_exclu  = &apos;Excluded Objects&apos;.
  gc_dir    = &apos;Export Folder&apos;.
  gc_doc    = &apos;Document Title&apos;.
  gc_open   = &apos;Open Document In MS Word&apos;.
  gc_bin    = &apos;Download Transport Files&apos;.
  gc_file   = &apos;Upload Transport File(Zip)&apos;.
  gc_objt   = &apos;New Object Types&apos;.
* documentation/message texts
  gcv_text_unexpected_error = &apos;An unexpected error occurred.&apos;.
  text_common-label_col_attr = &apos;Attribute&apos;.
  text_common-label_col_value = &apos;Value&apos;.
  text_common-title_tobj = &apos;Maintenance Object&apos;.
  text_common-title_html = &apos;Note Pre-Impl Documentation&apos;.
  text_common-txt_notice = &apos;Dear customer, please maintain objects in the below refer to this documentation and your own system settings.&apos; &amp;
                           &apos;In case some of the objects exist already and are exactly same as described in the documentation, you may simply igore them.&apos;.
  text_common-msg_success = &apos;Success&apos;.
  text_common-msg_ignore = &apos;Ignored.Nothing needs to be done on this object&apos;.
  text_common-msg_error = &apos;Failed&apos;.
  text_common-msg_error_msg = &apos;Error Message&apos;.
  text_common-rep_none = &apos;Dear $USERNAME, it seems there is no need to prepare documentation for the not.&apos;.
  text_common-rep_docu = &apos;Dear $USERNAME, here is documentation generation report : &apos;.
  text_common-action_en = &apos;Please open the generated html file using MS Office Word, save as DOCX&apos;.
  text_common-action2_en = &apos;Then review and make necessary modifications for your usage.&apos;.
  text_common-action_de = &apos;Please open the generated html file using IE , copy all the content to Word and save.&apos;.
  text_common-thanks = &apos;Thank you for using this tool, have a nice day ^_^&apos;.
  text_common-time_cost = &apos;Job finished in $TIME seconds.&apos;.

  text_devc-label_tp_layer = &apos;Transport Layer&apos;.
  text_devc-txt_tp_note = &apos;&lt;i style=mso-bidi-font-style:normal&gt;&lt;span style=color:red&gt;&apos; &amp;
                          &apos;Please fill in according to your own system landscape settings&apos; &amp;
                          &apos;&lt;/span&gt;&lt;/i&gt;&apos;.
  text_devc-title_access = &apos;Use Accesses&apos;.
  text_devc-title_interface = &apos;Package Interfaces&apos;.

  text_doma-label_value_range = &apos;Value Range&apos;.

  text_dtel-label_domain = &apos;Domain&apos;.
  text_dtel-label_data_type = &apos;Data Type &apos;.
  text_dtel-label_predf_type = &apos;Predefined type&apos;.
  text_dtel-label_fld_lab = &apos;Field Label&apos;.
  text_dtel-label_length = &apos;Length&apos;.
  text_dtel-label_short = &apos;Short&apos;.
  text_dtel-label_medium = &apos;Medium&apos;.
  text_dtel-label_long = &apos;Long&apos;.
  text_dtel-label_heading = &apos;Heading&apos;.
  text_dtel-txt_mt_docu_title = &apos;Maintain documentation for this data element:&apos;.
  text_dtel-txt_mt_docu_para = &apos;Please add documentation according to the format and content listed in the below.&lt;br&gt;&apos;.

  text_tabl-title_tech = &apos;Technical Settings:&apos;.
  text_tabl-label_fk_flds = &apos;Foreign Key Fields&apos;.
  text_tabl-title_flds = &apos;Fields: &apos;.
  text_tabl-title_comps = &apos;Components: &apos;.

  DATA lcv_note_fc TYPE string.
  lcv_note_fc = &apos;Please notice that those $ELE marked as italic are contained in included structure/table and you &lt;b&gt;DON&apos;&apos;T&lt;/b&gt; need to add them.&apos;.
  text_tabl-note_flds = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_flds WITH &apos;fields&apos;.
  text_tabl-note_comps = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_comps WITH &apos;components&apos;.

  text_tabl-title_fks = &apos;Foreign Keys:&apos;.
  text_tabl-note_fks = &apos;Maintain foreign key relationship for field: &apos;.
  text_tabl-title_namespace = &apos;Maintain Customer Namespace: &apos;.
  text_tabl-title_index = &apos;Indexes:&apos;.
  text_tabl-label_check_rq = &apos;Check required: &apos;.
  text_tabl-label_msg_no = &apos;MsgNo: &apos;.
  text_tabl-label_aarea = &apos;AArea: &apos;.
  text_tabl-label_screen_check = &apos;Screen check&apos;.
  text_tabl-label_card = &apos;Cardinality: &apos;.
  text_tabl-label_fk_type = &apos;Foreign key field type: &apos;.
  text_tabl-label_fk_semantic = &apos;Semantic attributes&apos;.

  text_view-title_tables = &apos;Tables: &apos;.
  text_view-title_join_conds = &apos;Join Conditions: &apos;.
  text_view-title_sel_conds = &apos;Selection conditions: &apos;.
  text_view-title_fields = &apos;View Flds:&apos;.
  text_view-note_join_cond = &apos;&lt;i&gt;No additional join condition needs to be maintained here.&lt;/i&gt;&apos;.
  text_view-note_sel_cond = &apos;&lt;i&gt;No additional selection condition needs to be maintained here.&lt;/i&gt;&apos;.

  text_enqu-label_allow_rfc = &apos;Allow RFC&apos;.
  text_enqu-label_tables = &apos;Tables&apos;.
  text_enqu-label_params = &apos;Parameters&apos;.

  text_shlp-txt_type_ele = &apos;Elementary&apos;.
  text_shlp-txt_type_col = &apos;Collective&apos;.
  text_shlp-txt_type = &apos;Type&apos;.

  text_ttyp-label_row_type = &apos;Line Type&apos;.

  text_msag-label_messages = &apos;Messages&apos;.

  text_mess-txt_title = &apos;Maintain messages with short text under message class as listed in the below&lt;br&gt;&apos;.
  text_mess-txt_mt_longtext = &apos;Maintain long text for message: &apos;.

  text_tobj-msg_obj_invalid = &apos;Maintenance Object does not exist any more, it might be deleted by someone else.&apos;.
  text_tobj-label_events = &apos;Events&apos;.
  text_tobj-txt_mt_event = &apos;In the maintenance object screen, click menu Enviroment-&gt;Modification-&gt;Events, &apos; &amp;
                           &apos;click &apos;&apos;New Entries&apos;&apos; button, input event type and FORM routine name, then save.&apos; &amp;
                           &apos;The code of the routines will be imported in the process of implementing note&apos;.

  text_vcls-title_obj_stru = &apos;Object Structure&apos;.
  text_vcls-title_fld_dep = &apos;Field Dependence&apos;.
  text_vcls-title_events = text_tobj-label_events.
  text_vcls-label_hier = &apos;Hierarchical Maintenance Operation Handling&apos;.
  text_vcls-label_type = &apos;Read Type&apos;.
  text_vcls-txt_type_comp = &apos;Complete&apos;.
  text_vcls-txt_type_sub = &apos;Subtree&apos;.
  text_vcls-txt_mt_event = &apos;In the maintenance screen of view cluster, double click node &apos;&apos;Events&apos;&apos;, &apos; &amp;
                           &apos;input main program name, event type, form routine and save.&apos;.

  text_tran-label_type           = &apos;Transaction Type&apos;.
  text_tran-label_default_values = &apos;Default Values&apos;.
  text_tran-label_classification = &apos;Classfication&apos;.
  text_tran-label_inherit_gui    = &apos;Inherit GUI Attributes&apos;.
  text_tran-label_prof_user      = &apos;Professional User Transaction&apos;.
  text_tran-label_easy_web       = &apos;Easy Web Transaction&apos;.
  text_tran-label_service        = &apos;Service&apos;.
  text_tran-label_pervasive      = &apos;Pervasive enabled&apos;.
  text_tran-label_auth_values    = &apos;Values&apos;.
  text_tran-label_oo_mode        = &apos;OO Transaction Mode&apos;.
  text_tran-label_oo_clas        = &apos;Class Name&apos;.
  text_tran-label_oo_meth        = &apos;Method&apos;.
  text_tran-label_oo_local_prog  = &apos;Local In Program&apos;.
  text_tran-label_oo_update_mode = &apos;Update mode&apos;.
  text_tran-label_transaction    = &apos;Transaction&apos;.
  text_tran-label_transaction_variant = &apos;Transaction Variant&apos;.
  text_tran-label_skip_init_screen    = &apos;Skip initial screen&apos;.

  text_tabu-txt_maint_node = &apos;Maintain entries for node : &apos;.
* instructions of supported object types
  text_devc-inst_devc = &apos;Run TCODE SE80 and enter in Repository Browser, select &apos;&apos;Package&apos;&apos; from dropdown list, &apos; &amp;
            &apos;input package name and press enter, click &apos;&apos;Yes&apos;&apos; in the pop up dialog box to create package, &apos; &amp;
            &apos;input necessary attribute values according to the documentation and save.&apos;.
  text_devc-inst_devp = &apos;Run TCODE SE21, input package name listed in the below, click &apos;&apos;Change&apos;&apos; button,&apos; &amp;
            &apos; click &apos;&apos;Use Accesses&apos;&apos; tab, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;&amp;
            &apos;input package interface name and error severity according to the documentation and save.&apos;.
  text_devc-inst_pinf = &apos;Run TCODE SE21, input package name listed in the below, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
            &apos;click &apos;&apos;Package Interfaces&apos;&apos; tab, click &apos;&apos;Add&apos;&apos; button, &apos; &amp;
            &apos;input package interface name and short description according to documentation and save.&apos;.
  text_devc-inst_devp_sub = &apos;Click &apos;&apos;Use Accesses&apos;&apos; tab, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
            &apos;input package interface name and error severity according to the documentation and save.&apos;.
  text_devc-inst_pinf_sub = &apos;Click &apos;&apos;Package Interfaces&apos;&apos; tab, click &apos;&apos;Add&apos;&apos; button, &apos; &amp;
            &apos;input package interface name and short description according to documentation and save.&apos;.
  text_fugr-inst_fugr = &apos;Select package where function group will be created, right click-&gt;Create-&gt;Function Group, &apos; &amp;
                        &apos;input attribute values and save.&apos;.
  text_fugr-inst_fugt = &apos;Select function group and right click-&gt;Change, input attribute values and save.&apos;.
  text_doma-inst_doma = &apos;Run TCODE SE11, select radio box &apos;&apos;Domain&apos;&apos;, input domain name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;input attribute values, save and activate.&apos;.
  text_dtel-inst_dtel = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input data element name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Data element&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tabl-inst_tabl = &apos;Run TCODE SE11, for database table, select radio box &apos;&apos;Database table&apos;&apos;, input table name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;maintain the attributes, fields, technical settings, indexes and etc.&apos; &amp;
                        &apos;For structure, select radio box &apos;&apos;Data type&apos;&apos;, input structure name, &apos; &amp;&amp;
                        &apos;click &apos;&apos;Create&apos;&apos; button, select radio box &apos;&apos;Structure&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tabl-inst_tabd = &apos;Run TCODE SE11, select radio box &apos;&apos;Database table&apos;&apos;, input table/structure name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;maintain the attributes, then save and activate.&apos;.
  text_view-inst_view = &apos;Run TCODE SE11, select radio box &apos;&apos;View&apos;&apos;, input view name, click &apos;&apos;Create&apos;&apos; button, select the view type,&apos; &amp;
                        &apos; maintain attributes, table/join conditions, &apos; &amp;
                        &apos;View fields, Selection Conditions, Maint Status and etc, then save and activate.&apos;.
  text_view-inst_vied = &apos;Run TCODE SE11, select radio box &apos;&apos;View&apos;&apos;, input view name, click &apos;&apos;Change&apos;&apos; button, maintain attributes, &apos; &amp;
                        &apos;table/join conditions, View fields, Selection Conditions, Maint Status and etc, then save and activate.&apos;.
  text_shlp-inst_shlp = &apos;Run TCODE SE11, select radio box &apos;&apos;Search help&apos;&apos;, input search help name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;select the search help type, maintain attributes, search help parameters and etc, then save and activate.&apos;.
  text_enqu-inst_enqu = &apos;Run TCODE SE11, select radio box &apos;&apos;Lock Object&apos;&apos;, input lock object name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;maintain attributes, tables, lock parameters and etc, then save and activate.&apos;.
  text_ttyp-inst_ttyp = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input table type name, click &apos;&apos;Create&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Table Type&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tobj-inst_tobj = &apos;Run TCODE SE54, input maintenance view name, select radio box &apos;&apos;Generated Objects&apos;&apos;, click &apos;&apos;Create/Change&apos;&apos; button, &apos; &amp;&amp;
                        &apos;select &apos;&apos;Yes&apos;&apos; in the popup confirmation dialog box, input attribute values and click the create button above, &apos; &amp;
                        &apos;choose package according to documentation and save.&apos;.
  text_nrob-inst_nrob = &apos;Run TCODE SNRO, input number range object name, click &apos;&apos;Create&apos;&apos; button, input attribute values and save, &apos; &amp;
                        &apos;choose package according to documentation.&apos;.
  text_msag-inst_msad = &apos;Run TCODE SE91, input message class name and click &apos;&apos;Create&apos;&apos; button, input attribute values, messages and save,&apos; &amp;
                        &apos; choose package according to documentation.&apos;.
  text_msag-inst_msag =  text_msag-inst_msad.
  text_msag-inst_mess = &apos;Run TCODE SE91, input message class name and click &apos;&apos;Change&apos;&apos; button, maintain message short texts, &apos; &amp;
                        &apos;for message with long text, uncheck the checkbox &apos; &amp;
                        &apos;&apos;&apos;Self-explanatory&apos;&apos;, then click menu &apos;&apos;Long text&apos;&apos;, maintain the long text according to documentation.&apos;.
  text_docu-inst_docu = &apos;For data element, run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input data element name and click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos; click menu &apos;&apos;Documentation&apos;&apos; and maintain the documentation as described in the below.&lt;br&gt;&apos; &amp;&amp;
                        &apos;For long text of message short text, run TCODE SE91, input message class name and click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select the message, uncheck the checkbox &apos;&apos;Self-explanatory&apos;&apos;, then click menu &apos;&apos;Long text&apos;&apos;, &apos; &amp;
                        &apos;maintain the long text as described in the below.&apos;.
  text_tran-inst_tran = &apos;Run TCODE SE93, input transaction code, click &apos;&apos;Create&apos;&apos; button, if &apos; &amp;
                        &apos;input short text and select Start object, if it already exists, simply ignore it, if not, &apos; &amp;
                        &apos;maintain the attribute values and choose package according to documentation, then save your work.&apos;.
  text_doma-inst_domd = &apos;Run TCODE SE11, select radio box &apos;&apos;Domain&apos;&apos;, input domain name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;input attribute values, save and activate.&apos;.
  text_dtel-inst_dted = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input data element name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Data element&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_tabl-inst_tabt = &apos;Run TCODE SE11, select radio box &apos;&apos;Database table&apos;&apos;, input table name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;click menu &apos;&apos;Technical Settings&apos;&apos;, maintain attribute values according documentation and save.&apos;.
  text_tabl-inst_indx = &apos;Run TCODE SE11, select radio box &apos;&apos;Database table&apos;&apos;, input table name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;click menu &apos;&apos;Indexes&apos;&apos;, maintain attribute values according documentation and save.&apos;.
  text_ttyp-inst_ttyd = &apos;Run TCODE SE11, select radio box &apos;&apos;Data type&apos;&apos;, input table type name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select radio box &apos;&apos;Table Type&apos;&apos;, input attribute values, then save and activate.&apos;.
  text_shlp-inst_shld = &apos;Run TCODE SE11, select radio box &apos;&apos;Search help&apos;&apos;, input search help name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;select the search help type, maintain attributes, search help parameters and etc, then save and activate.&apos;.
  text_enqu-inst_enqd = &apos;Run TCODE SE11, select radio box &apos;&apos;Lock Object&apos;&apos;, input lock object name, click &apos;&apos;Change&apos;&apos; button, &apos; &amp;
                        &apos;maintain attributes, tables, lock parameters and etc, then save and activate.&apos;.
  text_view-inst_viet = &apos;Run TCODE SE11, select radio box &apos;&apos;View&apos;&apos;, input view name, click &apos;&apos;Change&apos;&apos; button,  &apos; &amp;
                        &apos;click menu &apos;&apos;Goto&apos;&apos;-&gt;&apos;&apos;Technical Settings&apos;&apos;, maintain attribute values, then save and activate.&apos;.
  text_docu-inst_doct = &apos;&apos;.
  text_docu-inst_docv = &apos;&apos;.

  DATA: lcv_inst_dat TYPE string.
  lcv_inst_dat = &apos;Run TCODE $CODE, input $DATYPE name, click button &apos;&apos;Maintain&apos;&apos;,&apos; &amp;
          &apos; if warning message&apos;&apos;Caution: The table is cross-client&apos;&apos; popup, &apos; &amp; &apos;simply confirm it, then add entries in the below.&lt;br&gt;&apos; &amp;&amp;
          &apos;Notice that these entries might be dependent on other repository ojects, if you cannot go further, &apos; &amp;
          &apos;try to add the dependent objects first or do it again after implementing the note.&apos; &amp;&amp;
          &apos;Meanwhile, only those fields have a valid value need to maintain are listed, &apos; &amp;
          &apos;which means you don&apos;&apos;t need to care about other fields.&apos;.
  text_tabu-inst_cdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_cdat WITH &apos;SM34&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_cdat WITH &apos;view cluster&apos;.

  text_tabu-inst_vdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_vdat WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_vdat WITH &apos;maintenance view&apos;.

  text_tabu-inst_tabu = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_tabu WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_tabu WITH &apos;table&apos;.
ENDFORM.

FORM init_german_texts.
* I&apos;m sorry, but most of these German texts are actually translated by google and babylon...
* Auswahl Bildschirm Texte
  gc_case = &apos;Szenario Auswahl&apos;.
  gc_exp = &apos;erzeugen Anmerkung Vor-einführen Dokumentation&apos;.
  gc_imp = &apos;Antriebskraft-Transport-Dateien&apos;.
  gc_code = &apos;Kodieren Sie Helfer für neuen Objekt-Typ&apos;.
  gc_opt = &apos;Optionen&apos;.
  gc_trans = &apos;Transport-Antrag&apos;.
  gc_exclu = &apos;Ausgeschlossene Objekte&apos;.
  gc_dir = &apos;Export-Ordner&apos;.
  gc_doc = &apos;Dokument Title&apos;.
  gc_open = &apos;Offenes Dokument im Wort&apos;.
  gc_bin = &apos;Herunterladen Transport Files&apos;.
  gc_file = &apos;Hochladen Transport-Datei (zip)&apos;.
  gc_objt = &apos;Neue Objekt-Typen der&apos;.
* Dokumentation / Meldetexte
  gcv_text_unexpected_error = &apos;Ein unerwarteter Fehler ist aufgetreten.&apos;.
  text_common-label_col_attr = &apos;Attribut&apos;.
  text_common-label_col_value = &apos;Value&apos;.
  text_common-title_tobj = &apos;Wartung Object&apos;.
  text_common-title_html = &apos;Hinweis Pre-Impl Dokumentation&apos;.
  text_common-txt_notice = &apos;Sehr geehrter Kunde, bitte halten Objekte in der unten an dieser Dokumentation und Ihr eigenes System Einstellungen beziehen.&apos; &amp;&amp;
                           &apos;Bei einigen der Objekte bereits vorhanden sind und genau das gleiche wie in der Dokumentation beschrieben, können Sie einfach igore ihnen.&apos;.
  text_common-msg_success = &apos;Erfolg&apos;.
  text_common-msg_ignore = &apos;Ignored.Nothing muss auf diesem Gegenstand getan werden&apos;.
  text_common-msg_error = &apos;Ausfallen&apos;.
  text_common-msg_error_msg = &apos;Fehlermeldung&apos;.
  text_common-rep_none = &apos;Lieber $USERNAME, scheint es, dass es keinen Bedarf gibt, Dokumentation für die Anmerkung vorzubereiten.&apos;.
  text_common-rep_docu = &apos;Lieber $USERNAME, ist hier Dokumentationsgenerationsbericht : &apos;.
  text_common-action_en = &apos;Öffnen Sie bitte die erzeugte HTML-Datei unter Verwendung Mitgliedstaates Office Word, Abwehr als DOCX&apos;.
  text_common-action2_en = &apos;Dann wiederholen Sie und machen Sie notwendige Änderungen für Ihre Verwendung.&apos;.
  text_common-action_de = &apos;Öffnen Sie bitte die erzeugte HTML-Datei unter Verwendung IE, kopieren Sie den ganzen Inhalt, um abzufassen und zu speichern.&apos;.
  text_common-thanks = &apos;Danke für die Anwendung dieses Werkzeugs, haben Sie ein schöner Tag-^_^&apos;.
  text_common-time_cost = &apos;Job beendet in $TIME Sekunden.&apos;.

  text_devc-label_tp_layer = &apos;Transport Layer&apos;.
  text_devc-txt_tp_note = &apos;&lt;i style=mso-bidi-font-style:normal&gt;&lt;span style=color:red&gt;&apos; &amp;
                          &apos;Bitte in Bezug auf Ihre eigene Systemlandschaft Einstellungen füllen&apos; &amp;
                          &apos;&lt;/span&gt;&lt;/i&gt;&apos;.
  text_devc-title_access = &apos;Use Greift&apos;.
  text_devc-title_interface = &apos;Paket Interfaces&apos;.

  text_doma-label_value_range = &apos;Wert-Strecke&apos;.

  text_dtel-label_domain = &apos;Domain&apos;.
  text_dtel-label_data_type = &apos;Datentyp&apos;.
  text_dtel-label_predf_type = &apos;Vordefinierte Typ&apos;.
  text_dtel-label_fld_lab = &apos;Das Feld Label:&apos;.
  text_dtel-label_length = &apos;Länge&apos;.
  text_dtel-label_short = &apos;Kurzes&apos;.
  text_dtel-label_medium = &apos;mittleres&apos;.
  text_dtel-label_long = &apos;langes&apos;.
  text_dtel-label_heading = &apos;Überschrift&apos;.
  text_dtel-txt_mt_docu_title = &apos;Pflege der Dokumentation für dieses Datenelement:&apos;.
  text_dtel-txt_mt_docu_para = &apos;Bitte fügen Dokumentation nach Form und Inhalt in der unten. &lt;br&gt; aufgeführt.&apos;.

  text_tabl-title_tech = &apos;Technische Einstellungen:&apos;.
  text_tabl-label_fk_flds = &apos;Foreign Key Fields&apos;.
  text_tabl-title_flds = &apos;Fields:&apos;.
  text_tabl-title_comps = &apos;Komponenten:&apos;.

  DATA lcv_note_fc TYPE String.
  lcv_note_fc = &apos;Bitte beachten Sie, dass die $ELE als kursiv markiert inkludierten Struktur / Tabelle enthalten sind und Sie &lt;b&gt; DON&apos;&apos;T &lt;/b&gt; brauchen, um sie hinzuzufügen.&apos;.
  text_tabl-note_flds = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_flds WITH &apos;fields&apos;.
  text_tabl-note_comps = lcv_note_fc.
  REPLACE FIRST OCCURRENCE OF &apos;$ELE&apos; IN text_tabl-note_flds WITH &apos;Komponenten&apos;.

  text_tabl-title_fks = &apos;Foreign Keys:&apos;.
  text_tabl-note_fks = &apos;Pflegen Fremdschlüsselbeziehung für field:&apos;.
  text_tabl-title_namespace = &apos;Pflegen Kunde Namensraum:&apos;.
  text_tabl-title_index = &apos;Indexes:&apos;.
  text_tabl-label_check_rq = &apos;Check-in erforderlich:&apos;.
  text_tabl-label_msg_no = &apos;MsgNr:&apos;.
  text_tabl-label_aarea = &apos;AAREA:&apos;.
  text_tabl-label_screen_check = &apos;Bildschirm überprüfen&apos;.
  text_tabl-label_card = &apos;Kardinalität:&apos;.
  text_tabl-label_fk_type = &apos;Fremdschlüsselfeld Typ:&apos;.
  text_tabl-label_fk_semantic = &apos;Semantic Attribute&apos;.

  text_view-title_tables = &apos;Tabellen:&apos;.
  text_view-title_join_conds = &apos;Join-Bedingungen:&apos;.
  text_view-title_sel_conds = &apos;Selection Bedingungen:&apos;.
  text_view-title_fields = &apos;View Flds:&apos;.
  text_view-note_join_cond = &apos;&lt;i&gt; Keine zusätzliche Join-Bedingung muss hier gehalten werden. &lt;/i&gt;&apos;.
  text_view-note_sel_cond = &apos;&lt;i&gt; keine zusätzliche Auswahl Bedingung muss hier gehalten werden. &lt;/i&gt;&apos;.

  text_enqu-label_allow_rfc = &apos;Erlaube RFC&apos;.
  text_enqu-label_tables = &apos;Tabellen&apos;.
  text_enqu-label_params = &apos;Parameter&apos;.

  text_shlp-txt_type_ele = &apos;Elementary&apos;.
  text_shlp-txt_type_col = &apos;Collective&apos;.
  text_shlp-txt_type = &apos;Type&apos;.

  text_ttyp-label_row_type = &apos;Line Type&apos;.

  text_msag-label_messages = &apos;Nachrichten&apos;.

  text_mess-txt_title = &apos;Nachrichten pflegen mit kurzen Text unter Nachricht Klasse wie in der unten aufgeführten &lt;br&gt;&apos;.
  text_mess-txt_mt_longtext = &apos;Pflegen Langtext Nachricht:&apos;.

  text_tobj-msg_obj_invalid = &apos;Wartung Objekt nicht mehr existiert, könnte es von jemand anderem gelöscht werden.&apos;.
  text_tobj-label_events = &apos;Events&apos;.
  text_tobj-txt_mt_event = &apos;Im Instandhaltungsobjekt Bildschirm, klicken Sie auf Menü Enviroment-&gt; Modification-&gt; Veranstaltungen, &apos; &amp;&amp;
                           &apos;Klick &apos;&apos;New Entries&apos;&apos; Knopf, Eingang Event-Typ und FORM-Routine Namen, dann speichern. &apos; &amp;
                           &apos;Der Code der Routinen werden in den Prozess der Umsetzung beachten importiert werden.&apos;.

  text_vcls-title_obj_stru = &apos;Objekt-Struktur&apos;.
  text_vcls-title_fld_dep = &apos;Das Feld Dependence&apos;.
  text_vcls-title_events = text_tobj-label_events.
  text_vcls-label_hier = &apos;Hierarchische Instandhaltung Betrieb Handhabung&apos;.
  text_vcls-label_type = &apos;Read Type&apos;.
  text_vcls-txt_type_comp = &apos;Beenden&apos;.
  text_vcls-txt_type_sub = &apos;Subtree&apos;.
  text_vcls-txt_mt_event = &apos;In der Pflege von Viewclusters, doppelklicken Sie auf Knoten &apos;&apos;Events&apos;&apos;, Eingang Attributwerte und sparen.&apos;.

  text_tran-label_type           = &apos;Transaction Type&apos;.
  text_tran-label_default_values = &apos;Vorschlagswerte&apos;.
  text_tran-label_classification = &apos;Klassifikation&apos;.
  text_tran-label_inherit_gui    = &apos;GUI-Eigenschaften erben&apos;.
  text_tran-label_prof_user      = &apos;Professional User Transaction&apos;.
  text_tran-label_easy_web       = &apos;Easy Web Transaction&apos;.
  text_tran-label_service        = &apos;Service&apos;.
  text_tran-label_pervasive      = &apos;Pervasive enabled&apos;.
  text_tran-label_auth_values    = &apos;Werte&apos;.
  text_tran-label_oo_mode        = &apos;OO-Transaktionsmodell&apos;.
  text_tran-label_oo_clas        = &apos;Klassenname&apos;.
  text_tran-label_oo_meth        = &apos;Methode&apos;.
  text_tran-label_oo_local_prog  = &apos;lokal_in_Programm&apos;.
  text_tran-label_oo_update_mode = &apos;Verbuchungsmodus&apos;.
  text_tran-label_transaction    = &apos;Transaktion&apos;.
  text_tran-label_transaction_variant = &apos;Transaktionsvariante&apos;.
  text_tran-label_skip_init_screen    = &apos;Einstiegsbild überspringen&apos;.

  text_tabu-txt_maint_node = &apos;Pflegen Sie die Einträge für den Knoten:&apos;.
* Anweisungen der unterstützten Objekttypen
  text_devc-inst_devc = &apos;Run TCODE SE80 und geben in Repository Browser, wählen Sie&apos;&apos; Paket&apos;&apos; von Dropdown-Liste&apos; &amp;
            &apos;Input Paket Namen, klicken Sie auf&apos;&apos; Ja&apos;&apos; in der Pop-up-Dialogfeld Input notwendiges Attribut-Werte entsprechend der Dokumentation und sparen.&apos;.
  text_devc-inst_devp = &apos;Run TCODE SE21, Eingang Package-Namen in der unten aufgeführt ist, klicken&apos;&apos; ändern&apos;&apos; Knopf, klicken Sie auf &apos;&apos;Use Zugriffe Registerkarte auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;&amp;
            &apos;Input Paketschnittstelle Namen und Fehlerschwere entsprechend der Dokumentation und sparen.&apos;.
  text_devc-inst_pinf = &apos;Run TCODE SE21, Eingang Package-Namen in der unten aufgeführt ist, klicken&apos;&apos; ändern&apos;&apos; Knopf, klicken Sie auf &apos;&apos;Paketschnittstellen Registerkarte, klicken Sie auf&apos;&apos; Add&apos;&apos; Knopf,&apos; &amp;&amp;
            &apos;Input Paketschnittstelle Namen und eine kurze Beschreibung nach Dokumentation und sparen.&apos;.
  text_devc-inst_devp_sub = &apos;Klicken Sie auf &apos;&apos;Use Zugriffe Registerkarte auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;&amp;
            &apos;Input Paketschnittstelle Namen und Fehlerschwere entsprechend der Dokumentation und sparen.&apos;.
  text_devc-inst_pinf_sub = &apos;Klicken Sie auf &apos;&apos;&apos;&apos;Paketschnittstellen Registerkarte, klicken Sie auf&apos;&apos; Add&apos;&apos; Knopf,&apos; &amp;
            &apos;Input Paketschnittstelle Namen und eine kurze Beschreibung nach Dokumentation und sparen.&apos;.
  text_fugr-inst_fugr = &apos;Select-Paket, wo Funktion Gruppe erstellt werden soll, rechte Maustaste&gt; Create-&gt; Funktion Group, Eingang Attributwerte und sparen.&apos;.
  text_fugr-inst_fugt = &apos;Select Funktion Gruppe und klicken Sie rechts-&gt; Ändern Eingang Attributwerte und sparen.&apos;.
  text_doma-inst_doma = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Domain&apos;&apos;, Eingang Domain-Namen, klicken Sie auf&apos;&apos; Erstellen&apos;&apos; Knopf, Eingang Attributwerte, dann speichern und zu aktivieren.&apos;.
  text_dtel-inst_dtel = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Datentyp&apos;&apos;, Eingabedaten Element Name, auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;
                        &apos;Wählen Radiokasten&apos;&apos; Datenelement&apos;&apos;, Eingang Attributwerte, dann speichern und zu aktivieren.&apos;.
  text_tabl-inst_tabl = &apos;Run TCODE SE11, für Datenbank-Tabelle, wählen Sie Radio-Box &apos;&apos;Database Tabelle&apos;&apos;, Eingabe-Tabelle ein, klicken Sie &apos;&apos;erstellen&apos;&apos; Knopf,&apos; &amp;&amp;
                        &apos;Halten die Attribute, Felder, technischen Einstellungen, Indizes und etc.&apos; &amp;
                        &apos;Für Struktur, wählen Sie Radio-Box &apos;&apos;Datentyp&apos;&apos;, Input-Struktur name, &apos; &amp;&amp;
                        &apos;Klick &apos;&apos;&apos;&apos; erstellen, wählen Sie Radio-Box&apos;&apos; Struktur&apos;&apos;, Eingang Attributwerte, dann speichern und zu aktivieren. &apos;.
  text_tabl-inst_tabd = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Datenbank&apos;&apos; Tisch, Eingang Tabelle / Struktur Namen, auf&apos;&apos; ändern&apos;&apos; Knopf, pflegen Sie die Attribute, dann speichern und zu aktivieren.&apos;.
  text_view-inst_view = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Ansicht&apos;&apos;, Eingang Ansicht Name, klicken Sie auf&apos;&apos; Erstellen&apos;&apos; Knopf, &apos; &amp;&amp;
                        &apos;wählen Sie die Ansicht Typ, pflegen Attribute, Tisch / Join-Bedingungen,&apos; &amp;
                        &apos;View Felder, Selection AGB, Status-und Wa. etc, dann speichern und zu aktivieren.&apos;.
  text_view-inst_vied = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Ansicht&apos;&apos;, Eingang Ansicht Name, klicken Sie auf&apos;&apos; ändern&apos;&apos; Knopf, pflegen Attribute, Tisch / Join-Bedingungen,&apos; &amp;
                        &apos;View Felder, Selection AGB, Status-und Wa. etc, dann speichern und zu aktivieren.&apos;.

  text_shlp-inst_shlp = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Suchhilfe&apos;&apos;, Eingang Suchhilfe Namen, auf&apos;&apos; Erstellen&apos;&apos; Taste, wählen Sie die Suchhilfe Art pflegen Attribute&apos; &amp;
                        &apos;Suchhilfeparameter und etc, dann speichern und zu aktivieren.&apos;.
  text_enqu-inst_enqu = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Sperrobjektname&apos;&apos;, Eingang Sperrobjektname auf&apos;&apos; Erstellen&apos;&apos; Knopf, pflegen Attribute&apos; &amp;
                        &apos;Tische, Sperrparameter und etc, dann speichern und zu aktivieren. &apos;.
  text_ttyp-inst_ttyp = &apos;Run TCODE SE11, wählen Sie Radio-Box&apos;&apos; Datentyp&apos;&apos;, Eingänge Typnamen auf&apos;&apos; Erstellen&apos;&apos; Knopf,&apos; &amp;
                        &apos;Wählen Radiokasten&apos;&apos; Table Type&apos;&apos;, Eingang Attributwerte, dann speichern und zu aktivieren.&apos;.
  text_tobj-inst_tobj = &apos;Run TCODE SE54, Eingang Pflege-View ein, wählen Sie Radio-Box&apos;&apos; generierte Objekte&apos;&apos; auf&apos;&apos; erstellen / ändern&apos;&apos; Knopf,&apos; &amp;&amp;
                        &apos;Wählen Sie&apos;&apos; Ja&apos;&apos; in den Popup-Dialogfeld zur Bestätigung, Eingang Attributwerte und klicken Sie auf die Schaltfläche Erstellen oben, wählen Sie Paket nach Dokumentation und sparen.&apos;.
  text_nrob-inst_nrob = &apos;Run TCODE SNRO, Eingang Nummernkreisobjekts Namen, auf&apos;&apos; Erstellen&apos;&apos; Knopf, Eingang Attributwerte und speichern, wählen Sie Paket nach Dokumentation.&apos;.
  text_msag-inst_msad = &apos;Run TCODE SE91, Input-Message-Klasse, und klicken Sie&apos;&apos; erstellen&apos;&apos; Knopf, Eingang Attribut, Meldungen und speichern, wählen Sie Paket nach Dokumentation.&apos;.
  text_msag-inst_msag = text_msag-inst_msad.
  text_msag-inst_mess = &apos;Run TCODE SE91, Input-Message-Klasse, und klicken Sie&apos;&apos; ändern&apos;&apos; Knopf, pflegen Nachricht kurze Texte, &apos; &amp;&amp;
                        &apos;für die Nachrichtenübertragung mit langen Text, deaktivieren Sie das Kontrollkästchen &apos; &amp;
                        &apos;&apos;&apos;Selbsterklärende&apos;&apos;, klicken Sie dann auf Menü&apos;&apos; Langtext&apos;&apos;, halten die lange Text nach der Dokumentation.&apos;.
  text_docu-inst_docu = &apos;Für Daten-Element, TCODE SE11 ausführen, wählen Sie Radio-Box &apos;&apos;Datentyp&apos;&apos;, Eingabedaten Element und klicken Sie auf &apos;&apos;ändern&apos;&apos; Knopf,&apos; &amp;&amp;
                        &apos;Klicken im Menü &apos;&apos;Documentation&apos;&apos; und pflegen die Dokumentation, wie in der unten beschrieben. &lt;br&gt;&apos; &amp;&amp;
                        &apos;Für Langtext Nachricht Kurztext, TCODE SE91, Input-Message-Klasse, und klicken Sie &apos;&apos;ändern&apos;&apos; Knopf, wählen Sie die Nachricht ausführen, deaktivieren Sie die Checkbox&apos; &amp;&amp;
                        &apos; &apos;&apos;Selbsterklärende&apos;&apos;, klicken Sie dann auf Menü &apos;&apos;Langtext&apos;&apos;, halten die lange Text wie im Folgenden beschrieben.&apos;.
  text_tran-inst_tran = &apos;Run TCODE SE93, Eingang Transaktionscode auf&apos;&apos; Erstellen&apos;&apos; Knopf, wenn&apos; &amp;&amp;
                        &apos;Input Kurztext und wählen Sie Start-Objekt, wenn es bereits vorhanden ist, einfach ignorieren, wenn nicht,&apos; &amp;
                        &apos;Halten die Werte der Attribute und wählen Sie Paket nach der Dokumentation, dann speichern Sie Ihre Arbeit.&apos;.

  DATA: lcv_inst_dat TYPE String.
  lcv_inst_dat = &apos;Run TCODE $CODE, Eingang $DATYPE Namen klicken&apos;&apos; pflegen&apos;&apos;,&apos; &amp;&amp;
          &apos;Wenn Warnmeldung&apos;&apos; Achtung: Der Tisch ist Cross-client&apos;&apos; Pop-up,&apos; &amp; &apos;einfach bestätigen, dann fügen Sie Einträge in der Event auswählen.&apos; &amp;&amp;
          &apos;Beachten Sie, dass diese Einträge könnten abhängig von anderen Repository ojekte, wenn Sie nicht weiter gehen kann, versuchen,&apos; &amp;&amp;
          &apos;Fügen Sie die abhängigen Objekte ersten oder es wieder tun nach der Umsetzung der note.Meanwhile, haben nur die Felder einen gültigen Wert muss &apos; &amp;&amp;
          &apos;Aufgeführt zu erhalten, das heißt, Sie don&apos;&apos; t müssen über andere Felder zu kümmern.&apos;.
  text_tabu-inst_cdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_cdat WITH &apos;SM34&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_cdat WITH &apos;Viewclusters&apos;.

  text_tabu-inst_vdat = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_vdat WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_vdat WITH &apos;Pflege-View&apos;.

  text_tabu-inst_tabu = lcv_inst_dat.
  REPLACE FIRST OCCURRENCE OF &apos;$CODE&apos; IN text_tabu-inst_tabu WITH &apos;SM30&apos;.
  REPLACE FIRST OCCURRENCE OF &apos;$DATYPE&apos; IN text_tabu-inst_tabu WITH &apos;table&apos;.
ENDFORM.

FORM init_object_instructions.
  PERFORM append_instruction USING &apos;DEVC&apos; text_devc-inst_devc.
  PERFORM append_instruction USING &apos;DEVP&apos; text_devc-inst_devp.
  PERFORM append_instruction USING &apos;PINF&apos; text_devc-inst_pinf.
  PERFORM append_instruction USING &apos;FUGR&apos; text_fugr-inst_fugr.
  PERFORM append_instruction USING &apos;FUGR&apos; text_fugr-inst_fugt.
  PERFORM append_instruction USING &apos;DOMA&apos; text_doma-inst_doma.
  PERFORM append_instruction USING &apos;DTEL&apos; text_dtel-inst_dtel.
  PERFORM append_instruction USING &apos;TABL&apos; text_tabl-inst_tabl.
  PERFORM append_instruction USING &apos;TABD&apos; text_tabl-inst_tabd.
  PERFORM append_instruction USING &apos;VIEW&apos; text_view-inst_view.
  PERFORM append_instruction USING &apos;VIED&apos; text_view-inst_vied.
  PERFORM append_instruction USING &apos;SHLP&apos; text_shlp-inst_shlp.
  PERFORM append_instruction USING &apos;ENQU&apos; text_enqu-inst_enqu.
  PERFORM append_instruction USING &apos;TTYP&apos; text_ttyp-inst_ttyp.
  PERFORM append_instruction USING &apos;TOBJ&apos; text_tobj-inst_tobj.
  PERFORM append_instruction USING &apos;VCLS&apos; text_tabl-inst_tabd.
  PERFORM append_instruction USING &apos;NROB&apos; text_nrob-inst_nrob.
  PERFORM append_instruction USING &apos;DOCU&apos; text_docu-inst_docu.
  PERFORM append_instruction USING &apos;MSAD&apos; text_msag-inst_msad.
  PERFORM append_instruction USING &apos;MSAG&apos; text_msag-inst_msag.
  PERFORM append_instruction USING &apos;MESS&apos; text_msag-inst_mess.
  PERFORM append_instruction USING &apos;TRAN&apos; text_tran-inst_tran.
  PERFORM append_instruction USING &apos;CDAT&apos; text_tabu-inst_cdat.
  PERFORM append_instruction USING &apos;VDAT&apos; text_tabu-inst_vdat.
  PERFORM append_instruction USING &apos;TABU&apos; text_tabu-inst_tabu.
ENDFORM.

FORM append_instruction USING iv_object TYPE trobjtype iv_txt TYPE string.
  DATA: ls_inst TYPE s_object_instruction.

  ls_inst-object = iv_object.
  ls_inst-instruction = iv_txt.

  READ TABLE gt_object_instruction WITH TABLE KEY object = iv_object TRANSPORTING NO FIELDS.
  CHECK sy-subrc NE 0.
  INSERT ls_inst INTO TABLE gt_object_instruction.
ENDFORM.
***************** i18n End *****************</source>
 </PROG>
 <TABL TABNAME="ZPACKAGE_EXT" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Package Extensive Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="PARENTCL" DDLANGUAGE="E" POSITION="0001" ROLLNAME="PARENTCL" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" HEADLEN="25" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Previous Package" REPTEXT="Previous Package" SCRTEXT_S="Prev.Pack." SCRTEXT_M="Prev. Package" SCRTEXT_L="Previous Package" DOMNAME3L="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="PDEVCLASS" DDLANGUAGE="E" POSITION="0002" ROLLNAME="DEVLAYER" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="DEVLAYER" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Transport Layer in ABAP Workbench" REPTEXT="Transport Layer" SCRTEXT_S="Layer" SCRTEXT_M="Transport Layer" SCRTEXT_L="Transport Layer" DOMNAME3L="DEVLAYER" SHLPORIGIN="D" SHLPNAME="TCE_TRANSPORT_LAYERS" SHLPFIELD="TRANSLAYER" DEPTH="00" COMPTYPE="E" DEFFDNAME="TRANSPORTSCHICHT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="COMPONENT" DDLANGUAGE="E" POSITION="0003" ROLLNAME="UFFCTR" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="UFFCTR" ROUTPUTLEN="000000" MEMORYID="BMFR" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" ENTITYTAB="DF14L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Application Component" REPTEXT="Applic. Component" SCRTEXT_S="Appl.Comp." SCRTEXT_M="Component" SCRTEXT_L="Applic. Component" DOMMASTER="D" DOMNAME3L="UFFCTR" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="DLVUNIT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="DLVUNIT" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DLVUNIT" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="05" SCRLEN2="10" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="CVERS" MASK="  CHARE" MASKLEN="0000" DDTEXT="Software Component" REPTEXT="Software Component" SCRTEXT_S="Comp." SCRTEXT_M="Soft.Comp." SCRTEXT_L="Software Component" DOMNAME3L="DLVUNIT" SHLPORIGIN="D" SHLPNAME="H_CVERS" SHLPFIELD="COMPONENT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="APPLICAT" DDLANGUAGE="E" POSITION="0005" ROLLNAME="TRDEVCAPPL" ADMINFIELD="0" INTTYPE="C" INTLEN="000004" DOMNAME="TRDEVCAPPL" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Application area for package" REPTEXT="Applic. Area" SCRTEXT_S="Appl. Area" SCRTEXT_M="Applic. Area" SCRTEXT_L="Application Area" DOMMASTER="D" DOMNAME3L="TRDEVCAPPL" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="MAINPACK" DDLANGUAGE="E" POSITION="0006" ROLLNAME="MAINPACK" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="MAINPACK" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Main Package Indicator" REPTEXT="Main Package" SCRTEXT_S="Mn package" SCRTEXT_M="Main Package" SCRTEXT_L="Main Package" DOMNAME3L="MAINPACK" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="KORRFLAG" DDLANGUAGE="E" POSITION="0007" ROLLNAME="KORRFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="50" SCRLEN1="00" SCRLEN2="00" SCRLEN3="40" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Changes Recorded" REPTEXT="Record Object Changes in Transport Requests" SCRTEXT_L="Changes Recorded" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="PROJECT_ID" DDLANGUAGE="E" POSITION="0008" ROLLNAME="PAK_PROJECT_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000048" DOMNAME="PAK_PROJECT_ID" ROUTPUTLEN="000000" HEADLEN="07" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000024" OUTPUTLEN="000024" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="External cPro Project ID" REPTEXT="Project" SCRTEXT_S="Project" SCRTEXT_M="Project" SCRTEXT_L="cProjects Project" DOMNAME3L="PAK_PROJECT_ID" SHLPORIGIN="D" SHLPNAME="H_PAK_PROJECT_ID" SHLPFIELD="PROJECT_ID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="TRANSLATION_DEPTH_TEXT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="PAK_TRANSLATION_DEPTH_TEXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000120" DOMNAME="AS4TEXT" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="00" SCRLEN2="20" SCRLEN3="40" DTELMASTER="E" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Translation-Relevance" REPTEXT="Translation-Relevance" SCRTEXT_M="Transl.-Relevance" SCRTEXT_L="Translation-Relevance" DOMNAME3L="AS4TEXT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_EXT" FIELDNAME="USE_ACCESSES" DDLANGUAGE="E" POSITION="0010" ROLLNAME="ZT_PACKAGE_USE_ACCESS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Use Accesses" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZPACKAGE_USE_ACCESS" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Use Access" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZPACKAGE_USE_ACCESS" FIELDNAME="INTF_NAME" DDLANGUAGE="E" POSITION="0001" ROLLNAME="SCOMIFNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SCOMIFNAM" ROUTPUTLEN="000000" MEMORYID="INTFNAME" HEADLEN="30" SCRLEN1="10" SCRLEN2="20" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package Interface" REPTEXT="Package Interface" SCRTEXT_S="Interface" SCRTEXT_M="Package Interface" SCRTEXT_L="Package Interface" DOMNAME3L="SCOMIFNAM" SHLPORIGIN="D" SHLPNAME="PB_INTERFACE_NAME" SHLPFIELD="INTF_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_USE_ACCESS" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0002" ROLLNAME="DEVCLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE_USE_ACCESS" FIELDNAME="ERR_SEVER" DDLANGUAGE="E" POSITION="0003" ROLLNAME="ERRSEVRTY" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="ERRSEVRTY" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="20" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Error Severity" REPTEXT="Error Severity" SCRTEXT_S="Severity" SCRTEXT_M="Error Severity" SCRTEXT_L="Error Severity" DOMNAME3L="ERRSEVRTY" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZSEARCH_HELP" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Search Help Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="ISSIMPLE" DDLANGUAGE="E" POSITION="0010" ROLLNAME="DDSHSIMPLE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="DDBOOL" ROUTPUTLEN="000000" HEADLEN="02" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag if a search help is an elementary search help" REPTEXT="el" SCRTEXT_S="elementary" SCRTEXT_M="elementary" SCRTEXT_L="Element. search help" DOMMASTER="D" DOMNAME3L="DDBOOL" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="SELMETHOD" DDLANGUAGE="E" POSITION="0011" ROLLNAME="SELMETHOD" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="REFSHLP" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Selection method of an elementary search help" REPTEXT="Selection method" SCRTEXT_S="Sel. meth." SCRTEXT_M="Select. method" SCRTEXT_L="Selection method" DOMNAME3L="REFSHLP" SHLPORIGIN="D" SHLPNAME="DD_SELMETHOD" SHLPFIELD="SELMETHOD" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="SELMTYPE" DDLANGUAGE="E" POSITION="0012" ROLLNAME="SELMTYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SELMTYPE" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Cat. of selection method of an elementary search help" REPTEXT="S" SCRTEXT_S="Sel. cat." SCRTEXT_M="Selection cat." SCRTEXT_L="Select. method cat." DOMNAME3L="SELMTYPE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="SELMEXIT" DDLANGUAGE="E" POSITION="0013" ROLLNAME="DDSHSELEXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FUNCNAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TFDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Search help exit" REPTEXT="Search help exit" SCRTEXT_S="SHLP exit" SCRTEXT_M="Srch. help exit" SCRTEXT_L="Search help exit" DOMNAME3L="FUNCNAME" SHLPORIGIN="D" SHLPNAME="DD_SELMEXIT" SHLPFIELD="SELMEXIT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="HOTKEY" DDLANGUAGE="E" POSITION="0014" ROLLNAME="DDSHHOTKEY" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="CHAR1" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Hot key for a search help" REPTEXT="HKy" SCRTEXT_S="Abbreviat." SCRTEXT_M="Hot key" SCRTEXT_L="Hot key" DOMNAME3L="CHAR1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="DIALOGTYPE" DDLANGUAGE="E" POSITION="0015" ROLLNAME="DDSHDIATYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="DDSHDIATYP" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Dialog type" REPTEXT="Dialog" SCRTEXT_S="Dialog" SCRTEXT_M="Dialog type" SCRTEXT_L="Dialog type" DOMNAME3L="DDSHDIATYP" SHLPORIGIN="D" SHLPNAME="DD_DDSHDIATYP" SHLPFIELD="VALUE" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP" FIELDNAME="PARAMS" DDLANGUAGE="E" POSITION="0016" ROLLNAME="ZT_SEARCH_HELP_PARAM" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Search Help Parameters" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZSEARCH_HELP_PARAM" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Search help parameters" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="FIELDNAME" DDLANGUAGE="E" POSITION="0001" ROLLNAME="SHLPFIELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FDNAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of a search help parameter" REPTEXT="Search help parameter" SCRTEXT_S="Src.hlp.pr" SCRTEXT_M="SearchHelpParam" SCRTEXT_L="Search help param." DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" DEFFDNAME="SHLPPARAM" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="FLPOSITION" DDLANGUAGE="E" POSITION="0002" ROLLNAME="SFPOSITION" ADMINFIELD="0" INTTYPE="N" INTLEN="000008" DOMNAME="AS4POS" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="NUMC" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Position of a search help field" DOMNAME3L="AS4POS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="ROLLCHANGE" DDLANGUAGE="E" POSITION="0003" ROLLNAME="DDSHROLLCH" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="DDSHROLLCH" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Data elem. of parameter indep. of field of selection method" REPTEXT="Mod" SCRTEXT_S="Own DE" SCRTEXT_M="Mod. data elem." SCRTEXT_L="Data element modif." DOMNAME3L="DDSHROLLCH" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="ROLLNAME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="SHLPSPARDE" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="ROLLNAME" ROUTPUTLEN="000000" MEMORYID="ROL" HEADLEN="12" SCRLEN1="10" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD04L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Assigned data element" REPTEXT="Data element" SCRTEXT_S="Data elem." SCRTEXT_M="Data element" SCRTEXT_L="Data element" DOMNAME3L="ROLLNAME" SHLPORIGIN="D" SHLPNAME="DD_DTEL_NOREF" SHLPFIELD="ROLLNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="SHLPINPUT" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SHLPINPUT" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag for IMPORT Parameters for Search Help" REPTEXT="IMP" SCRTEXT_S="IMPORT" SCRTEXT_M="IMPORT Param." SCRTEXT_L="IMPORT Parameter" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="SHLPOUTPUT" DDLANGUAGE="E" POSITION="0006" ROLLNAME="SHLPOUTPUT" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag for EXPORT Parameters for Search Help" REPTEXT="EXP" SCRTEXT_S="EXPORT" SCRTEXT_M="EXPORT Param." SCRTEXT_L="EXPORT Parameter" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="SHLPSELPOS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="SHLPSELPOS" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SHLPPOS" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Position in dialog box of an elementary search help" REPTEXT="SPos" SCRTEXT_S="Sel. pos." SCRTEXT_M="Selection pos." SCRTEXT_L="Selection position" DOMNAME3L="SHLPPOS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="SHLPSELDIS" DDLANGUAGE="E" POSITION="0008" ROLLNAME="SHLPSELDIS" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Display field in dialog box of an elementary search help" REPTEXT="SDis" SCRTEXT_S="Sel. disp." SCRTEXT_M="Selection disp." SCRTEXT_L="Selection display" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="SHLPLISPOS" DDLANGUAGE="E" POSITION="0009" ROLLNAME="SHLPLISPOS" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SHLPPOS" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Position in the hit list of an elementary search help" REPTEXT="LPos" SCRTEXT_S="List pos." SCRTEXT_M="List position" SCRTEXT_L="List position" DOMNAME3L="SHLPPOS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="SHLPUPPER" DDLANGUAGE="E" POSITION="0010" ROLLNAME="MCNOUPPER" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag: Upper/lower case sensitive" REPTEXT="U/L" SCRTEXT_S="Up./lower" SCRTEXT_M="Upper/lower" SCRTEXT_L="Upper/lower" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0011" ADMINFIELD="0" INTLEN="000000" PRECFIELD="DDSHDEFLT" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Description of a default value for search help fields" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="DEFAULTVAL" DDLANGUAGE="E" POSITION="0012" ROLLNAME="DDSHDEFVAL" ADMINFIELD="1" INTTYPE="C" INTLEN="000042" DOMNAME="DEFAULT__3" ROUTPUTLEN="000000" HEADLEN="21" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000021" OUTPUTLEN="000021" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Default value for a search help parameter" REPTEXT="Default value" SCRTEXT_S="Default" SCRTEXT_M="Default value" SCRTEXT_L="Default value" DOMNAME3L="DEFAULT__3" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZSEARCH_HELP_PARAM" FIELDNAME="DEFAULTTYP" DDLANGUAGE="E" POSITION="0013" ROLLNAME="DDSHDEFTYP" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="DDSHDEFTYP" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Default type of a search help parameter" REPTEXT="Deft" SCRTEXT_S="Deflt.type" SCRTEXT_M="Type of default" SCRTEXT_L="Type of default" DOMNAME3L="DDSHDEFTYP" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTABLE" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Table Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="TABCLASS" DDLANGUAGE="E" POSITION="0010" ROLLNAME="TABCLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000016" DOMNAME="TABCLASS" ROUTPUTLEN="000000" HEADLEN="08" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000008" OUTPUTLEN="000008" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Table category" REPTEXT="Tab.cat." SCRTEXT_M="Table category" SCRTEXT_L="Table category" DOMMASTER="D" DOMNAME3L="TABCLASS" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="CONTFLAG" DDLANGUAGE="E" POSITION="0011" ROLLNAME="CONTFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="CONTFLAG" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Delivery class" REPTEXT="D" SCRTEXT_S="Del. class" SCRTEXT_M="Delivery class" SCRTEXT_L="Delivery class" DOMNAME3L="CONTFLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="MAINFLAG" DDLANGUAGE="E" POSITION="0012" ROLLNAME="MAINTFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="MAINTFLAG" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="18" SCRLEN3="25" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag if Maintenance with Standard Tools is allowed" REPTEXT="M" SCRTEXT_S="Tab. Maint" SCRTEXT_M="Table Maintenance" SCRTEXT_L="Table Maintenance" DOMNAME3L="MAINTFLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="FIELDS" DDLANGUAGE="E" POSITION="0013" ROLLNAME="ZT_TABLE_FIELD" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of ZTABLE_FIELD" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="TECH_SETTING" DDLANGUAGE="E" POSITION="0014" ROLLNAME="DD09V" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="Interface: Technical Settings Table/View" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0015" ADMINFIELD="0" INTLEN="000000" PRECFIELD="DD09L" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="DD: Technical settings of tables" DEPTH="01" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="TABNAME" DDLANGUAGE="E" POSITION="0016" ROLLNAME="TABNAME" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="AS4TAB" ROUTPUTLEN="000000" MEMORYID="DTB" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD02L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Table Name" REPTEXT="Table Name" SCRTEXT_S="Table" SCRTEXT_M="Table Name" SCRTEXT_L="Table Name" DOMNAME3L="AS4TAB" DEPTH="01" COMPTYPE="E" DEFFDNAME="TABNAME" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="AS4LOCAL" DDLANGUAGE="E" POSITION="0017" ROLLNAME="AS4LOCAL" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="AS4LOCAL" ROUTPUTLEN="000000" HEADLEN="02" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Activation Status of a Repository Object" REPTEXT="Ac" SCRTEXT_M="Activation Status" SCRTEXT_L="Activation Status" DOMNAME3L="AS4LOCAL" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="AS4VERS" DDLANGUAGE="E" POSITION="0018" ROLLNAME="AS4VERS" ADMINFIELD="1" INTTYPE="N" INTLEN="000008" DOMNAME="AS4VERS" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="NUMC" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Version of the entry (not used)" REPTEXT="Vers" SCRTEXT_M="Version" SCRTEXT_L="Version" DOMNAME3L="AS4VERS" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="TABKAT" DDLANGUAGE="E" POSITION="0019" ROLLNAME="TABKAT" ADMINFIELD="1" INTTYPE="C" INTLEN="000004" DOMNAME="TABKAT" ROUTPUTLEN="000000" HEADLEN="02" SCRLEN1="10" SCRLEN2="15" SCRLEN3="15" DTELMASTER="D" DATATYPE="CHAR" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Size category" REPTEXT="SC" SCRTEXT_S="Size cat." SCRTEXT_M="Size category" SCRTEXT_L="Size category" DOMMASTER="D" DOMNAME3L="TABKAT" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="TABART" DDLANGUAGE="E" POSITION="0020" ROLLNAME="TABART" ADMINFIELD="1" INTTYPE="C" INTLEN="000010" DOMNAME="TABART" ROUTPUTLEN="000000" HEADLEN="05" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000005" OUTPUTLEN="000005" DECIMALS="000000" ENTITYTAB="DDART" MASK="  CHARE" MASKLEN="0000" DDTEXT="Data class in technical settings" REPTEXT="Dt.Cl" SCRTEXT_S="Data class" SCRTEXT_M="Data class" SCRTEXT_L="Data class" DOMMASTER="D" DOMNAME3L="TABART" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="PUFFERUNG" DDLANGUAGE="E" POSITION="0021" ROLLNAME="PUFFERUNG" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="PUFFERUNG" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Buffering type indicator" REPTEXT="B" SCRTEXT_S="BuffType" SCRTEXT_M="Buffering type" SCRTEXT_L="Buffering type" DOMMASTER="D" DOMNAME3L="PUFFERUNG" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="SCHFELDANZ" DDLANGUAGE="E" POSITION="0022" ROLLNAME="SCHFELDANZ" ADMINFIELD="1" INTTYPE="N" INTLEN="000006" DOMNAME="SCHFELDANZ" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="No. of key fields for generic buffers" REPTEXT="Genkey" SCRTEXT_S="NoKeyFlds" SCRTEXT_M="NoKeyFields" SCRTEXT_L="No. of key fields" DOMNAME3L="SCHFELDANZ" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="PROTOKOLL" DDLANGUAGE="E" POSITION="0023" ROLLNAME="DDPROTOCOL" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="DDPROTOCOL" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Log Data Changes" REPTEXT="Log" SCRTEXT_S="Log" SCRTEXT_M="Log" SCRTEXT_L="Log" DOMMASTER="D" DOMNAME3L="DDPROTOCOL" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="SPEICHPUFF" DDLANGUAGE="E" POSITION="0024" ROLLNAME="SPEICHPUFF" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="SPEICHPUFF" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag for the storage type in the buffer" REPTEXT="S" SCRTEXT_S="StBuff" SCRTEXT_M="StorTypeBuffr" SCRTEXT_L="StorageTypeBuffer" DOMNAME3L="SPEICHPUFF" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="AS4USER" DDLANGUAGE="E" POSITION="0025" ROLLNAME="AS4USER" ADMINFIELD="1" INTTYPE="C" INTLEN="000024" DOMNAME="AS4USER" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000012" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Last Changed by" REPTEXT="Author" SCRTEXT_M="Last Changed By" SCRTEXT_L="Last Changed By" DOMNAME3L="AS4USER" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="AS4DATE" DDLANGUAGE="E" POSITION="0026" ROLLNAME="AS4DATE" ADMINFIELD="1" INTTYPE="D" INTLEN="000016" DOMNAME="AS4DATE" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="DATS" LENG="000008" OUTPUTLEN="000010" DECIMALS="000000" MASK="  DATSE" MASKLEN="0000" DDTEXT="Date of Last Change" REPTEXT="Date" SCRTEXT_M="Date" SCRTEXT_L="Date" DOMNAME3L="AS4DATE" SHLPORIGIN="T" DEPTH="01" COMPTYPE="E" DEFFDNAME="ÄNDERUNGSDATUM" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="AS4TIME" DDLANGUAGE="E" POSITION="0027" ROLLNAME="AS4TIME" ADMINFIELD="1" INTTYPE="T" INTLEN="000012" DOMNAME="AS4TIME" ROUTPUTLEN="000000" HEADLEN="07" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="TIMS" LENG="000006" OUTPUTLEN="000008" DECIMALS="000000" MASK="  TIMSE" MASKLEN="0000" DDTEXT="Last changed at" REPTEXT="Time" SCRTEXT_M="Time" SCRTEXT_L="Time" DOMNAME3L="AS4TIME" SHLPORIGIN="T" DEPTH="01" COMPTYPE="E" DEFFDNAME="ÄNDERUNGSZEIT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="TRANSPFLAG" DDLANGUAGE="E" POSITION="0028" ROLLNAME="DDTRANSP" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="DDTRANSP" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Convert to transparent table or maintain transparency" REPTEXT="T" SCRTEXT_S="TransFlag" SCRTEXT_M="TranspFlag" SCRTEXT_L="TranspFlag" DOMMASTER="D" DOMNAME3L="DDTRANSP" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="RESERVE" DDLANGUAGE="E" POSITION="0029" ROLLNAME="DDRESERVE" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="DDRESERV" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Reserved field in the ABAP Dictionary" REPTEXT="R" DOMNAME3L="DDRESERV" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="UEBERSETZ" DDLANGUAGE="E" POSITION="0030" ROLLNAME="UEBERSETZ" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="UEBERSETZ" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag whether table is relevant for translation" REPTEXT="T" SCRTEXT_S="Translat." SCRTEXT_M="Rel. for trans." SCRTEXT_L="Translation relevant" DOMMASTER="D" DOMNAME3L="UEBERSETZ" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="ACTFLAG" DDLANGUAGE="E" POSITION="0031" ROLLNAME="ACTFLAG" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="ACTFLAG" ROUTPUTLEN="000000" HEADLEN="02" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Activation flag" REPTEXT="Ac" SCRTEXT_M="Activation flag" SCRTEXT_L="Activation flag" DOMNAME3L="ACTFLAG" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="BUFALLOW" DDLANGUAGE="E" POSITION="0032" ROLLNAME="BUFALLOW" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="BUFALLOW" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="14" SCRLEN3="17" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Indicator for buffering allowed/not allowed" REPTEXT="B" SCRTEXT_S="Bufallow" SCRTEXT_M="Buff. allowed" SCRTEXT_L="Buff. allowed" DOMMASTER="D" DOMNAME3L="BUFALLOW" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="JAVAONLY" DDLANGUAGE="E" POSITION="0033" ROLLNAME="DDJAVAONLY" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="DDBOOL" ROUTPUTLEN="000000" HEADLEN="17" SCRLEN1="08" SCRLEN2="08" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Write access only with JAVA" REPTEXT="WriteWithJavaOnly" SCRTEXT_S="JavaOnly" SCRTEXT_M="JavaOnly" SCRTEXT_L="WriteWithJavaOnly" DOMMASTER="D" DOMNAME3L="DDBOOL" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="NAMESPACE" DDLANGUAGE="E" POSITION="0034" ROLLNAME="ZT_TABLE_NAMESPACE" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Table Namespace Attributes" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="FOREIGN_KEY_HEADER" DDLANGUAGE="E" POSITION="0035" ROLLNAME="DD08VTTYP" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type for DD08V" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="FOREIGN_KEYS" DDLANGUAGE="E" POSITION="0036" ROLLNAME="DD05MTTYP" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type for DD05M" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="ASSIGNMENTS" DDLANGUAGE="E" POSITION="0037" ROLLNAME="DD35VTTYP" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type for DD35V" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="INDEX_HEADER" DDLANGUAGE="E" POSITION="0038" ROLLNAME="DD12VTAB" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="DD: Index Header of a Table" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE" FIELDNAME="INDEX_FIELDS" DDLANGUAGE="E" POSITION="0039" ROLLNAME="DD17VTAB" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="DD: Index Fields of a Table" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTABLE_CONTENTS" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Table Contents" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_CONTENTS" FIELDNAME="ENTRIES" DDLANGUAGE="E" POSITION="0010" ROLLNAME="ZT_TABLE_ENTRIES" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Table Entry" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTABLE_FIELD" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Table Field: Thin Structure Of DD03P" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="FIELDNAME" DDLANGUAGE="E" POSITION="0001" ROLLNAME="FIELDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FDNAME" ROUTPUTLEN="000000" MEMORYID="DFD" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Field Name" REPTEXT="Field Name" SCRTEXT_S="Field" SCRTEXT_M="Field Name" SCRTEXT_L="Field Name" DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="KEYFLAG" DDLANGUAGE="E" POSITION="0002" ROLLNAME="KEYFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="KEYFLAG" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Identifies a key field of a table" REPTEXT="Key" SCRTEXT_M="Key field" SCRTEXT_L="Key field" DOMNAME3L="KEYFLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="MANDATORY" DDLANGUAGE="E" POSITION="0003" ROLLNAME="MANDATORY" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag: Field is required (not blank)" REPTEXT="Req." SCRTEXT_M="Required field" SCRTEXT_L="Required field" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="ROLLNAME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="ROLLNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="ROLLNAME" ROUTPUTLEN="000000" MEMORYID="ROL" HEADLEN="12" SCRLEN1="10" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD04L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Data element (semantic domain)" REPTEXT="Data element" SCRTEXT_S="Data elem." SCRTEXT_M="Data element" SCRTEXT_L="Data element" DOMNAME3L="ROLLNAME" SHLPORIGIN="D" SHLPNAME="DD_DTEL" SHLPFIELD="ROLLNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="CHECKTABLE" DDLANGUAGE="E" POSITION="0005" ROLLNAME="CHECKTABLE" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="AS4TAB" ROUTPUTLEN="000000" HEADLEN="11" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD02L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Check table name of the foreign key" REPTEXT="Check table" SCRTEXT_M="Check table" SCRTEXT_L="Check table" DOMNAME3L="AS4TAB" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="ADMINFIELD" DDLANGUAGE="E" POSITION="0006" ROLLNAME="ADMINFIELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Nesting depth for includes" REPTEXT="A" SCRTEXT_M="Admin. field" SCRTEXT_L="Admin. field" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="REFTABLE" DDLANGUAGE="E" POSITION="0007" ROLLNAME="REFTABLE" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="AS4TAB" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD02L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Table for reference field" REPTEXT="Reference table" SCRTEXT_S="Ref. table" SCRTEXT_M="Reference table" SCRTEXT_L="Reference table" DOMNAME3L="AS4TAB" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="PRECFIELD" DDLANGUAGE="E" POSITION="0008" ROLLNAME="PRECFIELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FDNAME" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of included table" REPTEXT="Name of include" SCRTEXT_M="Name of include" SCRTEXT_L="Name of include" DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="REFFIELD" DDLANGUAGE="E" POSITION="0009" ROLLNAME="REFFIELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FDNAME" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="12" SCRLEN3="12" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Reference field for currency and qty fields" REPTEXT="Ref. field" SCRTEXT_S="Ref. field" SCRTEXT_M="Ref. field" SCRTEXT_L="Ref. field" DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="NOTNULL" DDLANGUAGE="E" POSITION="0010" ROLLNAME="NOTNULL" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="NOTNULL" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Indicator that NOT NULL is forced for this field" REPTEXT="N" SCRTEXT_S="NOT NULL" SCRTEXT_M="NOT NULL forced" SCRTEXT_L="NOT NULL forced" DOMNAME3L="NOTNULL" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_FIELD" FIELDNAME="SHLPNAME" DDLANGUAGE="E" POSITION="0011" ROLLNAME="SHLPNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SHLPNAME" ROUTPUTLEN="000000" MEMORYID="SHLP" HEADLEN="10" SCRLEN1="10" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD30L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of a Search Help" REPTEXT="Srch Help" SCRTEXT_S="Srch Help" SCRTEXT_M="Search Help Name" SCRTEXT_L="Search Help Name" DOMNAME3L="SHLPNAME" SHLPORIGIN="D" SHLPNAME="DD_SHLP" SHLPFIELD="SHLPNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTABLE_NAMESPACE" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Table Namespace Reserved Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTABLE_NAMESPACE" FIELDNAME="TABNAME" DDLANGUAGE="E" POSITION="0001" ROLLNAME="TABNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="AS4TAB" ROUTPUTLEN="000000" MEMORYID="DTB" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD02L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Table Name" REPTEXT="Table Name" SCRTEXT_S="Table" SCRTEXT_M="Table Name" SCRTEXT_L="Table Name" DOMNAME3L="AS4TAB" DEPTH="00" COMPTYPE="E" DEFFDNAME="TABNAME" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_NAMESPACE" FIELDNAME="FIELDNAME" DDLANGUAGE="E" POSITION="0002" ROLLNAME="FIELDNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="FDNAME" ROUTPUTLEN="000000" MEMORYID="DFD" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD03L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Field Name" REPTEXT="Field Name" SCRTEXT_S="Field" SCRTEXT_M="Field Name" SCRTEXT_L="Field Name" DOMNAME3L="FDNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_NAMESPACE" FIELDNAME="KEYLOW" DDLANGUAGE="E" POSITION="0003" ROLLNAME="OBJ_NAMERE" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="TROBJNAMEK" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Generic Entry of Protected Namespace (Lowercase)" REPTEXT="Reserved Namespace" SCRTEXT_S="Namespace" SCRTEXT_M="Namespace" SCRTEXT_L="Namespace" DOMNAME3L="TROBJNAMEK" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTABLE_TYPE" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Table Type Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="ROWTYPE" DDLANGUAGE="E" POSITION="0010" ROLLNAME="TTROWTYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="OBJECTNAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="15" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of row type for table types" REPTEXT="Row Type" SCRTEXT_S="Row Type" SCRTEXT_M="Row type name" SCRTEXT_L="Row type name" DOMNAME3L="OBJECTNAME" SHLPORIGIN="D" SHLPNAME="DD_TYPES_AND_IMPLEM_CLIFS" SHLPFIELD="TYPENAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="ACCESSMODE" DDLANGUAGE="E" POSITION="0011" ROLLNAME="ACCESSMODE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="ACCESSMODE" ROUTPUTLEN="000000" HEADLEN="02" SCRLEN1="02" SCRLEN2="18" SCRLEN3="23" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Access modes for table types" REPTEXT="AM" SCRTEXT_S="AM" SCRTEXT_M="Access mode (code)" SCRTEXT_L="Access mode of tab.type" DOMNAME3L="ACCESSMODE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="KEYDEF" DDLANGUAGE="E" POSITION="0012" ROLLNAME="TTYPKEYDEF" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TTYPKEYDEF" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Key definition for table types" REPTEXT="K" SCRTEXT_M="Key (coded)" SCRTEXT_L="Key definition" DOMNAME3L="TTYPKEYDEF" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="KEYKIND" DDLANGUAGE="E" POSITION="0013" ROLLNAME="KEYKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="KEYKIND" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="18" SCRLEN3="24" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000004" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Key category for table types" REPTEXT="KyCt" SCRTEXT_S="Key cat." SCRTEXT_M="Key cat. (coded)" SCRTEXT_L="Key category of tab.type" DOMNAME3L="KEYKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="KEYFDCOUNT" DDLANGUAGE="E" POSITION="0014" ROLLNAME="KEYFDCNT" ADMINFIELD="0" INTTYPE="N" INTLEN="000008" DOMNAME="KEYFDCNT" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="10" SCRLEN2="17" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000004" OUTPUTLEN="000006" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Number of key fields of a table type" REPTEXT="Keycnt" SCRTEXT_S="Key fields" SCRTEXT_M="No. key fields" SCRTEXT_L="No. of key fields" DOMNAME3L="KEYFDCNT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="GENERIC" DDLANGUAGE="E" POSITION="0015" ROLLNAME="TYPGENERIC" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="DDBOOL" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="01" SCRLEN2="02" SCRLEN3="09" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Generic table type" REPTEXT="Gen" SCRTEXT_S="G" SCRTEXT_M="Ge" SCRTEXT_L="Generic" DOMMASTER="D" DOMNAME3L="DDBOOL" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="TYPELEN" DDLANGUAGE="E" POSITION="0016" ROLLNAME="DDLENG" ADMINFIELD="0" INTTYPE="N" INTLEN="000012" DOMNAME="DDLENG" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="05" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="NUMC" LENG="000006" OUTPUTLEN="000006" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Length (No. of Characters)" REPTEXT="Length" SCRTEXT_S="Lngth" SCRTEXT_M="No. of Characters" SCRTEXT_L="No. of Characters" DOMNAME3L="DDLENG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="TTYPKIND" DDLANGUAGE="E" POSITION="0017" ROLLNAME="TTYPKIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TTYPKIND" ROUTPUTLEN="000000" HEADLEN="14" SCRLEN1="10" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Category of table type (range or general table type)" REPTEXT="Table type cat" SCRTEXT_S="TabTypeCat" SCRTEXT_M="Table type cat(cd)" SCRTEXT_L="Cat. of table type" DOMNAME3L="TTYPKIND" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="RANGE_CTYP" DDLANGUAGE="E" POSITION="0018" ROLLNAME="RANGE_CTYP" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="ROLLNAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="23" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD04L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Elem. type of LOW and HIGH components of a Ranges type" REPTEXT="Associated Type" SCRTEXT_S="Assoc.Type" SCRTEXT_M="Associated Type" SCRTEXT_L="Assc. Type for LOW,HIGH" DOMNAME3L="ROLLNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="REFTYPE" DDLANGUAGE="E" POSITION="0019" ROLLNAME="DDREFTYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="DDREFTYPE" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="18" SCRLEN3="28" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Type of Object Referenced" SCRTEXT_M="Ref.Type  (Coded)" SCRTEXT_L="Type of Object Referenced" DOMNAME3L="DDREFTYPE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="OCCURS" DDLANGUAGE="E" POSITION="0020" ROLLNAME="DDOCCURS" ADMINFIELD="0" INTTYPE="N" INTLEN="000010" DOMNAME="DDOCCURS" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="18" SCRLEN3="00" DTELMASTER="D" DATATYPE="NUMC" LENG="000005" OUTPUTLEN="000005" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Initial Line Number for Table Types" SCRTEXT_M="Main Memory Size" DOMNAME3L="DDOCCURS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="PRIMARY_KEY" DDLANGUAGE="E" POSITION="0021" ROLLNAME="DD42V_TAB" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="DD: Table of Secondary Key Fields" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTABLE_TYPE" FIELDNAME="SECONDARY_KEY" DDLANGUAGE="E" POSITION="0022" ROLLNAME="DD43V_TAB" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="DD: Table of Secondary Index Headers" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTADIR_KEY" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Tadir Primary Key" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTADIR_KEY" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0001" ROLLNAME="PGMID" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTADIR_KEY" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0002" ROLLNAME="TROBJTYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTADIR_KEY" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0003" ROLLNAME="SOBJ_NAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTADIR_KEY" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0004" ROLLNAME="OBJFUNC" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTRANSACTION" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Repository Object Basic Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0002" ROLLNAME="PGMID" ADMINFIELD="1" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0003" ROLLNAME="TROBJTYPE" ADMINFIELD="1" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="SOBJ_NAME" ADMINFIELD="1" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0005" ROLLNAME="OBJFUNC" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0006" ROLLNAME="DEVCLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0007" ROLLNAME="CHAR80" ADMINFIELD="0" INTTYPE="C" INTLEN="000160" DOMNAME="CHAR80" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000080" OUTPUTLEN="000080" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Char 80" REPTEXT="Char80" SCRTEXT_S="Char80" SCRTEXT_M="Char80" SCRTEXT_L="Char80" DOMNAME3L="CHAR80" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="INT1" ADMINFIELD="0" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="AUTHORITY" DDLANGUAGE="E" POSITION="0009" ROLLNAME="ZT_TRANSACTION_AUTH" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Transaction Authoirty" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="BASIC_INFO" DDLANGUAGE="E" POSITION="0010" ROLLNAME="TSTCV" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="V STRUS" MASKLEN="0000" DDTEXT="Transaction code" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="TCODE" DDLANGUAGE="E" POSITION="0011" ROLLNAME="TCODE" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="TCODE" ROUTPUTLEN="000000" MEMORYID="TCD" HEADLEN="05" SCRLEN1="05" SCRLEN2="16" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" ENTITYTAB="TSTC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Transaction Code" REPTEXT="TCode" SCRTEXT_S="TCode" SCRTEXT_M="Transaction Code" SCRTEXT_L="Transaction Code" DOMNAME3L="TCODE" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="SPRSL" DDLANGUAGE="E" POSITION="0012" ROLLNAME="SPRAS" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SPRAS" ROUTPUTLEN="000000" MEMORYID="SPR" LOGFLAG="X" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="LANG" LENG="000001" OUTPUTLEN="000002" DECIMALS="000000" LOWERCASE="X" ENTITYTAB="T002" CONVEXIT="ISOLA" MASK="  LANGE" MASKLEN="0000" DDTEXT="Language Key" REPTEXT="Language" SCRTEXT_S="Language" SCRTEXT_M="Language" SCRTEXT_L="Language Key" DOMNAME3L="SPRAS" SHLPORIGIN="D" SHLPNAME="H_T002" SHLPFIELD="SPRAS" DEPTH="01" COMPTYPE="E" DEFFDNAME="LANGU" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="PGMNA" DDLANGUAGE="E" POSITION="0013" ROLLNAME="PROGRAM_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="PROGNAME" HEADLEN="08" SCRLEN1="10" SCRLEN2="20" SCRLEN3="40" DTELMASTER="E" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program Name" REPTEXT="Program" SCRTEXT_S="Program" SCRTEXT_M="Program" SCRTEXT_L="Program" DOMNAME3L="PROGNAME" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="DYPNO" DDLANGUAGE="E" POSITION="0014" ROLLNAME="DYNPRONR" ADMINFIELD="0" INTTYPE="N" INTLEN="000008" DOMNAME="DYNPRONR" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="06" SCRLEN2="08" SCRLEN3="12" DATATYPE="NUMC" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Screen number" REPTEXT="Screen" SCRTEXT_S="Screen" SCRTEXT_M="Screen" SCRTEXT_L="Screen no." DOMMASTER="D" DOMNAME3L="DYNPRONR" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="MENUE" DDLANGUAGE="E" POSITION="0015" ROLLNAME="SYCHAR05" ADMINFIELD="0" INTTYPE="C" INTLEN="000010" DOMNAME="SYCHAR05" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000005" OUTPUTLEN="000005" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="CHAR05 data element for SYST" DOMNAME3L="SYCHAR05" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="CINFO" DDLANGUAGE="E" POSITION="0016" ROLLNAME="SYHEX01" ADMINFIELD="0" INTTYPE="X" INTLEN="000001" DOMNAME="SYHEX01" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="RAW" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  RAW E" MASKLEN="0000" DDTEXT="HEX01 data element for SYST" DOMNAME3L="SYHEX01" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="ARBGB" DDLANGUAGE="E" POSITION="0017" ROLLNAME="MSGID" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="ARBGB" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" ENTITYTAB="T100A" MASK="  CHARE" MASKLEN="0000" DDTEXT="Message identification" REPTEXT="Message class" SCRTEXT_S="Msg. ID" SCRTEXT_M="Message ID" SCRTEXT_L="Message class" DOMNAME3L="ARBGB" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="TTEXT" DDLANGUAGE="E" POSITION="0018" ROLLNAME="TTEXT_STCT" ADMINFIELD="0" INTTYPE="C" INTLEN="000072" DOMNAME="TEXT36" HEADLEN="36" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000036" OUTPUTLEN="000036" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Transaction text" REPTEXT="Transaction text" SCRTEXT_S="Text" SCRTEXT_M="Text" SCRTEXT_L="Transaction text" DOMNAME3L="TEXT36" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="EXT_INFO" DDLANGUAGE="E" POSITION="0019" ROLLNAME="TSTCC" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="Additional Attributes for TSTC" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="TCODE" DDLANGUAGE="E" POSITION="0020" ROLLNAME="TCODE" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="TCODE" ROUTPUTLEN="000000" MEMORYID="TCD" HEADLEN="05" SCRLEN1="05" SCRLEN2="16" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" ENTITYTAB="TSTC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Transaction Code" REPTEXT="TCode" SCRTEXT_S="TCode" SCRTEXT_M="Transaction Code" SCRTEXT_L="Transaction Code" DOMNAME3L="TCODE" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_WEBGUI" DDLANGUAGE="E" POSITION="0021" ROLLNAME="S_WEBGUI" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SYCHAR01" ROUTPUTLEN="000000" HEADLEN="16" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="SAPGUI for HTML" REPTEXT="SAPGUI for HTML" SCRTEXT_S="HTML GUI" SCRTEXT_M="SAPGUI for HTML" SCRTEXT_L="SAPGUI for HTML" DOMNAME3L="SYCHAR01" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_WIN32" DDLANGUAGE="E" POSITION="0022" ROLLNAME="S_WIN32" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="CHAR1" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="20" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Windows 32" REPTEXT="SAPGUI for Windows" SCRTEXT_S="WIN GUI" SCRTEXT_M="SAPGUI for Windows" SCRTEXT_L="SAPGUI for Windows" DOMNAME3L="CHAR1" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_PLATIN" DDLANGUAGE="E" POSITION="0023" ROLLNAME="S_PLATIN" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SYCHAR01" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="SAPGUI for Java" REPTEXT="SAPGUI for Java" SCRTEXT_S="Java GUI" SCRTEXT_M="SAPGUI for Java" SCRTEXT_L="SAPGUI for Java" DOMNAME3L="SYCHAR01" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_SERVICE" DDLANGUAGE="E" POSITION="0024" ROLLNAME="IACSERVIC_" ADMINFIELD="0" INTTYPE="C" INTLEN="000028" DOMNAME="IACSERVICE" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000014" OUTPUTLEN="000014" DECIMALS="000000" ENTITYTAB="IACSERVICE" MASK="  CHARE" MASKLEN="0000" DDTEXT="Service name of Internet Application Component" REPTEXT="Service" SCRTEXT_S="Service" SCRTEXT_M="Service" SCRTEXT_L="Service" DOMNAME3L="IACSERVICE" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_PERVAS" DDLANGUAGE="E" POSITION="0025" ROLLNAME="S_PERVAS" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="CHAR1" ROUTPUTLEN="000000" HEADLEN="17" SCRLEN1="10" SCRLEN2="17" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Pervasive enabled" REPTEXT="Pervasive enabled" SCRTEXT_S="Pervasive" SCRTEXT_M="Pervasive enabled" SCRTEXT_L="Pervasive enabled" DOMNAME3L="CHAR1" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_DUMMY" DDLANGUAGE="E" POSITION="0026" ROLLNAME="FNKEY" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="FNKEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Function Key" DOMNAME3L="FNKEY" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_DUMMY1" DDLANGUAGE="E" POSITION="0027" ROLLNAME="FNKEY" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="FNKEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Function Key" DOMNAME3L="FNKEY" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="S_DUMMY2" DDLANGUAGE="E" POSITION="0028" ROLLNAME="FNKEY" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="FNKEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Function Key" DOMNAME3L="FNKEY" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="UICLASS" DDLANGUAGE="E" POSITION="0029" ROLLNAME="TSTCCLASS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="User Interface Classification for Transactions" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="TCODE" DDLANGUAGE="E" POSITION="0030" ROLLNAME="TCODE" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="TCODE" ROUTPUTLEN="000000" MEMORYID="TCD" HEADLEN="05" SCRLEN1="05" SCRLEN2="16" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" ENTITYTAB="TSTC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Transaction Code" REPTEXT="TCode" SCRTEXT_S="TCode" SCRTEXT_M="Transaction Code" SCRTEXT_L="Transaction Code" DOMNAME3L="TCODE" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="UI_CLASS" DDLANGUAGE="E" POSITION="0031" ROLLNAME="TCDUICLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="TCDUICLASS" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="25" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="User Interface Class of Transaction or Task" REPTEXT="UI class" SCRTEXT_S="UI class" SCRTEXT_M="UI class" SCRTEXT_L="User interface class" DOMNAME3L="TCDUICLASS" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="SRV_FILE" DDLANGUAGE="E" POSITION="0032" ROLLNAME="SRV_FNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000128" DOMNAME="TEXT64" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="17" SCRLEN3="28" DTELMASTER="D" DATATYPE="CHAR" LENG="000064" OUTPUTLEN="000064" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="ITS service file name" REPTEXT="ITS service file name" SCRTEXT_S="SF name" SCRTEXT_M="Service file name" SCRTEXT_L="ITS service file name" DOMNAME3L="TEXT64" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION" FIELDNAME="PARAM" DDLANGUAGE="E" POSITION="0033" ROLLNAME="TCDPARAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000508" DOMNAME="CHAR254" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000254" OUTPUTLEN="000254" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Parameters for transactions" SCRTEXT_S="Parameters" SCRTEXT_M="Parameters" SCRTEXT_L="Parameters" DOMNAME3L="CHAR254" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZTRANSACTION_AUTH" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Transaction Authority Settings" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZTRANSACTION_AUTH" FIELDNAME="OBJCT" DDLANGUAGE="E" POSITION="0001" ROLLNAME="XUOBJECT" ADMINFIELD="0" INTTYPE="C" INTLEN="000020" DOMNAME="XUOBJECT" ROUTPUTLEN="000000" MEMORYID="XUO" HEADLEN="25" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" ENTITYTAB="TOBJ" MASK="  CHARE" MASKLEN="0000" DDTEXT="Authorization Object" REPTEXT="Authorization Object" SCRTEXT_S="Object" SCRTEXT_M="Object" SCRTEXT_L="Authorization Object" DOMNAME3L="XUOBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION_AUTH" FIELDNAME="FIELD" DDLANGUAGE="E" POSITION="0002" ROLLNAME="XUFIELD" ADMINFIELD="0" INTTYPE="C" INTLEN="000020" DOMNAME="XUFIELD" ROUTPUTLEN="000000" HEADLEN="25" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Authorization Field" REPTEXT="Authorization Fld" SCRTEXT_S="Field name" SCRTEXT_M="Field Name" SCRTEXT_L="Authorization Field" DOMNAME3L="XUFIELD" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZTRANSACTION_AUTH" FIELDNAME="VALUE" DDLANGUAGE="E" POSITION="0003" ROLLNAME="XUVAL" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="XUVALUE" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Authorization Value" REPTEXT="Authorization Value" SCRTEXT_S="Value" SCRTEXT_M="Value" SCRTEXT_L="Authorization Value" DOMMASTER="D" DOMNAME3L="XUVALUE" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZVIEW" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="View Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="VIEWCLASS" DDLANGUAGE="E" POSITION="0010" ROLLNAME="VIEWCLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="VIEWCLASS" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="View Type" REPTEXT="Ty." SCRTEXT_S="View Type" SCRTEXT_M="View Type" SCRTEXT_L="View Type" DOMMASTER="D" DOMNAME3L="VIEWCLASS" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="CUSTOMAUTH" DDLANGUAGE="E" POSITION="0011" ROLLNAME="CONTFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="CONTFLAG" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Delivery class" REPTEXT="D" SCRTEXT_S="Del. class" SCRTEXT_M="Delivery class" SCRTEXT_L="Delivery class" DOMNAME3L="CONTFLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="VIEWGRANT" DDLANGUAGE="E" POSITION="0012" ROLLNAME="VIEWGRANT" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="VIEWGRANT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Maintenance status (modif. authorization) for view data" REPTEXT="MSt" SCRTEXT_S="Maint.stat" SCRTEXT_M="Maint. status" SCRTEXT_L="Maint. status" DOMMASTER="D" DOMNAME3L="VIEWGRANT" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="GLOBALFLAG" DDLANGUAGE="E" POSITION="0013" ROLLNAME="MAINTFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="MAINTFLAG" ROUTPUTLEN="000000" HEADLEN="01" SCRLEN1="10" SCRLEN2="18" SCRLEN3="25" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag if Maintenance with Standard Tools is allowed" REPTEXT="M" SCRTEXT_S="Tab. Maint" SCRTEXT_M="Table Maintenance" SCRTEXT_L="Table Maintenance" DOMNAME3L="MAINTFLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="TABLE_JOIN" DDLANGUAGE="E" POSITION="0014" ROLLNAME="ZT_DD26V" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of DD26V" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="FIELDS" DDLANGUAGE="E" POSITION="0015" ROLLNAME="ZT_DD27P" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of DD27P" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="JOIN_CONDITION" DDLANGUAGE="E" POSITION="0016" ROLLNAME="/GC1/TAB_DD28J" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Internal structure for joins of views" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW" FIELDNAME="SELECTION_CONDITION" DDLANGUAGE="E" POSITION="0017" ROLLNAME="ZT_DD28V" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of DD28V" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZVIEW_CLUSTER" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="View Cluster Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="HIEROPSOFF" DDLANGUAGE="E" POSITION="0010" ROLLNAME="SYCHAR01" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SYCHAR01" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="CHAR01 data element for SYST" DOMNAME3L="SYCHAR01" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="READKIND" DDLANGUAGE="E" POSITION="0011" ROLLNAME="SYCHAR01" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="SYCHAR01" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="CHAR01 data element for SYST" DOMNAME3L="SYCHAR01" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="BASEVCL" DDLANGUAGE="E" POSITION="0012" ROLLNAME="VCL_NAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="VCL_NAME" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="VCLDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Complex data object maintenance view cluster name" REPTEXT="Viewclust." SCRTEXT_S="Viewclust." SCRTEXT_M="View cluster" SCRTEXT_L="View cluster" DOMMASTER="D" DOMNAME3L="VCL_NAME" SHLPORIGIN="D" SHLPNAME="VCLNAME" SHLPFIELD="VCLNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="OBJECT_STRU" DDLANGUAGE="E" POSITION="0013" ROLLNAME="ZT_VIEW_CLUSTER_STRU" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of View Cluster Structure" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="FIELD_DEP" DDLANGUAGE="E" POSITION="0014" ROLLNAME="ZT_VIEW_CLUSTER_FLD_DEP" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of View Cluster Field Dependency" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZVIEW_CLUSTER" FIELDNAME="EVENTS" DDLANGUAGE="E" POSITION="0015" ROLLNAME="ZT_MAINTENANCE_EVENTS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Maintenance View Events" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZBASIC_ATTR" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Repository Object Basic Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0002" ROLLNAME="PGMID" ADMINFIELD="1" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0003" ROLLNAME="TROBJTYPE" ADMINFIELD="1" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="SOBJ_NAME" ADMINFIELD="1" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0005" ROLLNAME="OBJFUNC" ADMINFIELD="1" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0006" ROLLNAME="DEVCLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DDTEXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZBASIC_ATTR" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="INT1" ADMINFIELD="0" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZDATA_ELEMENT" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Data Element Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="DOMNAME" DDLANGUAGE="E" POSITION="0010" ROLLNAME="DOMNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DOMNAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD01L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Domain name" REPTEXT="Domain" SCRTEXT_S="Domain" SCRTEXT_M="Domain" SCRTEXT_L="Domain name" DOMNAME3L="DOMNAME" SHLPORIGIN="D" SHLPNAME="DD_DOMA" SHLPFIELD="DOMNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="FIELD_LABEL" DDLANGUAGE="E" POSITION="0011" ROLLNAME="ZDATA_ELEMENT_FIELD_LABEL" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="Data Element Field Label" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="HEADLEN" DDLANGUAGE="E" POSITION="0012" ROLLNAME="HEADLEN" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Maximum length of heading" REPTEXT="Hea" SCRTEXT_M="Header" SCRTEXT_L="Heading length" DOMNAME3L="SCRLEN" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SCRLEN1" DDLANGUAGE="E" POSITION="0013" ROLLNAME="SCRLEN_S" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Max. length for short field label" REPTEXT="SFL" SCRTEXT_M="ShortFieldLabelLen" SCRTEXT_L="ShortFieldLabelLen." DOMNAME3L="SCRLEN" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SCRLEN2" DDLANGUAGE="E" POSITION="0014" ROLLNAME="SCRLEN_M" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Max. length for medium field label" REPTEXT="MFL" SCRTEXT_M="Med.FieldLabelLen." SCRTEXT_L="MediumFieldLabelLen." DOMNAME3L="SCRLEN" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SCRLEN3" DDLANGUAGE="E" POSITION="0015" ROLLNAME="SCRLEN_L" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Max. length for long field label" REPTEXT="LFL" SCRTEXT_M="LongFieldLabelLen." SCRTEXT_L="Long field label len" DOMNAME3L="SCRLEN" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="REPTEXT" DDLANGUAGE="E" POSITION="0016" ROLLNAME="REPTEXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000110" DOMNAME="REPTEXT" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000055" OUTPUTLEN="000055" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Heading" REPTEXT="Heading" SCRTEXT_S="Heading" SCRTEXT_M="Heading" SCRTEXT_L="Heading" DOMNAME3L="REPTEXT" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SCRTEXT_S" DDLANGUAGE="E" POSITION="0017" ROLLNAME="SCRTEXT_S" ADMINFIELD="0" INTTYPE="C" INTLEN="000020" DOMNAME="SCRTEXT_S" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Short Field Label" REPTEXT="Short field label" SCRTEXT_S="Short" SCRTEXT_M="ShortFieldLabel" SCRTEXT_L="Short field label" DOMNAME3L="SCRTEXT_S" DEPTH="01" COMPTYPE="E" DEFFDNAME="SCRTEXT_S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SCRTEXT_M" DDLANGUAGE="E" POSITION="0018" ROLLNAME="SCRTEXT_M" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="SCRTEXT_M" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Medium Field Label" REPTEXT="Medium Field Label" SCRTEXT_S="Medium" SCRTEXT_M="Medium Fld Labl" SCRTEXT_L="Medium Field Label" DOMNAME3L="SCRTEXT_M" DEPTH="01" COMPTYPE="E" DEFFDNAME="SCRTEXT_M" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT" FIELDNAME="SCRTEXT_L" DDLANGUAGE="E" POSITION="0019" ROLLNAME="SCRTEXT_L" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="SCRTEXT_L" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Long Field Label" REPTEXT="Long Field Label" SCRTEXT_S="Long" SCRTEXT_M="Long Fld Label" SCRTEXT_L="Long field label" DOMNAME3L="SCRTEXT_L" DEPTH="01" COMPTYPE="E" DEFFDNAME="SCRTEXT_L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZDATA_ELEMENT_FIELD_LABEL" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Data Element Field Label" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="HEADLEN" DDLANGUAGE="E" POSITION="0001" ROLLNAME="HEADLEN" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Maximum length of heading" REPTEXT="Hea" SCRTEXT_M="Header" SCRTEXT_L="Heading length" DOMNAME3L="SCRLEN" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="SCRLEN1" DDLANGUAGE="E" POSITION="0002" ROLLNAME="SCRLEN_S" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Max. length for short field label" REPTEXT="SFL" SCRTEXT_M="ShortFieldLabelLen" SCRTEXT_L="ShortFieldLabelLen." DOMNAME3L="SCRLEN" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="SCRLEN2" DDLANGUAGE="E" POSITION="0003" ROLLNAME="SCRLEN_M" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Max. length for medium field label" REPTEXT="MFL" SCRTEXT_M="Med.FieldLabelLen." SCRTEXT_L="MediumFieldLabelLen." DOMNAME3L="SCRLEN" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="SCRLEN3" DDLANGUAGE="E" POSITION="0004" ROLLNAME="SCRLEN_L" ADMINFIELD="0" INTTYPE="N" INTLEN="000004" DOMNAME="SCRLEN" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="00" SCRLEN2="18" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Max. length for long field label" REPTEXT="LFL" SCRTEXT_M="LongFieldLabelLen." SCRTEXT_L="Long field label len" DOMNAME3L="SCRLEN" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="REPTEXT" DDLANGUAGE="E" POSITION="0005" ROLLNAME="REPTEXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000110" DOMNAME="REPTEXT" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000055" OUTPUTLEN="000055" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Heading" REPTEXT="Heading" SCRTEXT_S="Heading" SCRTEXT_M="Heading" SCRTEXT_L="Heading" DOMNAME3L="REPTEXT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="SCRTEXT_S" DDLANGUAGE="E" POSITION="0006" ROLLNAME="SCRTEXT_S" ADMINFIELD="0" INTTYPE="C" INTLEN="000020" DOMNAME="SCRTEXT_S" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Short Field Label" REPTEXT="Short field label" SCRTEXT_S="Short" SCRTEXT_M="ShortFieldLabel" SCRTEXT_L="Short field label" DOMNAME3L="SCRTEXT_S" DEPTH="00" COMPTYPE="E" DEFFDNAME="SCRTEXT_S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="SCRTEXT_M" DDLANGUAGE="E" POSITION="0007" ROLLNAME="SCRTEXT_M" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="SCRTEXT_M" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Medium Field Label" REPTEXT="Medium Field Label" SCRTEXT_S="Medium" SCRTEXT_M="Medium Fld Labl" SCRTEXT_L="Medium Field Label" DOMNAME3L="SCRTEXT_M" DEPTH="00" COMPTYPE="E" DEFFDNAME="SCRTEXT_M" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDATA_ELEMENT_FIELD_LABEL" FIELDNAME="SCRTEXT_L" DDLANGUAGE="E" POSITION="0008" ROLLNAME="SCRTEXT_L" ADMINFIELD="0" INTTYPE="C" INTLEN="000080" DOMNAME="SCRTEXT_L" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Long Field Label" REPTEXT="Long Field Label" SCRTEXT_S="Long" SCRTEXT_M="Long Fld Label" SCRTEXT_L="Long field label" DOMNAME3L="SCRTEXT_L" DEPTH="00" COMPTYPE="E" DEFFDNAME="SCRTEXT_L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZDOMAIN" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Domain Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="DATATYPE" DDLANGUAGE="E" POSITION="0010" ROLLNAME="DATATYPE_D" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="DATATYPE" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000010" DECIMALS="000000" VALEXI="X" CONVEXIT="DTYPE" MASK="  CHARE" MASKLEN="0000" DDTEXT="Data Type in ABAP Dictionary" REPTEXT="DTyp" SCRTEXT_S="Data Type" SCRTEXT_M="Data Type" SCRTEXT_L="Data Type" DOMNAME3L="DATATYPE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="LENG" DDLANGUAGE="E" POSITION="0011" ROLLNAME="DDLENG" ADMINFIELD="0" INTTYPE="N" INTLEN="000012" DOMNAME="DDLENG" ROUTPUTLEN="000000" HEADLEN="06" SCRLEN1="05" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="NUMC" LENG="000006" OUTPUTLEN="000006" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Length (No. of Characters)" REPTEXT="Length" SCRTEXT_S="Lngth" SCRTEXT_M="No. of Characters" SCRTEXT_L="No. of Characters" DOMNAME3L="DDLENG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="OUTPUTLEN" DDLANGUAGE="E" POSITION="0012" ROLLNAME="OUTPUTLEN" ADMINFIELD="0" INTTYPE="N" INTLEN="000012" DOMNAME="DDLENG" ROUTPUTLEN="000000" HEADLEN="07" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="NUMC" LENG="000006" OUTPUTLEN="000006" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Output Length" REPTEXT="OutLeng" SCRTEXT_M="Output Length" SCRTEXT_L="Output Length" DOMNAME3L="DDLENG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="DECIMALS" DDLANGUAGE="E" POSITION="0013" ROLLNAME="DECIMALS" ADMINFIELD="0" INTTYPE="N" INTLEN="000012" DOMNAME="DDLENG" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000006" OUTPUTLEN="000006" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Number of Decimal Places" REPTEXT="Decimal Places" SCRTEXT_S="Dec.Places" SCRTEXT_M="Decimal Places" SCRTEXT_L="Decimal Places" DOMNAME3L="DDLENG" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="LOWERCASE" DDLANGUAGE="E" POSITION="0014" ROLLNAME="LOWERCASE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Lowercase letters allowed/not allowed" REPTEXT="Lowercase Letters" SCRTEXT_S="Lowercase" SCRTEXT_M="Lower case" SCRTEXT_L="Lowercase Letters" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="SIGNFLAG" DDLANGUAGE="E" POSITION="0015" ROLLNAME="SIGNFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="02" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag for sign in numerical fields" REPTEXT="Sn" SCRTEXT_M="Sign" SCRTEXT_L="Sign" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="VALEXI" DDLANGUAGE="E" POSITION="0016" ROLLNAME="VALEXI" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Existence of fixed values" REPTEXT="Fixed values exist" SCRTEXT_S="Defaults" SCRTEXT_M="Fixed val. ex." SCRTEXT_L="Fixed values exist" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="ENTITYTAB" DDLANGUAGE="E" POSITION="0017" ROLLNAME="ENTITYTAB" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="AS4TAB" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD02L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Value table" REPTEXT="Value table" SCRTEXT_M="Value table" SCRTEXT_L="Value table" DOMNAME3L="AS4TAB" SHLPORIGIN="D" SHLPNAME="DD_DBTB" SHLPFIELD="TABNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN" FIELDNAME="VALUE_RANGE" DDLANGUAGE="E" POSITION="0018" ROLLNAME="ZT_DOMAIN_VALUE_RANGE" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Domain Value Range" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZDOMAIN_VALUE_RANGE" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Domain Value Range" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZDOMAIN_VALUE_RANGE" FIELDNAME="VALPOS" DDLANGUAGE="E" POSITION="0001" ROLLNAME="VALPOS" ADMINFIELD="0" INTTYPE="N" INTLEN="000008" DOMNAME="VALPOS" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DATATYPE="NUMC" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Domain value key" SCRTEXT_M="Value key" SCRTEXT_L="Value key" DOMNAME3L="VALPOS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN_VALUE_RANGE" FIELDNAME="DOMVALUE_L" DDLANGUAGE="E" POSITION="0002" ROLLNAME="DOMVALUE_L" ADMINFIELD="0" INTTYPE="C" INTLEN="000020" DOMNAME="DOMVAL" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="00" SCRLEN2="15" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000010" OUTPUTLEN="000010" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Values for Domains: Single Value / Upper Limit" REPTEXT="Fixed Val." SCRTEXT_M="Lower_value" SCRTEXT_L="Dom. lower value" DOMNAME3L="DOMVAL" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZDOMAIN_VALUE_RANGE" FIELDNAME="DDTEXT" DDLANGUAGE="E" POSITION="0003" ROLLNAME="VAL_TEXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="16" SCRLEN1="04" SCRLEN2="16" SCRLEN3="16" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Short Text for Fixed Values" REPTEXT="Short Descript." SCRTEXT_S="Text" SCRTEXT_M="Short Descript." SCRTEXT_L="Short Descript." DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZFUNCTION_GROUP" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Function Group Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZFUNCTION_GROUP" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZGS_0004" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Json Structure" AUTHCLASS="00" PROZPUFF="000" EXCLASS="4">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZGS_0004" FIELDNAME="ID" DDLANGUAGE="E" POSITION="0001" ROLLNAME="ZSTRING" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="E" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRGE" MASKLEN="0000" DDTEXT="JSON Key/Value" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZGS_0004" FIELDNAME="TX" DDLANGUAGE="E" POSITION="0002" ROLLNAME="ZSTRING" ADMINFIELD="0" INTTYPE="g" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DTELMASTER="E" DATATYPE="STRG" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRGE" MASKLEN="0000" DDTEXT="JSON Key/Value" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZLOCK_OBJECT" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Lock Object" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="RFCENABLE" DDLANGUAGE="E" POSITION="0010" ROLLNAME="RFCENABLE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Allow RFC for ENQUEUE/DEQUEUE function modules" REPTEXT="RFC" SCRTEXT_S="RFC" SCRTEXT_M="Allow RFC" SCRTEXT_L="Allow RFC" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="BASE_TABLES" DDLANGUAGE="E" POSITION="0011" ROLLNAME="ZT_DD26E" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of DD26E" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZLOCK_OBJECT" FIELDNAME="LOCK_PARAMS" DDLANGUAGE="E" POSITION="0012" ROLLNAME="ZT_DDENA" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of DDENA" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZMAINTENANCE_EVENT" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Event Of Maintenace View/View Cluster" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZMAINTENANCE_EVENT" FIELDNAME="EVENT" DDLANGUAGE="E" POSITION="0001" ROLLNAME="VCLMEVENT" ADMINFIELD="0" INTTYPE="C" INTLEN="000004" DOMNAME="VCLMEVENT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Viewcluster maintenance procedure event" REPTEXT="Evt" SCRTEXT_S="Date/Time" SCRTEXT_M="Maint. event" SCRTEXT_L="Maint. event" DOMMASTER="D" DOMNAME3L="VCLMEVENT" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_EVENT" FIELDNAME="FORMNAME" DDLANGUAGE="E" POSITION="0002" ROLLNAME="VIMFRMNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="SYCHAR30" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of FORM routine (extended table maintenance)" REPTEXT="FORM routine" SCRTEXT_S="Name" SCRTEXT_M="Name" SCRTEXT_L="FORM routine" DOMNAME3L="SYCHAR30" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZMAINTENANCE_VIEW" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Maintenance Definition" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="TABNAME" DDLANGUAGE="E" POSITION="0010" ROLLNAME="VIM_NAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="VIM_NAME" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TVDIR" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of table/view for extended table maintenance" REPTEXT="View/Table" SCRTEXT_S="View/Table" SCRTEXT_M="View/table" SCRTEXT_L="View/table" DOMNAME3L="VIM_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="AREA" DDLANGUAGE="E" POSITION="0011" ROLLNAME="FUNCT_POOL" ADMINFIELD="0" INTTYPE="C" INTLEN="000052" DOMNAME="AREA" ROUTPUTLEN="000000" HEADLEN="10" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000026" OUTPUTLEN="000026" DECIMALS="000000" ENTITYTAB="TLIBG" MASK="  CHARE" MASKLEN="0000" DDTEXT="Name of function group for maintenance modules" REPTEXT="Funct.grp." SCRTEXT_S="Funct.grp." SCRTEXT_M="Function group" SCRTEXT_L="Function group" DOMNAME3L="AREA" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="FG_DEVCLASS" DDLANGUAGE="E" POSITION="0012" ROLLNAME="DEVCLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="TYPE" DDLANGUAGE="E" POSITION="0013" ROLLNAME="MAINT_TYPE" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="VIM_MTYPE" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="04" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Maint. type: Single-level or two-level view/table maint." REPTEXT="Maintenance type" SCRTEXT_S="Type" SCRTEXT_M="Maint.type" SCRTEXT_L="Maintenance type" DOMNAME3L="VIM_MTYPE" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="LISTE" DDLANGUAGE="E" POSITION="0014" ROLLNAME="LIST_SCR" ADMINFIELD="0" INTTYPE="N" INTLEN="000008" DOMNAME="DYNPRONR" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Table maintenance dialog overview screen number" REPTEXT="List" SCRTEXT_S="Overview" SCRTEXT_M="Overview screen" SCRTEXT_L="Overview screen" DOMMASTER="D" DOMNAME3L="DYNPRONR" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="DETAIL" DDLANGUAGE="E" POSITION="0015" ROLLNAME="SINGLE_SCR" ADMINFIELD="0" INTTYPE="N" INTLEN="000008" DOMNAME="DYNPRONR" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="NUMC" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="Number of table maintenance dialog single screen" REPTEXT="Sngl" SCRTEXT_S="Single sc." SCRTEXT_M="Single scrn.no." SCRTEXT_L="Single screen" DOMMASTER="D" DOMNAME3L="DYNPRONR" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="MCLASS" DDLANGUAGE="E" POSITION="0016" ROLLNAME="DDMCLASS" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="DDBRGRU" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Authorization group for DD objects" REPTEXT="Authorization class" SCRTEXT_S="Auth.class" SCRTEXT_M="Authoriz.class" SCRTEXT_L="Authorization class" DOMNAME3L="DDBRGRU" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="CCLASS" DDLANGUAGE="E" POSITION="0017" ROLLNAME="DICBERCLS" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="BRGRU" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" ENTITYTAB="TBRG" MASK="  CHARE" MASKLEN="0000" DDTEXT="Table Authorization Group" REPTEXT="AuGr" SCRTEXT_S="Authoriztn" SCRTEXT_M="Authorization" SCRTEXT_L="Authorization Group" DOMNAME3L="BRGRU" SHLPORIGIN="D" SHLPNAME="H_DICBERCLS" SHLPFIELD="BRGRU" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMAINTENANCE_VIEW" FIELDNAME="EVENTS" DDLANGUAGE="E" POSITION="0018" ROLLNAME="ZT_MAINTENANCE_EVENTS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Maintenance View Events" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZMESSAGE" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Message Class Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE" FIELDNAME="MESSAGE_TEXTS" DDLANGUAGE="E" POSITION="0010" ROLLNAME="ZT_MESSAGE_TXT" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Message Texts" DEPTH="00" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZMESSAGE_TXT" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Message Text" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZMESSAGE_TXT" FIELDNAME="MSGNR" DDLANGUAGE="E" POSITION="0001" ROLLNAME="MSGNR" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" DOMNAME="MSGNR" ROUTPUTLEN="000000" HEADLEN="05" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T100" MASK="  CHARE" MASKLEN="0000" DDTEXT="Message number" REPTEXT="MsgNo" SCRTEXT_S="Msg.no." SCRTEXT_M="Message" SCRTEXT_L="Message" DOMNAME3L="MSGNR" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZMESSAGE_TXT" FIELDNAME="TEXT" DDLANGUAGE="E" POSITION="0002" ROLLNAME="NATXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000146" DOMNAME="NATXT" ROUTPUTLEN="000000" HEADLEN="18" SCRLEN1="07" SCRLEN2="20" SCRLEN3="40" DTELMASTER="D" DATATYPE="CHAR" LENG="000073" OUTPUTLEN="000073" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Message Text" REPTEXT="Message Text" SCRTEXT_S="Text" SCRTEXT_M="Message Text" SCRTEXT_L="Message Text" DOMNAME3L="NATXT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZNUMBER_RANGE" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Number Range Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="TXT" DDLANGUAGE="E" POSITION="0010" ROLLNAME="NROBJTXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000120" DOMNAME="TEXT60" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="55" SCRLEN1="10" SCRLEN2="13" SCRLEN3="20" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Number range object text" REPTEXT="Long text" SCRTEXT_S="Text" SCRTEXT_M="Long text" SCRTEXT_L="Long text" DOMNAME3L="TEXT60" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="DTELSOBJ" DDLANGUAGE="E" POSITION="0011" ROLLNAME="NRSOBJNAM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DDOBJNAME" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="30" SCRLEN1="10" SCRLEN2="20" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Subobject data element" REPTEXT="Subobject data element" SCRTEXT_S="Sobj.datel" SCRTEXT_M="Subobj. data element" SCRTEXT_L="Subobject data element" DOMNAME3L="DDOBJNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="DOMLEN" DDLANGUAGE="E" POSITION="0012" ROLLNAME="NRLENDOM" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DOMNAME" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="DD01L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Number length domain" REPTEXT="Number length domain" SCRTEXT_S="No. domain" SCRTEXT_M="No.len domain" SCRTEXT_L="Number length domain" DOMNAME3L="DOMNAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="PERCENTAGE" DDLANGUAGE="E" POSITION="0013" ROLLNAME="NRPERC" ADMINFIELD="0" INTTYPE="P" INTLEN="000002" DOMNAME="NRPERC" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="30" DATATYPE="DEC" LENG="000003" OUTPUTLEN="000004" DECIMALS="000001" MASK="  DEC E" MASKLEN="0000" DDTEXT="Percentage for warning message" REPTEXT="Warning %" SCRTEXT_S="Warning %" SCRTEXT_M="Warning %" SCRTEXT_L="Warning %" DOMNAME3L="NRPERC" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="CODE" DDLANGUAGE="E" POSITION="0014" ROLLNAME="NRCODE" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="CHAR20" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="CUA interface code" REPTEXT="Number range transaction" SCRTEXT_S="No.rng.tra" SCRTEXT_M="No.r.transation" SCRTEXT_L="Number range transaction" DOMNAME3L="CHAR20" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="BUFFER" DDLANGUAGE="E" POSITION="0015" ROLLNAME="NRBUFFER" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="CHAR1" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Buffer flag" SCRTEXT_S="Buffer" SCRTEXT_M="Buffering" SCRTEXT_L="Buffering" DOMNAME3L="CHAR1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="NOIVBUFFER" DDLANGUAGE="E" POSITION="0016" ROLLNAME="NRIVBUFFER" ADMINFIELD="0" INTTYPE="N" INTLEN="000016" DOMNAME="NUM8" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="25" DATATYPE="NUMC" LENG="000008" OUTPUTLEN="000008" DECIMALS="000000" MASK="  NUMCE" MASKLEN="0000" DDTEXT="No. of numbers that must be held in the buffer" SCRTEXT_S="No. of nos" SCRTEXT_M="No. of numbers" SCRTEXT_L="No. of numbers in buffer" DOMNAME3L="NUM8" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="NONRSWAP" DDLANGUAGE="E" POSITION="0017" ROLLNAME="NRSWAP" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag: No rolling of intervals" REPTEXT="No rolling" SCRTEXT_S="No rolling" SCRTEXT_M="No rolling" SCRTEXT_L="No rolling" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZNUMBER_RANGE" FIELDNAME="YEARIND" DDLANGUAGE="E" POSITION="0018" ROLLNAME="NRYEARIND" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="XFELD" ROUTPUTLEN="000000" LOGFLAG="X" HEADLEN="55" SCRLEN1="10" SCRLEN2="15" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Flag, whether number range object is to-year relevant" REPTEXT="To-year flag" SCRTEXT_S="Year flag" SCRTEXT_M="To-year flag" SCRTEXT_L="To-year flag" DOMNAME3L="XFELD" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZPACKAGE" DDLANGUAGE="E" TABCLASS="INTTAB" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" LANGDEP="X" DDTEXT="Package All Attributes" AUTHCLASS="00" PROZPUFF="000" EXCLASS="1">
  <dd09l AS4VERS="0000" SCHFELDANZ="000"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0001" ADMINFIELD="0" INTLEN="000000" PRECFIELD="ZBASIC_ATTR" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Repository Object Basic Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME=".INCLUDE" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="1" INTLEN="000000" PRECFIELD="ZTADIR_KEY" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="      S" MASKLEN="0000" DDTEXT="Tadir Primary Key" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="PGMID" DDLANGUAGE="E" POSITION="0003" ROLLNAME="PGMID" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="PGMID" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Program ID in Requests and Tasks" REPTEXT="PgID" SCRTEXT_S="Prog. ID" SCRTEXT_M="Program ID" SCRTEXT_L="Program ID" DOMNAME3L="PGMID" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="OBJECT" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TROBJTYPE" ADMINFIELD="2" INTTYPE="C" INTLEN="000008" DOMNAME="OBJECT" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Type" REPTEXT="Obj." SCRTEXT_S="Obj. Type" SCRTEXT_M="Object Type" SCRTEXT_L="Object Type" DOMNAME3L="OBJECT" SHLPORIGIN="D" SHLPNAME="SCTSOBJECT" SHLPFIELD="OBJECT" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="OBJ_NAME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="SOBJ_NAME" ADMINFIELD="2" INTTYPE="C" INTLEN="000080" DOMNAME="SOBJ_NAME" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000040" OUTPUTLEN="000040" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object Name in Object Directory" REPTEXT="Object Name" SCRTEXT_S="Obj. Name" SCRTEXT_M="Object Name" SCRTEXT_L="Object Name" DOMMASTER="D" DOMNAME3L="SOBJ_NAME" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="OBJFUNC" DDLANGUAGE="E" POSITION="0006" ROLLNAME="OBJFUNC" ADMINFIELD="2" INTTYPE="C" INTLEN="000002" DOMNAME="OBJFUNC" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Object function" SCRTEXT_S="Function" SCRTEXT_M="Function" SCRTEXT_L="Function" DOMMASTER="D" DOMNAME3L="OBJFUNC" SHLPORIGIN="F" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="DEVCLASS" DDLANGUAGE="E" POSITION="0007" ROLLNAME="DEVCLASS" ADMINFIELD="1" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" MEMORYID="DVC" HEADLEN="08" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Package" REPTEXT="Package" SCRTEXT_S="Package" SCRTEXT_M="Package" SCRTEXT_L="Package" DOMNAME3L="DEVCLASS" SHLPORIGIN="D" SHLPNAME="DEVCLASS" SHLPFIELD="DEVCLASS" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="SHORT_TEXT" DDLANGUAGE="E" POSITION="0008" ROLLNAME="DDTEXT" ADMINFIELD="1" INTTYPE="C" INTLEN="000120" DOMNAME="DDTEXT" ROUTPUTLEN="000000" HEADLEN="60" SCRLEN1="00" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Explanatory short text" REPTEXT="Short text" SCRTEXT_M="Short text" SCRTEXT_L="Short text" DOMNAME3L="DDTEXT" DEPTH="00" COMPTYPE="E" DEFFDNAME="DDTEXT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="SCREENSHOTS_CNT" DDLANGUAGE="E" POSITION="0009" ROLLNAME="INT1" ADMINFIELD="1" INTTYPE="X" INTLEN="000001" DOMNAME="INT1" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="03" SCRLEN2="15" SCRLEN3="20" DATATYPE="INT1" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" MASK="  INT1E" MASKLEN="0000" DDTEXT="Dummy for B20 int1 (Local Everywhere)" SCRTEXT_S="Int" SCRTEXT_M="Int." SCRTEXT_L="Int." DOMNAME3L="INT1" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="EXT_ATTR" DDLANGUAGE="E" POSITION="0010" ROLLNAME="ZPACKAGE_EXT" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="STRU" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  STRUS" MASKLEN="0000" DDTEXT="Package Extensive Attributes" DEPTH="00" COMPTYPE="S" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="PARENTCL" DDLANGUAGE="E" POSITION="0011" ROLLNAME="PARENTCL" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DEVCLASS" ROUTPUTLEN="000000" HEADLEN="25" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="TDEVC" MASK="  CHARE" MASKLEN="0000" DDTEXT="Previous Package" REPTEXT="Previous Package" SCRTEXT_S="Prev.Pack." SCRTEXT_M="Prev. Package" SCRTEXT_L="Previous Package" DOMNAME3L="DEVCLASS" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="PDEVCLASS" DDLANGUAGE="E" POSITION="0012" ROLLNAME="DEVLAYER" ADMINFIELD="0" INTTYPE="C" INTLEN="000008" DOMNAME="DEVLAYER" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000004" OUTPUTLEN="000004" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Transport Layer in ABAP Workbench" REPTEXT="Transport Layer" SCRTEXT_S="Layer" SCRTEXT_M="Transport Layer" SCRTEXT_L="Transport Layer" DOMNAME3L="DEVLAYER" SHLPORIGIN="D" SHLPNAME="TCE_TRANSPORT_LAYERS" SHLPFIELD="TRANSLAYER" DEPTH="01" COMPTYPE="E" DEFFDNAME="TRANSPORTSCHICHT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="COMPONENT" DDLANGUAGE="E" POSITION="0013" ROLLNAME="UFFCTR" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" DOMNAME="UFFCTR" ROUTPUTLEN="000000" MEMORYID="BMFR" HEADLEN="20" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" ENTITYTAB="DF14L" MASK="  CHARE" MASKLEN="0000" DDTEXT="Application Component" REPTEXT="Applic. Component" SCRTEXT_S="Appl.Comp." SCRTEXT_M="Component" SCRTEXT_L="Applic. Component" DOMMASTER="D" DOMNAME3L="UFFCTR" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="DLVUNIT" DDLANGUAGE="E" POSITION="0014" ROLLNAME="DLVUNIT" ADMINFIELD="0" INTTYPE="C" INTLEN="000060" DOMNAME="DLVUNIT" ROUTPUTLEN="000000" HEADLEN="30" SCRLEN1="05" SCRLEN2="10" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000030" OUTPUTLEN="000030" DECIMALS="000000" ENTITYTAB="CVERS" MASK="  CHARE" MASKLEN="0000" DDTEXT="Software Component" REPTEXT="Software Component" SCRTEXT_S="Comp." SCRTEXT_M="Soft.Comp." SCRTEXT_L="Software Component" DOMNAME3L="DLVUNIT" SHLPORIGIN="D" SHLPNAME="H_CVERS" SHLPFIELD="COMPONENT" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="APPLICAT" DDLANGUAGE="E" POSITION="0015" ROLLNAME="TRDEVCAPPL" ADMINFIELD="0" INTTYPE="C" INTLEN="000004" DOMNAME="TRDEVCAPPL" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000002" OUTPUTLEN="000002" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Application area for package" REPTEXT="Applic. Area" SCRTEXT_S="Appl. Area" SCRTEXT_M="Applic. Area" SCRTEXT_L="Application Area" DOMMASTER="D" DOMNAME3L="TRDEVCAPPL" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="MAINPACK" DDLANGUAGE="E" POSITION="0016" ROLLNAME="MAINPACK" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="MAINPACK" ROUTPUTLEN="000000" HEADLEN="20" SCRLEN1="10" SCRLEN2="20" SCRLEN3="30" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Main Package Indicator" REPTEXT="Main Package" SCRTEXT_S="Mn package" SCRTEXT_M="Main Package" SCRTEXT_L="Main Package" DOMNAME3L="MAINPACK" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="KORRFLAG" DDLANGUAGE="E" POSITION="0017" ROLLNAME="KORRFLAG" ADMINFIELD="0" INTTYPE="C" INTLEN="000002" DOMNAME="AS4FLAG" ROUTPUTLEN="000000" HEADLEN="50" SCRLEN1="00" SCRLEN2="00" SCRLEN3="40" DTELMASTER="D" DATATYPE="CHAR" LENG="000001" OUTPUTLEN="000001" DECIMALS="000000" VALEXI="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Changes Recorded" REPTEXT="Record Object Changes in Transport Requests" SCRTEXT_L="Changes Recorded" DOMNAME3L="AS4FLAG" SHLPORIGIN="F" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="PROJECT_ID" DDLANGUAGE="E" POSITION="0018" ROLLNAME="PAK_PROJECT_ID" ADMINFIELD="0" INTTYPE="C" INTLEN="000048" DOMNAME="PAK_PROJECT_ID" ROUTPUTLEN="000000" HEADLEN="07" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000024" OUTPUTLEN="000024" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="External cPro Project ID" REPTEXT="Project" SCRTEXT_S="Project" SCRTEXT_M="Project" SCRTEXT_L="cProjects Project" DOMNAME3L="PAK_PROJECT_ID" SHLPORIGIN="D" SHLPNAME="H_PAK_PROJECT_ID" SHLPFIELD="PROJECT_ID" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="TRANSLATION_DEPTH_TEXT" DDLANGUAGE="E" POSITION="0019" ROLLNAME="PAK_TRANSLATION_DEPTH_TEXT" ADMINFIELD="0" INTTYPE="C" INTLEN="000120" DOMNAME="AS4TEXT" ROUTPUTLEN="000000" HEADLEN="55" SCRLEN1="00" SCRLEN2="20" SCRLEN3="40" DTELMASTER="E" DATATYPE="CHAR" LENG="000060" OUTPUTLEN="000060" DECIMALS="000000" LOWERCASE="X" MASK="  CHARE" MASKLEN="0000" DDTEXT="Translation-Relevance" REPTEXT="Translation-Relevance" SCRTEXT_M="Transl.-Relevance" SCRTEXT_L="Translation-Relevance" DOMNAME3L="AS4TEXT" DEPTH="01" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPACKAGE" FIELDNAME="USE_ACCESSES" DDLANGUAGE="E" POSITION="0020" ROLLNAME="ZT_PACKAGE_USE_ACCESS" ADMINFIELD="0" INTLEN="000000" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="TTYP" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  TTYPL" MASKLEN="0000" DDTEXT="Table Type Of Use Accesses" DEPTH="01" COMPTYPE="L" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TRAN TCODE="YNOT" PGMNA="YNOT" DYPNO="1000" CINFO="80">
  <tstct SPRSL="E" TCODE="YNOT" TTEXT="Why Not?"/>
  <tstcc TCODE="YNOT" S_WEBGUI="1" S_WIN32="X" S_PLATIN="X"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
 <TRAN TCODE="YNOT_BUILD" PGMNA="YNOT_BUILD" DYPNO="0000" CINFO="80">
  <tstct SPRSL="E" TCODE="YNOT_BUILD" TTEXT="Build YNOT to All-In-One and Nugg"/>
  <tstcc TCODE="YNOT_BUILD" S_WEBGUI="1" S_WIN32="X" S_PLATIN="X"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
 <TTYP TYPENAME="ZT_VIEW_CLUSTER_STRU" DDLANGUAGE="E" ROWTYPE="V_VCLSTRUC" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of View Cluster Structure" TYPELEN="000356" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_VIEW_CLUSTER_FLD_DEP" DDLANGUAGE="E" ROWTYPE="V_VCLSTDEP" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of View Cluster Field Dependency" TYPELEN="000302" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_TRANSACTION_AUTH" DDLANGUAGE="E" ROWTYPE="ZTRANSACTION_AUTH" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Transaction Authoirty" TYPELEN="000120" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_TABLE_NAMESPACE" DDLANGUAGE="E" ROWTYPE="ZTABLE_NAMESPACE" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Table Namespace Attributes" TYPELEN="000180" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_TABLE_FIELD" DDLANGUAGE="E" ROWTYPE="ZTABLE_FIELD" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of ZTABLE_FIELD" TYPELEN="000428" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_TABLE_ENTRIES" DDLANGUAGE="E" ROWTYPE="TROBJ_NAME" ROWKIND="E" DATATYPE="CHAR" LENG="000120" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Table Entry" TYPELEN="000120" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_SEARCH_HELP_PARAM" DDLANGUAGE="E" ROWTYPE="ZSEARCH_HELP_PARAM" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Search Help Parameters" TYPELEN="000190" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_PACKAGE_USE_ACCESS" DDLANGUAGE="E" ROWTYPE="ZPACKAGE_USE_ACCESS" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Use Accesses" TYPELEN="000128" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_MESSAGE_TXT" DDLANGUAGE="E" ROWTYPE="ZMESSAGE_TXT" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Message Texts" TYPELEN="000152" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_MAINTENANCE_EVENTS" DDLANGUAGE="E" ROWTYPE="ZMAINTENANCE_EVENT" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Maintenance View Events" TYPELEN="000064" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_DOMAIN_VALUE_RANGE" DDLANGUAGE="E" ROWTYPE="ZDOMAIN_VALUE_RANGE" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Domain Value Range" TYPELEN="000148" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_DDENA" DDLANGUAGE="E" ROWTYPE="DDENA" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of DDENA" TYPELEN="000240" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_DD28V" DDLANGUAGE="E" ROWTYPE="DD28V" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of DD28V" TYPELEN="000360" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_DD27P" DDLANGUAGE="E" ROWTYPE="DD27P" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of DD27P" TYPELEN="001346" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_DD26V" DDLANGUAGE="E" ROWTYPE="DD26V" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of DD26V" TYPELEN="000252" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZT_DD26E" DDLANGUAGE="E" ROWTYPE="DD26E" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of DD26E" TYPELEN="000254" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
 <TTYP TYPENAME="ZGY_0004" DDLANGUAGE="E" ROWTYPE="ZGS_0004" ROWKIND="S" DATATYPE="STRU" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table Type Of Json Structure" TYPELEN="000016" CTLENG="000000" CTDECIMALS="000000" OCCURS="00000"/>
</nugget>
